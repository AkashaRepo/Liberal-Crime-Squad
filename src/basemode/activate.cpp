
#include "../includes.h"

const string blankString = "";
const string CONST_activate066 = "Activate Uninvolved Liberals";
const string CONST_activate067 = "ÄÄÄÄCODE NAMEÄÄÄÄÄÄÄÄÄÄÄÄSKILLÄÄÄHEALTHÄÄÄLOCATIONÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ";
/*
Copyright (c) 2002,2003,2004 by Tarn Adams                                            //
//
This file is part of Liberal Crime Squad.                                             //
//
Liberal Crime Squad is free software; you can redistribute it and/or modify     //
it under the terms of the GNU General Public License as published by            //
the Free Software Foundation; either version 2 of the License, or               //
(at your option) any later version.                                             //
//
Liberal Crime Squad is distributed in the hope that it will be useful,          //
but WITHOUT ANY WARRANTY; without even the implied warranty of                  //
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the                  //
GNU General Public License for more details.                                    //
//
You should have received a copy of the GNU General Public License               //
along with Liberal Crime Squad; if not, write to the Free Software              //
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA   02111-1307   USA     //
*/
/*
This file was created by Chris Johnson (grundee@users.sourceforge.net)
by copying code from game.cpp.
To see descriptions of files and functions, see the list at
the bottom of includes.h in the top src folder.
*/
// Note: this file is encoded in the PC-8 / Code Page 437 / OEM-US character set
// (The same character set used by Liberal Crime Squad when it is running)
// Certain special characters won't display correctly unless your text editor is
// set to use that character set, such as this e with an accent: ‚
// In Windows Notepad with the Terminal font, OEM/DOS encoding it should work fine.
// You can set this in Notepad by going to Format->Font and choosing the Terminal font,
// then choosing OEM/DOS in the Script dropdown box.
// In Notepad++ go to the Encoding menu, Character sets, Western European, OEM-US... easy!
// In Code::Blocks's editor go to Settings->Editor->the Other Settings tab and
// then pick WINDOWS-437 from the dropdown box and then choose the radio button
// to make this the default encoding and disable auto-detection of the encoding.
// Then close the file and reopen it (since Code::Blocks detects the encoding
// when it opens the file and it can't be changed after that; what we changed was
// how it detects encoding for files it opens in the future, not files already open).
// In Microsoft Visual C++, right-click the file in the Solution Explorer,
// select CONST_activate001, choose CONST_activateB066,
// then choose CONST_activate002.
// In MS-DOS Editor (included with Windows as EDIT.COM in your system32 directory),
// the codepage will be correct already since it's running in a console window just
// like Liberal Crime Squad. Well OK, the encoding might be wrong, but then it's wrong
// in Liberal Crime Squad TOO, and to fix it, go to Control Panel, Regional and Language Settings,
// Advanced tab, and choose English (United States) from the dropdown box as the encoding
// for non-Unicode applications, then press OK.
// If you have a Linux or other UNIX-based system you are obviously smart enough
// to figure out for yourself how to open a file in OEM-US PC-8 codepage 437 in
// your favorite text editor. If you're on Mac OS X, well that's UNIX-based, figure
// it out for yourself.
const string tag_value = "value";
const string tag_attribute = "attribute";
const string tag_skill = "skill";
string singleDot = ".";
#include "../creature/creature.h"
#include "../locations/locations.h"
#include "../items/armortype.h"
#include "../common/ledgerEnums.h"
#include "../common/ledger.h"
#include "../creature/augmenttype.h"
#include "../common/translateid.h"
// for  int getsquad(int)
//#include "../common/commonactions.h"
void sorting_prompt(short listforsorting);
#include "../common/commonactionsCreature.h"
// for void sortliberals(std::vector<Creature *>&,short,bool)
#include "../common/commondisplay.h"
#include "../common/commondisplayCreature.h"
// for void printfunds(int,int,char*)
#include "../common/getnames.h"
string gettitle(Creature &cr);
string getactivity(ActivityST &act);
//#include "../common/help.h"
void HelpActivities(int);
//#include "../common/stringconversion.h"
string attribute_enum_to_string(int);
#include "../cursesAlternative.h"
#include "../cursesAlternativeConstants.h"
#include "../customMaps.h"
#include "../set_color_support.h"
#include "../locations/locationsPool.h"
siegest* getseigestFromLocation(int secondaryLocation);
void gotoEquipmentScreen(int loc);
void createTempSquadWithJustThisLiberal(Creature *cr, int cursquadid);
#include "../common/creaturePoolCreature.h"
#include "../common/musicClass.h"
vector<ActivityAndString> data_lessons;
map<Activity, Data_Activity> data_activities;
map<char, vector<ActivityAndString> > activate_menu_items;
vector<RecruitData> recruitable_creatures;
vector<CreatureTypes> ACTIVITY_TEACH_FIGHTING_DEFAULT;
// this first block are creatures with All Weapon Skills, Martial Arts, Dodge, and First Aid
vector<CreatureTypes> ACTIVITY_TEACH_COVERT_DEFAULT;
// this second block are creatures with Computers, Security, Stealth, Disguise, Tailoring, Seduction, Psychology, & Driving
vector<CreatureTypes> ACTIVITY_TEACH_POLITICS_DEFAULT;
// this third block are creatures with Writing, Persuasion, Law, Street Sense, Science, Religion, Business, Music, & Art
Activity getDefaultActivityTeaching(Creature *cr) {
	for (CreatureTypes type : ACTIVITY_TEACH_FIGHTING_DEFAULT) {
		if (cr->type == type) {
			return ACTIVITY_TEACH_FIGHTING;
		}
	}
	for (CreatureTypes type : ACTIVITY_TEACH_COVERT_DEFAULT) {
		if (cr->type == type) {
			return ACTIVITY_TEACH_COVERT;
		}
	}
	for (CreatureTypes type : ACTIVITY_TEACH_POLITICS_DEFAULT) {
		if (cr->type == type) {
			return ACTIVITY_TEACH_POLITICS;
		}
	}
	return ACTIVITY_TEACH_POLITICS;

}
extern string closeParenthesis;
string spaceDashSpace;
string singleSpace = " ";
string commaSpace;
// These two functions handle listing and updating class choices
int classlist = 0;
void listclasses(Creature *cr)
{
	const string CONST_activate007 = "Other classes";
	const string CONST_activate006 = "Classes cost $60 a day. Study what?";
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(10, 40, CONST_activate006);
	for (int i = 0; i < 5; ++i)
	{
		if (i + classlist < len(data_lessons))
		{
			set_color_easy(cr->activity.type == data_lessons[i + classlist].activity ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
			mvaddstrAlt(12 + i, 40, to_string(i + 1) + spaceDashSpace + data_lessons[i + classlist].str);
		}
	}
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(17, 40, to_string(6) + spaceDashSpace + CONST_activate007);
}
void updateclasschoice(Creature *cr, char choice)
{
	if (choice >= '1' && choice <= '5')
	{
		if (choice - '1' + classlist < len(data_lessons))
			cr->activity.type = data_lessons[choice - '1' + classlist].activity;
		listclasses(cr);
	}
	else if (choice == '6')
	{
		classlist += 5;
		if (classlist >= len(data_lessons))
			classlist = 0;
		listclasses(cr);
	}
}
char incrementChar(char c, int i) {
	return c + i;
}
void recruitSelect(Creature &cr)
{
	const string CONST_activate011 = "Press a Letter to select a Profession";
	const string CONST_activate010 = "ÄÄÄÄTYPEÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄDIFFICULTY TO ARRANGE MEETINGÄÄ";
	const string CONST_activate009 = " try to meet and recruit today?";
	const string CONST_activate008 = "What type of person will ";
	extern short interface_pgup;
	extern short interface_pgdn;
	extern short lawList[LAWNUM];
	// Number of recruitable creatures
	int options = len(recruitable_creatures);
	for (int i = 0; i < options; i++)
	{
		// Dynamic difficulty for certain creatures, recalculated each time the function is called
		if (recruitable_creatures[i].type == CREATURE_MUTANT)
		{
			if (lawList[LAW_NUCLEARPOWER] == -2 && lawList[LAW_POLLUTION] == -2)
				recruitable_creatures[i].difficulty = 2;
			else if (lawList[LAW_NUCLEARPOWER] == -2 || lawList[LAW_POLLUTION] == -2)
				recruitable_creatures[i].difficulty = 6;
			else
				recruitable_creatures[i].difficulty = 9;
		}
	}
	int page = 0;
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, CONST_activate008);
		addstrAlt(cr.name);
		addstrAlt(CONST_activate009);
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(1, 0, CONST_activate010);
		for (int p = page * 19, y = 2; p < options&&p < page * 19 + 19; p++, y++)
		{
			set_color_easy(WHITE_ON_BLACK);
			moveAlt(y, 0);
			addcharAlt(y + 'A' - 2); addstrAlt(spaceDashSpace);
			addstrAlt(recruitable_creatures[p].name);
			moveAlt(y, 49);
			displayDifficulty(recruitable_creatures[p].difficulty);
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(22, 0, CONST_activate011);
		mvaddstrAlt(23, 0, addpagestr());
		int c = getkeyAlt();
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0)page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 19 < options)page++;
		if (c >= 'a'&&c <= 's')
		{
			int p = page * 19 + (int)(c - 'a');
			if (p < options)
			{
				cr.activity.type = ACTIVITY_RECRUITING;
				cr.activity.arg = recruitable_creatures[p].type;
				break;
			}
		}
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
	}
	return;
}
void show_victim_status(Creature *victim)
{
	const string CONST_activate014 = "Age: ";
	const string CONST_activate013 = "Heart: ";
	const string CONST_activate012 = "Status:";
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(2, 55, CONST_activate012);
	printhealthstat(*victim, 2, 66, true);
	printwoundstat(*victim, 4, 55);
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(11, 55, CONST_activate013); mvaddstrAlt(11, 66, victim->get_attribute(ATTRIBUTE_HEART, true));
	mvaddstrAlt(12, 55, CONST_activate014); mvaddstrAlt(12, 66, victim->age);
}
#include <sstream>
vector<string>& split_string(const string &s, char delim, vector<string> &elems) {
	ostringstream oss;
	for (char c : s) {
		if (c == ' ')
		{
			elems.push_back(oss.str());
			oss.str(string());
		}
		else if (c == '\n')
		{
			elems.push_back(oss.str());
			elems.push_back(blankString);
			oss.str(string());
		}
		else oss << c;
	}
	elems.push_back(oss.str());
	return elems;
}
void selectAugmentType(vector<AugmentType *> &aug_type, char aug_c, int age);
void select_augmentation(Creature *cr) //TODO: Finish and general cleanup
{
	const string CONST_activate032 = " has been brutally murdered by ";
	const string CONST_activate031 = " has been augmented with ";
	const string CONST_activate030 = " has been horribly disfigured";
	const string CONST_activate029 = "Press any key to return";
	const string CONST_activate028 = "Are you sure? (y/n)";
	const string CONST_activate027 = "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ";
	const string CONST_activate026 = "Description";
	const string CONST_activate025 = "Chance at Success: ";
	const string CONST_activate024 = " +";
	const string CONST_activate023 = "Effect: ";
	const string CONST_activate022 = "Augmentation: ";
	const string CONST_activate021 = "Subject: ";
	const string CONST_activate020 = "Select an Augmentation";
	const string CONST_activate019 = "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ";
	const string CONST_activate017 = "Press a Letter to select a Liberal";
	const string CONST_activate016 = "ÄÄÄÄNAMEÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄHEALTHÄÄÄÄÄÄÄÄÄÄÄÄHEARTÄÄÄÄÄÄÄÄAGEÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ";
	const string CONST_activate015 = "Select a Liberal to perform experiments on";
	extern Log gamelog;
	extern short interface_pgup;
	extern short interface_pgdn;
	Creature *victim = 0;
	vector<Creature *> temppool = getLiberalsSharingLocation(cr);
	int cur_step = 0, page = 0, c = 0, aug_c = 0;
	vector<AugmentType *> aug_type;
	AugmentType *selected_aug;
	while (true)
	{
		eraseAlt();

		switch (cur_step) {
		case 0: //PAGE 0, selecting a liberal
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(0, 0, CONST_activate015);
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(1, 0, CONST_activate016);
			for (int p = page * 19, y = 2; p < len(temppool) && p < page * 19 + 19; p++, y++)
			{
				set_color_easy(WHITE_ON_BLACK); //c==y+'a'-2);
				moveAlt(y, 0);
				addcharAlt(y + 'A' - 2); addstrAlt(spaceDashSpace);
				addstrAlt(temppool[p]->name);
				mvaddstrAlt(y, 49, temppool[p]->get_attribute(ATTRIBUTE_HEART, true));
				mvaddstrAlt(y, 62, temppool[p]->age);
				printhealthstat(*temppool[p], y, 31, TRUE);
			}
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(22, 0, CONST_activate017);
			mvaddstrAlt(23, 0, addpagestr());
			c = getkeyAlt();
			//PAGE UP
			if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0)page--;
			//PAGE DOWN
			if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 19 < len(temppool))page++;
			if (c >= 'a'&&c <= 's')
			{
				int p = page * 19 + c - 'a';
				if (p < len(temppool))
				{
					victim = temppool[p];
					cur_step = 1;
				}
				else
					victim = 0;
			}
			if (c == 'x' || c == ESC || c == SPACEBAR || c == ENTER) return;
			break;
		case 1: //PAGE 1, selecting an augmentation
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(0, 0, CONST_activate021);
			set_color_easy(WHITE_ON_BLACK);
			addstrAlt(victim->name); addstrAlt(commaSpace); addstrAlt(gettitle(*victim));
			//mvaddstrAlt(1,0,CONST_activate019);
			show_victim_status(victim);
			mvaddstrAlt(2, 1, CONST_activate020);
			for (int p = page * 19, y = 4; p < AUGMENTATIONNUM&&p < page * 19 + 19; p++, y++)
			{
				bool already_augmented = victim->get_augmentation(y - 4).type != -1;
				if (already_augmented) set_color_easy(BLACK_ON_BLACK_BRIGHT);
				else set_color_easy(aug_c == y + 'a' - 4 ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
				moveAlt(y, 1);
				addcharAlt(y + 'A' - 4); addstrAlt(spaceDashSpace);
				addstrAlt(Augmentation::get_name(y - 4));
			}
			if (aug_c >= 'a'&&aug_c <= 'e'&&c >= 'a'&&c <= 'e')
			{
				aug_type.clear();
				if (victim->get_augmentation(aug_c - 'a').type == -1) //False if already augmented on that bodypart.
				{
					selectAugmentType(aug_type, aug_c, victim->age);
				}
			}
			set_color_easy(WHITE_ON_BLACK);
			for (int x = 0, y = 4; x < aug_type.size(); x++, y++)
			{
				//set_color(COLOR_WHITE,COLOR_BLACK,c==y+'1'-5);
				mvaddcharAlt(y, 26, y + '1' - 4); addstrAlt(spaceDashSpace);
				addstrAlt(aug_type[x]->get_name());
			}
			//Checks to see if valid input, and moves to next screen
			if (aug_c >= 'a'&&aug_c <= 'e'&&c >= '1'&&c <= '0' + aug_type.size())
			{
				cur_step = 2;
				selected_aug = aug_type[c - '1'];
				break;
			}
			c = getkeyAlt();
			if (c >= 'a'&&c <= 'e') aug_c = c;
			else if (c == ESC)return;
			else if (c == 'x' || c == SPACEBAR || c == ENTER) { cur_step = 0; aug_type.clear(); aug_c = 0; }
			break;
		case 2: //PAGE 2, confirm your choices
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(0, 0, CONST_activate021);
			set_color_easy(WHITE_ON_BLACK);
			addstrAlt(victim->name); addstrAlt(commaSpace); addstrAlt(gettitle(*victim));
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(2, 0, CONST_activate022);
			set_color_easy(WHITE_ON_BLACK);
			addstrAlt(selected_aug->get_name());
			show_victim_status(victim);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(4, 0, CONST_activate023);
			set_color_easy(WHITE_ON_BLACK);
			string selected_attribute = attribute_enum_to_string(selected_aug->get_attribute());
			addstrAlt((char)(toupper(selected_attribute.at(0))) +
				selected_attribute.substr(1) +
				(selected_aug->get_effect() >= 0 ? CONST_activate024 : singleSpace) +
				tostring(selected_aug->get_effect()));
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(5, 0, CONST_activate025);
			int skills = cr->get_skill(SKILL_SCIENCE) + (cr->get_skill(SKILL_FIRSTAID) / 2);
			int difficulty = selected_aug->get_difficulty();
			set_color_easy(WHITE_ON_BLACK);
			addstrAlt(to_string(100 * skills / difficulty));
			mvaddstrAlt(7, 0, CONST_activate026);
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(8, 0, CONST_activate027);
			vector<string> desc;
			split_string(selected_aug->get_description(), ' ', desc);
			int chars_left = 50;
			int line = 9;
			for (int i = 0; i < desc.size(); i++)
			{
				if (desc[i].length() > 50) continue;
				else if (desc[i] == blankString)
				{
					line++;
					chars_left = 50;
					continue;
				}
				else if (chars_left<0 || desc[i].length()>chars_left)
				{
					line++;
					chars_left = 50;
					i--;
					continue;
				}
				else if (desc[i].length() <= chars_left)
				{
					mvaddstrAlt(line, 50 - chars_left, desc[i]);
					chars_left -= (desc[i].length() + 1);
				}
			}
			mvaddstrAlt(23, 1, CONST_activate028);
			c = getkeyAlt();
			if (c == 'y')
			{
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(23, 1, CONST_activate029);
				moveAlt(21, 1);
				int blood_saved = 10 * cr->get_skill(SKILL_SCIENCE) + 15 * cr->get_skill(SKILL_FIRSTAID);
				if (blood_saved > 100) blood_saved = 100;
				victim->blood -= 100 - blood_saved;
				if (skills < difficulty &&
					LCSrandom((100 * difficulty) / skills) < 100)
				{
					unsigned char* wound = nullptr;
					switch (selected_aug->get_type())
					{
					case AUGMENTATION_HEAD:
						wound = &victim->wound[BODYPART_HEAD];
						victim->blood -= 100;
						break;
					case AUGMENTATION_BODY:
						wound = &victim->wound[BODYPART_BODY];
						victim->blood -= 100;
						break;
					case AUGMENTATION_ARMS:
						if (LCSrandom(2))
							wound = &victim->wound[BODYPART_ARM_LEFT];
						else
							wound = &victim->wound[BODYPART_ARM_RIGHT];
						victim->blood -= 25;
						break;
					case AUGMENTATION_LEGS:
						if (LCSrandom(2))
							wound = &victim->wound[BODYPART_LEG_LEFT];
						else
							wound = &victim->wound[BODYPART_LEG_RIGHT];
						victim->blood -= 25;
						break;
					case AUGMENTATION_SKIN:
						if (LCSrandom(2))
							wound = &victim->wound[BODYPART_HEAD];
						else
							wound = &victim->wound[BODYPART_BODY];
						victim->blood -= 50;
						break;
					}
					*wound |= WOUND_NASTYOFF;
					if (victim->blood > 0)
					{
						set_color_easy(RED_ON_BLACK_BRIGHT);
						addstrAlt(string(victim->name) + CONST_activate030, gamelog);
					}
				}
				else //It was successful... but not without some injuries
				{
					unsigned char* wound = nullptr;
					switch (selected_aug->get_type())
					{
					case AUGMENTATION_HEAD:
						wound = &victim->wound[BODYPART_HEAD];
						break;
					case AUGMENTATION_BODY:
						wound = &victim->wound[BODYPART_BODY];
						break;
					case AUGMENTATION_ARMS:
						if (LCSrandom(2))
							wound = &victim->wound[BODYPART_ARM_RIGHT];
						else
							wound = &victim->wound[BODYPART_ARM_LEFT];
						break;
					case AUGMENTATION_LEGS:
						if (LCSrandom(2))
							wound = &victim->wound[BODYPART_LEG_RIGHT];
						else
							wound = &victim->wound[BODYPART_LEG_LEFT];
						break;
					case AUGMENTATION_SKIN:
						wound = &victim->wound[BODYPART_HEAD];
						break;
					}
					*wound |= WOUND_BLEEDING;
					*wound |= WOUND_BRUISED;
					selected_aug->make_augment(victim->get_augmentation(selected_aug->get_type()));
					victim->adjust_attribute(selected_aug->get_attribute(), selected_aug->get_effect());
					cr->train(SKILL_SCIENCE, 15);
					addjuice(*cr, 10, 1000);
					set_color_easy(GREEN_ON_BLACK_BRIGHT);
					addstrAlt(string(victim->name) + CONST_activate031 + selected_aug->get_name(), gamelog);
				}
				if (victim->blood <= 0) //Lost too much blood, you killed 'em
				{
					set_color_easy(RED_ON_BLACK_BRIGHT);
					victim->die();
					addstrAlt(string(victim->name) + CONST_activate032 + cr->name, gamelog);
				}
				show_victim_status(victim);
				pressAnyKey();
				return;
			}
			else if (c == ESC)return;
			else if (c == 'x' || c == SPACEBAR || c == ENTER || c == 'n') { cur_step = 1; selected_aug = nullptr; }
			break;
		}
	}
}
int armor_makedifficulty(ArmorType& type, Creature *cr) //Make class method? -XML
{
	int basedif = type.get_make_difficulty() - cr->get_skill(SKILL_TAILORING) + 3;
	return max(basedif, 0);
}
int armor_makedifficulty(Armor& type, Creature *cr)
{
	extern vector<ArmorType *> armortype;
	return armor_makedifficulty(*armortype[getarmortype(type.get_itemtypename())], cr);
}
/* base - activate - make clothing */
void select_makeclothing(Creature *cr)
{
	const string CONST_activate036 = "Press a Letter to select a Type of Clothing";
	const string CONST_activate035 = "ÄÄÄÄNAMEÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄDIFFICULTYÄÄÄÄÄÄÄÄÄÄÄÄÄCOSTÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ";
	const string CONST_activate034 = " try to make?   (Note: Half Cost if you have cloth)";
	const string CONST_activate033 = "Which will ";
	extern short interface_pgup;
	extern short interface_pgdn;
	extern short lawList[LAWNUM];
	extern vector<ArmorType *> armortype;
	vector<int> armortypei;
	for (int a = 0; a < len(armortype); a++)
	{
		if (armortype[a]->get_make_difficulty() == 0)
			continue;
		if (armortype[a]->deathsquad_legality()
			&& (lawList[LAW_POLICEBEHAVIOR] != -2 || lawList[LAW_DEATHPENALTY] != -2))
			continue;
		armortypei.push_back(a);
	}
	int page = 0;
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, CONST_activate033);
		addstrAlt(cr->name);
		addstrAlt(CONST_activate034);
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(1, 0, CONST_activate035);
		int y = 2;
		for (int p = page * 19; p < len(armortypei) && p < page * 19 + 19; p++, y++)
		{
			set_color_easy(WHITE_ON_BLACK);
			moveAlt(y, 0);
			addcharAlt(y + 'A' - 2); addstrAlt(spaceDashSpace);
			addstrAlt(armortype[armortypei[p]]->get_name());
			moveAlt(y, 37);
			displayDifficulty(MAX(armor_makedifficulty(*armortype[armortypei[p]], cr), 0));
			set_color_easy(GREEN_ON_BLACK_BRIGHT);
			string price = '$' + tostring(armortype[armortypei[p]]->get_make_price());
			mvaddstrAlt(y, 64 - len(price), price);
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(22, 0, CONST_activate036);
		mvaddstrAlt(23, 0, addpagestr());
		int c = getkeyAlt();
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0)page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 19 < len(armortypei))page++;
		if (c >= 'a'&&c <= 's')
		{
			int p = page * 19 + c - 'a';
			if (p < len(armortypei))
			{
				cr->activity.type = ACTIVITY_MAKE_ARMOR;
				cr->activity.arg = armortypei[p]; //Use id name of armor type instead? -XML
				return;
			}
		}
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
	}
}
vector<string> standard_activities_and_data;
void selectOneOfStandardActivities(char c, char choiceChar, Creature *cr) {
	extern bool ZEROMORAL;
	int choice = choiceChar - '1';
	switch (c) {
	case 'a':
		switch (choiceChar)
		{
		case '1':
		case '2':
		case '4':
			//case '5':cr->activity.type=ACTIVITY_DOS_ATTACKS;
		case '5':
		case '6':
			cr->activity.type = activate_menu_items[c][choice].activity;
			break;
		case '3':cr->activity.type = ACTIVITY_GRAFFITI;
			cr->activity.arg = -1;
			break;
		case '7':
			if (cr->location != -1 &&
				LocationsPool::getInstance().getCompoundWalls(cr->location) & COMPOUND_PRINTINGPRESS)
			{
				cr->activity.type = ACTIVITY_WRITE_GUARDIAN; break;
			}
		default:
			if (cr->get_attribute(ATTRIBUTE_WISDOM, true) > 7 || cr->juice < 0)
				cr->activity.type = ACTIVITY_COMMUNITYSERVICE;
			else if (cr->get_attribute(ATTRIBUTE_WISDOM, true) > 4)
				cr->activity.type = ACTIVITY_TROUBLE;
			else
			{
				if (cr->get_skill(SKILL_COMPUTERS) > 2)
					cr->activity.type = ACTIVITY_HACKING;
				else if (cr->get_skill(SKILL_ART) > 1)
				{
					cr->activity.type = ACTIVITY_GRAFFITI;
					cr->activity.arg = -1;
				}
				else
					cr->activity.type = ACTIVITY_TROUBLE;
			}
		}
		break;
	case 'b':
		switch (choiceChar)
		{
		case '1':
		case '2':
		case '3':
		case '4':
			cr->activity.type = activate_menu_items[c][choice].activity;
			break;
		default:
			if (cr->get_weapon().is_instrument())
				cr->activity.type = ACTIVITY_SELL_MUSIC;
			else if (cr->get_skill(SKILL_ART) > 1)
				cr->activity.type = ACTIVITY_SELL_ART;
			else if (cr->get_skill(SKILL_TAILORING) > 1)
				cr->activity.type = ACTIVITY_SELL_TSHIRTS;
			else if (cr->get_skill(SKILL_MUSIC) > 1)
				cr->activity.type = ACTIVITY_SELL_MUSIC;
			else cr->activity.type = ACTIVITY_DONATIONS;
		}
		break;
	case 'c':
		switch (choiceChar)
		{
		case '1':
		case '3':
			//case '4':cr->activity.type=ACTIVITY_DOS_RACKET;break;
			cr->activity.type = activate_menu_items[c][choice].activity;
			break;
		case '2':
			if (ZEROMORAL || cr->age >= 18)
				cr->activity.type = ACTIVITY_PROSTITUTION; break;
		default:
			if (cr->get_skill(SKILL_COMPUTERS) > 1)
				cr->activity.type = ACTIVITY_CCFRAUD;
			else if (cr->get_skill(SKILL_SEDUCTION) > 1 && (ZEROMORAL || cr->age >= 18))
				cr->activity.type = ACTIVITY_PROSTITUTION;
			else cr->activity.type = ACTIVITY_SELL_DRUGS;
		}
		break;
	case 'd':
		switch (choiceChar)
		{
		case '1': { // Pick type to recruit
			ActivityST oact = cr->activity;
			cr->activity.type = ACTIVITY_NONE;
			recruitSelect(*cr);
			if (cr->activity.type == ACTIVITY_RECRUITING) break;
			else cr->activity = oact;
			break; }
		case '2': { // Pick clothing to make
			ActivityST oact = cr->activity;
			cr->activity.type = ACTIVITY_NONE;
			select_makeclothing(cr);
			if (cr->activity.type == ACTIVITY_MAKE_ARMOR) break;
			else cr->activity = oact;
			break; }
		case '3':
			cr->activity.type = activate_menu_items[c][choice].activity;
			break;
		case '4':
			cr->activity.type = ACTIVITY_STEALCARS;
			break;
		case '5':
			if (!cr->canwalk() && !(cr->flag & CREATUREFLAG_WHEELCHAIR))
				cr->activity.type = ACTIVITY_WHEELCHAIR;
			break;
		case '6': {
			if (cr->get_skill(SKILL_SCIENCE) != 0) {
				ActivityST oact = cr->activity;
				cr->activity.type = ACTIVITY_NONE;
				select_augmentation(cr);
				if (cr->activity.type == ACTIVITY_AUGMENT) break;
				else cr->activity = oact;
			}
			break; }
		}
		break;
	}
}
/* base - activate - hostages */
void select_tendhostage(Creature *cr)
{
	const string CONST_activate043 = "Press a Letter to select a Conservative";
	const string CONST_activate042 = "Day";
	const string CONST_activate041 = "Days";
	const string CONST_activate040 = "DAYS IN CAPTIVITY";
	const string CONST_activate038 = " be watching over?";
	const string CONST_activate037 = "Which hostage will ";
	extern short mode;
	extern short interface_pgup;
	extern short interface_pgdn;
	vector<Creature *> temppool = getHostagesSharingLocation(cr);
	if (!len(temppool))return;
	if (len(temppool) == 1)
	{
		cr->activity.type = ACTIVITY_HOSTAGETENDING;
		cr->activity.arg = temppool[0]->id;
		return;
	}
	int page = 0;
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(0, 0, CONST_activate037);
		addstrAlt(cr->name);
		addstrAlt(CONST_activate038);
		mvaddstrAlt(1, 0, CONST_activate067);
		mvaddstrAlt(1, 57, CONST_activate040);
		int y = 2;
		for (int p = page * 19; p < len(temppool) && p < page * 19 + 19; p++, y++)
		{
			set_color_easy(WHITE_ON_BLACK);
			moveAlt(y, 0);
			addcharAlt(y + 'A' - 2); addstrAlt(spaceDashSpace);
			addstrAlt(temppool[p]->name);
			char bright = 0;
			int skill = 0;
			for (int sk = 0; sk < SKILLNUM; sk++)
			{
				skill += temppool[p]->get_skill(sk);
				if (temppool[p]->get_skill_ip(sk) >= 100 + (10 * temppool[p]->get_skill(sk)) &&
					temppool[p]->get_skill(sk) < temppool[p]->skill_cap(sk, true))bright = 1;
			}
			set_color_easy(bright ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
			mvaddstrAlt(y, 25, skill);
			printhealthstat(*temppool[p], y, 33, TRUE);
			if (mode == REVIEWMODE_JUSTICE)set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			else set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(y, 42, LocationsPool::getInstance().getLocationNameWithGetnameMethod(temppool[p]->location, true, true));
			set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
			mvaddstrAlt(y, 57, temppool[p]->joindays);
			addstrAlt(singleSpace);
			if (temppool[p]->joindays > 1)addstrAlt(CONST_activate041);
			else addstrAlt(CONST_activate042);
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(22, 0, CONST_activate043);
		mvaddstrAlt(23, 0, addpagestr());
		int c = getkeyAlt();
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0) page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 19 < len(temppool)) page++;
		if (c >= 'a'&&c <= 's')
		{
			int p = page * 19 + (int)(c - 'a');
			if (p < len(temppool))
			{
				cr->activity.type = ACTIVITY_HOSTAGETENDING;
				cr->activity.arg = temppool[p]->id;
				return;
			}
		}
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
	}
}
void activate(Creature *cr)
{
	const string CONST_activate058 = " will ";
	const string CONST_activate057 = "X - Nothing for Now";
	const string CONST_activate056 = "Enter - Confirm Selection";
	const string CONST_activate055 = "? - Help";
	const string CONST_activate054 = "E - Equip this Liberal";
	const string CONST_activate053 = "Z - Dispose of bodies";
	const string CONST_activate052 = "H - Heal Liberals";
	const string CONST_activate051 = "M - Move to the Free Clinic";
	const string CONST_activate050 = "L - Learn in the University District";
	const string CONST_activate049 = "I - Tend to a Conservative hostage";
	const string CONST_activate048 = "T - Teaching Other Liberals";
	const string CONST_activate047 = " be doing today?";
	const string CONST_activate046 = "Taking Action: What will ";
	const string CONST_activate045 = " yesterday. What now?";
	const string CONST_activate044 = " made $";
	extern int selectedsiege;
	extern long cursquadid;
	int hostagecount = countHostagesSharingLocation(cr);
	int state = 0, choice = 0;
	char havedead = countDeadSharingLocation(cr);
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		printfunds();
		moveAlt(0, 0);
		if (cr->income)
		{
			addstrAlt(cr->name);
			addstrAlt(CONST_activate044);
			addstrAlt(cr->income);
			addstrAlt(CONST_activate045);
		}
		else
		{
			addstrAlt(CONST_activate046);
			addstrAlt(cr->name);
			addstrAlt(CONST_activate047);
		}
		printcreatureinfo(cr);
		makedelimiter();
		Data_Activity activity = data_activities[(Activity)cr->activity.type];
		if (!state)
		{
			if (activity.key != 'x')
				state = activity.key;
		}
		int oldstate = state;
		for (int i = 0; i < len(standard_activities_and_data); i++) {
			set_color_easy(state == 'a' + i ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
			mvaddstrAlt(10 + i, 1, incrementChar('A', i) + spaceDashSpace + standard_activities_and_data[i]);
		}
		set_color_easy(state == 't' ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
		mvaddstrAlt(14, 1, CONST_activate048);
		if (hostagecount > 0)set_color_easy(state == 'i' ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(15, 1, CONST_activate049);
		set_color_easy(state == 'l' ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
		mvaddstrAlt(16, 1, CONST_activate050);
		if (clinictime(*cr))set_color_easy(state == 'm' ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(17, 1, CONST_activate051);
		if (cr->get_skill(SKILL_FIRSTAID) != 0)
			set_color_easy(state == 'h' ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
		else
			set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(18, 1, CONST_activate052);
		if (havedead)set_color_easy(state == 'z' ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(19, 1, CONST_activate053);
		char sieged = 0;
		{
			siegest *siege = getseigestFromLocation(selectedsiege);
			if (siege) sieged = siege->siege;
		}
		/*char underattack=0;
		if(siege&&sieged) underattack=siege->underattack;*/
		if (!sieged)
			set_color_easy(WHITE_ON_BLACK);
		else
			set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(20, 1, CONST_activate054);
		if (state >= 'a' && state < 'a' + len(standard_activities_and_data))
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(19, 40, CONST_activate055);
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(20, 40, CONST_activate056);
		set_color_easy(state == 'x' ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
		mvaddstrAlt(21, 1, CONST_activate057);
		if (state == 'l')
		{
			listclasses(cr);
		}
		else
		{
			int ypos = 10;
			for (ActivityAndString current_item : activate_menu_items[state]) {
				set_color_easy(cr->activity.type == current_item.activity ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
				moveAlt(ypos, 40);
				if (current_item.i > 0)
				{
					addstrAlt(current_item.i);
					addstrAlt(spaceDashSpace);
				}
				ypos++;
				string outputString;
				if (current_item.skill == SKILLNUM) { outputString = current_item.str; }
				else {
					if (cr->get_skill(current_item.skill) >= 8) { outputString = current_item.str3; }
					else
						if (cr->get_skill(current_item.skill) >= 4) { outputString = current_item.str2; }
						else {
							outputString = current_item.str;
						}
				}
				addstrAlt(outputString);
			}
		}
		set_color_easy(WHITE_ON_BLACK);
		moveAlt(22, 3);
		if (activity.show_name)
		{
			addstrAlt(cr->name);
			addstrAlt(CONST_activate058);
		}
		addstrAlt(activity.lineAttempt(0, cr));
		mvaddstrAlt(23, 3, activity.lineAttempt(1, cr));
		mvaddstrAlt(24, 3, activity.lineAttempt(2, cr));
		int c = getkeyAlt();
		if (c >= 'a'&&c <= 'z') state = c;
		if ((c >= 'a'&&c <= 'z') || (c >= '0'&&c <= '9'))
		{
			choice = c;
			switch (state)
			{
			case 'a':
			case 'b':
			case 'c':
			case 'd':
				selectOneOfStandardActivities(state, choice, cr);
				break;
			case 't':
				switch (choice)
				{
				case '1':
				case '2':
				case '3':
					// activate_menu_items['t'] starts its index at 0 with ACTIVITY_NONE, instead of starting at 1 the way the other maps do
					// This is a temporary fix as part of a move to basically remove switch(state) as well as switch(choice)
					cr->activity.type = activate_menu_items['t'][(choice - '1') + 1].activity;
					break;
				default:
					cr->activity.type = getDefaultActivityTeaching(cr);
					break;
				}
				break;
			case 'i':
				if (hostagecount > 0)
				{
					ActivityST oact = cr->activity;
					cr->activity.type = ACTIVITY_NONE;
					select_tendhostage(cr);
					if (cr->activity.type == ACTIVITY_HOSTAGETENDING) break;
					else cr->activity = oact;
				}
				state = oldstate;
				break;
			case 'l':
				updateclasschoice(cr, choice);
				break;
			case 'm':
				if (clinictime(*cr)) cr->activity.type = ACTIVITY_CLINIC;
				else state = oldstate;
				break;
			case 'h':
				if (cr->get_skill(SKILL_FIRSTAID)) cr->activity.type = ACTIVITY_HEAL;
				else state = oldstate;
				break;
			case 'z':
				if (havedead) cr->activity.type = ACTIVITY_BURY;
				else state = oldstate;
				break;
			case 'e':
				if (!sieged)
				{

					createTempSquadWithJustThisLiberal(cr, cursquadid);
				}
				state = oldstate;
				break;
			case 'x':
				cr->activity.type = ACTIVITY_NONE;
				break;
			default:
				state = oldstate;
				break;
			}
		}
		// Enter pressed
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
		// ? Pressed
		if (c == '?')
			if (state == 'a' || state == 'b' || state == 'c' || state == 'd')
				HelpActivities(cr->activity.type); // Call activity help pages
	}
}
//Activism
Activity getDefaultActivityActivism(Creature *cr) {
	if (cr->get_attribute(ATTRIBUTE_WISDOM, true) > 7 || cr->juice < 0)
		return ACTIVITY_COMMUNITYSERVICE;
	else if (cr->get_attribute(ATTRIBUTE_WISDOM, true) > 4)
		return ACTIVITY_TROUBLE;
	else
	{
		if (cr->get_skill(SKILL_COMPUTERS) > 2)
			return ACTIVITY_HACKING;
		else if (cr->get_skill(SKILL_ART) > 1)
		{
			cr->activity.arg = -1;
			return ACTIVITY_GRAFFITI;
		}
		else return ACTIVITY_TROUBLE;
	}
}
//Fundraising
Activity getDefaultActivityFundraising(Creature *cr) {
	if (cr->get_weapon().is_instrument())
		return ACTIVITY_SELL_MUSIC;
	else if (cr->get_skill(SKILL_ART) > 1)
		return ACTIVITY_SELL_ART;
	else if (cr->get_skill(SKILL_TAILORING) > 1)
		return ACTIVITY_SELL_TSHIRTS;
	else if (cr->get_skill(SKILL_MUSIC) > 1)
		return ACTIVITY_SELL_MUSIC;
	else return ACTIVITY_DONATIONS;
}
//Illegal Fundraising
Activity getDefaultActivityIllegalFundraising(Creature *cr) {
	extern bool ZEROMORAL;
	if (cr->get_skill(SKILL_COMPUTERS) > 1)
		return ACTIVITY_CCFRAUD;
	else if (cr->get_skill(SKILL_SEDUCTION) > 1 && (ZEROMORAL || cr->age >= 18))
		return ACTIVITY_PROSTITUTION;
	else
		return ACTIVITY_SELL_DRUGS;
}
vector<string> bulkActivityString;
const string mostlyendings = "mostlyendings\\";

const string CONST_activate060 = "standard_activities_and_data.txt";
const string CONST_activate059 = "bulkActivityString.txt";
vector<file_and_text_collection> activate_text_file_collection = {
customText(&bulkActivityString, mostlyendings + CONST_activate059),
customText(&standard_activities_and_data, mostlyendings + CONST_activate060),
};
void activatebulk()
{
	const string CONST_activate064 = "Press a Letter to Assign an Activity.  Press a Number to select an Activity.";
	const string CONST_activate063 = "BULK ACTIVITY";
	const string CONST_activate062 = "ÄÄÄÄCODE NAMEÄÄÄÄÄÄÄÄÄÄÄÄCURRENT ACTIVITYÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ";
	extern short interface_pgup;
	extern short interface_pgdn;
	vector<Creature *> temppool = activatable_liberals();
	if (!len(temppool)) return;
	int page = 0, selectedactivity = 0;
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		printfunds();
		mvaddstrAlt(0, 0, CONST_activate066);
		mvaddstrAlt(1, 0, CONST_activate062);
		mvaddstrAlt(1, 51, CONST_activate063);

		for (int i = 0; i < len(bulkActivityString); i++) {
			set_color_easy(selectedactivity == i ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
			mvaddstrAlt(2 + i, 51, incrementChar('1', i) + spaceDashSpace + bulkActivityString[i]);
		}
		int y = 2;
		for (int p = page * 19; p < len(temppool) && p < page * 19 + 19; p++, y++)
		{
			set_color_easy(WHITE_ON_BLACK);
			moveAlt(y, 0);
			addcharAlt(y + 'A' - 2); addstrAlt(spaceDashSpace);
			addstrAlt(temppool[p]->name);
			moveAlt(y, 25);
			set_activity_color(temppool[p]->activity.type);
			addstrAlt(getactivity(temppool[p]->activity));
			/*if(temppool[p]->activity.type==ACTIVITY_TROUBLE)
			{
			addstrAlt(spaceParanthesisDollar);
			addstrAlt(temppool[p]->activity.arg);
			addstrAlt(closeParenthesis);
			}*/
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(22, 0, CONST_activate064);
		mvaddstrAlt(23, 0, addpagestr());
		int c = getkeyAlt();
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0) page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 19 < len(temppool)) page++;
		if (c >= 'a'&&c <= 's')
		{
			int p = page * 19 + c - 'a';
			if (p < len(temppool))
			{
				switch (selectedactivity)
				{
				case 0: //Activism
					temppool[p]->activity.type = getDefaultActivityActivism(temppool[p]);
					break;
				case 1: //Fundraising
					temppool[p]->activity.type = getDefaultActivityFundraising(temppool[p]);
					break;
				case 2: //Illegal Fundraising
					temppool[p]->activity.type = getDefaultActivityIllegalFundraising(temppool[p]);
					break;
				case 3: //Check polls
					temppool[p]->activity.type = ACTIVITY_POLLS;
					break;
				case 4: //Steal cars
					temppool[p]->activity.type = ACTIVITY_STEALCARS;
					break;
				case 5: //Volunteer
					temppool[p]->activity.type = ACTIVITY_COMMUNITYSERVICE;
					break;
				case 6: //Repair Clothing
					temppool[p]->activity.type = ACTIVITY_REPAIR_ARMOR;
					break;
				}
			}
		}
		if (c >= '1'&&c <= '7')
			selectedactivity = c - '1';
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
	}
}
// Return the difficulty of tracking this character type down, for the
// purpose of the activation menu. 0 is trivial, 10 is impossible.
int recruitFindDifficulty(int creatureType)
{
	for (int i = 0; i < len(recruitable_creatures); i++)
		if (recruitable_creatures[i].type == creatureType)
			return recruitable_creatures[i].difficulty;
	return 10; // No RecruitData; assume impossible to recruit
}
string recruitName(int creatureType) {

	const string CONST_activate065 = "missingno";
	for (int i = 0; i < len(recruitable_creatures); i++)
		if (recruitable_creatures[i].type == creatureType)
			return recruitable_creatures[i].name;
	return CONST_activate065;
}
/* base - activate the uninvolved */
void activate()
{
	const string CONST_activate071 = "Press Z to assign simple tasks in bulk.";
	const string CONST_activate070 = " T to sort people.";
	const string CONST_activate069 = "Press a Letter to Assign an Activity.";
	const string CONST_activate068 = "ACTIVITY";
	extern MusicClass music;
	extern short mode;
	extern short interface_pgup;
	extern short interface_pgdn;
	extern short activesortingchoice[SORTINGCHOICENUM];
	vector<Creature *> temppool = activatable_liberals();
	if (!len(temppool)) return;
	sortliberals(temppool, activesortingchoice[SORTINGCHOICE_ACTIVATE]);
	int page = 0;
	while (true)
	{
		music.play(MUSIC_ACTIVATE);
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		printfunds();
		mvaddstrAlt(0, 0, CONST_activate066);
		mvaddstrAlt(1, 0, CONST_activate067);
		mvaddstrAlt(1, 57, CONST_activate068);
		int y = 2;
		for (int p = page * 19; p < len(temppool) && p < page * 19 + 19; p++, y++)
		{
			set_color_easy(WHITE_ON_BLACK);
			moveAlt(y, 0);
			addcharAlt(y + 'A' - 2); addstrAlt(spaceDashSpace);
			addstrAlt(temppool[p]->name);
			char bright = 0;
			int skill = 0;
			for (int sk = 0; sk < SKILLNUM; sk++)
			{
				skill += temppool[p]->get_skill(sk);
				if (temppool[p]->get_skill_ip(sk) >= 100 + (10 * temppool[p]->get_skill(sk)) &&
					temppool[p]->get_skill(sk) < temppool[p]->skill_cap(sk, true))bright = 1;
			}
			set_color_easy(bright ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
			mvaddstrAlt(y, 25, skill);
			printhealthstat(*temppool[p], y, 33, TRUE);
			if (mode == REVIEWMODE_JUSTICE)set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			else set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(y, 42, LocationsPool::getInstance().getLocationNameWithGetnameMethod(temppool[p]->location, true, true));
			moveAlt(y, 57);
			// Let's add some color here...
			set_activity_color(temppool[p]->activity.type);
			addstrAlt(getactivity(temppool[p]->activity));
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(22, 0, CONST_activate069);
		mvaddstrAlt(23, 0, addpagestr());
		addstrAlt(CONST_activate070);
		mvaddstrAlt(24, 0, CONST_activate071);
		int c = getkeyAlt();
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0) page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 19 < len(temppool)) page++;
		if (c >= 'a'&&c <= 's')
		{
			int p = page * 19 + c - 'a';
			if (p < len(temppool)) activate(temppool[p]);
		}
		if (c == 't')
		{
			sorting_prompt(SORTINGCHOICE_ACTIVATE);
			sortliberals(temppool, activesortingchoice[SORTINGCHOICE_ACTIVATE], true);
		}
		if (c == 'z') activatebulk();
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
	}
}

#include "../combat/fight.h"

const string CONST_recruit013 = "Adventures in Liberal Recruitment";
const string CONST_recruit012 = "Press enter or escape to call it a day.";
const string CONST_recruit011 = "%c - ";
const string CONST_recruit010 = "%s was able to get information on multiple people.";
const string CONST_recruit007 = "%s managed to set up a meeting with ";
const string CONST_recruit006 = "%s was unable to track down a %s.";
const string CONST_recruit005 = "%s asks around for a %s...";

char talk(Creature &a, const int t);

recruitst::recruitst(Creature *cr, int id) {
	extern short attitude[VIEWNUM];
	recruit = cr;
	recruiter_id = id;
	//Has heard of the LCS
	if ((int)LCSrandom(100) < attitude[VIEW_LIBERALCRIMESQUAD])
	{
		//Likes the LCS
		if ((int)LCSrandom(100) < attitude[VIEW_LIBERALCRIMESQUADPOS])
			eagerness1 = 3;
		//Doesn't like the LCS
		else eagerness1 = 0;
	}
	else eagerness1 = 2;
}
recruitst::~recruitst()
{
	delete recruit;
}
char recruitst::eagerness()
{
	char eagerness_temp = eagerness1;
	//Moderates are decidedly less interested
	if (recruit->align == 0) eagerness_temp -= 2;
	//Conservatives are extremely uninterested
	if (recruit->align == -1) eagerness_temp -= 4;
	return eagerness_temp;
}
//extern string singleDot;
/* recruiting */
char recruitment_activity(Creature &cr)
{
	extern MusicClass music;
	extern short cursite;
	extern Creature encounter[ENCMAX];
	int ocursite = cursite;
	cursite = cr.location;
	int type = cr.activity.arg;
	int difficulty = recruitFindDifficulty(type);
	string name = recruitName(type);
	if (type >= 0)
	{
		music.play(MUSIC_RECRUITING);
		cr.train(SKILL_STREETSENSE, 5);
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, CONST_recruit013);
		printcreatureinfo(&cr);
		makedelimiter();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstr_f(10, 0, CONST_recruit005.c_str(), cr.name, name);
		pressAnyKey();
		int recruitCount = 0;
		if (difficulty < 10)
			// Generate recruitment candidates
			for (recruitCount = 0; recruitCount < 5; recruitCount++)
			{
				if (recruitCount == 0 || cr.skill_roll(SKILL_STREETSENSE) > (difficulty + recruitCount * 2))
				{
					makecreature(encounter[recruitCount], type);
					encounter[recruitCount].namecreature();
				}
				else break;
			}
		if (recruitCount == 0) {
			mvaddstr_f(11, 0, CONST_recruit006.c_str(), cr.name, name);
			pressAnyKey();
			cursite = ocursite;
			return 0;
		}
		else if (recruitCount == 1) {
			mvaddstr_f(11, 0, CONST_recruit007.c_str(), cr.name);
			set_alignment_color(encounter[0].align);
			addstrAlt(encounter[0].name);
			add_age(encounter[0]);
			set_color_easy(WHITE_ON_BLACK);
			addstrAlt(singleDot);
			pressAnyKey();
			eraseAlt();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(0, 0, CONST_recruit013);
			printcreatureinfo(&encounter[0]);
			makedelimiter();
			talk(cr, 0);
		}
		else {
			while (true)
			{
				eraseAlt();
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(0, 0, CONST_recruit013);
				printcreatureinfo(&cr);
				makedelimiter();
				set_color_easy(WHITE_ON_BLACK);
				mvaddstr_f(10, 0, CONST_recruit010.c_str(), cr.name);
				for (int i = 0; i < recruitCount; i++) {
					set_color_easy(WHITE_ON_BLACK);
					mvaddstr_f(12 + i, 0, CONST_recruit011.c_str(), 'a' + i);
					set_alignment_color(encounter[i].align);
					addstrAlt(encounter[i].name);
					add_age(encounter[i]);
				}
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(12 + recruitCount + 1, 0, CONST_recruit012);
				int c = getkeyAlt();
				if (c == ENTER || c == ESC) break;
				c -= 'a';
				if (c >= 0 && c < ENCMAX - 1 && encounter[c].exists)
				{
					int id = encounter[c].id;
					eraseAlt();
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(0, 0, CONST_recruit013);
					printcreatureinfo(&encounter[c]);
					makedelimiter();
					talk(cr, c);
					if (encounter[c].id == id) delenc(c, 0);
					recruitCount--;
					if (recruitCount <= 0) break;
				}
			}
		}
	}
	cursite = ocursite;
	return 1;
}

//// #include "../common/commonactions.h"
void sorting_prompt(short listforsorting);
string getactivity(ActivityST &act);
void activate_sleeper(Creature *cr)
{
	const string CONST_activate_sleepers023 = " will steal equipment and send it to the Shelter.";
	const string CONST_activate_sleepers022 = " will embezzle money for the LCS.";
	const string CONST_activate_sleepers021 = " will snoop around for secrets and enemy plans.";
	const string CONST_activate_sleepers020 = " will try to recruit additional sleeper agents.";
	const string CONST_activate_sleepers019 = " will build support for Liberal causes.";
	const string CONST_activate_sleepers018 = " will stay out of trouble.";
	const string CONST_activate_sleepers017 = "3 - Steal Equipment";
	const string CONST_activate_sleepers016 = "2 - Embezzle Funds";
	const string CONST_activate_sleepers015 = "1 - Uncover Secrets";
	const string CONST_activate_sleepers014 = "3 - [Need More Juice to Recruit]";
	const string CONST_activate_sleepers013 = "3 - [Enlightened Can't Recruit]";
	const string CONST_activate_sleepers012 = "3 - Expand Sleeper Network";
	const string CONST_activate_sleepers011 = "2 - Advocate Liberalism";
	const string CONST_activate_sleepers010 = "1 - Lay Low";
	const string CONST_activate_sleepers009 = "Enter - Confirm Selection";
	const string CONST_activate_sleepers008 = "C - Join the Active LCS";
	const string CONST_activate_sleepers007 = "B - Espionage";
	const string CONST_activate_sleepers006 = "A - Communication and Advocacy";
	const string CONST_activate_sleepers005 = " focus on?";
	const string CONST_activate_sleepers004 = "Taking Undercover Action:   What will ";
	int state = 0, choice = 0;
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		printfunds();
		mvaddstrAlt(0, 0, CONST_activate_sleepers004);
		addstrAlt(cr->name);
		addstrAlt(CONST_activate_sleepers005);
		printcreatureinfo(cr);
		makedelimiter();
		set_color_easy(state == 'a' ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
		mvaddstrAlt(10, 1, CONST_activate_sleepers006);
		set_color_easy(state == 'b' ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
		mvaddstrAlt(11, 1, CONST_activate_sleepers007);
		set_color_easy(state == 'c' ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
		mvaddstrAlt(12, 1, CONST_activate_sleepers008);
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(20, 40, CONST_activate_sleepers009);
		switch (state)
		{
		case 'a':
			set_color_easy(cr->activity.type == ACTIVITY_NONE ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
			mvaddstrAlt(10, 40, CONST_activate_sleepers010);
			set_color_easy(cr->activity.type == ACTIVITY_SLEEPER_LIBERAL ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
			mvaddstrAlt(11, 40, CONST_activate_sleepers011);
			if (subordinatesleft(*cr))
			{
				set_color_easy(cr->activity.type == ACTIVITY_SLEEPER_RECRUIT ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
				mvaddstrAlt(12, 40, CONST_activate_sleepers012);
			}
			else
			{
				set_color_easy(BLACK_ON_BLACK_BRIGHT);
				if (cr->flag & CREATUREFLAG_BRAINWASHED)
					mvaddstrAlt(12, 40, CONST_activate_sleepers013);
				else mvaddstrAlt(12, 40, CONST_activate_sleepers014);
			}
			break;
		case 'b':
			set_color_easy(cr->activity.type == ACTIVITY_SLEEPER_SPY ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
			mvaddstrAlt(10, 40, CONST_activate_sleepers015);
			set_color_easy(cr->activity.type == ACTIVITY_SLEEPER_EMBEZZLE ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
			mvaddstrAlt(11, 40, CONST_activate_sleepers016);
			set_color_easy(cr->activity.type == ACTIVITY_SLEEPER_STEAL ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
			mvaddstrAlt(12, 40, CONST_activate_sleepers017);
			break;
		}
		set_color_easy(WHITE_ON_BLACK);
		switch (cr->activity.type)
		{
		case ACTIVITY_NONE:
			mvaddstrAlt(22, 3, cr->name);
			addstrAlt(CONST_activate_sleepers018);
			break;
		case ACTIVITY_SLEEPER_LIBERAL:
			mvaddstrAlt(22, 3, cr->name);
			addstrAlt(CONST_activate_sleepers019);
			break;
		case ACTIVITY_SLEEPER_RECRUIT:
			if (subordinatesleft(*cr))
			{
				mvaddstrAlt(22, 3, cr->name);
				addstrAlt(CONST_activate_sleepers020);
			}
			break;
		case ACTIVITY_SLEEPER_SPY:
			mvaddstrAlt(22, 3, cr->name);
			addstrAlt(CONST_activate_sleepers021);
			break;
		case ACTIVITY_SLEEPER_EMBEZZLE:
			mvaddstrAlt(22, 3, cr->name);
			addstrAlt(CONST_activate_sleepers022);
			break;
		case ACTIVITY_SLEEPER_STEAL:
			mvaddstrAlt(22, 3, cr->name);
			addstrAlt(CONST_activate_sleepers023);
			break;
		}
		int c = getkeyAlt();
		if (c >= 'a'&&c <= 'z') state = c;
		if ((c >= 'a'&&c <= 'z') || (c >= '1'&&c <= '9'))
		{
			choice = c;
			switch (state)
			{
			case 'a':
				switch (choice)
				{
				default:
				case '1':cr->activity.type = ACTIVITY_NONE; break;
				case '2':cr->activity.type = ACTIVITY_SLEEPER_LIBERAL; break;
				case '3':
					if (subordinatesleft(*cr))
						cr->activity.type = ACTIVITY_SLEEPER_RECRUIT; break;
				}
				break;
			case 'b':
				switch (choice)
				{
				default:
				case '1':cr->activity.type = ACTIVITY_SLEEPER_SPY; break;
				case '2':cr->activity.type = ACTIVITY_SLEEPER_EMBEZZLE; break;
				case '3':cr->activity.type = ACTIVITY_SLEEPER_STEAL; break;
				}
				break;
			}
		}
		if (state == 'c')
		{
			//ActivityST oact=cr->activity;
			cr->activity.type = ACTIVITY_SLEEPER_JOINLCS;
		}
		if (c == 'x')
		{
			cr->activity.type = ACTIVITY_NONE;
			break;
		}
		else
			if (c == ENTER || c == ESC || c == SPACEBAR) break;
	}
}
/* base - activate sleepers */
void activate_sleepers()
{
	extern string percentSign;
	const string CONST_activate_sleepers031 = " T to sort people.";
	const string CONST_activate_sleepers030 = "Press a Letter to Assign an Activity.";
	const string CONST_activate_sleepers029 = "Effectiveness: ";
	const string CONST_activate_sleepers028 = "ACTIVITY";
	const string CONST_activate_sleepers027 = "SITE";
	const string CONST_activate_sleepers026 = "JOB";
	const string CONST_activate_sleepers025 = "CODE NAME";
	const string CONST_activate_sleepers024 = "Activate Sleeper Agents";
	extern MusicClass music;
	extern short interface_pgup;
	extern short interface_pgdn;
	extern short activesortingchoice[SORTINGCHOICENUM];
	vector<Creature *> temppool;
	selectOnlySleepersThatCanWork(temppool);
	if (!len(temppool)) return;
	sortliberals(temppool, activesortingchoice[SORTINGCHOICE_ACTIVATESLEEPERS]);
	int page = 0;
	while (true)
	{
		music.play(MUSIC_SLEEPERS);
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		printfunds();
		mvaddstrAlt(0, 0, CONST_activate_sleepers024);
		makedelimiter(1);
		mvaddstrAlt(1, 4, CONST_activate_sleepers025);
		mvaddstrAlt(1, 25, CONST_activate_sleepers026);
		mvaddstrAlt(1, 42, CONST_activate_sleepers027);
		mvaddstrAlt(1, 57, CONST_activate_sleepers028);
		int y = 2;
		for (int p = page * 9; p < len(temppool) && p < page * 9 + 9; p++, y += 2)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddcharAlt(y, 0, (y - 2) / 2 + 'A'); addstrAlt(spaceDashSpace);
			addstrAlt(temppool[p]->name);
			mvaddstrAlt(y, 25, temppool[p]->get_type_name());
			mvaddstrAlt(y + 1, 6, CONST_activate_sleepers029);
			if (temppool[p]->infiltration > 0.8f)
				set_color_easy(RED_ON_BLACK_BRIGHT);
			else if (temppool[p]->infiltration > 0.6f)
				set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
			else if (temppool[p]->infiltration > 0.4f)
				set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			else if (temppool[p]->infiltration > 0.2f)
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
			else if (temppool[p]->infiltration > 0.1f)
				set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(GREEN_ON_BLACK);
			addstrAlt(static_cast<long>(temppool[p]->infiltration * 100 + 0.5)); // gets rounded to nearest integer
			addstrAlt(percentSign);
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(y, 42, LocationsPool::getInstance().getLocationNameWithGetnameMethod(temppool[p]->worklocation, true, true));
			// Let's add some color here...
			set_activity_color(temppool[p]->activity.type);
			mvaddstrAlt(y, 57, getactivity(temppool[p]->activity));
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(22, 0, CONST_activate_sleepers030);
		mvaddstrAlt(23, 0, addpagestr() + CONST_activate_sleepers031);
		set_color_easy(WHITE_ON_BLACK);
		int c = getkeyAlt();
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0) page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 9 < len(temppool)) page++;
		if (c >= 'a'&&c <= 's')
		{
			int p = page * 9 + (int)(c - 'a');
			if (p < len(temppool))
				activate_sleeper(temppool[p]);
		}
		if (c == 't')
		{
			sorting_prompt(SORTINGCHOICE_ACTIVATESLEEPERS);
			sortliberals(temppool, activesortingchoice[SORTINGCHOICE_ACTIVATESLEEPERS], true);
		}
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
	}
}


//// #include "../includes.h"

const string tag_POLICECAR = "POLICECAR";
const string tag_WEAPON_SPRAYCAN = "WEAPON_SPRAYCAN";
const string tag_WEAPON = "WEAPON";
const string CONST_activities106 = " has ";
const string CONST_activities121 = "!";
#include "../vehicle/vehicletype.h"
#include "../vehicle/vehicle.h"
#include "../log/log.h"
#include "../common/commonactions.h"
#include "../politics/politics.h"
//for int publicmood(int l);
#include "../combat/chase.h"
#include "../combat/chaseCreature.h"
//for void makechasers(long sitetype,long sitecrime);
#include "../combat/fightCreature.h"  
void makeloot(Creature &cr, vector<Item *> &loot);

vector<string> quality_0;
vector<string> quality_20;
vector<string> quality_35;
vector<string> quality_50;
vector<string> words_meaning_hacked;
vector<string> enemy_website;
vector<string> win_hand_to_hand;
vector<string> lose_hand_to_hand;
vector<string> car_wont_start;
vector<string> gets_nervous;
vector<string> cant_hotwire_car;
vector<string> almost_hotwire_car;
vector<string> cant_find_keys;
vector<string> cant_find_keys_no_free_speech;
map< Views, stringConnectedToView > pollingData;
map< Activity, CreatureSkill> trainingActivity;
const string activities = "activities\\";

const string CONST_activities022 = "cant_find_keys_no_free_speech.txt";
const string CONST_activities021 = "cant_find_keys.txt";
const string CONST_activities020 = "almost_hotwire_car.txt";
const string CONST_activities019 = "cant_hotwire_car.txt";
const string CONST_activities018 = "gets_nervous.txt";
const string CONST_activities017 = "car_wont_start.txt";
const string CONST_activities016 = "lose_hand_to_hand.txt";
const string CONST_activities015 = "win_hand_to_hand.txt";
const string CONST_activities014 = "enemy_website.txt";
const string CONST_activities013 = "words_meaning_hacked.txt";
const string CONST_activities012 = "quality_50.txt";
const string CONST_activities011 = "quality_35.txt";
const string CONST_activities010 = "quality_20.txt";
const string CONST_activities009 = "quality_0.txt";
vector<file_and_text_collection> activities_text_file_collection = {
	/*activities.cpp*/
	customText(&quality_0, activities + CONST_activities009),
	customText(&quality_20, activities + CONST_activities010),
	customText(&quality_35, activities + CONST_activities011),
	customText(&quality_50, activities + CONST_activities012),
	customText(&words_meaning_hacked, activities + CONST_activities013),
	customText(&enemy_website, activities + CONST_activities014),
	customText(&win_hand_to_hand, activities + CONST_activities015),
	customText(&lose_hand_to_hand, activities + CONST_activities016),
	customText(&car_wont_start, activities + CONST_activities017),
	customText(&gets_nervous, activities + CONST_activities018),
	customText(&cant_hotwire_car, activities + CONST_activities019),
	customText(&almost_hotwire_car, activities + CONST_activities020),
	customText(&cant_find_keys, activities + CONST_activities021),
	customText(&cant_find_keys_no_free_speech, activities + CONST_activities022),
};
void doActivitySolicitDonations(vector<Creature *> &solicit, char &clearformess);
void doActivitySellTshirts(vector<Creature *> &tshirts, char &clearformess);
void doActivitySellArt(vector<Creature *> &art, char &clearformess);
void doActivitySellMusic(vector<Creature *> &music, char &clearformess);
void doActivitySellBrownies(vector<Creature *> &brownies, char &clearformess);
void doActivityHacking(vector<Creature *> &hack, char &clearformess);
void doActivityGraffiti(vector<Creature *> &graffiti, char &clearformess);
void doActivityProstitution(vector<Creature *> &prostitutes, char &clearformess);
void doActivityLearn(vector<Creature *> &students, char &clearformess);
void doActivityTrouble(vector<Creature *> &trouble, char &clearformess);
void doActivityTeach(vector<Creature *> &teachers, char &clearformess);
void doActivityBury(vector<Creature *> &bury, char &clearformess);
void adjustblogpower(int &power)
{
	if (power < 20)
	{
		addstrAlt(pickrandom(quality_0));
		power = -signed(LCSrandom(2));
	}
	else if (power < 35)
	{
		addstrAlt(pickrandom(quality_20));
		power = 1;
	}
	else if (power < 50)
	{
		addstrAlt(pickrandom(quality_35));
		power = 2;
	}
	else
	{
		addstrAlt(pickrandom(quality_50));
		power = 3;
	}
}
struct trainItem {
	CreatureSkill whichSkill;
	int experience;
	int maxLevel;
	trainItem(CreatureSkill whichSkill_, int experience_, int maxLevel_) :whichSkill(whichSkill_), experience(experience_), maxLevel(maxLevel_) {}
};
struct stringAndMaybeTrain {
	string str;
	vector<trainItem> trainingItem;
	stringAndMaybeTrain(const string& str_, const vector<trainItem>& trainingItem_) : str(str_), trainingItem(trainingItem_) {}
};
const string CONST_activities026 = " peruses some sewing magazines.";
const string CONST_activities025 = " cleans the kitchen.";
const string CONST_activities024 = " reorganizes the armor closet.";
const string CONST_activities023 = " tidies up the safehouse.";
vector<stringAndMaybeTrain> cleanSafeHouse = {
	stringAndMaybeTrain(CONST_activities023, vector<trainItem>({})),
	stringAndMaybeTrain(CONST_activities024, vector<trainItem>({})),
	stringAndMaybeTrain(CONST_activities025, vector<trainItem>({})),
	stringAndMaybeTrain(CONST_activities026, vector<trainItem>({ trainItem(SKILL_TAILORING, 1,MAXATTRIBUTE) }))
};
void findArmorToRepair(Armor* armor, Item* pile, int &pileindex, vector<Item* > *pilelist, Creature cr);
/* armor repair */
void repairarmor(Creature &cr, char &clearformess)
{
	const string CONST_activities033 = " ruined";
	const string CONST_activities032 = " repairs what little can be fixed of ";
	const string CONST_activities031 = " finds there is no hope of repairing ";
	const string CONST_activities030 = " repairs ";
	const string CONST_activities029 = " is working to repair ";
	const string CONST_activities028 = " cleans ";
	const string CONST_activities027 = " disposes of ";
	extern Log gamelog;
	extern vector<squadst *> squad;
	Armor *armor = NULL;
	Item *pile = NULL;
	vector<Item *> *pilelist = NULL;
	int pileindex = 0;
	// Clean yourself up first
	if (cr.get_armor().is_bloody() || cr.get_armor().is_damaged())
		armor = &cr.get_armor();
	else if (cr.squadid != -1)
	{
		int sq = getsquad(cr.squadid);
		for (int l = 0; l < len(squad[sq]->loot); l++)
			if (squad[sq]->loot[l]->whatIsThis() == THIS_IS_ARMOR)
			{
				Armor* a = static_cast<Armor*>(squad[sq]->loot[l]); //cast -XML
				if (a->is_bloody() || a->is_damaged())
				{
					armor = a;
					pile = squad[sq]->loot[l];
					pileindex = l;
					pilelist = &squad[sq]->loot;
					break;
				}
			}
	}
	// Multiple passes, to find the best item to work on
	if (cr.location != -1 && armor == NULL) {
		findArmorToRepair(armor, pile, pileindex, pilelist, cr);

	}
	if (clearformess) eraseAlt();
	else makedelimiter();
	if (armor == NULL)
	{
		mvaddstrAlt(8, 1, cr.name, gamelog);
		stringAndMaybeTrain cleaningString = pickrandom(cleanSafeHouse);
		addstrAlt(cleaningString.str, gamelog);
		for (trainItem o : cleaningString.trainingItem) {
			cr.train(o.whichSkill, o.experience, o.maxLevel);
		}
		gamelog.nextMessage();
		pressAnyKey();
	}
	else
	{
		string armorname = armor->get_name();// Get name before we maybe destroy it
		bool repairfailed = false;
		bool qualityReduction = !LCSrandom(10);
		bool armorDestroyed = !armor->decrease_quality(0);
		if (armor->is_damaged())
		{
			long dif = armor_makedifficulty(*armor, &cr);
			dif >>= (armor->get_quality() - 1);  // it is easy to patch up rags
			cr.train(SKILL_TAILORING, dif / 2 + 1);
			if (LCSrandom(1 + dif / 2)) repairfailed = true;
		}
		else {
			repairfailed = true;
		}
		if (armorDestroyed)
			repairfailed = false;  // Its dead, Jim; stop trying to fix it
		if (repairfailed)
			qualityReduction = false; // Low skill repairers shredding your shirts seem too harsh
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		moveAlt(8, 1);
		std::string result = blankString;
		result += cr.name;
		if (armorDestroyed)
		{
			set_color_easy(RED_ON_BLACK_BRIGHT);
			result += CONST_activities027;
		}
		else if (repairfailed && armor->is_bloody())
		{
			set_color_easy(CYAN_ON_BLACK_BRIGHT);
			result += CONST_activities028;
		}
		else if (repairfailed)
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			result += CONST_activities029;
		}
		else
		{
			if (!qualityReduction)
			{
				set_color_easy(GREEN_ON_BLACK_BRIGHT);
				result += CONST_activities030;
			}
			else
			{
				armorDestroyed = !armor->decrease_quality(1);
				if (armorDestroyed)
				{
					set_color_easy(RED_ON_BLACK_BRIGHT);
					result += CONST_activities031;
				}
				else
				{
					set_color_easy(YELLOW_ON_BLACK_BRIGHT);
					result += CONST_activities032;
				}
			}
		}
		if (pile)
		{
			result += armor->aan();
		}
		else
			result += cr.hisher();
		if (armorDestroyed)
			result += CONST_activities033;
		result += singleSpace + armorname + singleDot;
		addstrAlt(result, gamelog);
		gamelog.nextMessage();
		if (pile)
		{
			if (pile->get_number() > 1)
			{
				Item *newpile = pile->split(pile->get_number() - 1);
				pilelist->push_back(newpile);
			}
		}
		armor->set_bloody(false);
		if (!repairfailed)
		{
			armor->set_damaged(false);
		}
		if (armorDestroyed)
		{
			if (!pile) // repairer was wearing it
			{
				cr.strip(NULL);
			}
			else // scrap from stockpile
			{
				delete_and_remove(*pilelist, pileindex);
			}
		}
		pressAnyKey();
	}
}
void addLootToLoc(int loc, Item* it);
char tryFindCloth(int cursite);
/* armor manufacture */
void makearmor(Creature &cr, char &clearformess)
{
	const string CONST_activities042 = " wasted the materials for a";
	const string CONST_activities041 = "th-rate";
	const string CONST_activities040 = "fourth-rate";
	const string CONST_activities039 = "third-rate";
	const string CONST_activities038 = "second-rate";
	const string CONST_activities037 = "first-rate";
	const string CONST_activities036 = " has made a ";
	const string CONST_activities035 = " cannot find enough cloth to reduce clothing costs.";
	const string CONST_activities034 = " cannot afford material for clothing.";
	extern Log gamelog;
	extern class Ledger ledger;
	extern vector<squadst *> squad;
	extern vector<ArmorType *> armortype;
	int at = cr.activity.arg;
	int cost = armortype[at]->get_make_price();
	int hcost = (cost >> 1) + 1;
	int dif = armor_makedifficulty(*armortype[at], &cr);
	if (ledger.get_funds() < hcost)
	{
		if (clearformess) eraseAlt();
		else makedelimiter();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, cr.name, gamelog);
		addstrAlt(CONST_activities034, gamelog);
		gamelog.nextMessage();
		pressAnyKey();
		return;
	}
	else
	{
		char foundcloth = 0;
		if (cr.squadid != -1)
		{
			int sq = getsquad(cr.squadid);
			for (int l = 0; l < len(squad[sq]->loot); l++)
				if (squad[sq]->loot[l]->whatIsThis() == THIS_IS_LOOT &&
					(squad[sq]->loot[l])->is_cloth()) //cast -XML
				{
					if (squad[sq]->loot[l]->get_number() == 1)
						delete_and_remove(squad[sq]->loot, l);
					else squad[sq]->loot[l]->decrease_number(1);
					foundcloth = 1;
					break;
				}
		}
		if (!foundcloth) foundcloth = tryFindCloth(cr.location);
		if (!foundcloth&&ledger.get_funds() < cost)
		{
			if (clearformess) eraseAlt();
			else makedelimiter();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(8, 1, cr.name, gamelog);
			addstrAlt(CONST_activities035, gamelog);
			gamelog.nextMessage();
			pressAnyKey();
		}
		else
		{
			if (foundcloth) ledger.subtract_funds(hcost, EXPENSE_MANUFACTURE);
			else ledger.subtract_funds(cost, EXPENSE_MANUFACTURE);
			cr.train(SKILL_TAILORING, dif * 2 + 1);
			int quality = 1;
			while (LCSrandom(10) < dif && quality <= armortype[at]->get_quality_levels())
				quality++;
			if (clearformess) eraseAlt();
			else makedelimiter();
			Item *it = new Armor(at, quality);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(8, 1, cr.name, gamelog);
			if (quality <= ((Armor*)it)->get_quality_levels())
			{
				addstrAlt(CONST_activities036, gamelog);
				switch (quality)
				{
				case 1:addstrAlt(CONST_activities037, gamelog); break;
				case 2:addstrAlt(CONST_activities038, gamelog); break;
				case 3:addstrAlt(CONST_activities039, gamelog); break;
				case 4:addstrAlt(CONST_activities040, gamelog); break;
				default:addstrAlt(quality, gamelog); addstrAlt(CONST_activities041, gamelog); break;
				}
				addLootToLoc(cr.location, it);
			}
			else
			{
				addstrAlt(CONST_activities042, gamelog);
			}
			addstrAlt(singleSpace, gamelog);
			addstrAlt(armortype[at]->get_name(), gamelog);
			addstrAlt(singleDot, gamelog);
			gamelog.nextMessage();
			pressAnyKey();
		}
	}
}
/* search for polls */
map<short, string> supportsLiberalLaw;
void survey(Creature *cr)
{
	const string CONST_activities076 = "wanted amnesty for illegal immigrants";
	const string CONST_activities075 = "condemned unnecessary immigration regulations";
	const string CONST_activities074 = "believed in legalizing marijuana";
	const string CONST_activities073 = "supported keeping marijuana legal";
	const string CONST_activities072 = "% ";
	const string CONST_activities071 = "??";
	const string CONST_activities070 = "None     ";
	const string CONST_activities069 = "Low      ";
	const string CONST_activities068 = "Moderate ";
	const string CONST_activities067 = "High     ";
	const string CONST_activities066 = "Very High";
	const string CONST_activities063 = "Unknown  ";
	const string CONST_activities062 = "........................................................";
	const string CONST_activities061 = "                                                                                ";
	const string CONST_activities060 = "    ";
	const string CONST_activities059 = "Enter - Done";
	const string CONST_activities058 = " Liberal percentage points.";
	const string CONST_activities057 = "Results are +/- ";
	const string CONST_activities056 = "XX% Issue ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?Public Interest";
	const string CONST_activities055 = "Additional notable findings:";
	const string CONST_activities054 = "The public is not concerned with politics right now.";
	const string CONST_activities053 = "Liberal Media Bias.";
	const string CONST_activities052 = "Conservative Media Bias.";
	const string CONST_activities051 = "the LCS terrorists.";
	const string CONST_activities050 = "the Liberal Crime Squad.";
	const string CONST_activities049 = "activist political groups.";
	const string CONST_activities048 = "political terrorism.";
	const string CONST_activities047 = "taking strong action.";
	const string CONST_activities046 = "The people are most concerned about ";
	const string CONST_activities045 = "President ";
	const string CONST_activities044 = "% had a favorable opinion of ";
	const string CONST_activities043 = "Survey of Public Opinion, According to Recent Polls";
	extern Log gamelog;
	extern MusicClass music;
	extern short interface_pgup;
	extern short interface_pgdn;
	extern Log gamelog;
	extern char newscherrybusted;
	extern char endgamestate;
	extern newsstoryst *sitestory;
	// Show die rolls, 100% accurate poll numbers
	extern bool SHOWMECHANICS;
	extern char execname[EXECNUM][POLITICIAN_NAMELEN];
	extern short exec[EXECNUM];
	extern short attitude[VIEWNUM];
	extern short public_interest[VIEWNUM];
	extern short lawList[LAWNUM];
	music.play(MUSIC_ELECTIONS);
	static const char SURVEY_PAGE_SIZE = 14;
	int creatureskill = cr->skill_roll(SKILL_COMPUTERS);
	int misschance = 30 - creatureskill, noise;
	if (misschance < 5)misschance = 5;
	if (creatureskill < 1) noise = 18 + LCSrandom(3); // 18 to 20
	else if (creatureskill < 2) noise = 16 + LCSrandom(2); // 16 or 17
	else if (creatureskill < 3) noise = 14 + LCSrandom(2); // 14 or 15
	else if (creatureskill < 4) noise = 12 + LCSrandom(2); // 12 or 13
	else if (creatureskill < 5) noise = 10 + LCSrandom(2); // 10 or 11
	else if (creatureskill < 6) noise = 8 + LCSrandom(2); // 8 or 9
	else if (creatureskill < 7) noise = 7;
	else if (creatureskill < 9) noise = 6;
	else if (creatureskill < 11) noise = 5;
	else if (creatureskill < 14) noise = 4;
	else if (creatureskill < 18) noise = 3;
	else noise = 2;
	int survey[VIEWNUM];
	int maxview = -1;
	for (int v = 0; v < VIEWNUM; v++)
	{
		survey[v] = attitude[v];
		if (v != VIEW_LIBERALCRIMESQUAD && v != VIEW_LIBERALCRIMESQUADPOS/*&&v!=VIEW_POLITICALVIOLENCE*/)
		{
			if (maxview != -1) { if (public_interest[v] > public_interest[maxview]) maxview = v; }
			else { if (public_interest[v] > 0) maxview = v; }
		}
		//MAKE SURVEY ACCURATE IF DEBUGGING
		if (!SHOWMECHANICS) {
			do { survey[v] += LCSrandom(noise * 2 + 1) - noise; } while (!LCSrandom(20));
		}
		if (survey[v] < 0) survey[v] = 0;
		if (survey[v] > 100) survey[v] = 100;
		if (!SHOWMECHANICS) {
			if (LCSrandom(public_interest[v] + 100) < int(misschance)) survey[v] = -1;
		}
		if (v == VIEW_LIBERALCRIMESQUAD && attitude[v] == 0) survey[v] = -1;
		if (v == VIEW_LIBERALCRIMESQUADPOS && survey[VIEW_LIBERALCRIMESQUAD] <= 0) survey[v] = -1;
	}
	eraseAlt();
	//TODO: Sort out the gamelog for this.
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(0, 0, CONST_activities043);
	int approval = presidentapproval();
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(2, 0, approval / 10 + (LCSrandom(noise * 2 + 1) - noise), gamelog);
	addstrAlt(CONST_activities044);
	set_alignment_color(exec[EXEC_PRESIDENT], true);
	addstrAlt(CONST_activities045);
	addstrAlt(execname[EXEC_PRESIDENT]);
	set_color_easy(WHITE_ON_BLACK);
	addstrAlt(singleDot);
	//Top excitement issue
	if (maxview != -1)
	{
		mvaddstrAlt(4, 0, CONST_activities046);
		switch (maxview)
		{
			//case VIEW_POLITICALVIOLENCE:
			//   if(attitude[VIEW_POLITICALVIOLENCE]>50) addstrAlt(CONST_activities047);
			//   else addstrAlt(CONST_activities048);
			//   break;
		case VIEW_LIBERALCRIMESQUAD:
		case VIEW_LIBERALCRIMESQUADPOS:
			if (attitude[VIEW_LIBERALCRIMESQUAD] < 50) addstrAlt(CONST_activities049);
			else
			{
				if (attitude[VIEW_LIBERALCRIMESQUADPOS] > 50) addstrAlt(CONST_activities050);
				else addstrAlt(CONST_activities051);
			}
			break;
		case VIEW_AMRADIO:
		case VIEW_CABLENEWS:
			if (attitude[VIEW_AMRADIO] + attitude[VIEW_CABLENEWS] > 100) addstrAlt(CONST_activities052);
			else addstrAlt(CONST_activities053);
			break;
		default:
			stringConnectedToView currentView = pollingData[(Views)maxview];
			if (attitude[maxview] > 50) {
				addstrAlt(pollingData[(Views)maxview].aboveFifty);
			}
			else {
				if (lawList[maxview] == 2) {
					addstrAlt(pollingData[(Views)maxview].belowFiftyEliteLiberalLaw);
				}
				else if (lawList[maxview] >= 1) {
					addstrAlt(pollingData[(Views)maxview].belowFiftyLiberalLaw);
				}
				else {
					addstrAlt(currentView.belowFifty);
				}
			}
			break;
		}
	}
	else
	{
		mvaddstrAlt(4, 0, CONST_activities054);
	}
	//Header for issue box
	mvaddstrAlt(6, 0, CONST_activities055);
	mvaddstrAlt(7, 0, CONST_activities056);
	//Footer
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(23, 0, CONST_activities057);
	addstrAlt(noise);
	addstrAlt(CONST_activities058);
	mvaddstrAlt(24, 0, CONST_activities059);
	mvaddstrAlt(24, 40, addprevpagestr() + CONST_activities060 + addnextpagestr());
	int page = 0;
	const int maxpage = VIEWNUM / SURVEY_PAGE_SIZE;
	while (true)
	{
		//Keep pages within bounds
		if (page < 0) page = maxpage;
		if (page > maxpage) page = 0;
		//Start from the top
		int y = 8;
		//Draw each line
		for (int v = page * SURVEY_PAGE_SIZE; v < (page + 1)*SURVEY_PAGE_SIZE; v++, y++)
		{
			if (v >= VIEWNUM || (v == VIEW_CONSERVATIVECRIMESQUAD && (endgamestate >= ENDGAME_CCS_DEFEATED || newscherrybusted < 2)))
			{
				mvaddstrAlt(y, 0, CONST_activities061);
				continue;
			}
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(y, 4, CONST_activities062);
			if (noise >= 7 || survey[v] == -1) addstrAlt(CONST_activities063);
			else if (noise >= 4)
			{
				if (public_interest[v] > 50) addstrAlt(CONST_activities067);
				else addstrAlt(CONST_activities069);
			}
			else
			{
				if (public_interest[v] > 100) addstrAlt(CONST_activities066);
				else if (public_interest[v] > 50) addstrAlt(CONST_activities067);
				else if (public_interest[v] > 10) addstrAlt(CONST_activities068);
				else if (public_interest[v]) addstrAlt(CONST_activities069);
				else addstrAlt(CONST_activities070);
			}
			if (survey[v] == -1)set_color_easy(BLACK_ON_BLACK_BRIGHT);
			else if (survey[v] < 10)set_color_easy(RED_ON_BLACK_BRIGHT);
			else if (survey[v] < 30)set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
			else if (survey[v] < 50)set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			else if (survey[v] < 70)set_color_easy(BLUE_ON_BLACK_BRIGHT);
			else if (survey[v] < 90)set_color_easy(CYAN_ON_BLACK_BRIGHT);
			else set_color_easy(GREEN_ON_BLACK_BRIGHT);
			moveAlt(y, 0);
			if (survey[v] == -1) addstrAlt(CONST_activities071);
			else
			{
				if (survey[v] < 10)addcharAlt('0');
				addstrAlt(survey[v]);
			}
			addstrAlt(CONST_activities072);
			if (v == VIEW_DRUGS) {
				if (lawList[LAW_DRUGS] >= 1) addstrAlt(CONST_activities073);
				else addstrAlt(CONST_activities074);
			}
			else if (v == VIEW_IMMIGRATION) {
				if (lawList[LAW_IMMIGRATION] >= 1) addstrAlt(CONST_activities075);
				else addstrAlt(CONST_activities076);
			}
			else {
				addstrAlt(supportsLiberalLaw[v]);
			}
		}
		while (true)
		{
			int c = getkeyAlt();
			if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) return;
			else if (c == interface_pgup || c == KEY_UP || c == KEY_LEFT) { page--; break; }
			else if (c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) { page++; break; }
		}
	}
}
// Police accost your liberal!
void attemptarrest(Creature & liberal, const char* str, int clearformess)
{

	const string CONST_activities077 = " is accosted by police while ";

	extern Log gamelog;
	extern newsstoryst *sitestory;
	extern chaseseqst chaseseq;
	extern vector<newsstoryst *> newsstory;
	if (str)
	{
		if (clearformess) eraseAlt();
		else makedelimiter();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, liberal.name, gamelog);
		addstrAlt(CONST_activities077, gamelog);
		addstrAlt(str, gamelog);
		addstrAlt(CONST_activities121, gamelog);
		gamelog.nextMessage();
		pressAnyKey();
	}
	// Chase sequence! Wee!
	makechasers(-1, 5);
	if (!sitestory)
	{
		newsstoryst *ns = new newsstoryst;
		ns->type = NEWSSTORY_WANTEDARREST; // TODO: Make a more generic catch-all arrest story
		ns->loc = -1;
		newsstory.push_back(ns);
		sitestory = ns;
	}
	chaseseq.clean();
	chaseseq.location = LocationsPool::getInstance().getLocationParent(liberal.location);
	footchase(liberal);
}
// While galavanting in public, your liberals may be ambushed by police
int checkforarrest(Creature & liberal, const char* string, int clearformess)
{
	extern newsstoryst *sitestory;
	extern vector<newsstoryst *> newsstory;
	bool arrest = false;
	if (!liberal.animalgloss && liberal.is_naked() && LCSrandom(2))
	{
		criminalize(liberal, LAWFLAG_DISTURBANCE);
		newsstoryst *ns = new newsstoryst;
		ns->type = NEWSSTORY_NUDITYARREST;
		ns->loc = -1;
		newsstory.push_back(ns);
		sitestory = ns;
		arrest = true;
	}
	else if (liberal.heat > liberal.get_skill(SKILL_STREETSENSE) * 10)
	{
		if (!LCSrandom(50))
		{
			newsstoryst *ns = new newsstoryst;
			ns->type = NEWSSTORY_WANTEDARREST;
			ns->loc = -1;
			newsstory.push_back(ns);
			sitestory = ns;
			arrest = true;
		}
	}
	if (arrest) attemptarrest(liberal, string, clearformess);
	return arrest;
}
#include "../common/creaturePool.h"
/* misc activation related things */
// *JDSRETURN*
void funds_and_trouble(char &clearformess)
{
	extern short background_liberal_influence[VIEWNUM];
	//ACTIVITIES FOR INDIVIDUALS
	extern vector<Creature *> pool;
	vector<Creature *> trouble, hack, bury, solicit, tshirts, art, music, graffiti, brownies, prostitutes, teachers, students;
	for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
	{
		if (!pool[p]->alive) continue;
		if (pool[p]->location == -1)
		{
			pool[p]->activity.type = ACTIVITY_NONE;
			continue;
		}
		switch (pool[p]->activity.type)
		{
		case ACTIVITY_TEACH_FIGHTING:
		case ACTIVITY_TEACH_POLITICS:
		case ACTIVITY_TEACH_COVERT:
			teachers.push_back(pool[p]);
			break;
		case ACTIVITY_CCFRAUD:
		case ACTIVITY_DOS_RACKET:
		case ACTIVITY_DOS_ATTACKS:
		case ACTIVITY_HACKING:
			hack.push_back(pool[p]);
			break;
		case ACTIVITY_GRAFFITI:
			graffiti.push_back(pool[p]);
			break;
		case ACTIVITY_TROUBLE:
			trouble.push_back(pool[p]);
			break;
		case ACTIVITY_COMMUNITYSERVICE:
			addjuice(*pool[p], 1, 10);
			change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, 1, 0, 80);
			break;
		case ACTIVITY_SELL_TSHIRTS:
			tshirts.push_back(pool[p]);
			break;
		case ACTIVITY_SELL_ART:
			art.push_back(pool[p]);
			break;
		case ACTIVITY_SELL_MUSIC:
			music.push_back(pool[p]);
			break;
		case ACTIVITY_DONATIONS:
			solicit.push_back(pool[p]);
			break;
		case ACTIVITY_SELL_DRUGS:
			brownies.push_back(pool[p]);
			break;
		case ACTIVITY_PROSTITUTION:
			prostitutes.push_back(pool[p]);
			break;
		case ACTIVITY_BURY:
			bury.push_back(pool[p]);
			pool[p]->activity.type = ACTIVITY_NONE;
			break;
		case ACTIVITY_CLINIC:
			hospitalize(find_site_index_in_same_city(SITE_HOSPITAL_CLINIC, pool[p]->location), *pool[p]);
			pool[p]->activity.type = ACTIVITY_NONE;
			break;
		case ACTIVITY_STUDY_DEBATING:
		case ACTIVITY_STUDY_MARTIAL_ARTS:
		case ACTIVITY_STUDY_DRIVING:
		case ACTIVITY_STUDY_PSYCHOLOGY:
		case ACTIVITY_STUDY_FIRST_AID:
		case ACTIVITY_STUDY_LAW:
		case ACTIVITY_STUDY_DISGUISE:
		case ACTIVITY_STUDY_SCIENCE:
		case ACTIVITY_STUDY_BUSINESS:
			//case ACTIVITY_STUDY_COOKING:
		case ACTIVITY_STUDY_GYMNASTICS:
		case ACTIVITY_STUDY_ART:
		case ACTIVITY_STUDY_TEACHING:
		case ACTIVITY_STUDY_MUSIC:
		case ACTIVITY_STUDY_WRITING:
		case ACTIVITY_STUDY_LOCKSMITHING:
		case ACTIVITY_STUDY_COMPUTERS:
		case ACTIVITY_STUDY_FENCING:
		case ACTIVITY_STUDY_WEAVING:
		case ACTIVITY_STUDY_RELIGION:
			//case ACTIVITY_STUDY_MAGIC:
		case ACTIVITY_STUDY_CLUB:
		case ACTIVITY_STUDY_STREETSENSE:
		case ACTIVITY_STUDY_THROWING:
		case ACTIVITY_STUDY_STEALTH:
		case ACTIVITY_STUDY_SEDUCTION:
			students.push_back(pool[p]);
			break;
		case ACTIVITY_SLEEPER_JOINLCS:
			if (!LocationsPool::getInstance().isThereASiegeHere(find_site_index_in_same_city(SITE_RESIDENTIAL_SHELTER, pool[p]->location)))
			{
				pool[p]->activity.type = ACTIVITY_NONE;
				pool[p]->flag &= ~CREATUREFLAG_SLEEPER;
				pool[p]->location = pool[p]->base = find_site_index_in_same_city(SITE_RESIDENTIAL_SHELTER, pool[p]->location);
			}
			//Letters to the editor
		case ACTIVITY_WRITE_LETTERS:
			if (pool[p]->skill_check(SKILL_WRITING, DIFFICULTY_EASY))
				background_liberal_influence[randomissue()] += 5;
			pool[p]->train(SKILL_WRITING, LCSrandom(5) + 1);
			break;
			//Guardian Essays
			//Basically letters to the editor, but thrice as potent, and can backfire
		case ACTIVITY_WRITE_GUARDIAN:
			if (pool[p]->skill_check(SKILL_WRITING, DIFFICULTY_EASY))
				background_liberal_influence[randomissue()] += 15;
			else
				background_liberal_influence[randomissue()] -= 15;
			pool[p]->train(SKILL_WRITING, LCSrandom(5) + 1);
			break;
		}
	}
	doActivitySolicitDonations(solicit, clearformess);
	doActivitySellTshirts(tshirts, clearformess);
	doActivitySellArt(art, clearformess);
	doActivitySellMusic(music, clearformess);
	doActivitySellBrownies(brownies, clearformess);
	doActivityHacking(hack, clearformess);
	doActivityGraffiti(graffiti, clearformess);
	doActivityProstitution(prostitutes, clearformess);
	doActivityLearn(students, clearformess);
	doActivityTrouble(trouble, clearformess);
	doActivityTeach(teachers, clearformess);
	doActivityBury(bury, clearformess);
}
void doActivitySolicitDonations(vector<Creature *> &solicit, char &clearformess)
{  //SOLICITORS
	const string CONST_activities079 = "soliciting donations";
	extern class Ledger ledger;
	long total_income = 0;
	for (int s = 0; s < len(solicit); s++)
	{
		if (!checkforarrest(*solicit[s], CONST_activities079.c_str(), clearformess))
		{
			int income = solicit[s]->skill_roll(SKILL_PERSUASION) *
				solicit[s]->get_armor().get_professionalism() + 1;
			// Country's alignment dramatically affects effectiveness
			// The more conservative the country, the more effective
			if (publicmood(-1) > 90) income /= 2;
			if (publicmood(-1) > 65) income /= 2;
			if (publicmood(-1) > 35) income /= 2;
			if (publicmood(-1) > 10) income /= 2;
			solicit[s]->income = income;
			total_income += income;
			solicit[s]->train(SKILL_PERSUASION, max(5 - solicit[s]->get_skill(SKILL_PERSUASION), 2));
		}
	}
	ledger.add_funds(total_income, INCOME_DONATIONS);
}
void doActivitySellTshirts(vector<Creature *> &tshirts, char &clearformess)
{
	const string CONST_activities080 = "selling shirts";
	extern class Ledger ledger;
	extern short background_liberal_influence[VIEWNUM];
	for (int s = 0; s < len(tshirts); s++)
	{
		if (!checkforarrest(*tshirts[s], CONST_activities080.c_str(), clearformess))
		{
			long money = (tshirts[s]->skill_roll(SKILL_TAILORING) +
				tshirts[s]->skill_roll(SKILL_BUSINESS)) / 2;
			// Country's alignment affects effectiveness
			// In a Liberal country, there are many competing vendors
			if (publicmood(-1) > 65) money /= 2;
			if (publicmood(-1) > 35) money /= 2;
			//If you're selling epic shirts enough they'll have some political impact
			if (tshirts[s]->skill_check(SKILL_TAILORING, DIFFICULTY_FORMIDABLE))
				background_liberal_influence[randomissue()] += 5;
			tshirts[s]->income = money;
			ledger.add_funds(money, INCOME_TSHIRTS);
			tshirts[s]->train(SKILL_TAILORING, max(7 - tshirts[s]->get_skill(SKILL_TAILORING), 2));
			tshirts[s]->train(SKILL_BUSINESS, max(7 - tshirts[s]->get_skill(SKILL_BUSINESS), 2));
		}
	}
}
void doActivitySellArt(vector<Creature *> &art, char &clearformess)
{
	const string CONST_activities081 = "sketching portraits";
	extern class Ledger ledger;
	extern short background_liberal_influence[VIEWNUM];
	for (int s = 0; s < len(art); s++)
	{
		if (!checkforarrest(*art[s], CONST_activities081.c_str(), clearformess))
		{
			long money = art[s]->skill_roll(SKILL_ART);
			// Country's alignment affects effectiveness
			// In a Liberal country, there are many competing vendors
			if (publicmood(-1) > 65) money /= 2;
			if (publicmood(-1) > 35) money /= 2;
			//Epic Liberal art may have positive political effect
			if (art[s]->skill_check(SKILL_ART, DIFFICULTY_FORMIDABLE))
				background_liberal_influence[randomissue()] += 5;
			art[s]->income = money;
			ledger.add_funds(money, INCOME_SKETCHES);
			art[s]->train(SKILL_ART, max(7 - art[s]->get_skill(SKILL_ART), 4));
		}
	}
}
void doActivitySellMusic(vector<Creature *> &music, char &clearformess)
{
	const string CONST_activities082 = "playing music";
	extern class Ledger ledger;
	extern short background_liberal_influence[VIEWNUM];
	for (int s = 0; s < len(music); s++)
	{
		if (!checkforarrest(*music[s], CONST_activities082.c_str(), clearformess))
		{
			long money = music[s]->skill_roll(SKILL_MUSIC) / 2;
			bool has_instrument = music[s]->get_weapon().is_instrument();
			if (has_instrument) money *= 4;
			// Country's alignment affects effectiveness
			// In a Liberal country, there are many competing vendors
			if (publicmood(-1) > 65) money /= 2;
			if (publicmood(-1) > 35) money /= 2;
			//Epic Liberal protest songs
			if (music[s]->skill_check(SKILL_MUSIC, DIFFICULTY_FORMIDABLE))
				background_liberal_influence[randomissue()] += has_instrument ? 10 : 5;
			ledger.add_funds(money, INCOME_BUSKING);
			music[s]->income = money;
			if (has_instrument) music[s]->train(SKILL_MUSIC, max(7 - music[s]->get_skill(SKILL_MUSIC), 4));
			else music[s]->train(SKILL_MUSIC, max(5 - music[s]->get_skill(SKILL_MUSIC), 2));
		}
	}
}
void doActivitySellBrownies(vector<Creature *> &brownies, char &clearformess)
{
	const string CONST_activities083 = "selling brownies";
	extern newsstoryst *sitestory;
	extern class Ledger ledger;
	extern short lawList[LAWNUM];
	extern vector<newsstoryst *> newsstory;
	for (int s = 0; s < len(brownies); s++)
	{
		//Check for police search
		int dodgelawroll = LCSrandom(1 + 30 * lawList[LAW_DRUGS] + 3);
		//Saved by street sense?
		if (dodgelawroll == 0)
			dodgelawroll = brownies[s]->skill_check(SKILL_STREETSENSE, DIFFICULTY_AVERAGE);
		if (dodgelawroll == 0 && lawList[LAW_DRUGS] <= 0) // Busted!
		{
			newsstoryst *ns = new newsstoryst;
			ns->type = NEWSSTORY_DRUGARREST;
			ns->loc = -1;
			newsstory.push_back(ns);
			sitestory = ns;
			criminalize(*brownies[s], LAWFLAG_BROWNIES);
			attemptarrest(*brownies[s], CONST_activities083.c_str(), clearformess);
		}
		long money = brownies[s]->skill_roll(SKILL_PERSUASION) +
			brownies[s]->skill_roll(SKILL_BUSINESS) +
			brownies[s]->skill_roll(SKILL_STREETSENSE);
		// more money when more illegal
		if (lawList[LAW_DRUGS] == -2) money *= 4;
		if (lawList[LAW_DRUGS] == -1) money *= 2;
		if (lawList[LAW_DRUGS] == 1) money /= 4;
		if (lawList[LAW_DRUGS] == 2) money /= 8;
		brownies[s]->income = money;
		ledger.add_funds(money, INCOME_BROWNIES);
		// Make the sale
		brownies[s]->train(SKILL_PERSUASION, max(4 - brownies[s]->get_skill(SKILL_PERSUASION), 1));
		// Know the streets
		brownies[s]->train(SKILL_STREETSENSE, max(7 - brownies[s]->get_skill(SKILL_STREETSENSE), 3));
		// Manage your money
		brownies[s]->train(SKILL_BUSINESS, max(10 - brownies[s]->get_skill(SKILL_BUSINESS), 3));
	}
}
vector<activityData> hackingActivities;
#include "../items/lootTypePoolItem.h"
void doActivityHacking(vector<Creature *> &hack, char &clearformess)
{
	const string CONST_activities088 = " a ";
	const string CONST_activities086 = "Your hackers have ";
	const string CONST_activities084 = "Your Hackers have ";
	extern Log gamelog;
	extern class Ledger ledger;
	if (len(hack))
	{
		vector<Creature *> cc,/*web,ddos,*/truehack;
		//First, do accounting to figure out who's doing what
		for (int h = 0; h < len(hack); h++)
		{
			switch (hack[h]->activity.type)
			{
			case ACTIVITY_CCFRAUD:
				hack[h]->train(SKILL_COMPUTERS, 2);
				cc.push_back(hack[h]);
				break;
			case ACTIVITY_DOS_ATTACKS:
				hack[h]->train(SKILL_COMPUTERS, 2);
				//web.push_back(hack[h]);
				break;
			case ACTIVITY_DOS_RACKET:
				hack[h]->train(SKILL_COMPUTERS, 4);
				// ddos.push_back(hack[h]);
				break;
			case ACTIVITY_HACKING:
				hack[h]->train(SKILL_COMPUTERS, 4);
				truehack.push_back(hack[h]);
				break;
			}
		}
		char msg[200] = { 0 };
		//MAJOR HACKING
		int hack_skill = 0;
		for (int h = 0; h < len(truehack); h++)
			hack_skill = max(hack_skill, truehack[h]->skill_roll(SKILL_COMPUTERS));
		if (DIFFICULTY_HEROIC <= hack_skill + len(truehack) - 1)
		{
			if (len(truehack) > 1) strcpy(msg, CONST_activities084.c_str());
			else { strcpy(msg, truehack[0]->name); strcat(msg, CONST_activities106.c_str()); }
			int trackdif = 0, juiceval = 0;
			int short crime = 0;
			activityData currentActivity = pickrandom(hackingActivities);
			strcat(msg, currentActivity.msgString);
			trackdif = currentActivity.difficulty;
			crime = currentActivity.crime;
			juiceval = currentActivity.juiceval;
			if (len(currentActivity.lootType) > 0) {
				addLootToLoc(hack[0]->location, getNewLoot(pickrandom(currentActivity.lootType)));
			}
			for (ChangeOfOpinion o : currentActivity.opinion) {
				change_public_opinion(o.view, o.x, o.y, o.z);
			}
			if (trackdif > hack_skill + LCSrandom(5) - 2)
				for (int h = 0; h < len(truehack); h++)
					criminalize(*hack[h], crime);
			// Award juice to the hacking team for a job well done
			for (int h = 0; h < len(truehack); h++)
				addjuice(*truehack[h], juiceval, 200);
		}
		else if (DIFFICULTY_FORMIDABLE <= hack_skill + len(truehack) - 1)
		{
			int issue = LCSrandom(VIEWNUM - 5), crime = LAWFLAG_INFORMATION;
			if (len(truehack) > 1) strcpy(msg, CONST_activities086.c_str());
			else { strcpy(msg, truehack[0]->name); strcat(msg, CONST_activities106.c_str()); }
			strcat(msg, pickrandom(words_meaning_hacked).data());
			strcat(msg, CONST_activities088.c_str());
			strcat(msg, pickrandom(enemy_website).data());
			strcat(msg, singleDot.data());
			change_public_opinion(issue, 1);
			if (DIFFICULTY_HEROIC > hack_skill + LCSrandom(5) - 2)
				for (int h = 0; h < len(truehack); h++)
					criminalize(*truehack[h], crime);
			// Award juice to the hacking team for a job well done
			for (int h = 0; h < len(truehack); h++)
				addjuice(*truehack[h], 5, 100);
		}
		if (msg[0])
		{
			if (clearformess) eraseAlt();
			else makedelimiter();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(8, 1, msg, gamelog);
			gamelog.nextMessage();
			msg[0] = 0;
			pressAnyKey();
		}
		//CREDIT CARD FRAUD
		for (int h = 0; h < len(cc); h++)
		{
			hack_skill = cc[h]->skill_roll(SKILL_COMPUTERS);
			int difficulty = DIFFICULTY_CHALLENGING;
			if (difficulty <= hack_skill)
			{
				// *JDS* You get between $1 and $100, plus an extra $1-50 every
				// time you pass a check against your hacking skill, where chance of
				// failure is one over the adjusted hackers' skill divided by four. Once
				// a check fails, no more money is gained. This check will be made
				// up to 20 times, at which point the loop breaks. The skill check
				// here doesn't take into account funding.
				int fundgain = LCSrandom(101);
				while (difficulty < hack_skill)
				{
					fundgain += LCSrandom(51);
					difficulty += 2;
				}
				ledger.add_funds(fundgain, INCOME_CCFRAUD);
				cc[h]->income = fundgain / len(cc);
				if (fundgain / 25 > LCSrandom(hack_skill + 1))
					criminalize(*cc[h], LAWFLAG_CCFRAUD);
			}
			if (msg[0])
			{
				if (clearformess) eraseAlt();
				else makedelimiter();
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(8, 1, msg, gamelog); //TODO: Log this?
				gamelog.nextMessage();
				msg[0] = 0;
				pressAnyKey();
			}
		}
	}
}
int lenloot(int cursite);
string gimmeASprayCan(Creature* graffiti);
void buyMeASprayCan(Creature* graffiti);
void doActivityGraffiti(vector<Creature *> &graffiti, char &clearformess)
{
	const string CONST_activities100 = " has begun work on a large mural about ";
	const string CONST_activities099 = " works through the night on a large mural.";
	const string CONST_activities098 = " mural about ";
	const string CONST_activities097 = " beautiful";
	const string CONST_activities096 = " has completed a";
	const string CONST_activities095 = " while spraying an LCS tag!";
	const string CONST_activities094 = " while working on the mural!";
	const string CONST_activities093 = " was spotted by the police";
	const string CONST_activities092 = " needs a spraycan equipped to do graffiti.";
	const string CONST_activities091 = " bought spraypaint for graffiti.";
	const string CONST_activities090 = " from ";
	const string CONST_activities089 = " grabbed a ";
	extern newsstoryst *sitestory;
	extern Log gamelog;
	extern class Ledger ledger;
	extern short public_interest[VIEWNUM];
	extern short background_liberal_influence[VIEWNUM];
	extern vector<newsstoryst *> newsstory;
	if (len(graffiti))
	{
		for (int s = 0; s < len(graffiti); s++)
		{
			if (!graffiti[s]->get_weapon().can_graffiti())
			{
				if (clearformess) eraseAlt();
				else makedelimiter();
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(8, 1, graffiti[s]->name, gamelog);
				//Check base inventory for a spraycan
				bool foundone = false;
				string gottaCan = gimmeASprayCan(graffiti[s]);
				if (len(gottaCan)) {
					foundone = true;
					addstrAlt(CONST_activities089, gamelog);
					addstrAlt(gottaCan, gamelog);
					addstrAlt(CONST_activities090, gamelog);
					addstrAlt(LocationsPool::getInstance().getLocationName(graffiti[s]->base)); //TODO: Explicitly log it, or will the game log it?
					addstrAlt(singleDot, gamelog);
					pressAnyKey();
				}

				if (!foundone && ledger.get_funds() >= 20)
				{
					ledger.subtract_funds(20, EXPENSE_SHOPPING);
					addstrAlt(CONST_activities091, gamelog);
					pressAnyKey();
					buyMeASprayCan(graffiti[s]);
				}
				else if (!foundone)
				{
					addstrAlt(CONST_activities092, gamelog);
					graffiti[s]->activity.type = ACTIVITY_NONE;
					pressAnyKey();
				}
				gamelog.nextMessage(); //Next message now so that we don't have to type it for every case.
			}
			int issue = VIEW_LIBERALCRIMESQUAD, power = 1;
			if (clearformess) eraseAlt();
			else makedelimiter();
			if (!LCSrandom(10) &&
				!(graffiti[s]->skill_check(SKILL_STREETSENSE, DIFFICULTY_AVERAGE)))
			{
				if (clearformess) eraseAlt();
				else makedelimiter();
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(8, 1, graffiti[s]->name, gamelog);
				addstrAlt(CONST_activities093, gamelog);
				criminalize(*graffiti[s], LAWFLAG_VANDALISM);
				graffiti[s]->train(SKILL_STREETSENSE, 20);
				if (graffiti[s]->activity.arg != -1)
				{
					addstrAlt(CONST_activities094, gamelog);
					graffiti[s]->activity.arg = -1;
				}
				else addstrAlt(CONST_activities095, gamelog);
				gamelog.nextMessage();
				newsstoryst *ns = new newsstoryst;
				ns->type = NEWSSTORY_GRAFFITIARREST;
				ns->loc = -1;
				ns->positive = 0;
				newsstory.push_back(ns);
				sitestory = ns;
				pressAnyKey();
				attemptarrest(*graffiti[s], NULL, clearformess);
			}
			else if (graffiti[s]->activity.arg != -1)
			{
				power = 0;
				if (!LCSrandom(3))
				{
					issue = graffiti[s]->activity.arg;
					power = graffiti[s]->skill_roll(SKILL_ART) / 3;
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(8, 1, graffiti[s]->name, gamelog);
					addstrAlt(CONST_activities096, gamelog);
					if (power > 3)addstrAlt(CONST_activities097, gamelog);
					addstrAlt(CONST_activities098, gamelog);
					addstrAlt(getview(issue, false), gamelog);
					addstrAlt(singleDot, gamelog);
					gamelog.nextMessage();
					graffiti[s]->activity.arg = -1;
					addjuice(*graffiti[s], power, power * 20);
					change_public_opinion(issue, power);
					graffiti[s]->train(SKILL_ART, max(10 - graffiti[s]->get_skill(SKILL_ART) / 2, 1));
					pressAnyKey();
				}
				else
				{
					power = 0;
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(8, 1, graffiti[s]->name, gamelog);
					addstrAlt(CONST_activities099, gamelog);
					gamelog.nextMessage();
					graffiti[s]->train(SKILL_ART, max(10 - graffiti[s]->get_skill(SKILL_ART) / 2, 1));
					pressAnyKey();
				}
			}
			else if (!LCSrandom(max(30 - graffiti[s]->get_skill(SKILL_ART) * 2, 5)))
			{
				issue = randomissue();
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(8, 1, graffiti[s]->name, gamelog);
				addstrAlt(CONST_activities100, gamelog);
				addstrAlt(getview(issue, false), gamelog);
				addstrAlt(singleDot, gamelog);
				gamelog.nextMessage();
				graffiti[s]->activity.arg = issue;
				power = 0;
				graffiti[s]->train(SKILL_ART, max(10 - graffiti[s]->get_skill(SKILL_ART) / 2, 1));
				pressAnyKey();
			}
			graffiti[s]->train(SKILL_ART, max(4 - graffiti[s]->get_skill(SKILL_ART), 0));
			if (issue == VIEW_LIBERALCRIMESQUAD)
			{
				change_public_opinion(VIEW_LIBERALCRIMESQUAD, LCSrandom(2), 0, 65);
				change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, !LCSrandom(8), 0, 65);
				public_interest[issue] += power;
			}
			else
			{
				change_public_opinion(VIEW_LIBERALCRIMESQUAD, LCSrandom(2) + 1, 0, 85);
				change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, !LCSrandom(4), 0, 65);
				public_interest[issue] += power;
				background_liberal_influence[issue] += power;
			}
		}
	}
}
void doActivityProstitution(vector<Creature *> &prostitutes, char &clearformess)
{
	const string CONST_activities102 = " was nearly caught in a prostitution sting.";
	const string CONST_activities101 = " has been arrested in a prostitution sting.";
	extern Log gamelog;
	extern class Ledger ledger;
	for (int p = len(prostitutes) - 1; p >= 0; p--)
	{
		// Business once every three days or so
		if (LCSrandom(3)) continue;
		//char num[20];
		long fundgain = 0;
		char caught = 0;
		// Skill determies how much money you get
		int performance = prostitutes[p]->skill_roll(SKILL_SEDUCTION);
		if (performance > DIFFICULTY_HEROIC)
			fundgain = LCSrandom(201) + 200;
		else
			fundgain = LCSrandom(10 * performance) + 10 * performance;
		// Street sense check or deal with slimy people that reduce dignity and juice
		if (!LCSrandom(3) &&
			!(prostitutes[p]->skill_check(SKILL_STREETSENSE, DIFFICULTY_AVERAGE)))
		{
			addjuice(*prostitutes[p], -!LCSrandom(3), -20);
		}
		// Gain seduction and street sense
		prostitutes[p]->train(SKILL_SEDUCTION, max(10 - prostitutes[p]->get_skill(SKILL_SEDUCTION), 0));
		prostitutes[p]->train(SKILL_STREETSENSE, max(10 - prostitutes[p]->get_skill(SKILL_STREETSENSE), 0));
		if (!LCSrandom(50)) // Police sting?
		{
			if (!(prostitutes[p]->skill_check(SKILL_STREETSENSE, DIFFICULTY_AVERAGE))) // Street sense to avoid
			{
				if (clearformess) eraseAlt();
				else makedelimiter();
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(8, 1, prostitutes[p]->name, gamelog);
				addstrAlt(CONST_activities101, gamelog);
				gamelog.nextMessage();
				addjuice(*prostitutes[p], -7, -30);
				pressAnyKey();
				caught = 1;
				removesquadinfo(*prostitutes[p]);
				prostitutes[p]->carid = -1;
				prostitutes[p]->location = find_site_index_in_same_city(SITE_GOVERNMENT_POLICESTATION, prostitutes[p]->location);
				prostitutes[p]->drop_weapons_and_clips(NULL);
				prostitutes[p]->activity.type = ACTIVITY_NONE;
				criminalize(*prostitutes[p], LAWFLAG_PROSTITUTION);
			}
			else
			{
				if (clearformess) eraseAlt();
				else makedelimiter();
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(8, 1, prostitutes[p]->name, gamelog);
				addstrAlt(CONST_activities102, gamelog);
				gamelog.nextMessage();
				addjuice(*prostitutes[p], 5, 0);
				pressAnyKey();
			}
		}
		if (!caught)
		{
			prostitutes[p]->train(SKILL_STREETSENSE, max(5 - prostitutes[p]->get_skill(SKILL_STREETSENSE), 0));
			ledger.add_funds(fundgain, INCOME_PROSTITUTION);
			prostitutes[p]->income = fundgain;
		}
	}
}
void doActivityLearn(vector<Creature *> &students, char &clearformess)
{
	const string CONST_activities104 = " can.";
	const string CONST_activities103 = " has learned as much as ";
	extern Log gamelog;
	extern class Ledger ledger;
	for (int s = len(students) - 1; s >= 0; s--)
	{
		if (ledger.get_funds() < 60) break;
		ledger.subtract_funds(60, EXPENSE_TRAINING);
		int skill[2] = { -1, -1 };
		int effectiveness[2] = { 20, 20 };
		skill[0] = trainingActivity[(Activity)(students[s]->activity.type)];
		bool worthcontinuing = false;
		for (int i = 0; i < 2; i++)
			if (skill[i] != -1)
			{  // rapid decrease in effectiveness as your skill gets higher.
				effectiveness[i] /= (students[s]->get_skill(skill[i]) + 1);
				if (effectiveness[i] < 1)
					effectiveness[i] = 1;
				students[s]->train(skill[i], effectiveness[i]);
				if (students[s]->get_skill(skill[i]) < students[s]->skill_cap(skill[i], true))
					worthcontinuing = true;
			}
		if (!worthcontinuing)
		{
			students[s]->activity.type = ACTIVITY_NONE;
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(8, 1, students[s]->name, gamelog);
			addstrAlt(CONST_activities103, gamelog);
			addstrAlt(students[s]->heshe(), gamelog);
			addstrAlt(CONST_activities104, gamelog);
			gamelog.nextMessage();
			pressAnyKey();
		}
	}
}
void doActivityTrouble(vector<Creature *> &trouble, char &clearformess)
{
	const string CONST_activities139 = "broken!";
	const string CONST_activities138 = "'s last unbroken rib is ";
	const string CONST_activities137 = "'s rib is ";
	const string CONST_activities136 = "One of ";
	const string CONST_activities135 = "'s ribs are ";
	const string CONST_activities134 = " of ";
	const string CONST_activities133 = "All ";
	const string CONST_activities132 = "'s tooth has been pulled out with pliers!";
	const string CONST_activities131 = "'s teeth have been smashed out on the curb.";
	const string CONST_activities130 = "'s neck has been broken!";
	const string CONST_activities129 = "'s upper spine has been broken!";
	const string CONST_activities128 = "'s lower spine has been broken!";
	const string CONST_activities127 = " is severely beaten before the mob is broken up.";
	const string CONST_activities126 = " out of everyone who got close!";
	const string CONST_activities125 = "shit";
	const string CONST_activities124 = "[tar]";
	const string CONST_activities123 = " beat the ";
	const string CONST_activities122 = "The mob scatters!";
	const string CONST_activities120 = " brandishes the ";
	const string CONST_activities119 = " is cornered by a mob of angry rednecks.";
	const string CONST_activities118 = "causing trouble";
	const string CONST_activities117 = "set up a mock sweatshop in the middle of the mall!";
	const string CONST_activities116 = "burned a corporate symbol and denounced capitalism!";
	const string CONST_activities115 = "distributed fliers graphically illustrating CIA torture!";
	const string CONST_activities114 = "distributed fliers graphically illustrating executions!";
	const string CONST_activities113 = "squirted business people with fake polluted water!";
	const string CONST_activities112 = "dressed up and pretended to be a radioactive mutant!";
	const string CONST_activities111 = "dressed up and pretended to be radioactive mutants!";
	const string CONST_activities110 = "gone downtown and reenacted a police beating!";
	const string CONST_activities109 = "posted horrifying dead abortion doctor pictures downtown!";
	const string CONST_activities108 = "disrupted a traditional wedding at a church!";
	const string CONST_activities107 = "run around uptown splashing paint on fur coats!";
	const string CONST_activities105 = "Your Activists have ";
	extern Log gamelog;
	extern newsstoryst *sitestory;
	extern short public_interest[VIEWNUM];
	extern short lawList[LAWNUM];
	extern short background_liberal_influence[VIEWNUM];
	extern vector<newsstoryst *> newsstory;
	if (len(trouble))
	{
		long juiceval = 0;
		char done = 0;
		short crime = 0;
		if (clearformess) eraseAlt();
		else makedelimiter();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		moveAlt(8, 1);
		if (len(trouble) > 1) addstrAlt(CONST_activities105, gamelog);
		else { addstrAlt(trouble[0]->name, gamelog); addstrAlt(CONST_activities106, gamelog); }
		int power = 0;
		for (int t = 0; t < len(trouble); t++)
			power += trouble[t]->skill_roll(SKILL_PERSUASION) +
			trouble[t]->skill_roll(SKILL_STREETSENSE);
		int mod = 1;
		if (LCSrandom(10) < power) mod++;
		if (LCSrandom(20) < power) mod++;
		if (LCSrandom(40) < power) mod++;
		if (LCSrandom(60) < power) mod++;
		if (LCSrandom(80) < power) mod++;
		if (LCSrandom(100) < power) mod++;
		do
		{
			switch (LCSrandom(10))
			{
			case 0:
				addstrAlt(CONST_activities107, gamelog);
				juiceval = 2;
				crime = LAWFLAG_ASSAULT;
				change_public_opinion(VIEW_LIBERALCRIMESQUAD, mod);
				change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, mod >> 1, 0, 70);
				public_interest[VIEW_ANIMALRESEARCH] += mod;
				background_liberal_influence[VIEW_ANIMALRESEARCH] += mod;
				done = 1;
				break;
			case 1:
			{
				if (lawList[LAW_GAY] < 2)
				{
					addstrAlt(CONST_activities108, gamelog);
					change_public_opinion(VIEW_LIBERALCRIMESQUAD, mod);
					change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, mod, 0, 70);
					public_interest[VIEW_GAY] += mod;
					background_liberal_influence[VIEW_GAY] += mod;
					juiceval = 2;
					crime = LAWFLAG_DISTURBANCE;
					done = 1;
				}
				break;
			}
			case 2:
			{
				if (lawList[LAW_ABORTION] < 2)
				{
					addstrAlt(CONST_activities109, gamelog);
					change_public_opinion(VIEW_LIBERALCRIMESQUAD, mod);
					change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, mod, 0, 70);
					public_interest[VIEW_WOMEN] += mod;
					background_liberal_influence[VIEW_WOMEN] += mod;
					juiceval = 1;
					done = 1;
				}
				break;
			}
			case 3:
			{
				if (lawList[LAW_POLICEBEHAVIOR] < 2)
				{
					addstrAlt(CONST_activities110, gamelog);
					change_public_opinion(VIEW_LIBERALCRIMESQUAD, mod);
					change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, mod, 0, 70);
					public_interest[VIEW_POLICEBEHAVIOR] += mod;
					background_liberal_influence[VIEW_POLICEBEHAVIOR] += mod;
					juiceval = 2;
					crime = LAWFLAG_DISTURBANCE;
					done = 1;
				}
				break;
			}
			case 4:
			{
				if (lawList[LAW_NUCLEARPOWER] < 2)
				{
					if (len(trouble) > 1)addstrAlt(CONST_activities111, gamelog);
					else addstrAlt(CONST_activities112, gamelog);
					change_public_opinion(VIEW_LIBERALCRIMESQUAD, mod);
					change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, mod, 0, 70);
					public_interest[VIEW_NUCLEARPOWER] += mod;
					background_liberal_influence[VIEW_NUCLEARPOWER] += mod;
					juiceval = 2;
					crime = LAWFLAG_DISTURBANCE;
					done = 1;
				}
				break;
			}
			case 5:
			{
				if (lawList[LAW_POLLUTION] < 2)
				{
					addstrAlt(CONST_activities113, gamelog);
					change_public_opinion(VIEW_LIBERALCRIMESQUAD, mod);
					change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, mod, 0, 70);
					public_interest[VIEW_POLLUTION] += mod;
					background_liberal_influence[VIEW_POLLUTION] += mod;
					juiceval = 2;
					crime = LAWFLAG_DISTURBANCE;
					done = 1;
				}
				break;
			}
			case 6:
			{
				if (lawList[LAW_DEATHPENALTY] < 2)
				{
					addstrAlt(CONST_activities114, gamelog);
					change_public_opinion(VIEW_LIBERALCRIMESQUAD, mod);
					change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, mod, 0, 70);
					public_interest[VIEW_DEATHPENALTY] += mod;
					background_liberal_influence[VIEW_DEATHPENALTY] += mod;
					juiceval = 1;
					done = 1;
				}
				break;
			}
			case 7:
			{
				addstrAlt(CONST_activities115, gamelog);
				change_public_opinion(VIEW_LIBERALCRIMESQUAD, mod);
				change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, mod, 0, 70);
				public_interest[VIEW_TORTURE] += mod;
				background_liberal_influence[VIEW_TORTURE] += mod;
				juiceval = 1;
				done = 1;
				break;
			}
			case 8:
			{
				addstrAlt(CONST_activities116, gamelog);
				change_public_opinion(VIEW_LIBERALCRIMESQUAD, mod);
				change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, mod, 0, 70);
				public_interest[VIEW_CORPORATECULTURE] += mod;
				background_liberal_influence[VIEW_CORPORATECULTURE] += mod;
				if (lawList[LAW_CORPORATE] == -2)
				{               // In extreme corporate culture cases this should give a flag burning charge! -- kviiri
					juiceval = 2;  // Done -- SlatersQuest
					crime = LAWFLAG_BURNFLAG;
				}
				else juiceval = 1;
				done = 1;
				break;
			}
			case 9:
			{
				addstrAlt(CONST_activities117, gamelog);
				change_public_opinion(VIEW_LIBERALCRIMESQUAD, mod);
				change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, mod, 0, 70);
				public_interest[VIEW_SWEATSHOPS] += mod;
				background_liberal_influence[VIEW_SWEATSHOPS] += mod;
				juiceval += 1;
				done = 1;
				break;
			}
			}
		} while (!done);
		gamelog.nextMessage(); //Do this now so that it doesn't have to be done in every case up there.
		pressAnyKey();
		if (crime != 0)
		{
			for (int t = 0; t < len(trouble); t++)
			{
				if (!LCSrandom(30) &&
					!(trouble[t]->skill_check(SKILL_STREETSENSE, DIFFICULTY_AVERAGE)))
				{
					if (clearformess) eraseAlt();
					else makedelimiter();
					if (!LCSrandom(4))
					{
						newsstoryst *ns = new newsstoryst;
						ns->type = NEWSSTORY_WANTEDARREST; // should probably create a NEWSSTORY_TROUBLEARREST and implement it fully
						ns->loc = -1;                      // but this will have to do for now
						ns->positive = 0;
						newsstory.push_back(ns);
						sitestory = ns;
						attemptarrest(*trouble[t], CONST_activities118.c_str(), clearformess);
					}
					else
					{
						set_color_easy(WHITE_ON_BLACK_BRIGHT);
						mvaddstrAlt(8, 1, trouble[t]->name, gamelog);
						addstrAlt(CONST_activities119, gamelog);
						gamelog.nextMessage();
						pressAnyKey();
						bool wonfight = false;
						if (trouble[t]->get_weapon().is_threatening())
						{
							if (clearformess) eraseAlt();
							else makedelimiter();
							set_color_easy(WHITE_ON_BLACK_BRIGHT);
							mvaddstrAlt(8, 1, trouble[t]->name, gamelog);
							addstrAlt(CONST_activities120, gamelog);
							addstrAlt(trouble[t]->get_weapon().get_name(), gamelog);
							addstrAlt(CONST_activities121, gamelog);
							gamelog.nextMessage();
							pressAnyKey();
							if (clearformess) eraseAlt();
							else makedelimiter();
							set_color_easy(WHITE_ON_BLACK_BRIGHT);
							mvaddstrAlt(8, 1, CONST_activities122, gamelog);
							gamelog.nextMessage();
							pressAnyKey();
							addjuice(*trouble[t], 5, 20);
							wonfight = true;
						}
						else
						{
							for (int count = 0; count <= LCSrandom(5) + 2; count++)
							{
								if (clearformess) eraseAlt();
								else makedelimiter();
								if (trouble[t]->skill_roll(SKILL_HANDTOHAND) > LCSrandom(6) + count)
								{
									set_color_easy(CYAN_ON_BLACK_BRIGHT);
									mvaddstrAlt(8, 1, trouble[t]->name, gamelog);
									addstrAlt(singleSpace, gamelog);
									addstrAlt(pickrandom(win_hand_to_hand), gamelog);
									gamelog.nextMessage();
									pressAnyKey();
									wonfight = true;
								}
								else
								{
									set_color_easy(YELLOW_ON_BLACK_BRIGHT);
									mvaddstrAlt(8, 1, trouble[t]->name, gamelog);
									addstrAlt(singleSpace, gamelog);
									addstrAlt(pickrandom(lose_hand_to_hand), gamelog);
									gamelog.nextMessage();
									pressAnyKey();
									count++; // fight goes faster when you're losing
									wonfight = false;
								}
							}
							if (wonfight)
							{
								if (clearformess) eraseAlt();
								else makedelimiter();
								set_color_easy(GREEN_ON_BLACK_BRIGHT);
								mvaddstrAlt(8, 1, trouble[t]->name, gamelog);
								addstrAlt(CONST_activities123, gamelog);
								if (lawList[LAW_FREESPEECH] == -2)
									addstrAlt(CONST_activities124, gamelog);
								else addstrAlt(CONST_activities125, gamelog);
								addstrAlt(CONST_activities126, gamelog);
								gamelog.nextMessage();
								pressAnyKey();
								addjuice(*trouble[t], 30, 300);
								if (trouble[t]->blood > 70)trouble[t]->blood = 70;
							}
						}
						if (!wonfight)
						{
							if (clearformess) eraseAlt();
							else makedelimiter();
							set_color_easy(RED_ON_BLACK_BRIGHT);
							mvaddstrAlt(8, 1, trouble[t]->name, gamelog);
							addstrAlt(CONST_activities127, gamelog);
							gamelog.nextMessage();
							trouble[t]->activity.type = ACTIVITY_CLINIC;
							pressAnyKey();
							addjuice(*trouble[t], -10, -50);
							if (trouble[t]->blood > 10)trouble[t]->blood = 10;
							if (!LCSrandom(5))
							{
								if (clearformess) eraseAlt();
								else makedelimiter();
								switch (LCSrandom(10))
								{
								case 0:
									if (trouble[t]->special[SPECIALWOUND_LOWERSPINE] == 1)
									{
										mvaddstrAlt(8, 1, trouble[t]->name, gamelog);
										addstrAlt(CONST_activities128, gamelog);
										gamelog.nextMessage();
										trouble[t]->special[SPECIALWOUND_LOWERSPINE] = 0;
										pressAnyKey();
									}
									break;
								case 1:
									if (trouble[t]->special[SPECIALWOUND_UPPERSPINE] == 1)
									{
										mvaddstrAlt(8, 1, trouble[t]->name, gamelog);
										addstrAlt(CONST_activities129, gamelog);
										gamelog.nextMessage();
										trouble[t]->special[SPECIALWOUND_UPPERSPINE] = 0;
										pressAnyKey();
									}
									break;
								case 2:
									if (trouble[t]->special[SPECIALWOUND_NECK] == 1)
									{
										mvaddstrAlt(8, 1, trouble[t]->name, gamelog);
										addstrAlt(CONST_activities130, gamelog);
										gamelog.nextMessage();
										trouble[t]->special[SPECIALWOUND_NECK] = 0;
										pressAnyKey();
									}
									break;
								case 3:
									if (trouble[t]->special[SPECIALWOUND_TEETH] > 0)
									{
										mvaddstrAlt(8, 1, trouble[t]->name);
										if (trouble[t]->special[SPECIALWOUND_TEETH] > 1)addstrAlt(CONST_activities131, gamelog);
										else addstrAlt(CONST_activities132, gamelog);
										gamelog.nextMessage();
										trouble[t]->special[SPECIALWOUND_TEETH] = 0;
										pressAnyKey();
									}
									break;
								default:
								{
									if (trouble[t]->special[SPECIALWOUND_RIBS] > 0)
									{
										int ribminus = LCSrandom(RIBNUM) + 1;
										if (ribminus > trouble[t]->special[SPECIALWOUND_RIBS])ribminus = trouble[t]->special[SPECIALWOUND_RIBS];
										moveAlt(8, 1);
										if (ribminus > 1)
										{
											if (ribminus == trouble[t]->special[SPECIALWOUND_RIBS])
												addstrAlt(CONST_activities133, gamelog);
											addstrAlt(ribminus, gamelog);
											addstrAlt(CONST_activities134, gamelog);
											addstrAlt(trouble[t]->name, gamelog);
											addstrAlt(CONST_activities135, gamelog);
										}
										else if (trouble[t]->special[SPECIALWOUND_RIBS] > 1)
										{
											addstrAlt(CONST_activities136, gamelog);
											addstrAlt(trouble[t]->name, gamelog);
											addstrAlt(CONST_activities137, gamelog);
										}
										else
										{
											addstrAlt(trouble[t]->name);
											addstrAlt(CONST_activities138, gamelog);
										}
										addstrAlt(CONST_activities139, gamelog);
										gamelog.nextMessage();
										pressAnyKey();
										trouble[t]->special[SPECIALWOUND_RIBS] -= ribminus;
									}
									break;
								}
								}
							}
						}
					}
				}
			}
		}
		for (int h = 0; h < len(trouble); h++)
			addjuice(*trouble[h], juiceval, 40);
	}
}
void doActivityTeach(vector<Creature *> &teachers, char &clearformess)
{
	extern class Ledger ledger;
	extern vector<Creature *> pool;
	for (int t = 0; t < len(teachers); t++)
	{
		int skillarray[14];
		int cost = 0, students = 0;
		//Build a list of skills to train and determine the cost for running
		//a class depending on what the teacher is teaching
		switch (teachers[t]->activity.type)
		{
		case ACTIVITY_TEACH_POLITICS:
			cost = 2;
			skillarray[0] = SKILL_LAW;
			skillarray[1] = SKILL_PERSUASION;
			skillarray[2] = SKILL_WRITING;
			skillarray[3] = SKILL_RELIGION;
			skillarray[4] = SKILL_BUSINESS;
			skillarray[5] = SKILL_SCIENCE;
			skillarray[6] = SKILL_STREETSENSE;
			skillarray[7] = SKILL_MUSIC;
			skillarray[8] = SKILL_ART;
			skillarray[9] = -1;
			break;
		case ACTIVITY_TEACH_COVERT:
			cost = 6;
			skillarray[0] = SKILL_SECURITY;
			skillarray[1] = SKILL_COMPUTERS;
			skillarray[2] = SKILL_DISGUISE;
			skillarray[3] = SKILL_TAILORING;
			skillarray[4] = SKILL_STEALTH;
			skillarray[5] = SKILL_SEDUCTION;
			skillarray[6] = SKILL_PSYCHOLOGY;
			skillarray[7] = SKILL_DRIVING;
			skillarray[8] = -1;
			break;
		case ACTIVITY_TEACH_FIGHTING:
			cost = 10;
			skillarray[0] = SKILL_KNIFE;
			skillarray[1] = SKILL_SWORD;
			skillarray[2] = SKILL_CLUB;
			skillarray[3] = SKILL_PISTOL;
			skillarray[4] = SKILL_RIFLE;
			skillarray[5] = SKILL_SHOTGUN;
			skillarray[6] = SKILL_HEAVYWEAPONS;
			skillarray[7] = SKILL_AXE;
			skillarray[8] = SKILL_SMG;
			skillarray[9] = SKILL_THROWING;
			skillarray[10] = SKILL_HANDTOHAND;
			skillarray[11] = SKILL_DODGE;
			skillarray[12] = SKILL_FIRSTAID;
			skillarray[13] = -1;
			break;
		}
		//Count potential students for this teacher to get an idea of efficiency
		for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
		{
			//If they're at the location
			if (pool[p]->location == teachers[t]->location &&
				pool[p]->align == ALIGN_LIBERAL &&
				pool[p]->alive)
			{
				//Step through the array of skills to train
				for (int i = 0; i < 13; i++)           //Any reason why we aren't using a while(true) loop or something even more dynamic? --kviiri
				{
					//If no more skills to train, stop
					if (skillarray[i] == -1) break;
					//Otherwise, if the student has less skill than the teacher, train the student
					//proportional to the difference in skill between teacher and student times the
					//teacher's ability at teaching
					if (pool[p]->get_skill(skillarray[i]) < teachers[t]->get_skill(skillarray[i]) - 1 &&
						pool[p]->get_skill(skillarray[i]) < teachers[t]->get_skill(SKILL_TEACHING) + 2 &&
						pool[p]->get_skill(skillarray[i]) < pool[p]->skill_cap(skillarray[i], true))
					{
						students++;
					}
				}
			}
		}
		//Check funds.
		if (ledger.get_funds() < min(students, 10)*cost)
			continue; //Can't afford to teach them. Continue with next teacher.
					  //Walk through and train people
		for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
		{
			//If they're at the location
			if (pool[p]->location == teachers[t]->location &&
				pool[p]->align == ALIGN_LIBERAL &&
				pool[p]->alive)
			{
				//Step through the array of skills to train
				for (int i = 0; i < 13; i++)
				{
					//If no more skills to train, stop
					if (skillarray[i] == -1)break;
					//Otherwise, if the student has less skill than the teacher, train the student
					//proportional to the difference in skill between teacher and student times the
					//teacher's ability at teaching
					if (pool[p]->get_skill(skillarray[i]) < teachers[t]->get_skill(skillarray[i]) - 1 &&
						pool[p]->get_skill(skillarray[i]) < teachers[t]->get_skill(SKILL_TEACHING) + 2 &&
						pool[p]->get_skill(skillarray[i]) < pool[p]->skill_cap(skillarray[i], true))
					{
						// Teach based on teacher's skill in the topic plus skill in teaching, minus
						// student's skill in the topic
						int teach = teachers[t]->get_skill(skillarray[i]) +
							teachers[t]->get_skill(SKILL_TEACHING) -
							pool[p]->get_skill(skillarray[i]);
						//at ten students, cost no longer goes up, but effectiveness goes down.
						if (students > 10)
						{
							//teach = (teach * 10) / students; //teach at 50% speed with twice as many students.
							teach = ((teach * 30 / students) + teach) / 4; //62.5% speed with twice as many students.
						}
						if (teach < 1)
							teach = 1;
						// Cap at 10 points per day
						if (teach > 10)
							teach = 10;
						pool[p]->train(skillarray[i], teach);
						/*if(students<10)
						{
						students++;
						ledger.subtract_funds(cost,EXPENSE_TRAINING);
						if(students==10)cost=0;
						}*/
					}
				}
			}
		}
		ledger.subtract_funds(cost*min(students, 10), EXPENSE_TRAINING);
		teachers[t]->train(SKILL_TEACHING, min(students, 10));
	}
}
void lootTheBody(Creature &cr, int base);
void doActivityBury(vector<Creature *> &bury, char &clearformess)
{
	const string CONST_activities141 = "'s body";
	const string CONST_activities140 = "burying ";
	extern newsstoryst *sitestory;
	extern vector<Creature *> pool;
	extern vector<newsstoryst *> newsstory;
	if (len(bury))
	{
		for (int p = CreaturePool::getInstance().lenpool() - 1; p >= 0; p--)
		{
			if (pool[p]->alive) continue;
			bool arrest_attempted = false;
			lootTheBody(*pool[p], bury[0]->base);

			for (int b = 0; b < len(bury); b++)
			{
				if (!arrest_attempted && !(bury[b]->skill_check(SKILL_STREETSENSE, DIFFICULTY_EASY)))
				{
					arrest_attempted = true; // Only attempt one burial arrest per body
					newsstoryst *ns = new newsstoryst;
					ns->type = NEWSSTORY_BURIALARREST;
					ns->loc = -1;
					newsstory.push_back(ns);
					sitestory = ns;
					criminalize(*bury[b], LAWFLAG_BURIAL);
					char str[100];
					strcpy(str, CONST_activities140.c_str());
					strcat(str, pool[p]->name);
					strcat(str, CONST_activities141.c_str());
					attemptarrest(*bury[b], str, clearformess);
					// If a liberal is spotted they should not do more burials.
					bury.erase(bury.begin() + b--);
					break;
				}
			}
			//BURY (even if interrupted)
			delete_and_remove(pool, p);
			if (!len(bury)) break; //Stop burials if none are left doing them.
		}
	}
}
int lenVehicleType();
int steal_difficultytofind(const int v);
string vehicleTypelongname(const int p);
bool carselect(Creature &cr, short &cartype)
{
	const string CONST_activities145 = "Press a Letter to select a Type of Car";
	const string CONST_activities144 = "ÄÄÄÄTYPEÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄDIFFICULTY TO FIND UNATTENDEDÄÄ";
	const string CONST_activities143 = " try to find and steal today?";
	const string CONST_activities142 = "What type of car will ";
	extern short interface_pgup;
	extern short interface_pgdn;
	cartype = -1;
	vector<int> cart;
	for (int a = 0; a < lenVehicleType(); a++)
		if (steal_difficultytofind(a) < 10) cart.push_back(a);
	int page = 0;
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, CONST_activities142);
		addstrAlt(cr.name);
		addstrAlt(CONST_activities143);
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(1, 0, CONST_activities144);
		int y = 2;
		for (int p = page * 19; p < len(cart) && p < page * 19 + 19; p++)
		{
			set_color_easy(WHITE_ON_BLACK);
			moveAlt(y, 0);
			addcharAlt(y + 'A' - 2); addstrAlt(spaceDashSpace);
			addstrAlt(vehicleTypelongname(cart[p]));
			moveAlt(y++, 49);
			displayDifficulty(steal_difficultytofind(cart[p]));
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(22, 0, CONST_activities145);
		mvaddstrAlt(23, 0, addpagestr());
		int c = getkeyAlt();
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0) page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 19 < len(cart)) page++;
		if (c >= 'a'&&c <= 's')
		{
			int p = page * 19 + c - 'a';
			if (p < len(cart))
			{
				cartype = cart[p];
				return true;
			}
		}
		// Too easy to accidentally back out
		// Not a big problem if this page isn't skippable
		// (There's no immediate risk in picking a car)
		// - JDS
		//if(c=='x'||c==ENTER||c==ESC||c==SPACEBAR)break;
	}
	return false;
}

void observeAlarm(const bool sensealarm, const bool alarmon, const string name, const string carname) {
	extern Log gamelog;
	const string CONST_activities162 = " stands by the ";
	const string CONST_activities161 = "THIS IS THE VIPER!   STAND AWAY!";
	const string CONST_activities160 = "THE VIPER:   ";
	const string CONST_activities158 = "STAND AWAY FROM THE VEHICLE!   <BEEP!!> <BEEP!!>";
	const string CONST_activities183 = "<BEEP!!> <BEEP!!> <BEEP!!> <BEEP!!>";
	//const string CONST_activities182 = "REMOVE YOURSELF FROM THE VEHICLE!   <BEEP!!> <BEEP!!>";
	const string CONST_activities181 = ":   ";
	const string CONST_activities180 = "THE VIPER";
	if (alarmon)
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		moveAlt(10, 0);
		if (sensealarm)addstrAlt(CONST_activities180);
		else addstrAlt(carname);
		addstrAlt(CONST_activities181);
		set_color_easy(RED_ON_BLACK_BRIGHT);
		if (sensealarm)addstrAlt(CONST_activities158);
		else addstrAlt(CONST_activities183);
	}
	else if (sensealarm)
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(10, 0, CONST_activities160);
		set_color_easy(RED_ON_BLACK_BRIGHT);
		addstrAlt(CONST_activities161, gamelog);
		gamelog.nextMessage();
	}
	else
	{
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(10, 0, name, gamelog);
		addstrAlt(CONST_activities162, gamelog);
		addstrAlt(carname, gamelog);
		addstrAlt(singleDot, gamelog);
		gamelog.nextMessage();
	}
}

string wasUnableToFind(const string old);
string considerLeaving(const bool sensealarm, const bool alarmon, const string name);

Vehicle* getVehicleOfThisType(int cartype);
void newVehicle(Vehicle *startcar);
/* steal a car */
bool stealcar(Creature &cr, char &clearformess)
{
	const string CONST_activities202 = " has been spotted by a passerby!";
	const string CONST_activities201 = "If they were here, I'd have found them by now.";
	const string CONST_activities200 = "I don't think they're in here...";
	const string CONST_activities199 = "Are they even in here?";
	const string CONST_activities198 = ": <rummaging> ";
	const string CONST_activities197 = " found the keys ";
	const string CONST_activities196 = "Holy shit!  ";
	const string CONST_activities195 = "Holy [Car Keys]!  ";
	const string CONST_activities194 = "under the back seat!";
	const string CONST_activities193 = "under the front seat!";
	const string CONST_activities192 = "in the glove compartment!";
	const string CONST_activities191 = "above the pull-down sunblock thingy!";
	const string CONST_activities190 = "in the ignition.  Damn.";
	const string CONST_activities189 = "in SPACE. With ALIENS. Seriously.";
	const string CONST_activities188 = " hotwires the car!";
	const string CONST_activities187 = "Enter - The Viper has finally deterred ";
	const string CONST_activities185 = "B - Desperately search for keys.";
	const string CONST_activities184 = "A - Hotwire the car.";


	const string CONST_activities186 = "Enter - Call it a day.";
	const string CONST_activities183 = "<BEEP!!> <BEEP!!> <BEEP!!> <BEEP!!>";
	const string CONST_activities182 = "REMOVE YOURSELF FROM THE VEHICLE!   <BEEP!!> <BEEP!!>";
	const string CONST_activities181 = ":   ";
	const string CONST_activities180 = "THE VIPER";


	const string CONST_activities179 = " is behind the wheel of a ";
	const string CONST_activities178 = "Adventures in Liberal Car Theft";
	const string CONST_activities176 = "An alarm suddenly starts blaring!";
	const string CONST_activities175 = " but it is still somewhat intact.";
	const string CONST_activities174 = " with a ";
	const string CONST_activities173 = " cracks the window";
	const string CONST_activities171 = " smashes the window";
	const string CONST_activities170 = " fiddles with the lock with no luck.";
	const string CONST_activities169 = " jimmies the car door open.";

	const string CONST_activities164 = "B - Break the window.";
	const string CONST_activities163 = "A - Pick the lock.";
	const string CONST_activities153 = "A - Approach the driver's side door.";
	const string CONST_activities152 = " looks from a distance at an empty ";
	const string CONST_activities150 = " found a ";
	const string CONST_activities147 = " looks around for an accessible vehicle...";
	extern Log gamelog;
	extern MusicClass music;
	extern short mode;
	extern short interface_pgup;
	extern short interface_pgdn;
	extern newsstoryst *sitestory;
	extern chaseseqst chaseseq;
	extern short fieldskillrate;
	extern short lawList[LAWNUM];
	extern vector<newsstoryst *> newsstory;
	music.play(MUSIC_CARTHEFT);
	clearformess = 1;
	short cartype;
	if (carselect(cr, cartype))
	{
		int diff = steal_difficultytofind(cartype) * 2;
		Vehicle *v = NULL;
		int old = cartype;
		cr.train(SKILL_STREETSENSE, 5);
		//THEFT SEQUENCE
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, CONST_activities178, gamelog);
		gamelog.nextMessage();
		printcreatureinfo(&cr);
		makedelimiter();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(10, 0, cr.name, gamelog);
		addstrAlt(CONST_activities147, gamelog);
		pressAnyKey();
		//ROUGH DAY
		if (!cr.skill_check(SKILL_STREETSENSE, diff))
			do cartype = LCSrandom(lenVehicleType());
		while (cartype == old || LCSrandom(10) < steal_difficultytofind(cartype));
		v = getVehicleOfThisType(cartype);
		string carname = v->fullname();
		mvaddstrAlt(11, 0, cr.name, gamelog);
		if (old != cartype)
		{
			addstrAlt(wasUnableToFind(vehicleTypelongname(old)), gamelog);
		}
		else addstrAlt(CONST_activities150, gamelog);
		addstrAlt(v->longname(), gamelog);
		addstrAlt(singleDot, gamelog);
		gamelog.nextMessage();
		pressAnyKey();
		//APPROACH?
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, CONST_activities178);
		printcreatureinfo(&cr);
		makedelimiter();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(10, 0, cr.name, gamelog);
		addstrAlt(CONST_activities152, gamelog);
		addstrAlt(carname, gamelog);
		addstrAlt(singleDot, gamelog);
		gamelog.nextMessage();
		mvaddstrAlt(12, 0, CONST_activities153);
		mvaddstrAlt(13, 0, CONST_activities186);
		while (true)
		{
			int c = getkeyAlt();
			if (c == 'a')break;
			if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) { delete v; return false; }
		}
		//SECURITY?
		bool alarmon = false, sensealarm = LCSrandom(100) < v->sensealarmchance(),
			touchalarm = LCSrandom(100) < v->touchalarmchance();
		char windowdamage = 0;
		for (bool entered = false; !entered;)
		{
			eraseAlt();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(0, 0, CONST_activities178);
			printcreatureinfo(&cr);
			makedelimiter();

			observeAlarm(sensealarm != 0, alarmon, cr.name, carname);

			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(12, 0, CONST_activities163);
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(13, 0, CONST_activities164);
			moveAlt(14, 0);

			addstrAlt(considerLeaving(sensealarm, alarmon, cr.name));

			char method = -1;
			while (method == -1)
			{
				int c = getkeyAlt();
				if (c == 'a')method = 0;
				if (c == 'b')method = 1;
				if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) { delete v; return false; } /* try again tomorrow */
			}
			//PICK LOCK
			if (method == 0)
			{
				if (cr.skill_check(SKILL_SECURITY, DIFFICULTY_AVERAGE))
				{
					switch (fieldskillrate)
					{
					case FIELDSKILLRATE_FAST:
						cr.train(SKILL_SECURITY, 25); break;
					case FIELDSKILLRATE_CLASSIC:
						cr.train(SKILL_SECURITY, max(5 - cr.get_skill(SKILL_SECURITY), 0)); break;
					case FIELDSKILLRATE_HARD:
						cr.train(SKILL_SECURITY, 0); break;
					}
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(16, 0, cr.name, gamelog);
					addstrAlt(CONST_activities169, gamelog);
					gamelog.nextMessage();
					pressAnyKey();
					entered = true;
				}
				else
				{
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(16, 0, cr.name, gamelog);
					addstrAlt(CONST_activities170, gamelog);
					gamelog.nextMessage();
					pressAnyKey();
				}
			}
			//BREAK WINDOW
			if (method == 1)
			{
				int difficulty = static_cast<int>(DIFFICULTY_EASY / cr.get_weapon().get_bashstrengthmod()) - windowdamage;
				if (cr.attribute_check(ATTRIBUTE_STRENGTH, difficulty))
				{
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(16, 0, cr.name, gamelog);
					addstrAlt(CONST_activities171, gamelog);
					if (cr.get_weapon().get_bashstrengthmod() > 1)
					{
						addstrAlt(CONST_activities174, gamelog);
						addstrAlt(cr.get_weapon().get_name(2), gamelog);
					}
					addstrAlt(singleDot, gamelog);
					gamelog.nextMessage();
					windowdamage = 10;
					pressAnyKey();
					entered = true;
				}
				else
				{
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(16, 0, cr.name, gamelog);
					addstrAlt(CONST_activities173, gamelog);
					if (cr.get_weapon().get_bashstrengthmod() > 1)
					{
						addstrAlt(CONST_activities174, gamelog);
						addstrAlt(cr.get_weapon().get_name(2), gamelog);
					}
					addstrAlt(CONST_activities175, gamelog);
					gamelog.nextMessage();
					windowdamage++;
					pressAnyKey();
				}
			}
			//ALARM CHECK
			int y = 17;
			if (touchalarm || sensealarm)
			{
				if (!alarmon)
				{
					set_color_easy(YELLOW_ON_BLACK_BRIGHT);
					mvaddstrAlt(y++, 0, CONST_activities176, gamelog);
					gamelog.nextMessage();
					pressAnyKey();
					alarmon = true;
				}
			}
			//NOTICE CHECK
			if (!LCSrandom(50) || (!LCSrandom(5) && alarmon))
			{
				set_color_easy(RED_ON_BLACK_BRIGHT);
				mvaddstrAlt(y++, 0, cr.name, gamelog);
				addstrAlt(CONST_activities202, gamelog);
				gamelog.nextMessage();
				pressAnyKey();
				//FOOT CHASE
				chaseseq.clean();
				chaseseq.location = LocationsPool::getInstance().getLocationParent(cr.location);
				newsstoryst *ns = new newsstoryst;
				ns->type = NEWSSTORY_CARTHEFT;
				newsstory.push_back(ns);
				sitestory = ns;
				makechasers(-1, 5);
				if (footchase(cr)) {
					mode = GAMEMODE_BASE;
					delete v; return false;
				} // Switched to return false; this will cause you to try again tomorrow
				else {
					mode = GAMEMODE_BASE;
					delete v; return false;
				}
			}
		}
		//START CAR
		char keys_in_car = LCSrandom(5) > 0, key_search_total = 0;
		int key_location = LCSrandom(5), nervous_counter = 0;
		//char ignition_progress=0;
		for (bool started = false; !started;)
		{
			nervous_counter++;
			eraseAlt();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(0, 0, CONST_activities178);
			printcreatureinfo(&cr);
			makedelimiter();
			int y = 10;
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(y++, 0, cr.name, gamelog);
			addstrAlt(CONST_activities179, gamelog);
			addstrAlt(carname, gamelog);
			addstrAlt(singleDot, gamelog);
			gamelog.nextMessage();
			if (alarmon)
			{
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				moveAlt(y++, 0);
				if (sensealarm)addstrAlt(CONST_activities180);
				else addstrAlt(carname);
				addstrAlt(CONST_activities181);
				set_color_easy(RED_ON_BLACK_BRIGHT);
				if (sensealarm)addstrAlt(CONST_activities182);
				else addstrAlt(CONST_activities183);
			}
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt((++y)++, 0, CONST_activities184);
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(y++, 0, CONST_activities185);
			moveAlt(y++, 0);
			if (!sensealarm)addstrAlt(CONST_activities186);
			else { addstrAlt(CONST_activities187); addstrAlt(cr.name); addstrAlt(singleDot); }
			y++;
			char method = -1;
			while (method == -1)
			{
				int c = getkeyAlt();
				if (c == 'a') method = 0;
				if (c == 'b') method = 1;
				if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) { delete v; return false; } // Call it a day and try again tomorrow
			}
			//HOTWIRE CAR
			if (method == 0)
			{
				if (cr.skill_check(SKILL_SECURITY, DIFFICULTY_CHALLENGING))
				{
					switch (fieldskillrate)
					{
					case FIELDSKILLRATE_FAST:
						cr.train(SKILL_SECURITY, 50); break;
					case FIELDSKILLRATE_CLASSIC:
						cr.train(SKILL_SECURITY, max(10 - cr.get_skill(SKILL_SECURITY), 0)); break;
					case FIELDSKILLRATE_HARD:
						cr.train(SKILL_SECURITY, 0); break;
					}
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(y++, 0, cr.name, gamelog);
					addstrAlt(CONST_activities188, gamelog);
					gamelog.nextMessage();
					pressAnyKey();
					started = true;
				}
				else
				{
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(y++, 0, cr.name, gamelog);
					int flavor_text;
					if (cr.get_skill(SKILL_SECURITY) < 4)
						addstrAlt(pickrandom(cant_hotwire_car));
					else {
						if (LCSrandom(cant_hotwire_car.size() + almost_hotwire_car.size()) >= cant_hotwire_car.size()) {
							addstrAlt(pickrandom(almost_hotwire_car));
						}
						else {
							addstrAlt(pickrandom(cant_hotwire_car));
						}
					}
					gamelog.nextMessage();
					pressAnyKey();
				}
			}
			//KEYS
			if (method == 1)
			{
				int difficulty;
				const char * location;
				if (!keys_in_car)
				{
					difficulty = DIFFICULTY_IMPOSSIBLE;
					location = CONST_activities189.c_str();
				}
				else switch (key_location)
				{
				case 0:
				default:
					difficulty = DIFFICULTY_AUTOMATIC;
					location = CONST_activities190.c_str();
					break;
				case 1:
					difficulty = DIFFICULTY_EASY;
					location = CONST_activities191.c_str();
					break;
				case 2:
					difficulty = DIFFICULTY_EASY;
					location = CONST_activities192.c_str();
					break;
				case 3:
					difficulty = DIFFICULTY_AVERAGE;
					location = CONST_activities193.c_str();
					break;
				case 4:
					difficulty = DIFFICULTY_HARD;
					location = CONST_activities194.c_str();
					break;
				}
				if (cr.attribute_check(ATTRIBUTE_INTELLIGENCE, difficulty))
				{
					set_color_easy(GREEN_ON_BLACK_BRIGHT);
					moveAlt(y++, 0);
					if (lawList[LAW_FREESPEECH] == -2)addstrAlt(CONST_activities195, gamelog); // Holy car keys Batman!
					else addstrAlt(CONST_activities196, gamelog);
					addstrAlt(cr.name, gamelog);
					addstrAlt(CONST_activities197, gamelog);
					addstrAlt(location, gamelog);
					gamelog.nextMessage();
					pressAnyKey();
					started = true;
				}
				else
				{
					key_search_total++;
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(y++, 0, cr.name, gamelog);
					addstrAlt(CONST_activities198, gamelog);
					set_color_easy(GREEN_ON_BLACK_BRIGHT);
					if (key_search_total == 5)
						addstrAlt(CONST_activities199, gamelog);
					else if (key_search_total == 10)
						addstrAlt(CONST_activities200, gamelog);
					else if (key_search_total == 15)
						addstrAlt(CONST_activities201, gamelog);
					else if (key_search_total > 15)
					{
						addstrAlt(pickrandom(car_wont_start), gamelog);
					}
					else
					{
						if (lawList[LAW_FREESPEECH] == -2) {
							addstrAlt(pickrandom(cant_find_keys_no_free_speech));
						}
						else {
							addstrAlt(pickrandom(cant_find_keys));
						}
					}
					gamelog.nextMessage();
					pressAnyKey();
				}
			}
			//NOTICE CHECK
			if (!started && (!LCSrandom(50) || (!LCSrandom(5) && alarmon)))
			{
				set_color_easy(RED_ON_BLACK_BRIGHT);
				mvaddstrAlt(y++, 0, cr.name, gamelog);
				addstrAlt(CONST_activities202, gamelog);
				gamelog.nextMessage();
				pressAnyKey();
				//FOOT CHASE
				chaseseq.clean();
				chaseseq.location = LocationsPool::getInstance().getLocationParent(cr.location);
				newsstoryst *ns = new newsstoryst;
				ns->type = NEWSSTORY_CARTHEFT;
				newsstory.push_back(ns);
				sitestory = ns;
				makechasers(-1, 5);
				if (footchase(cr)) {
					mode = GAMEMODE_BASE;
					delete v; return 0;
				}
				else {
					mode = GAMEMODE_BASE;
					delete v; return 0;
				}
			}
			// Nervous message check
			else if (!started && (LCSrandom(7) + 5) < nervous_counter)
			{
				nervous_counter = 0;
				moveAlt(++y, 0); y++;
				set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				addstrAlt(cr.name, gamelog);
				addstrAlt(singleSpace, gamelog);
				addstrAlt(pickrandom(gets_nervous), gamelog);
				gamelog.nextMessage();
				pressAnyKey();
			}
		}
		//CHASE SEQUENCE
		//CAR IS OFFICIAL, THOUGH CAN BE DELETE BY chasesequence()
		addjuice(cr, v->steal_juice(), 100);
		newVehicle(v);
		v->add_heat(14 + v->steal_extraheat());
		v->set_location(cr.base);
		// Automatically assign this car to this driver, if no other one is present
		if (cr.pref_carid == -1)
		{
			cr.pref_carid = v->id();
			cr.pref_is_driver = true;
		}
		chaseseq.clean();
		chaseseq.location = LocationsPool::getInstance().getLocationParent(cr.location);
		int chaselev = !LCSrandom(13 - windowdamage);
		if (chaselev > 0 || (v->vtypeidname() == tag_POLICECAR && LCSrandom(2))) //Identify police cruiser. Temporary solution? -XML
		{
			v->add_heat(10);
			chaselev = 1;
			newsstoryst *ns = new newsstoryst;
			ns->type = NEWSSTORY_CARTHEFT;
			newsstory.push_back(ns);
			sitestory = ns;
			makechasers(-1, chaselev);
			if (!chasesequence(cr, *v)) // Caught or killed in the chase. Do not need to delete vehicle.
				return 0;
		}
		return 1;
	}
	return 0;
}
/* get a wheelchair */
void getwheelchair(Creature &cr, char &clearformess)
{
	const string CONST_activities204 = " was unable to get a wheelchair.  Maybe tomorrow...";
	const string CONST_activities203 = " has procured a wheelchair.";
	extern Log gamelog;
	if (clearformess) eraseAlt();
	else makedelimiter();
	if (LCSrandom(2))
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, cr.name, gamelog);
		addstrAlt(CONST_activities203, gamelog);
		cr.flag |= CREATUREFLAG_WHEELCHAIR;
	}
	else
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, cr.name, gamelog);
		addstrAlt(CONST_activities204, gamelog);
	}
	gamelog.nextMessage();
	pressAnyKey();
}

#include "../sitemode/sitedisplay.h"

//// #include "common/commondisplay.h"
void printparty();


#include "combat/haulkidnap.h"
void squadgrab_immobile(char dead);
//// #include "combat/haulkidnapCreature.h"
void freehostage(Creature &cr, char situation);


void addLocationChange(int cursite, sitechangest change);
string smellsPanic;


string ableToStopBleed;
string sWounds;
string isBurned;
string drops;
string sBody;

/* handles end of round stuff for one creature */
void advancecreature(Creature &cr)
{
	extern squadst *activesquad;
	extern newsstoryst *sitestory;
	extern int locx;
	extern int locy;
	extern int locz;
	extern Log gamelog;
	extern short mode;
	extern int stat_dead;
	extern int stat_kills;
	extern int ccs_siege_kills;
	extern int ccs_boss_kills;
	extern short cursite;
	extern int sitecrime;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	extern short lawList[LAWNUM];
	if (!cr.alive) return;
	char incaprint;
	if (incapacitated(cr, 1, incaprint))
	{
		if (incaprint)
		{
			printparty();
			if (mode == GAMEMODE_CHASECAR ||
				mode == GAMEMODE_CHASEFOOT) printchaseencounter();
			else printencounter();
			pressAnyKey();
		}
	}
	int bleed = 0, topmedicalskill = 0;
	Creature* topmedical = NULL;
	for (int i = 0; i < 6; i++) if (activesquad->squad[i] &&
		activesquad->squad[i]->alive&&
		activesquad->squad[i]->stunned == 0 &&
		activesquad->squad[i]->blood > 40 &&
		activesquad->squad[i]->id != cr.id&&
		activesquad->squad[i]->get_skill(SKILL_FIRSTAID) > topmedicalskill)
		topmedicalskill = (topmedical = activesquad->squad[i])->get_skill(SKILL_FIRSTAID);
	for (int w = 0; w < BODYPARTNUM; w++)
	{
		if (cr.wound[w] & WOUND_BLEEDING)
		{
			if (LCSrandom(500) < cr.get_attribute(ATTRIBUTE_HEALTH, true))
				cr.wound[w] ^= WOUND_BLEEDING;
			else if (cr.squadid != -1 && topmedical&&topmedical->skill_check(SKILL_FIRSTAID, DIFFICULTY_FORMIDABLE))
			{
				clearmessagearea();
				set_color_easy(GREEN_ON_BLACK_BRIGHT);
				mvaddstrAlt(16, 1, topmedical->name, gamelog);
				addstrAlt(ableToStopBleed, gamelog);
				mvaddstrAlt(17, 1, cr.name, gamelog);
				addstrAlt(sWounds, gamelog);
				gamelog.newline();
				topmedical->train(SKILL_FIRSTAID, max(int(50 - topmedicalskill * 2), 0));
				cr.wound[w] ^= WOUND_BLEEDING;
				pressAnyKey();
			}
			else bleed++;
		}
	}
	if (mode == GAMEMODE_SITE && LCSrandom(3) &&
		((levelmap[locx][locy][locz].flag & SITEBLOCK_FIRE_PEAK) ||
		(levelmap[locx][locy][locz].flag & SITEBLOCK_FIRE_END)))
	{
		int burndamage = (levelmap[locx][locy][locz].flag&SITEBLOCK_FIRE_PEAK) ? LCSrandom(40) : LCSrandom(20);
		clearmessagearea();
		// Firefighter's bunker gear reduces burn damage
		if (cr.get_armor().has_fireprotection())
		{
			// Base effect is 3/4 damage reduction, the denominator
			// increases with low quality or damaged gear
			int denom = 4;
			// Damaged gear
			if (cr.get_armor().is_damaged()) denom += 2;
			// Shoddy quality gear
			denom += cr.get_armor().get_quality() - 1;
			// Apply damage reduction
			burndamage = static_cast<int>(burndamage * (1 - (3.0 / denom)));
		}
		cr.blood -= burndamage;
		if (cr.blood <= 0)
		{
			cr.die();
			if (cr.squadid != -1)
			{
				if (cr.align == 1) stat_dead++;
			}
			else if (cr.align == -1 && (cr.animalgloss != ANIMALGLOSS_ANIMAL || lawList[LAW_ANIMALRESEARCH] == 2))
			{
				stat_kills++;
				if (LocationsPool::getInstance().isThereASiegeHere(cursite)) LocationsPool::getInstance().addSiegeKill(cursite);
				if (LocationsPool::getInstance().isThereASiegeHere(cursite) && cr.animalgloss == ANIMALGLOSS_TANK) LocationsPool::getInstance().removeTank(cursite);
				if (LocationsPool::getInstance().getRentingType(cursite) == RENTING_CCS)
				{
					if (cr.type == CREATURE_CCS_ARCHCONSERVATIVE) ccs_boss_kills++;
					ccs_siege_kills++;
				}
			}
			if (cr.squadid == -1)
			{
				sitecrime += 10;
				sitestory->crime.push_back(CRIME_KILLEDSOMEBODY);
				criminalizeparty(LAWFLAG_MURDER);
				//<-- people dying in fire? probably your fault for starting it
			}
			adddeathmessage(cr);
			pressAnyKey();
			if (cr.prisoner != NULL) freehostage(cr, 1);
		}
		else
		{
			set_color_easy(RED_ON_BLACK);
			mvaddstrAlt(16, 1, cr.name, gamelog);
			addstrAlt(isBurned, gamelog);
			gamelog.newline(); //Next message?
			pressAnyKey();
		}
	}
	if (bleed > 0)
	{
		clearmessagearea();
		cr.blood -= bleed;
		levelmap[locx][locy][locz].flag |= SITEBLOCK_BLOODY;
		cr.get_armor().set_bloody(true);
		if (cr.blood <= 0)
		{
			cr.die();
			if (cr.squadid != -1)
			{
				if (cr.align == 1) stat_dead++;
			}
			else if (cr.align == -1 && (cr.animalgloss != ANIMALGLOSS_ANIMAL || lawList[LAW_ANIMALRESEARCH] == 2))
			{
				stat_kills++;
				if (LocationsPool::getInstance().isThereASiegeHere(cursite))LocationsPool::getInstance().addSiegeKill(cursite);
				if (LocationsPool::getInstance().isThereASiegeHere(cursite) && cr.animalgloss == ANIMALGLOSS_TANK)LocationsPool::getInstance().removeTank(cursite);
				if (LocationsPool::getInstance().getRentingType(cursite) == RENTING_CCS)
				{
					if (cr.type == CREATURE_CCS_ARCHCONSERVATIVE) ccs_boss_kills++;
					ccs_siege_kills++;
				}
			}
			if (cr.squadid == -1)
			{
				sitecrime += 10;
				sitestory->crime.push_back(CRIME_KILLEDSOMEBODY);
				//criminalizeparty(LAWFLAG_MURDER);
				//^-- might not die from squad attacking
			}
			adddeathmessage(cr);
			pressAnyKey();
			if (cr.prisoner != NULL) freehostage(cr, 1);
		}
	}
}

/* handles end of round stuff for everyone */
void creatureadvance()
{
	extern int sitecrime;
	extern newsstoryst *sitestory;
	extern short cursite;
	extern short sitealarm;
	extern short sitealarmtimer;
	extern short siteonfire;
	extern squadst *activesquad;
	extern short siteonfire;
	extern Log gamelog;
	extern short mode;
	extern short postalarmtimer;
	extern Creature encounter[ENCMAX];
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] == NULL) continue;
		if (!activesquad->squad[p]->alive) continue;
		advancecreature(*activesquad->squad[p]);
		if (activesquad->squad[p]->prisoner != NULL)
		{
			advancecreature(*activesquad->squad[p]->prisoner);
			if (!activesquad->squad[p]->prisoner->alive)
			{
				if (activesquad->squad[p]->prisoner->squadid == -1)
				{
					clearmessagearea();
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(16, 1, activesquad->squad[p]->name, gamelog);
					addstrAlt(drops, gamelog);
					addstrAlt(activesquad->squad[p]->prisoner->name, gamelog);
					addstrAlt(sBody, gamelog);
					gamelog.newline();
					makeloot(*activesquad->squad[p]->prisoner);
					pressAnyKey();
					sitecrime += 10;
					sitestory->crime.push_back(CRIME_KILLEDSOMEBODY);
					//criminalizeparty(LAWFLAG_MURDER);
					//<-- might not die from squad's attacks
					if (activesquad->squad[p]->prisoner->type == CREATURE_CORPORATE_CEO ||
						activesquad->squad[p]->prisoner->type == CREATURE_RADIOPERSONALITY ||
						activesquad->squad[p]->prisoner->type == CREATURE_NEWSANCHOR ||
						activesquad->squad[p]->prisoner->type == CREATURE_SCIENTIST_EMINENT ||
						activesquad->squad[p]->prisoner->type == CREATURE_JUDGE_CONSERVATIVE)sitecrime += 30;
					delete_and_nullify(activesquad->squad[p]->prisoner);
				}
			}
		}
	}
	if (LocationsPool::getInstance().isThereASiegeHere(cursite))
	{
		CreaturePool::getInstance().advanceCreaturesAtLocation(cursite);
		autopromote(cursite);
	}
	for (int e = 0; e < ENCMAX; e++)
	{
		if (!encounter[e].exists) continue;
		if (!encounter[e].alive) continue;
		advancecreature(encounter[e]);
	}
	if (mode != GAMEMODE_CHASECAR)
	{
		//TAKE THE INJURED WITH YOU
		squadgrab_immobile(0);
		//TAKE THE DEAD WITH YOU
		squadgrab_immobile(1);
	}
	for (int e = ENCMAX - 1; e >= 0; e--)
	{
		if (!encounter[e].exists) continue;
		if (!encounter[e].alive) delenc(e, 1);
	}
	if (mode == GAMEMODE_SITE)
	{
		if (sitealarm&&sitecrime > 10) postalarmtimer++;
		if (sitealarmtimer > 0 && !sitealarm&&sitecrime > 5)
		{
			sitealarmtimer--;
			if (sitealarmtimer <= 0)
			{
				sitealarmtimer = 0;
				clearmessagearea();
				set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				mvaddstrAlt(16, 1, smellsPanic, gamelog);
				gamelog.newline();
				if (mode == GAMEMODE_CHASECAR ||
					mode == GAMEMODE_CHASEFOOT)printchaseencounter();
				else printencounter();
				pressAnyKey();
			}
		}
		for (int z = 0; z < MAPZ; z++)
		{
			bool stairs = 0; // Will check if higher levels are accessible
			for (int y = 0; y < MAPY; y++)
			{
				for (int x = 0; x < MAPX; x++)
				{
					if (levelmap[x][y][z].flag & SITEBLOCK_EXIT) continue;
					if (levelmap[x][y][z].special != -1)
						if (levelmap[x][y][z].special & SPECIAL_STAIRS_UP) stairs = 1;
					// Extinguish ending fires
					if (levelmap[x][y][z].flag & SITEBLOCK_FIRE_END)
					{
						if (!LCSrandom(15))
						{
							levelmap[x][y][z].flag &= ~SITEBLOCK_FIRE_END;
							levelmap[x][y][z].flag |= SITEBLOCK_DEBRIS;
						}
					}
					// Cool/spread peak fires
					if (levelmap[x][y][z].flag & SITEBLOCK_FIRE_PEAK)
					{
						siteonfire = 1;
						if (!LCSrandom(10))
						{
							levelmap[x][y][z].flag &= ~SITEBLOCK_FIRE_PEAK;
							levelmap[x][y][z].flag |= SITEBLOCK_FIRE_END;
						}
						else if (!LCSrandom(4)) // Spread fire
						{
							int dir = LCSrandom(4); // Random initial direction
							int tries = 0; // Will try all four directions before giving up
							while (tries < 4)
							{
								int xmod = 0, ymod = 0;
								switch (dir)
								{
								case 0:xmod = -1; break;
								case 1:xmod = 1; break;
								case 2:ymod = -1; break;
								case 3:ymod = 1; break;
								}
								// Check if the tile is a valid place to spread fire to
								if (x + xmod < MAPX&&x + xmod >= 0 && y + ymod < MAPY&&y + ymod >= 0 &&
									!(levelmap[x + xmod][y + ymod][z].flag & SITEBLOCK_FIRE_START) &&
									!(levelmap[x + xmod][y + ymod][z].flag & SITEBLOCK_DEBRIS) &&
									!(levelmap[x + xmod][y + ymod][z].flag & SITEBLOCK_FIRE_PEAK) &&
									!(levelmap[x + xmod][y + ymod][z].flag & SITEBLOCK_FIRE_END) &&
									!(levelmap[x + xmod][y + ymod][z].flag & SITEBLOCK_EXIT) &&
									!(levelmap[x + xmod][y + ymod][z].flag & SITEBLOCK_METAL))
								{
									// Spread it
									levelmap[x + xmod][y + ymod][z].flag |= SITEBLOCK_FIRE_START;
									break;
								}
								// Else try another direction
								tries++;
								dir++; dir %= 4;
							}
							if (tries == 5) // If all four directions unacceptable, spread upward
							{
								// Check if up is valid
								if (z < MAPZ &&
									!(levelmap[x][y][z + 1].flag & SITEBLOCK_FIRE_START) &&
									!(levelmap[x][y][z + 1].flag & SITEBLOCK_DEBRIS) &&
									!(levelmap[x][y][z + 1].flag & SITEBLOCK_FIRE_PEAK) &&
									!(levelmap[x][y][z + 1].flag & SITEBLOCK_FIRE_END) &&
									!(levelmap[x][y][z + 1].flag & SITEBLOCK_METAL))
								{
									// Spread it
									levelmap[x][y][z + 1].flag |= SITEBLOCK_FIRE_START;
								}
								// Else give up
							}
						}
					}
					// Aggrivate starting fires
					if (levelmap[x][y][z].flag & SITEBLOCK_FIRE_START)
					{
						if (!LCSrandom(5))
						{
							sitechangest change(x, y, z, SITEBLOCK_DEBRIS);
							addLocationChange(cursite, change);
							levelmap[x][y][z].flag &= ~SITEBLOCK_BLOCK;
							levelmap[x][y][z].flag &= ~SITEBLOCK_DOOR;
							levelmap[x][y][z].flag &= ~SITEBLOCK_FIRE_START;
							levelmap[x][y][z].flag |= SITEBLOCK_FIRE_PEAK;
							sitecrime += 5;
						}
					}
				}
			}
			// If no stairs to the next level were found, don't continue to that level
			if (!stairs) break;
		}
	}
	//I'll do this here so that everything that happened in the round is grouped together.
	//Note the check is to make sure that no excessive blank lines appear between encounters
	//in the gamelog due to something not happening for a round or two (like the squad
	//moving around with no mishaps). In other words, it only does nexMessage if
	//something was logged this round.
	if (gamelog.hasMessage()) gamelog.nextMessage();
}

//// #include "../includes.h"

const string CONST_armor011 = "]";
const string CONST_armor010 = "[";
const string tag_D = "D";
const string tag_B = "B";
const string tag_X = "X";
const string tag_quality = "quality";
const string tag_false = "false";
const string tag_damaged = "damaged";
const string tag_true = "true";
const string tag_bloody = "bloody";
const string tag_blood = "blood";
const string tag_armor = "armor";
#include "../common/stringconversion.h"

Armor::Armor(const std::string& inputXml) : Item(inputXml)
{
	CMarkup xml;
	xml.SetDoc(inputXml);
	xml.FindElem();
	xml.IntoElem();
	while (xml.FindElem())
	{
		std::string tag = xml.GetTagName();
		if (tag == tag_bloody) bloody_ = stringtobool(xml.GetData()) == 1;
		else if (tag == tag_damaged) damaged_ = stringtobool(xml.GetData()) == 1;
		else if (tag == tag_quality) quality_ = atoi(xml.GetData().c_str());
	}
}
string Armor::showXml() const
{
	CMarkup xml;
	xml.AddElem(tag_armor);
	xml.IntoElem();
	addBaseValues(xml);
	xml.AddElem(tag_bloody, (bloody_ ? tag_true : tag_false));
	xml.AddElem(tag_damaged, (damaged_ ? tag_true : tag_false));
	xml.AddElem(tag_quality, tostring(quality_));
	return xml.GetDoc();
}
string Armor::equip_title() const
{
	return equip_title(false);
}
string Armor::equip_title(bool full) const
{
	string et = (full ? get_name() : get_shortname());
	if (quality_ <= get_quality_levels() && (bloody_ || damaged_ || quality_ > 1))
	{
		et += CONST_armor010;
		if (quality_ > 9) et += tag_X;
		else if (quality_ > 1) et += tostring(quality_);
		if (bloody_) et += tag_B;
		if (damaged_) et += tag_D;
		et += CONST_armor011;
	}
	return et;
}
Armor* Armor::split(int number)
{
	if (number > number_) number = number_;
	Armor* newi = clone();
	newi->number_ = number;
	number_ -= number;
	return newi;
}
bool Armor::merge(Item& i)
{
	if (i.whatIsThis() == THIS_IS_ARMOR && is_same_type(i))
	{
		Armor& a = static_cast<Armor&>(i); //cast -XML
		if (bloody_ == a.bloody_&&damaged_ == a.damaged_&&quality_ == a.quality_)
		{
			increase_number(a.get_number());
			a.set_number(0);
			return true;
		}
	}
	return false;
}
bool Armor::decrease_quality(int decrease)
{
	quality_ += decrease;
	if (quality_ < 1) quality_ = 1;
	return quality_ <= get_quality_levels();
}
bool Armor::sort_compare_special(Item* other) const
{
	if (other)
	{
		int thisi = getarmortype(get_itemtypename());
		int otheri = getarmortype(other->get_itemtypename());
		if (thisi < otheri || otheri == -1) return false;
		else if (thisi > otheri&&otheri != -1) return true;
		else if (other->whatIsThis() == THIS_IS_ARMOR)
		{
			Armor* a = static_cast<Armor*>(other); //cast... -XML
			if (quality_ < a->quality_) return false;
			else if (quality_ > a->quality_) return true;
			else if (damaged_ != a->damaged_) return damaged_;
			else if (bloody_ != a->bloody_) return bloody_;
			else return false;
		}
		else return false;
	}
	else return false;
}
void Armor::set_damaged(bool d)
{
	if (can_get_damaged() || !d) damaged_ = d;
}
void Armor::set_bloody(bool b)
{
	if (can_get_bloody() || !b) bloody_ = b;
}
const string ruinedName = "Tattered Rags";
const string& Armor::get_name() const
{
	extern vector<ArmorType *> armortype;
	if (quality_ <= get_quality_levels())
		return armortype[getarmortype(get_itemtypename())]->get_name();
	else return ruinedName;
}
const string& Armor::get_shortname() const
{
	extern vector<ArmorType *> armortype;
	if (quality_ <= get_quality_levels())
		return armortype[getarmortype(get_itemtypename())]->get_shortname();
	else return ruinedName;
}
long Armor::get_fencevalue() const
{
	extern vector<ArmorType *> armortype;
	if (quality_ <= get_quality_levels())
		return armortype[getarmortype(get_itemtypename())]->get_fencevalue() / quality_;
	else return 0;
}
int Armor::get_make_difficulty() const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->get_make_difficulty();
}
int Armor::get_make_price() const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->get_make_price();
}
bool Armor::deathsquad_legality() const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->deathsquad_legality();
}
bool Armor::can_get_bloody() const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->can_get_bloody();
}
bool Armor::can_get_damaged() const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->can_get_damaged();
}
int Armor::get_armor(int bodypart) const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->get_armor(bodypart);
}
bool Armor::has_fireprotection() const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->has_fireprotection();
}
bool Armor::covers(int bodypart) const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->covers(bodypart);
}
bool Armor::conceals_face() const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->conceals_face();
}
int Armor::get_interrogation_basepower() const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->get_interrogation_basepower();
}
int Armor::get_interrogation_assaultbonus() const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->get_interrogation_assaultbonus();
}
int Armor::get_interrogation_drugbonus() const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->get_interrogation_drugbonus();
}
int Armor::get_professionalism() const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->get_professionalism();
}
int Armor::get_stealth_value() const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->get_stealth_value();
}
int Armor::get_weaponsize_concealment() const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->get_weaponsize_concealment();
}
bool Armor::conceals_weaponsize(int weaponsize) const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->conceals_weaponsize(weaponsize);
}
bool Armor::is_mask() const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->is_mask();
}
bool Armor::is_surprise_mask() const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->is_surprise_mask();
}
const string Armor::get_description() const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->get_description();
}
int Armor::get_durability() const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->get_durability();
}
int Armor::get_quality_levels() const
{
	extern vector<ArmorType *> armortype;
	return armortype[getarmortype(get_itemtypename())]->get_quality_levels();
}


//// #include "../includes.h"
const string CONST_armortypeB044 = ": ";

const string CONST_armortype055 = "UNDEF";
const string CONST_armortype054 = "Unknown element for armor type ";
const string CONST_armortype053 = "::InterrogationST: ";
const string CONST_armortype051 = "::armor: ";
const string CONST_armortype049 = "::body_covering::conceal_face: ";
const string CONST_armortype048 = "Invalid boolean value for armor type ";
const string CONST_armortype047 = "::body_covering::legs: ";
const string CONST_armortype045 = "::body_covering::arms: ";
const string CONST_armortype043 = "::body_covering::head: ";
const string CONST_armortype041 = "::body_covering::body: ";
const string CONST_armortype037 = "::armor::fireprotection: ";
const string CONST_armortype035 = "::deathsquad_legality: ";
const string tag_durability = "durability";
const string tag_qualitylevels = "qualitylevels";
const string tag_description = "description";
const string tag_surprise = "surprise";
const string tag_mask = "mask";
const string tag_stealth = "stealth";
const string tag_stealth_value = "stealth_value";
const string tag_conceal_weapon_size = "conceal_weapon_size";
const string tag_professionalism = "professionalism";
const string tag_drugbonus = "drugbonus";
const string tag_assaultbonus = "assaultbonus";
const string tag_basepower = "basepower";
const string tag_base = "base";
const string tag_interrogation = "interrogation";
const string tag_shortname = "shortname";
const string tag_conceals_face = "conceals_face";
const string tag_legs = "legs";
const string tag_arms = "arms";
const string tag_head = "head";
const string tag_body = "body";
const string tag_body_covering = "body_covering";
const string tag_fire = "fire";
const string tag_fireprotection = "fireprotection";
const string tag_limbs = "limbs";
const string tag_can_get_damaged = "can_get_damaged";
const string tag_can_get_bloody = "can_get_bloody";
const string tag_deathsquad_legality = "deathsquad_legality";
const string tag_make_price = "make_price";
const string tag_make_difficulty = "make_difficulty";

ArmorType::ArmorType(MCD_STR xmlstring)
	: ItemType(xmlstring),
	make_difficulty_(0), make_price_(0), deathsquad_legality_(false),
	can_get_bloody_(true), can_get_damaged_(true),
	stealth_value_(0), armor_body_(0), armor_head_(0), armor_limbs_(0), fireprotection_(false),
	cover_head_(false), cover_body_(true), cover_arms_(true), cover_legs_(true), conceal_face_(false),
	shortname_(CONST_armortype055), shortname_future_(CONST_armortype055), shortname_defined_(false), shortname_future_defined_(false),
	interrogation_basepower_(0), interrogation_assaultbonus_(0), interrogation_drugbonus_(0),
	professionalism_(2), conceal_weaponsize_(5),
	mask_(false), surprise_mask_(false), description_(CONST_armortype055),
	quality_levels_(4), durability_(10)
{
	init(xmlstring);
}
ArmorType::ArmorType(const ArmorType& base, MCD_STR xmlstring)
	: ItemType(base, xmlstring),
	make_difficulty_(base.make_difficulty_), make_price_(base.make_price_), deathsquad_legality_(base.deathsquad_legality_),
	can_get_bloody_(base.can_get_bloody_), can_get_damaged_(base.can_get_damaged_),
	stealth_value_(base.stealth_value_), armor_body_(base.armor_body_), armor_head_(base.armor_head_), armor_limbs_(base.armor_limbs_), fireprotection_(base.fireprotection_),
	cover_head_(base.cover_head_), cover_body_(base.cover_body_), cover_arms_(base.cover_arms_), cover_legs_(base.cover_legs_), conceal_face_(base.conceal_face_),
	shortname_(base.shortname_), shortname_future_(base.shortname_future_), shortname_defined_(base.shortname_defined_), shortname_future_defined_(base.shortname_future_defined_),
	interrogation_basepower_(base.interrogation_basepower_), interrogation_assaultbonus_(base.interrogation_assaultbonus_), interrogation_drugbonus_(base.interrogation_drugbonus_),
	professionalism_(base.professionalism_), conceal_weaponsize_(base.conceal_weaponsize_),
	mask_(base.mask_), surprise_mask_(base.surprise_mask_), description_(base.description_),
	quality_levels_(base.quality_levels_), durability_(base.durability_)
{
	init(xmlstring);
}
void ArmorType::init(const MCD_STR& xmlstring)
{
	CMarkup xml;
	xml.SetDoc(xmlstring);
	xml.FindElem();
	xml.IntoElem();
	while (xml.FindElem()) //Loop over all the elements inside the armortype element.
	{
		std::string element = xml.GetTagName();
		if (element == tag_make_difficulty)
			make_difficulty_ = atoi(xml.GetData());
		else if (element == tag_make_price)
			make_price_ = atoi(xml.GetData());
		else if (element == tag_deathsquad_legality)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				deathsquad_legality_ = true;
			else if (b == 0)
				deathsquad_legality_ = false;
			/*else
			errorlog << CONST_armortype048 << idname()
			<< CONST_armortype035 << xml.GetData() << std::endl;*/
		}
		else if (element == tag_can_get_bloody)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				can_get_bloody_ = true;
			else if (b == 0)
				can_get_bloody_ = false;
		}
		else if (element == tag_can_get_damaged)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				can_get_damaged_ = true;
			else if (b == 0)
				can_get_damaged_ = false;
		}
		else if (element == tag_armor)
		{
			xml.IntoElem();
			while (xml.FindElem())
			{
				element = xml.GetTagName();
				if (element == tag_body)
					armor_body_ = atoi(xml.GetData());
				else if (element == tag_head)
					armor_head_ = atoi(xml.GetData());
				else if (element == tag_limbs)
					armor_limbs_ = atoi(xml.GetData());
				else if (element == tag_fireprotection)
				{
					int b = stringtobool(xml.GetData());
					if (b == 1)
						fireprotection_ = true;
					else if (b == 0)
						fireprotection_ = false;
					/*else
					errorlog << CONST_armortype048 << idname()
					<< CONST_armortype037 << xml.GetData() << std::endl;*/
				}
				/*else
				errorlog << CONST_armortype054 << idname()
				<< CONST_armortype051 << element << endl;*/
			}
			xml.OutOfElem();
		}
		else if (element == tag_body_covering)
		{
			xml.IntoElem();
			while (xml.FindElem())
			{
				element = xml.GetTagName();
				if (element == tag_body)
				{
					int b = stringtobool(xml.GetData());
					if (b == 1)
						cover_body_ = true;
					else if (b == 0)
						cover_body_ = false;
					/*else
					errorlog << CONST_armortype048 << idname()
					<< CONST_armortype041 << xml.GetData() << std::endl;*/
				}
				else if (element == tag_head)
				{
					int b = stringtobool(xml.GetData());
					if (b == 1)
						cover_head_ = true;
					else if (b == 0)
						cover_head_ = false;
					/*else
					errorlog << CONST_armortype048 << idname()
					<< CONST_armortype043 << xml.GetData() << std::endl;*/
				}
				else if (element == tag_arms)
				{
					int b = stringtobool(xml.GetData());
					if (b == 1)
						cover_arms_ = true;
					else if (b == 0)
						cover_arms_ = false;
					/*else
					errorlog << CONST_armortype048 << idname()
					<< CONST_armortype045 << xml.GetData() << std::endl;*/
				}
				else if (element == tag_legs)
				{
					int b = stringtobool(xml.GetData());
					if (b == 1)
						cover_legs_ = true;
					else if (b == 0)
						cover_legs_ = false;
					/*else
					errorlog << CONST_armortype048 << idname()
					<< CONST_armortype047 << xml.GetData() << std::endl;*/
				}
				else if (element == tag_conceals_face)
				{
					int b = stringtobool(xml.GetData());
					if (b == 1)
						conceal_face_ = true;
					else if (b == 0)
						conceal_face_ = false;
					/*else
					errorlog << CONST_armortype048 << idname()
					<< CONST_armortype049 << xml.GetData() << std::endl;*/
				}
				/*else
				errorlog << CONST_armortype054 << idname()
				<< CONST_armortype051 << element << endl;*/
			}
			xml.OutOfElem();
		}
		else if (element == tag_shortname)
		{
			shortname_ = xml.GetData();
			shortname_defined_ = true;
			if (len(shortname_) > 14)
				shortname_.resize(14);
		}
		else if (element == tag_interrogation)
		{
			xml.IntoElem();
			while (xml.FindElem())
			{
				if (element == tag_basepower)
					interrogation_basepower_ = atoi(xml.GetData());
				else if (element == tag_assaultbonus)
					interrogation_assaultbonus_ = atoi(xml.GetData());
				else if (element == tag_drugbonus)
					interrogation_drugbonus_ = atoi(xml.GetData());
				/*else
				errorlog << CONST_armortype054 << idname()
				<< CONST_armortype053 << element << endl;*/
			}
			xml.OutOfElem();
		}
		else if (element == tag_professionalism)
			professionalism_ = atoi(xml.GetData());
		else if (element == tag_conceal_weapon_size)
			conceal_weaponsize_ = atoi(xml.GetData());
		else if (element == tag_stealth_value)
			stealth_value_ = atoi(xml.GetData());
		else if (element == tag_mask)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				mask_ = true;
			else if (b == 0)
				mask_ = false;
		}
		else if (element == tag_surprise)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				surprise_mask_ = true;
			else if (b == 0)
				surprise_mask_ = false;
		}
		else if (element == tag_description)
			description_ = xml.GetData();
		else if (element == tag_qualitylevels)
			quality_levels_ = max(1, atoi(xml.GetData()));
		else if (element == tag_durability)
			durability_ = max(0, atoi(xml.GetData()));
		/*else
		errorlog << CONST_armortype054 << idname() << CONST_armortypeB044 << element << endl;*/
	}
	if (!shortname_defined_ && len(name_) <= 14)
		shortname_ = name_;
}
int ArmorType::get_armor(int bodypart) const
{
	if (covers(bodypart))
	{
		switch (bodypart)
		{
		case BODYPART_HEAD:
			return armor_head_;
		case BODYPART_BODY:
			return armor_body_;
		case BODYPART_ARM_RIGHT:
		case BODYPART_ARM_LEFT:
			return armor_limbs_;
		case BODYPART_LEG_RIGHT:
		case BODYPART_LEG_LEFT:
			return armor_limbs_;
		}
	}
	return 0;
}
bool ArmorType::covers(int bodypart) const
{
	switch (bodypart)
	{
	case BODYPART_HEAD: return cover_head_;
	case BODYPART_BODY: return cover_body_;
	case BODYPART_ARM_RIGHT:
	case BODYPART_ARM_LEFT: return cover_arms_;
	case BODYPART_LEG_RIGHT:
	case BODYPART_LEG_LEFT: return cover_legs_;
	}
	return false;
}
const string& ArmorType::get_shortname() const
{
	extern int year;
	if (shortname_future_defined_ && year >= 2100)
		return shortname_future_;
	else if (year >= 2100 && name_future_defined_ && len(name_future_) <= 14)
		return name_future_;
	else //if (shortname_defined_)
		return shortname_;
	/*else if (len(name()) <= 14)
	return name();
	else
	return CONST_armortype055;*/
}
bool ArmorType::conceals_weaponsize(int weaponsize) const
{
	return (conceal_weaponsize_ >= weaponsize);
}


const string CONST_augmentation017 = "Conservative Swine! (Bug)";
const string CONST_augmentation016 = "Skin";
const string CONST_augmentation015 = "Legs";
const string CONST_augmentation014 = "Arms";
const string CONST_augmentation013 = "Body";
const string CONST_augmentation012 = "Head";
const string tag_skin = "skin";
const string tag_effect = "effect";
const string tag_type = "type";
const string tag_name = "name";
const string tag_augmentation = "augmentation";

std::string Augmentation::get_name(int au)
{
	switch (au)
	{
	case AUGMENTATION_HEAD: return CONST_augmentation012;
	case AUGMENTATION_BODY: return CONST_augmentation013;
	case AUGMENTATION_ARMS: return CONST_augmentation014;
	case AUGMENTATION_LEGS: return CONST_augmentation015;
	case AUGMENTATION_SKIN: return CONST_augmentation016;
	default: return CONST_augmentation017;
	}
}
std::string Augmentation::showXml() const
{
	CMarkup xml;
	xml.AddElem(tag_augmentation);
	xml.IntoElem();
	xml.AddElem(tag_name, name);
	xml.AddElem(tag_type, type);
	xml.AddElem(tag_attribute, attribute);
	xml.AddElem(tag_effect, effect);
	xml.AddElem(tag_value, value);
	return xml.GetDoc();
}
Augmentation::Augmentation(const std::string& inputXml)
{
	CMarkup xml;
	xml.SetDoc(inputXml);
	xml.FindElem();
	xml.IntoElem();
	while (xml.FindElem())
	{
		std::string tag = xml.GetTagName();
		if (tag == tag_name)
			name = xml.GetData();
		else if (tag == tag_type)
			type = atoi(xml.GetData().c_str());
		else if (tag == tag_attribute)
			attribute = atoi(xml.GetData().c_str());
		else if (tag == tag_effect)
			effect = atoi(xml.GetData().c_str());
		else if (tag == tag_value)
			value = atoi(xml.GetData().c_str());
	}
}
int augment_string_to_enum(const string& augmentname)
{
	if (augmentname == tag_head)
		return AUGMENTATION_HEAD;
	else if (augmentname == tag_body)
		return AUGMENTATION_BODY;
	else if (augmentname == tag_arms)
		return AUGMENTATION_ARMS;
	else if (augmentname == tag_legs)
		return AUGMENTATION_LEGS;
	else if (augmentname == tag_skin)
		return AUGMENTATION_SKIN;
	else
		return -1;
}

// #include "../includes.h"
const string CONST_augmenttypeB014 = " lacks idname.";
const string CONST_augmenttype013 = "Augment type ";
const string CONST_augmenttype012 = "LACKS IDNAME ";

const string tag_difficulty = "difficulty";
const string tag_cost = "cost";
const string tag_min_age = "min_age";
const string tag_max_age = "max_age";
const string tag_idname = "idname";
const string tag_id = "id";
int AugmentType::number_of_augmenttypes = 0;
AugmentType::AugmentType(const std::string& xmlstring) : max_age_(-1), min_age_(-1), cost_(0), difficulty_(5)
{
	extern Log xmllog;
	id_ = number_of_augmenttypes++;
	CMarkup xml;
	xml.SetDoc(xmlstring);
	xml.FindElem();
	idname_ = xml.GetAttrib(tag_idname);
	if (!len(idname_))
	{
		idname_ = CONST_augmenttype012 + tostring(id_);
		xmllog.log(CONST_augmenttype013 + tostring(id_) + CONST_augmenttypeB014);
	}
	xml.IntoElem();
	while (xml.FindElem())
	{
		std::string element = xml.GetTagName();
		if (element == tag_name)
			name_ = xml.GetData();
		else if (element == tag_type)
			type_ = augment_string_to_enum(xml.GetData());
		else if (element == tag_attribute)
			attribute_ = attribute_string_to_enum(xml.GetData());
		else if (element == tag_effect)
			effect_ = atoi(xml.GetData().c_str());
		else if (element == tag_description)
			description_ = xml.GetData();
		else if (element == tag_max_age)
			max_age_ = atoi(xml.GetData().c_str());
		else if (element == tag_min_age)
			min_age_ = atoi(xml.GetData().c_str());
		else if (element == tag_cost)
			cost_ = atoi(xml.GetData().c_str());
		else if (element == tag_difficulty)
			difficulty_ = atoi(xml.GetData().c_str());
	}
}
void AugmentType::make_augment(Augmentation& au)
{
	au.name = get_name();
	au.type = get_type();
	au.attribute = get_attribute();
	au.effect = get_effect();
}

//#include "../includes.h"
const string CONST_baseactions004 = "vehicleParagraph.txt";

#define CH_BOX_DRAWINGS_LIGHT_VERTICAL 0xb3
#define CH_UPPER_HALF_BLOCK 0xdf
#define CH_LOWER_HALF_BLOCK 0xdc
#define CH_BOX_DRAWINGS_LIGHT_VERTICAL_AND_HORIZONTAL 0xc5
#define CH_FULL_BLOCK 0xdb
#define CH_LIGHT_SHADE 0xb0
#define CH_MEDIUM_SHADE 0xb1
#define CH_DARK_SHADE 0xb2

#include "../common/consolesupport.h"
//#include "../common/getnames.h"
void enter_name(int, int, char*, int, const char*);
//#include "../common/commonactionsCreature.h"
int squadsize(const squadst *st);

string enter_done;
string chooseALiberalTo;
string string_sleeper;
vector<string> vehicleParagraph;
vector<file_and_text_collection> baseactions_text_file_collection = {
	customText(&vehicleParagraph, mostlyendings + CONST_baseactions004),
};
/* base - burn the flag */
void burnflag()
{
	int flagparts = 126, flag[18][7][4];
	for (int y = 0; y < 7; y++) if (y < 6) for (int x = 0; x < 18; x++)
	{
		if (x < 9 && y < 4)
		{
			switch (y)
			{
			case 0: flag[x][y][0] = ((x % 2) ? '.' : ':'); break;
			default: flag[x][y][0] = ':'; break;
			case 3: flag[x][y][0] = CH_LOWER_HALF_BLOCK; break;
			}
			flag[x][y][2] = COLOR_BLUE;
		}
		else
		{
			flag[x][y][0] = CH_LOWER_HALF_BLOCK;
			flag[x][y][2] = COLOR_RED;
		}
		flag[x][y][1] = COLOR_WHITE;
		flag[x][y][3] = 1;
	}
	else for (int x = 0; x < 18; x++)
	{
		flag[x][y][0] = CH_UPPER_HALF_BLOCK;
		flag[x][y][1] = COLOR_RED;
		flag[x][y][2] = COLOR_BLACK;
		flag[x][y][3] = 0;
	}
	int x1 = LCSrandom(18);
	int y1 = LCSrandom(7);
	flag[x1][y1][0] = CH_DARK_SHADE;
	flag[x1][y1][1] = COLOR_YELLOW;
	flag[x1][y1][2] = COLOR_BLACK;
	flag[x1][y1][3] = 1;
	bool first = true;
	while (flagparts > 0)
	{
		if (!first) for (int x = 0; x < 18; x++) for (int y = 0; y < 7; y++)
		{
			if (flag[x][y][0] == CH_BOX_DRAWINGS_LIGHT_VERTICAL)flag[x][y][0] = CH_DARK_SHADE;
			else if (flag[x][y][0] == CH_DARK_SHADE)
			{
				flag[x][y][0] = CH_MEDIUM_SHADE;
				flag[x][y][1] = COLOR_RED;
				flag[x][y][2] = COLOR_BLACK;
				flag[x][y][3] = 0;
			}
			else if (flag[x][y][0] == CH_MEDIUM_SHADE)
			{
				flag[x][y][0] = CH_LIGHT_SHADE;
				flag[x][y][1] = COLOR_BLACK;
				flag[x][y][2] = COLOR_BLACK;
				flag[x][y][3] = 1;
			}
			else if (flag[x][y][0] == CH_LIGHT_SHADE)
			{
				flagparts--;
				flag[x][y][0] = ' ';
				flag[x][y][1] = COLOR_BLACK;
				flag[x][y][2] = COLOR_BLACK;
				flag[x][y][3] = 0;
			}
		}
		else first = false;
		for (int x = 0; x < 18; x++) for (int y = 0; y < 7; y++)
		{
			set_color(short(flag[x][y][1]), short(flag[x][y][2]), bool(flag[x][y][3]));
			mvaddchAlt(y + 10, x + 31, flag[x][y][0]);
		}
		pause_ms(10);
		bool gotnew = false;
		while (!gotnew&&flagparts > 3)
		{
			int x = LCSrandom(18);
			int y = LCSrandom(7);

			if (flag[x][y][0] == ':' || flag[x][y][0] == '.' || flag[x][y][0] == CH_UPPER_HALF_BLOCK || flag[x][y][0] == CH_LOWER_HALF_BLOCK)
			{
				bool conf = false;
				if (x > 0)
				{
					if (flag[x - 1][y][0] != ':'&&
						flag[x - 1][y][0] != '.'&&
						flag[x - 1][y][0] != CH_UPPER_HALF_BLOCK &&
						flag[x - 1][y][0] != CH_LOWER_HALF_BLOCK) conf = true;
				}
				if (x < 17)
				{
					if (flag[x + 1][y][0] != ':'&&
						flag[x + 1][y][0] != '.'&&
						flag[x + 1][y][0] != CH_UPPER_HALF_BLOCK &&
						flag[x + 1][y][0] != CH_LOWER_HALF_BLOCK) conf = true;
				}
				if (y > 0)
				{
					if (flag[x][y - 1][0] != ':'&&
						flag[x][y - 1][0] != '.'&&
						flag[x][y - 1][0] != CH_UPPER_HALF_BLOCK &&
						flag[x][y - 1][0] != CH_LOWER_HALF_BLOCK) conf = true;
				}
				if (y < 6)
				{
					if (flag[x][y + 1][0] != ':'&&
						flag[x][y + 1][0] != '.'&&
						flag[x][y + 1][0] != CH_UPPER_HALF_BLOCK &&
						flag[x][y + 1][0] != CH_LOWER_HALF_BLOCK) conf = true;
				}
				if (conf)
				{
					flag[x][y][0] = CH_BOX_DRAWINGS_LIGHT_VERTICAL;
					flag[x][y][1] = COLOR_YELLOW;
					flag[x][y][2] = COLOR_BLACK;
					flag[x][y][3] = 1;
					gotnew = true;
				}
			}
		}
	}
}
/* base - new slogan */
void getslogan()
{
	const string CONST_baseactions006 = "                                                                                          ";
	const string CONST_baseactions005 = "What is your new slogan?";
	extern char slogan[SLOGAN_LEN];
	extern string slogan_str;
	extern vector<string> default_slogans;
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(16, 0, CONST_baseactions005);
	mvaddstrAlt(17, 0, CONST_baseactions006); // 80 spaces
	enter_name(17, 0, slogan, SLOGAN_LEN, pickrandom(default_slogans).c_str());
	slogan_str = slogan;
}
/* base - reorder party */
void orderparty()
{
	const string CONST_baseactions009 = " in Spot ";
	const string CONST_baseactions008 = "Choose squad member to replace ";
	const string CONST_baseactions007 = "Choose squad member to move";
	extern short party_status;
	extern squadst *activesquad;
	party_status = -1;
	int partysize = squadsize(activesquad);
	if (partysize <= 1) return;
	while (true)
	{
		printparty();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 26, CONST_baseactions007);
		int oldPos = getkeyAlt();
		if (oldPos<'1' || oldPos>partysize + '1' - 1) return; // User chose index out of range, exit
		makedelimiter();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		std::string str = CONST_baseactions008;
		str += activesquad->squad[oldPos - '1']->name;
		str += CONST_baseactions009;
		str += (char)oldPos;
		mvaddstrCenter(8, str);
		int newPos = getkeyAlt();
		if (newPos<'1' || newPos>partysize + '1' - 1) return; // User chose index out of range, exit
		swap(activesquad->squad[oldPos - '1'], activesquad->squad[newPos - '1']);
	}
}
int lenVehiclePool();
int getCarID(const int l);
string getCarFullname(const int l);
/* base - assign a vehicle to this squad */
void setvehicles()
{
	const string CONST_baseactions012 = "be a passenger.";
	const string CONST_baseactions011 = "drive it.";
	const string CONST_baseactions010 = "Choosing the Right Liberal Vehicle";
	extern squadst *activesquad;
	extern short interface_pgup;
	extern short interface_pgdn;
	if (!activesquad) return;
	int page = 0;
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, CONST_baseactions010);
		printparty();
		int x = 1, y = 10;
		char str[200];
		for (int l = page * 18; l < lenVehiclePool() && l < page * 18 + 18; l++)
		{
			bool this_squad = false;
			for (int p = 0; p < 6; p++)
			{
				if (activesquad->squad[p] == NULL) continue;
				if (activesquad->squad[p]->alive&&
					activesquad->squad[p]->pref_carid == getCarID(l))
				{
					this_squad = true;
					break;
				}
			}
			bool another_squad = CreaturePool::getInstance().isThisCarWantedByAnotherSquad(getCarID(l), activesquad->id);
			if (this_squad&&another_squad)
				set_color_easy(RED_ON_BLACK_BRIGHT);
			else if (another_squad)
				set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			else if (this_squad)
				set_color_easy(GREEN_ON_BLACK_BRIGHT);
			else
				set_color_easy(WHITE_ON_BLACK);
			str[0] = l - page * 18 + 'A';
			str[1] = '\x0';
			strcat(str, spaceDashSpace.c_str());
			strcat(str, getCarFullname(l).c_str());
			mvaddstrAlt(y, x, str);
			x += 26;
			if (x > 53) x = 1, y++;
		}
		set_color_easy(WHITE_ON_BLACK);
		//PAGE UP
		if (page > 0)
		{
			mvaddstrAlt(17, 1, addprevpagestr());
		}
		//PAGE DOWN
		if ((page + 1) * 18 < lenVehiclePool())
		{
			mvaddstrAlt(17, 53, addnextpagestr());
		}
		for (int i = 0; i < len(vehicleParagraph); i++) {
			mvaddstrAlt(18 + i, 1, vehicleParagraph[i]);
		}
		// TODO this is the only instance in entire program using getkey_cap()
		int c = getkey_cap();
		if (c >= 'A'&&c <= 'R')
		{
			int slot = c - 'A' + page * 18;
			if (slot >= 0 && slot < lenVehiclePool())
			{
				bool choice = true;
				if (activesquad->squad[0])
				{
					choice = false;
					for (int c = 1; c < 6; c++)
					{
						if (activesquad->squad[c]) //are these slots always filled in order?
						{
							choice = true;
							break;
						}
					}
				}
				int c = '1';
				if (choice)
				{
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(8, 20, chooseALiberalTo + CONST_baseactions011);
					c = getkeyAlt();
				}
				if (c >= '1'&&c <= '6')
				{
					if (activesquad->squad[c - '1'] != NULL)
					{
						activesquad->squad[c - '1']->pref_carid = getCarID(slot);
						if (activesquad->squad[c - '1']->canwalk())
							activesquad->squad[c - '1']->pref_is_driver = 1;
						else activesquad->squad[c - '1']->pref_is_driver = 0;
					}
				}
			}
		}
		if (c >= 'a'&&c <= 'r')
		{
			int slot = c - 'a' + page * 18;
			if (slot >= 0 && slot < lenVehiclePool())
			{
				bool choice = true;
				if (activesquad->squad[0])
				{
					choice = false;
					for (int c = 1; c < 6; c++)
					{
						if (activesquad->squad[c]) //are these slots always filled in order?
						{
							choice = true;
							break;
						}
					}
				}
				int c = '1';
				if (choice)
				{
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(8, 20, chooseALiberalTo + CONST_baseactions012);
					c = getkeyAlt();
				}
				if (c >= '1'&&c <= '6')
				{
					if (activesquad->squad[c - '1'])
					{
						activesquad->squad[c - '1']->pref_carid = getCarID(slot);
						activesquad->squad[c - '1']->pref_is_driver = 0;
					}
				}
			}
		}
		//SAV - adding way to remove people from vehicles.
		if (c >= '1'&&c <= '6')
		{
			// 1. Is there someone there?
			if (activesquad->squad[c - '1'])
			{
				// 2. Are they in a vehicle? Someday we'll want to enforce car capacity
				int vin = activesquad->squad[c - '1']->pref_carid;
				if (vin > -1)
				{
					activesquad->squad[c - '1']->pref_carid = -1;
					activesquad->squad[c - '1']->pref_is_driver = 0;
				}
			}
		}
		//SAV - End add
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0) page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 18 < lenVehiclePool()) page++;
		if (c == 'x' || c == 'X' || c == ENTER || c == ESC || c == SPACEBAR) return;
	}
}


const string tag_Sta = "Sta, ";
const string tag_Libp = "Lib+, ";
const string tag_Lib = "Lib, ";
const string tag_Mod = "Mod, ";
const string tag_Cons = "Cons, ";
const string tag_Consp = "Cons+";

#include "../cursesgraphics.h"
bool liberalagenda(signed char won);
#include "../basemode/baseactions.h"
//// #include "../basemode/activate_sleepers.h"
void activate_sleepers();
//// #include "../basemode/activate.h"
void activate();
#include "../basemode/reviewmode.h"
void review();
#include "../common/equipment.h"
void equip(vector<Item *> &loot, int loc);
//// #include "../politics/politics.h"
bool stalinview(short view, bool islaw);
//// #include "../monthly/monthly.h"
void passmonth(char &clearformess, char canseethings);
#include "../daily/daily.h"
//for int monthday();
#include "../daily/siege.h"
string change_squad_order;
enum CantSeeReason
{
	CANTSEE_DATING = 1,
	CANTSEE_HIDING = 2,
	CANTSEE_OTHER = 3,
	CANTSEE_DISBANDING = 4
};
string check_status_of_squad_liberal;
string show_squad_liberal_status;
bool show_disbanding_screen(int& oldforcemonth)
{
	const string CONST_basemode030 = "R - Recreate the Liberal Crime Squad                  Any Other Key - Next Month";
	const string CONST_basemode029 = "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ";
	const string CONST_basemode026 = "Conservative";
	const string CONST_basemode025 = "Liberal";
	const string CONST_basemode024 = "Public Mood";
	const string CONST_basemode020 = "Libertarian";
	const string CONST_basemode019 = "Stalinist";
	const string CONST_basemode017 = "Supreme Court: ";
	const string CONST_basemode016 = "Senate: ";
	const string CONST_basemode015 = "House: ";
	const string CONST_basemode014 = ", 2nd Term";
	const string CONST_basemode013 = ", 1st Term";
	const string CONST_basemode012 = "President: ";
	extern MusicClass music;
	extern int year;
	extern int month;
	extern int disbandtime;
	extern short execterm;
	extern bool stalinmode;
	extern short exec[EXECNUM];
	extern char execname[EXECNUM][POLITICIAN_NAMELEN];
	extern short house[HOUSENUM];
	extern short senate[SENATENUM];
	extern short court[COURTNUM];
	extern short lawList[LAWNUM];
	extern short attitude[VIEWNUM];
	extern vector<Creature *> pool;
	if (oldforcemonth == month) return true;
	music.play(MUSIC_DISBANDED);
	for (int p = CreaturePool::getInstance().lenpool() - 1; p >= 0; p--)
	{
		int targetjuice = LCSrandom(100 * (year - disbandtime + 1));
		if (targetjuice > 1000) targetjuice = 1000;
		if (pool[p]->juice < targetjuice&&pool[p]->hireid != -1 && !(pool[p]->flag&CREATUREFLAG_SLEEPER))
			pool[p]->alive = 0; // Kill for the purposes of disbanding all contacts below
	}
	oldforcemonth = month;
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(0, 0, getmonth(month) + singleSpace);
	addstrAlt(year);
	signed char align = exec[EXEC_PRESIDENT];
	set_alignment_color(align, true);
	mvaddstrAlt(1, 0, CONST_basemode012);
	addstrAlt(execname[EXEC_PRESIDENT]); addstrAlt(commaSpace);
	addstrAlt(getalign(align));
	if (execterm == 1)addstrAlt(CONST_basemode013);
	else addstrAlt(CONST_basemode014);
	int housemake[6] = { 0,0,0,0,0,0 };
	for (int h = 0; h < HOUSENUM; h++) housemake[house[h] + 2]++;
	if (housemake[5] + min(housemake[0], housemake[4]) >= HOUSEMAJORITY) align = ALIGN_STALINIST; // Stalinists have a majority (perhaps with help from extremists on both sides)
	else if (housemake[0] >= HOUSEMAJORITY) align = ALIGN_ARCHCONSERVATIVE; // Arch-Conservatives have a majority
	else if (housemake[4] >= HOUSEMAJORITY) align = ALIGN_ELITELIBERAL; // Elite Liberals have a majority
	else if (housemake[0] + housemake[1] >= HOUSEMAJORITY) align = ALIGN_CONSERVATIVE; // Conservatives plus Arch-Conservatives have a majority
	else if (housemake[3] + housemake[4] >= HOUSEMAJORITY) align = ALIGN_LIBERAL; // Liberals plus Elite Liberals have a majority
	else align = ALIGN_MODERATE; // nobody has a majority
	set_alignment_color(align, true);
	mvaddstrAlt(2, 0, CONST_basemode015);
	if (stalinmode) addstrAlt(tostring(housemake[5]) + tag_Sta);
	addstrAlt(tostring(housemake[4]) + tag_Libp);
	addstrAlt(tostring(housemake[3]) + tag_Lib);
	addstrAlt(tostring(housemake[2]) + tag_Mod);
	addstrAlt(tostring(housemake[1]) + tag_Cons);
	addstrAlt(tostring(housemake[0]) + tag_Consp);
	int senatemake[6] = { 0,0,0,0,0,0 };
	for (int s = 0; s < SENATENUM; s++) senatemake[senate[s] + 2]++;
	senatemake[exec[EXEC_VP] + 2]++; // Vice President is tie-breaking vote in the Senate
	if (senatemake[5] + min(senatemake[0], senatemake[4]) >= SENATEMAJORITY) align = ALIGN_STALINIST; // Stalinists have a majority (perhaps with help from extremists on both sides)
	else if (senatemake[0] >= SENATEMAJORITY) align = ALIGN_ARCHCONSERVATIVE; // Arch-Conservatives have a majority
	else if (senatemake[4] >= SENATEMAJORITY) align = ALIGN_ELITELIBERAL; // Elite Liberals have a majority
	else if (senatemake[0] + senatemake[1] >= SENATEMAJORITY) align = ALIGN_CONSERVATIVE; // Conservatives plus Arch-Conservatives have a majority
	else if (senatemake[3] + senatemake[4] >= SENATEMAJORITY) align = ALIGN_LIBERAL; // Liberals plus Elite Liberals have a majority
	else align = ALIGN_MODERATE; // nobody has a majority
	set_alignment_color(align, true);
	senatemake[exec[EXEC_VP] + 2]--; // Vice President isn't actually a Senator though
	mvaddstrAlt(3, 0, CONST_basemode016);
	if (stalinmode) addstrAlt(tostring(senatemake[5]) + tag_Sta);
	addstrAlt(tostring(senatemake[4]) + tag_Libp);
	addstrAlt(tostring(senatemake[3]) + tag_Lib);
	addstrAlt(tostring(senatemake[2]) + tag_Mod);
	addstrAlt(tostring(senatemake[1]) + tag_Cons);
	addstrAlt(tostring(senatemake[0]) + tag_Consp);
	int courtmake[6] = { 0,0,0,0,0,0 };
	for (int s = 0; s < COURTNUM; s++) courtmake[court[s] + 2]++;
	if (courtmake[5] + min(courtmake[0], courtmake[4]) >= COURTMAJORITY) align = ALIGN_STALINIST; // Stalinists have a majority (perhaps with help from extremists on both sides)
	else if (courtmake[0] >= COURTMAJORITY) align = ALIGN_ARCHCONSERVATIVE; // Arch-Conservatives have a majority
	else if (courtmake[4] >= COURTMAJORITY) align = ALIGN_ELITELIBERAL; // Elite Liberals have a majority
	else if (courtmake[0] + courtmake[1] >= COURTMAJORITY) align = ALIGN_CONSERVATIVE; // Conservatives plus Arch-Conservatives have a majority
	else if (courtmake[3] + courtmake[4] >= COURTMAJORITY) align = ALIGN_LIBERAL; // Liberals plus Elite Liberals have a majority
	else align = ALIGN_MODERATE; // nobody has a majority
	set_alignment_color(align, true);
	mvaddstrAlt(4, 0, CONST_basemode017);
	if (stalinmode) addstrAlt(tostring(courtmake[5]) + tag_Sta);
	addstrAlt(tostring(courtmake[4]) + tag_Libp);
	addstrAlt(tostring(courtmake[3]) + tag_Lib);
	addstrAlt(tostring(courtmake[2]) + tag_Mod);
	addstrAlt(tostring(courtmake[1]) + tag_Cons);
	addstrAlt(tostring(courtmake[0]) + tag_Consp);
	for (int l = 0; l < LAWNUM; l++)
	{
		align = lawList[l];
		set_alignment_color(align, true);
		mvaddstrAlt(6 + l / 3, l % 3 * 30, getlaw(l));
	}
	if (stalinmode)
	{
		int stalin = 0; // the Stalinist mood position from 1 to 78 (left=Stalinist, right=Libertarian)
		for (int v = 0; v < VIEWNUM - 3; v++)
			stalin += stalinview(v, false) ? attitude[v] : 100 - attitude[v];
		stalin = 78 - (stalin * 77) / ((VIEWNUM - 3) * 100); // very accurate Stalinist mood positioning!
		if (stalin >= 64) align = ALIGN_ELITELIBERAL;
		else if (stalin >= 48) align = ALIGN_LIBERAL;
		else if (stalin >= 32) align = ALIGN_MODERATE;
		else if (stalin >= 16) align = ALIGN_CONSERVATIVE;
		else align = ALIGN_ARCHCONSERVATIVE;
		set_alignment_color(align, true);
		mvaddstrAlt(17, 33, CONST_basemode024);
		set_color_easy(RED_ON_BLACK_BRIGHT);
		mvaddstrAlt(17, 1, CONST_basemode019);
		set_color_easy(GREEN_ON_BLACK_BRIGHT);
		mvaddstrAlt(17, 68, CONST_basemode020);
		set_color_easy(RED_ON_BLACK_BRIGHT);
		mvaddstrAlt(18, 0, "\x11ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ");
		set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
		mvaddstrAlt(18, 16, CONST_basemode029);
		set_color_easy(YELLOW_ON_BLACK_BRIGHT);
		mvaddstrAlt(18, 32, CONST_basemode029);
		set_color_easy(CYAN_ON_BLACK_BRIGHT);
		mvaddstrAlt(18, 48, CONST_basemode029);
		set_color_easy(GREEN_ON_BLACK_BRIGHT);
		mvaddstrAlt(18, 64, "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ\x10");
		set_alignment_color(align, true);
		mvaddcharAlt(18, stalin, 'O');
	}
	int mood = 0; // the mood position from 1 to 78 (left=left-wing, right=right-wing)
	for (int v = 0; v < VIEWNUM - 3; v++) mood += attitude[v];
	mood = 78 - (mood * 77) / ((VIEWNUM - 3) * 100); // very accurate mood positioning!
	if (mood >= 64) align = ALIGN_ARCHCONSERVATIVE;
	else if (mood >= 48) align = ALIGN_CONSERVATIVE;
	else if (mood >= 32) align = ALIGN_MODERATE;
	else if (mood >= 16) align = ALIGN_LIBERAL;
	else align = ALIGN_ELITELIBERAL;
	set_alignment_color(align, true);
	mvaddstrAlt(stalinmode ? 21 : 20, 33, CONST_basemode024);
	set_color_easy(GREEN_ON_BLACK_BRIGHT);
	mvaddstrAlt(21, 1, CONST_basemode025);
	set_color_easy(RED_ON_BLACK_BRIGHT);
	mvaddstrAlt(21, 67, CONST_basemode026);
	set_color_easy(GREEN_ON_BLACK_BRIGHT);
	mvaddstrAlt(22, 0, "\x11ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ");
	set_color_easy(CYAN_ON_BLACK_BRIGHT);
	mvaddstrAlt(22, 16, CONST_basemode029);
	set_color_easy(YELLOW_ON_BLACK_BRIGHT);
	mvaddstrAlt(22, 32, CONST_basemode029);
	set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
	mvaddstrAlt(22, 48, CONST_basemode029);
	set_color_easy(RED_ON_BLACK_BRIGHT);
	mvaddstrAlt(22, 64, "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ\x10");
	set_alignment_color(align, true);
	mvaddcharAlt(22, mood, 'O');
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(24, 0, CONST_basemode030);
	return(getkeyAlt() != 'r');
}
void printIfLongWait(int nonsighttime) {
	extern MusicClass music;
	extern Log gamelog;
	const string CONST_basemode033 = "It sure has been a while.  Things might have changed a bit.";
	const string CONST_basemode032 = "It has been a long time.  A lot must have changed...";
	const string CONST_basemode031 = "How long since you've heard these sounds...  times have changed.";
	if (nonsighttime >= 365 * 4)
	{
		music.play(MUSIC_BASEMODE);
		eraseAlt();
		char str[100];
		if (nonsighttime >= 365 * 16)
			strcpy(str, CONST_basemode031.c_str());
		else if (nonsighttime >= 365 * 8)
			strcpy(str, CONST_basemode032.c_str());
		else strcpy(str, CONST_basemode033.c_str());
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrCenter(12, str, gamelog);
		gamelog.nextMessage(); //Write out buffer to prepare for the next message.
		pressAnyKey();
	}
}

void stillDontForceWait(const char sieged, const char cannotwait,
	const char haveflag,
	const char partysize) {

	extern int selectedsiege;
	extern squadst *activesquad;
	extern string slogan_str;
	extern vector<Creature *> pool;
	extern Log gamelog;
	extern class Ledger ledger;
	extern int day;

	const string CONST_basemode062 = "P - PATRIOTISM: fly a flag here ($20)";
	const string CONST_basemode061 = "P - PROTEST: burn the flag";
	const string CONST_basemode060 = "S - FREE SPEECH: the Liberal Slogan";
	const string CONST_basemode059 = " (next month)";
	const string CONST_basemode058 = "W - Wait a day";
	const string CONST_basemode057 = "W - Wait out the siege";
	const string CONST_basemode056 = "Cannot Wait until Siege Resolved";
	const string CONST_basemode055 = "X - Live to fight EVIL another day";
	const string CONST_basemode054 = "F - Go forth to stop EVIL";
	const string CONST_basemode053 = "G - Give Up";
	const string CONST_basemode052 = "F - Escape/Engage";
	const string CONST_basemode051 = "C - Cancel this Squad's Departure";


	if (partysize)
	{
		if (activesquad->activity.type != ACTIVITY_NONE) set_color_easy(WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
	}
	else set_color_easy(BLACK_ON_BLACK_BRIGHT);
	mvaddstrAlt(20, 1, CONST_basemode051);



	if (sieged)
	{
		if (partysize) set_color_easy(WHITE_ON_BLACK);
		else
		{
			set_color_easy(BLACK_ON_BLACK_BRIGHT);
			for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
			{
				if (pool[p]->location == selectedsiege)
				{
					set_color_easy(WHITE_ON_BLACK);
					break;
				}
			}
		}
		mvaddstrAlt(19, 1, CONST_basemode052);
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(19, 23, CONST_basemode053);
	}
	else
	{
		if (partysize) set_color_easy(WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(19, 1, CONST_basemode054);
	}


	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(23, 40, CONST_basemode055);
	set_color_easy(WHITE_ON_BLACK);

	if (cannotwait) mvaddstrAlt(23, 1, CONST_basemode056);
	else
	{
		if (sieged) mvaddstrAlt(23, 1, CONST_basemode057);
		else mvaddstrAlt(23, 1, CONST_basemode058);
		if (day == monthday()) addstrAlt(CONST_basemode059);
	}
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(22, 40, CONST_basemode060);

	if (haveflag)
	{
		if (sieged) set_color_easy(GREEN_ON_BLACK_BRIGHT);
		else set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(22, 1, CONST_basemode061);
	}
	else
	{
		if (ledger.get_funds() >= 20 && !sieged && (selectedsiege != -1 || activesquad != NULL))
			set_color_easy(WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(22, 1, CONST_basemode062);
	}

	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	if (haveflag) mvaddstrCenter(17, slogan_str);
	else mvaddstrCenter(13, slogan_str);
}
void dontForceWait(const char sieged, const char underattack, 
	const char haveflag,
	const Location *loc,
	const char safenumber,
	const char partysize) {

	const string CONST_basemode050 = "B - Sleepers";
	const string CONST_basemode049 = "A - Activate Liberals";
	const string CONST_basemode048 = "L - The Status of the Liberal Agenda";
	const string CONST_basemode047 = "Z - Next Location";
	const string CONST_basemode046 = "TAB - Next Squad";
	const string CONST_basemode045 = "O - Reorder";
	const string CONST_basemode044 = "R - Review Assets and Form Squads";
	const string CONST_basemode043 = "V - Vehicles";
	const string CONST_basemode042 = "E - Equip Squad";
	const string CONST_basemode041 = "ÄÄÄ PLANNING ÄÄÄ";
	const string CONST_basemode040 = "ÄÄÄ ACTIVISM ÄÄÄ";
	const string CONST_basemode039 = ":::::::::";
	const string CONST_basemode038 = ":.:.:.:.:";
	const string CONST_basemode037 = " (No Food)";
	const string CONST_basemode036 = "Under Siege";
	const string CONST_basemode035 = "Under Attack";
	const string CONST_basemode034 = "I - Invest in this location";


	extern int selectedsiege;
	extern squadst *activesquad;
	extern vector<squadst *> squad;
	extern vector<Creature *> pool;

			eraseAlt();
			if (activesquad != NULL) selectedsiege = -1;
			locheader();
			if (selectedsiege != -1)
			{
				printlocation(selectedsiege);
				if (LocationsPool::getInstance().canBeUpgraded(selectedsiege) &&
					!LocationsPool::getInstance().isThereASiegeHere(selectedsiege))
				{
					set_color_easy(WHITE_ON_BLACK);
					mvaddstrAlt(8, 1, CONST_basemode034);
				}
			}
			else if (activesquad != NULL) printparty();
			else makedelimiter();


			if (sieged)
			{
				if (underattack)
				{
					set_color_easy(RED_ON_BLACK_BRIGHT);
					mvaddstrAlt(8, 1, CONST_basemode035);
				}
				else
				{
					set_color_easy(YELLOW_ON_BLACK_BRIGHT);
					mvaddstrAlt(8, 1, CONST_basemode036);
					int stock = 1;
					if (loc)stock = loc->compound_stores;
					if (!stock)addstrAlt(CONST_basemode037);
				}
			}


			if (haveflag) for (int y = 0; y < 7; y++)
			{
				if (y < 6)
				{
					set_color_easy(y < 4 ? WHITE_ON_BLUE_BRIGHT : WHITE_ON_RED_BRIGHT);
					if (y == 0) mvaddstrAlt(y + 10, 31, CONST_basemode038);
					else if (y < 3) mvaddstrAlt(y + 10, 31, CONST_basemode039);
					else for (int x = 0; x < 9; x++) mvaddchAlt(y + 10, 31 + x, CH_LOWER_HALF_BLOCK);
					set_color_easy(WHITE_ON_RED_BRIGHT);
					for (int x = 9; x < 18; x++) addchAlt(CH_LOWER_HALF_BLOCK);
				}
				else
				{
					set_color_easy(RED_ON_BLACK);
					for (int x = 0; x < 18; x++) mvaddchAlt(y + 10, 31 + x, CH_UPPER_HALF_BLOCK);
				}
			}


			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(18, 10, CONST_basemode040);
			mvaddstrAlt(18, 51, CONST_basemode041);
			if (partysize && !underattack) set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(19, 40, CONST_basemode042);
			if (lenVehiclePool() && partysize) set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(19, 60, CONST_basemode043);
			if (CreaturePool::getInstance().lenpool()) set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(20, 40, CONST_basemode044);
			if (partysize > 1) set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			if (partysize && !sieged) mvaddstrAlt(8, 30, CONST_basemode045);
			if (activesquad && !sieged) // don't cover up info about siege with irrelevant squad name of a squad that will be disbanded during the siege anyway
			{
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(8, 1, activesquad->name);
				addchAlt(CH_BOX_DRAWINGS_LIGHT_HORIZONTAL); //in case of overlap, at least make it clear where the name ends.
			}


			if (len(squad) > 1 || (!activesquad&&len(squad))) set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(8, 43, CONST_basemode046);
			if (safenumber > 0) set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);


			mvaddstrAlt(8, 62, CONST_basemode047);
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(21, 40, CONST_basemode048);
			set_color_easy(BLACK_ON_BLACK_BRIGHT);
			for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++) if (pool[p]->is_active_liberal())
			{
				if (pool[p]->squadid != -1)
				{
					int sq = getsquad(pool[p]->squadid);
					if (sq != -1) if (squad[sq]->activity.type != ACTIVITY_NONE) continue;
				}
				set_color_easy(WHITE_ON_BLACK);
				break;
			}


			mvaddstrAlt(21, 1, CONST_basemode049);
			set_color_easy(BLACK_ON_BLACK_BRIGHT);
			for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++){
				if (pool[p]->is_lcs_sleeper())
				{
					set_color_easy(WHITE_ON_BLACK);
					break;
				}
			}

			mvaddstrAlt(21, 25, CONST_basemode050);
			
		
}
void pressedThisKeyInBaseMode(const int c) {
	extern char disbanding;
	extern squadst *activesquad;
	extern int selectedsiege;
	extern short party_status;
	extern vector<squadst *> squad;

	switch (c)
	{
	case 'i': if (selectedsiege != -1)
		if (LocationsPool::getInstance().canBeUpgraded(selectedsiege) && !LocationsPool::getInstance().isThereASiegeHere(selectedsiege))
			investlocation(); break;
	case 'l': disbanding = liberalagenda(0); break;

	case 'a': activate(); break;
	case 'b': activate_sleepers(); break;
	case TAB: if (len(squad)) {
		if (!activesquad) activesquad = squad[0];
		else for (int sq = 0; sq < len(squad); sq++)
			if (squad[sq] == activesquad)
			{
				if (sq == len(squad) - 1) activesquad = squad[0];
				else activesquad = squad[sq + 1];
				break;
			}
	} break;

	case 'r': if (CreaturePool::getInstance().lenpool()) review(); break;

	case 's': getslogan(); break;
	case '0': party_status = -1; break;
	case '1': case '2': case '3': case '4': case '5': case '6':
		if (activesquad) if (activesquad->squad[c - '1']) {
			if (party_status == c - '1') fullstatus(party_status);
			else party_status = c - '1';
		} break;
	}
}

void findCantSeeReason(char &canseethings, char &forcewait) {
	bool isPartOfJusticeSystem(int cursite);
	extern char cantseereason;
	extern vector<Creature *> pool;

	for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
	{
		if (pool[p]->alive&&
			pool[p]->align == 1 &&
			pool[p]->dating == 0 &&
			pool[p]->hiding == 0 &&
			!(pool[p]->flag & CREATUREFLAG_SLEEPER))
		{
			if (!isPartOfJusticeSystem(pool[p]->location))
			{
				canseethings = 1;
				if (pool[p]->clinic == 0) { forcewait = 0; break; }
			}
		}
		else
		{
			if (pool[p]->dating == 1 && cantseereason > CANTSEE_DATING) cantseereason = CANTSEE_DATING;
			else if (pool[p]->hiding != 0 && cantseereason > CANTSEE_HIDING) cantseereason = CANTSEE_HIDING;
		}
	}
}

int countSafeHouses();
Location* getLocation();
void equipLoot(int l, int loc);
bool isThisSafehouse(int loc);
void burnFlagAtLocation(int l);
int lenVehiclePool();
void mode_base()
{
	const string CONST_basemode063 = "Time passes...";
	extern char cantseereason;
	extern char disbanding;
	extern squadst *activesquad;
	extern Log gamelog;
	extern MusicClass music;
	extern int stat_buys;
	extern int stat_burns;
	extern int year;
	extern int month;
	extern int selectedsiege;
	extern int day;
	extern short party_status;
	extern class Ledger ledger;
	extern short lawList[LAWNUM];
	extern string slogan_str;
	extern vector<squadst *> squad;
	extern vector<Creature *> pool;
	int nonsighttime = 0, oldforcemonth = month;
	// FIXME This while(true) loop does not have an exit point  It relies on end_game(); to be called at some point
	// Unless the player presses 'x', at which point this function 'return's
	while (true)
	{
		char forcewait = 1;
		char canseethings = 0;
		cantseereason = CANTSEE_OTHER;
		if (disbanding)
		{
			cantseereason = CANTSEE_DISBANDING;
			disbanding = show_disbanding_screen(oldforcemonth);
		}
		else
		{
			findCantSeeReason(canseethings, forcewait);

		}
		if (!forcewait)
		{
			printIfLongWait(nonsighttime);
			nonsighttime = 0;
		}
		int partysize = squadsize(activesquad);
		if (activesquad && !partysize)
		{
			delete_and_remove(squad, getsquad(activesquad->id));
			activesquad = NULL;
		}
		int safenumber = countSafeHouses();
		Location *loc = getLocation();
		siegest *siege = NULL;
		if (loc) siege = &loc->siege;
		char sieged = 0, underattack = 0;
		if (siege) sieged = siege->siege;
		if (sieged)
		{
			underattack = siege->underattack;
			if (!forcewait) music.play(MUSIC_SIEGE);
			else music.play(MUSIC_DISBANDED);
		}
		else if (!forcewait) music.play(MUSIC_BASEMODE);
		else music.play(MUSIC_DISBANDED);
		char haveflag = 0;
		if (loc) haveflag = loc->haveflag;
		// Count people at each location
		int* num_present = new int[LocationsPool::getInstance().lenpool()];
		for (int i = 0; i < LocationsPool::getInstance().lenpool(); i++) num_present[i] = 0;
		for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
		{  // Dead people, non-liberals, and vacationers don't count
			if (!pool[p]->alive || pool[p]->align != 1 || pool[p]->location == -1) continue;
			num_present[pool[p]->location]++;
		}
		char cannotwait = 0;
		for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++)
		{
			if (!LocationsPool::getInstance().isThereASiegeHere(l)) continue;
			if (LocationsPool::getInstance().isThisUnderAttack(l))
			{
				// Allow siege if no liberals present
				if (num_present[l])cannotwait = 1;
				break;
			}
		}
		delete[] num_present;
		if (!forcewait) {
			
			dontForceWait(sieged, underattack,
				haveflag,
				loc,
				safenumber,
				partysize);
			stillDontForceWait(sieged, cannotwait,
				haveflag,
				partysize);
		}
		int c = forcewait ? 'w' : getkeyAlt();
		switch (c) {
		case 'x': return;

		case 'v': if (lenVehiclePool() && partysize) {
			short ops = party_status;
			party_status = -1;
			setvehicles();
			party_status = ops;
		} break;
		case 'g': if (sieged) { giveup(); cleangonesquads(); } break;
		case 'f': if (!sieged&&partysize > 0) stopevil();
				  else if (underattack) { escape_engage(); cleangonesquads(); }
				  else if (sieged) { sally_forth(); cleangonesquads(); } break;
		case 'z': if (safenumber) {
			activesquad = NULL;
			for (int l = (selectedsiege == -1 || selectedsiege + 1 >= LocationsPool::getInstance().lenpool()) ? 0 : selectedsiege + 1;
				l < LocationsPool::getInstance().lenpool(); l++)
				if (isThisSafehouse(l)) { selectedsiege = l; break; }
				else if (l == LocationsPool::getInstance().lenpool() - 1) l = -1;
		} break;
		case 'e': if (partysize && !underattack&&activesquad->squad[0]->location != -1) {
			short ops = party_status;
			party_status = -1;
			equipLoot(activesquad->squad[0]->location, -1);
			party_status = ops;
		} break;
		case 'o': if (partysize > 1) orderparty(); break;
		case 'c': if (partysize) activesquad->activity.type = ACTIVITY_NONE; break;
		case 'p': if (haveflag) {
			burnflag();
			stat_burns++;
			if (selectedsiege != -1)
			{
				burnFlagAtLocation(selectedsiege);
				if (lawList[LAW_FLAGBURNING] < 1)
					criminalizepool(LAWFLAG_BURNFLAG, -1, selectedsiege);
			}
			if (activesquad)
			{
				burnFlagAtLocation(activesquad->squad[0]->base);
				if (lawList[LAW_FLAGBURNING] < 1)
					criminalizepool(LAWFLAG_BURNFLAG, -1, activesquad->squad[0]->base);
			}
			if (sieged)
			{  //PUBLICITY IF BURN FLAG DURING SIEGE ESPECIALLY IF IT IS REALLY ILLEGAL
				change_public_opinion(VIEW_LIBERALCRIMESQUAD, 1);
				change_public_opinion(VIEW_FREESPEECH, 1, 1, 30);
				if (lawList[LAW_FLAGBURNING] <= 0)
				{
					change_public_opinion(VIEW_LIBERALCRIMESQUAD, 1);
					change_public_opinion(VIEW_FREESPEECH, 1, 1, 50);
				}
				if (lawList[LAW_FLAGBURNING] <= -1)
				{
					change_public_opinion(VIEW_LIBERALCRIMESQUAD, 5);
					change_public_opinion(VIEW_FREESPEECH, 2, 1, 70);
				}
				if (lawList[LAW_FLAGBURNING] == -2)
				{
					change_public_opinion(VIEW_LIBERALCRIMESQUAD, 15);
					change_public_opinion(VIEW_FREESPEECH, 5, 1, 90);
				}
			}
		}
				  else if (ledger.get_funds() >= 20 && !sieged&&loc) {
					  ledger.subtract_funds(20, EXPENSE_COMPOUND);
					  if (loc) loc->haveflag = 1;
					  stat_buys++;
				  } break;
		case 'w': if (forcewait || !cannotwait) {
			char clearformess = forcewait;
			if (!canseethings) nonsighttime++;
			advanceday(clearformess, canseethings);
			if (day > monthday()) passmonth(clearformess, canseethings);
			advancelocations();
			if (forcewait&&day == 1)
			{
				eraseAlt();
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(7, 5, CONST_basemode063, gamelog);
				mvaddstrAlt(9, 12, getmonth(month, true) + singleSpace, gamelog);
				mvaddstrAlt(9, 17, tostring(day) + commaSpace, gamelog);
				mvaddstrAlt(9, 21, year, gamelog);
				gamelog.nextMessage(); //Write out buffer to prepare for the next message.
				refreshAlt();
			}
		} break;
		default:
			pressedThisKeyInBaseMode(c);
			break;

		}
	}
}

// #include "../includes.h"
const string CONST_chase015 = "carchase_obstacle_child.txt";
const string CONST_chase014 = "carchase_obstacle_cross_traffic.txt";
const string CONST_chase013 = "carchase_obstacle_truck_pulls_out.txt";
const string CONST_chase012 = "carchase_obstacle_fruit_stand.txt";
const string CONST_chase011 = "carchase_obstacle_none.txt";
const string CONST_chase010 = "die_in_car.txt";
const string CONST_chase009 = "car_crash_fatalities.txt";
const string CONST_chase008 = "car_crash_modes.txt";
const string CONST_chase007 = "car_plows_through.txt";
const string CONST_chase006 = "car_speed.txt";

const string CONST_chase048 = " is still on your tail!";
const string CONST_chase079 = "C - Reflect on your lack of skill.";
const string CONST_chase076 = "F - Fight!";
const string CONST_chase075 = "E - Equip";
const string CONST_chase074 = "D - Try to lose them!";

const string tag_The = "The ";

//// #include "basemode/baseactions.h"
void orderparty();
//// #include "sitemode/advance.h"
void creatureadvance();
//// #include "sitemode/miscactions.h"
void reloadparty(bool wasteful = false);
//// #include "common/equipment.h"
void equip(vector<Item *> &loot, int loc);
#include "../combat/haulkidnapCreature.h"
void fillEncounter(CreatureTypes c, int numleft) {
	extern Creature encounter[ENCMAX];
	for (int e = 0; e < ENCMAX; e++)
	{
		if (!encounter[e].exists)
		{
			makecreature(encounter[e], c);
			numleft--;
		}
		if (numleft == 0)break;
	}
}
void emptyEncounter();
void emptyEncounter() {
	extern Creature encounter[ENCMAX];
	for (int e = 0; e < ENCMAX; e++)encounter[e].exists = 0;
}
vector<string> car_speed;
vector<string> car_plows_through;
vector<string> car_crash_modes;
vector<string> car_crash_fatalities;
vector<string> die_in_car;
vector<string> carchase_obstacle_none;
vector<string> carchase_obstacle_fruit_stand;
vector<string> carchase_obstacle_truck_pulls_out;
vector<string> carchase_obstacle_cross_traffic;
vector<string> carchase_obstacle_child;
const string chase = "chase\\";
vector<file_and_text_collection> chase_text_file_collection = {
	/*chase.cpp*/
	customText(&car_speed, chase + CONST_chase006),
	customText(&car_plows_through, chase + CONST_chase007),
	customText(&car_crash_modes, chase + CONST_chase008),
	customText(&car_crash_fatalities, chase + CONST_chase009),
	customText(&die_in_car, chase + CONST_chase010),
	customText(&carchase_obstacle_none, mostlyendings + CONST_chase011),
	customText(&carchase_obstacle_fruit_stand, mostlyendings + CONST_chase012),
	customText(&carchase_obstacle_truck_pulls_out, mostlyendings + CONST_chase013),
	customText(&carchase_obstacle_cross_traffic, mostlyendings + CONST_chase014),
	customText(&carchase_obstacle_child, mostlyendings + CONST_chase015),
};
map<short, vector<string> > carchaseObstacles;
string beingFollowedBySwine;
string lostThem;
string hereTheyCome;
string isSeized;
const int DRIVING_RANDOMNESS = 13;
void deleteVehicles(vector<Vehicle *>& carid);
void chase_giveup()
{
	const string CONST_chase020 = " is free.";
	const string CONST_chase019 = "s are free.";
	const string CONST_chase018 = "Your hostage";
	const string CONST_chase017 = "You pull over and are arrested.";
	const string CONST_chase016 = "You stop and are arrested.";
	extern chaseseqst chaseseq;
	extern short mode;
	extern squadst *activesquad;
	extern Log gamelog;
	int ps = find_site_index_in_same_city(SITE_GOVERNMENT_POLICESTATION, chaseseq.location);
	deleteVehicles(chaseseq.friendcar);
	int hostagefreed = 0;
	for (int p = 0; p < 6; p++)
	{
		if (!activesquad->squad[p]) continue;
		activesquad->squad[p]->squadid = -1;
		activesquad->squad[p]->carid = -1;
		activesquad->squad[p]->location = ps;
		activesquad->squad[p]->drop_weapons_and_clips(NULL);
		activesquad->squad[p]->activity.type = ACTIVITY_NONE;
		if (activesquad->squad[p]->prisoner)
		{
			if (activesquad->squad[p]->prisoner->squadid == -1) hostagefreed++;
			freehostage(*activesquad->squad[p], 2);
		}
		activesquad->squad[p] = NULL;
	}
	CreaturePool::getInstance().stopAllBleeding();
	clearmessagearea();
	clearcommandarea();
	set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
	moveAlt(16, 1);
	if (mode != GAMEMODE_CHASECAR)addstrAlt(CONST_chase016, gamelog);
	else addstrAlt(CONST_chase017, gamelog);
	gamelog.newline(); //New line.
	if (hostagefreed)
	{
		mvaddstrAlt(17, 1, CONST_chase018, gamelog);
		if (hostagefreed > 1)
			addstrAlt(CONST_chase019, gamelog);
		else addstrAlt(CONST_chase020, gamelog);
		gamelog.newline(); //New line.
	}
	pressAnyKey();
}
void evasiverun()
{
	const string CONST_chase035 = "thrown to the ground, and beaten senseless!";
	const string CONST_chase034 = "thrown to the ground, and beaten to death!";
	const string CONST_chase033 = " crushed beneath the tank's treads!";
	const string CONST_chase032 = "thrown to the ground, and shot in the head!";
	const string CONST_chase031 = "thrown to the ground, and tazed repeatedly!";
	const string CONST_chase030 = "thrown to the ground, and tazed to death!";
	const string CONST_chase029 = "pushed to the ground, and handcuffed!";
	const string CONST_chase028 = " breaks away!";
	const string CONST_chase026 = " can't keep up!";
	const string CONST_chase025 = " tips into a pool. The tank is trapped!";
	const string CONST_chase024 = "You scale a small building and leap between rooftops!";
	const string CONST_chase023 = "You climb a fence in record time!";
	const string CONST_chase022 = "You run as fast as you can!";
	const string CONST_chase021 = "You suddenly dart into an alley!";
	extern squadst *activesquad;
	extern Log gamelog;
	extern Creature encounter[ENCMAX];
	extern short lawList[LAWNUM];
	vector<int> yourspeed;
	yourspeed.resize(6);
	int yourworst = 10000, yourbest = 0, wheelchair = 0, notwheelchair = 0, theirbest = 0, theirworst = 10000;
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] == NULL) continue;
		if (activesquad->squad[p]->alive)
		{
			if (activesquad->squad[p]->flag & CREATUREFLAG_WHEELCHAIR)
			{
				yourspeed[p] = 0;
				wheelchair++;
			}
			else
			{
				yourspeed[p] = activesquad->squad[p]->attribute_roll(ATTRIBUTE_AGILITY) +
					activesquad->squad[p]->attribute_roll(ATTRIBUTE_HEALTH);
				//healthmodroll(yourspeed[p],*activesquad->squad[p]);
				notwheelchair++;
			}
			if (yourworst > yourspeed[p]) yourworst = yourspeed[p];
			if (yourbest < yourspeed[p]) yourbest = yourspeed[p];
		}
	}
	if (yourworst > 14)
	{
		yourworst += LCSrandom(5);
		clearmessagearea();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		moveAlt(16, 1);
		switch (LCSrandom(yourworst / 5))
		{
		default:
			addstrAlt(CONST_chase021, gamelog);
			gamelog.newline(); //New line.
			break;
		case 1:
			addstrAlt(CONST_chase022, gamelog);
			gamelog.newline(); //New line.
			break;
		case 2:
			addstrAlt(CONST_chase023, gamelog);
			gamelog.newline(); //New line.
			break;
		case 3:
			addstrAlt(CONST_chase024, gamelog);
			gamelog.newline(); //New line.
		}
		pressAnyKey();
	}
	for (int e = 0; e < ENCMAX; e++)
	{
		if (!encounter[e].exists) continue;
		int chaser = encounter[e].attribute_roll(ATTRIBUTE_AGILITY) +
			encounter[e].attribute_roll(ATTRIBUTE_HEALTH);
		//healthmodroll(chaser,encounter[e]);
		if (theirbest < chaser) theirbest = chaser;
		if (theirworst > chaser) theirworst = chaser;
		if (encounter[e].type == CREATURE_TANK && LCSrandom(10))
		{
			clearmessagearea();
			set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, encounter[e].name, gamelog);
			addstrAlt(singleSpace, gamelog);
			addstrAlt(pickrandom(car_plows_through), gamelog);
			pressAnyKey();
		}
		else if (chaser < yourworst)
		{
			clearmessagearea();
			set_color_easy(CYAN_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, encounter[e].name, gamelog);
			if (encounter[e].type == CREATURE_TANK)
			{
				addstrAlt(CONST_chase025, gamelog);
				gamelog.newline(); //New line.
			}
			else
			{
				addstrAlt(CONST_chase026, gamelog);
				gamelog.newline(); //Another new line.
			}
			delenc(e--, 0);
			printchaseencounter();
			pressAnyKey();
		}
		else
		{
			clearmessagearea();
			set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, encounter[e].name, gamelog);
			addstrAlt(CONST_chase048, gamelog);
			gamelog.newline(); //New line.
			pressAnyKey();
		}
	}
	//This last loop can be used to have fast people in
	//your squad escape one by one just as the enemy
	//falls behind one by one
	int othersleft = 0;
	for (int p = 5; p >= 0; p--)
	{
		if (!encounter[0].exists) break;
		if (activesquad->squad[p] == NULL) continue;
		if (activesquad->squad[p]->alive)
		{
			if (yourspeed[p] > theirbest)
			{
				if (p == 0 && othersleft == 0) break;
				clearmessagearea();
				set_color_easy(CYAN_ON_BLACK_BRIGHT);
				mvaddstrAlt(16, 1, activesquad->squad[p]->name, gamelog);
				addstrAlt(CONST_chase028, gamelog);
				gamelog.newline(); //New line.
				pressAnyKey();
				//Unload hauled hostage or body when they get back to the safehouse
				if (activesquad->squad[p]->prisoner != NULL)
				{
					//If this is an LCS member or corpse being hauled (marked as in the squad)
					if (activesquad->squad[p]->prisoner->squadid != -1)
					{
						//Take them out of the squad
						removesquadinfo(*activesquad->squad[p]->prisoner);
						//Set base and current location to squad's safehouse
						activesquad->squad[p]->prisoner->location = activesquad->squad[p]->base;
						activesquad->squad[p]->prisoner->base = activesquad->squad[p]->base;
					}
					else //A kidnapped conservative
					{
						//Convert them into a prisoner
						kidnaptransfer(*activesquad->squad[p]->prisoner);
						delete activesquad->squad[p]->prisoner;
					}
					activesquad->squad[p]->prisoner = NULL;
				}
				removesquadinfo(*activesquad->squad[p]);
				printparty();
			}
			else if (yourspeed[p] < theirbest - 10)
			{
				clearmessagearea();
				set_color_easy(CYAN_ON_BLACK_BRIGHT);
				mvaddstrAlt(16, 1, activesquad->squad[p]->name, gamelog);
				switch (encounter[0].type)
				{
				case CREATURE_COP:
					addstrAlt(isSeized, gamelog);
					if (lawList[LAW_POLICEBEHAVIOR] >= ALIGN_LIBERAL)
					{
						addstrAlt(CONST_chase029, gamelog);
						gamelog.newline(); //...Newline.
					}
					else
					{
						if (activesquad->squad[p]->blood <= 10)
						{
							addstrAlt(CONST_chase030, gamelog);
							gamelog.newline(); //Not another newline!
						}
						else
						{
							addstrAlt(CONST_chase031, gamelog);
							gamelog.newline(); //Yet another newline...
						}
						activesquad->squad[p]->blood -= 10;
					}
					break;
				case CREATURE_DEATHSQUAD:
					addstrAlt(isSeized, gamelog);
					addstrAlt(CONST_chase032, gamelog);
					gamelog.newline(); //New line.
					activesquad->squad[p]->blood = 0;
					break;
				case CREATURE_TANK:
					addstrAlt(CONST_chase033, gamelog);
					gamelog.newline(); //New line.
					activesquad->squad[p]->blood = 0;
					break;
				default:
					addstrAlt(isSeized, gamelog);
					if (activesquad->squad[p]->blood <= 60)
					{
						addstrAlt(CONST_chase034, gamelog);
						gamelog.newline(); //New line.
					}
					else
					{
						addstrAlt(CONST_chase035, gamelog);
						gamelog.newline(); //New line.
					}
					activesquad->squad[p]->blood -= 60;
					break;
				}
				if (activesquad->squad[p]->blood <= 0)
					activesquad->squad[p]->die();
				capturecreature(*activesquad->squad[p]);
				for (int i = p + 1, j = p; i < 6; i++, j++)
					activesquad->squad[j] = activesquad->squad[i];
				activesquad->squad[5] = NULL;
				// Death squads don't mess around, and don't fall behind when executing your people
				// Tanks don't stop either.
				if (encounter[0].type != CREATURE_DEATHSQUAD &&
					encounter[0].type != CREATURE_TANK)delenc(0, 0);
				printparty();
				printchaseencounter();
				pressAnyKey();
			}
			else othersleft++;
		}
	}
}
bool footchase()
{
	const string CONST_chase040 = "G - Give Up";
	const string CONST_chase036 = "As you exit the site, you notice that you are ";
	extern chaseseqst chaseseq;
	extern MusicClass music;
	extern short mode;
	extern char foughtthisround;
	extern squadst *activesquad;
	extern short party_status;
	extern newsstoryst *sitestory;
	extern Log gamelog;
	extern Creature encounter[ENCMAX];
	//NOTE: THIS FUNCTION RETURNS 1 IF ANYBODY ESCAPES
	//IT SHOULD NOT DELETE SQUADS OR CREATURES
	//SQUADS MAY BE FICTITIOUS AND BOTH WILL BE DELETED LATER ANYWAY
	reloadparty();
	//NUKE ALL CARS
	delete_and_clear(chaseseq.enemycar);
	//BAIL IF NO CHASERS
	int chasenum = 0;
	for (int e = 0; e < ENCMAX; e++)
	{
		if (encounter[e].exists) chasenum++;
		encounter[e].carid = -1;
	}
	if (chasenum == 0) return 1;
	mode = GAMEMODE_CHASEFOOT;
	music.play(MUSIC_FOOTCHASE);
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(0, 0, CONST_chase036, gamelog);
	moveAlt(1, 0);
	gamelog.newline(); //New line. I'd rather it be continuous but whatever.
	addstrAlt(beingFollowedBySwine, gamelog);
	gamelog.newline(); //New line.
	pressAnyKey();
	while (true)
	{
		int partysize = squadsize(activesquad), partyalive = squadalive(activesquad), encsize = 0;
		for (int e = 0; e < ENCMAX; e++) if (encounter[e].exists) encsize++;
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(0, 0, LocationsPool::getInstance().getLocationName(chaseseq.location));
		//PRINT PARTY
		if (partyalive == 0) party_status = -1;
		printparty();
		if (partyalive > 0)
		{
			//PRINT DRIVING SITUATION AND INSTRUCTIONS
			if (partysize > 1) set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(9, 40, change_squad_order);
			if (partysize > 0 && (party_status == -1 || partysize > 1))set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(10, 40, check_status_of_squad_liberal);
			if (party_status != -1)set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(11, 40, show_squad_liberal_status);
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(9, 1, CONST_chase074);
			mvaddstrAlt(10, 1, CONST_chase075);
			mvaddstrAlt(11, 1, CONST_chase076);
			if (chaseseq.canpullover)
			{
				mvaddstrAlt(12, 1, CONST_chase040);
			}
		}
		else
		{
			//DESTROY ALL CARS BROUGHT ALONG WITH PARTY
			deleteVehicles(chaseseq.friendcar);
			for (int p = 0; p < 6; p++)
			{
				if (activesquad->squad[p] == NULL)continue;
				activesquad->squad[p]->die();
				activesquad->squad[p]->location = -1;
				activesquad->squad[p] = NULL;
			}
			endcheck(END_BUT_NOT_END); // play the right music in case we're dead
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(9, 1, CONST_chase079);
		}
		//PRINT ENEMIES
		printchaseencounter();
		// check if we fought the previous loop; if so, add a blank gamelog line
		if (foughtthisround)gamelog.newline();
		foughtthisround = 0;
		int c = getkeyAlt();
		if (partyalive == 0 && c == 'c')
		{
			if (!endcheck())
			{
				mode = GAMEMODE_BASE;
				gamelog.nextMessage(); //Output this message, preparing for next.
				return 0;
			}
		}
		if (partyalive > 0)
		{
			if (c == 'o'&&partysize > 1) orderparty();
			if (c == '0') party_status = -1;
			if (c >= '1'&&c <= '6')
			{
				if (activesquad->squad[c - '1'] != NULL)
				{
					if (party_status == c - '1') fullstatus(party_status);
					else party_status = c - '1';
				}
			}
			if (c == 'g')
			{
				if (chaseseq.canpullover)
				{
					chase_giveup();
					mode = GAMEMODE_BASE;
					gamelog.nextMessage(); //Get ready for the next message.
					return 0;
				}
			}
			if (c == 'd')
			{
				if (encounter[0].exists&&
					encounter[0].type == CREATURE_COP)
				{
					sitestory->crime.push_back(CRIME_FOOTCHASE);
					criminalizeparty(LAWFLAG_RESIST);
				}
				evasiverun();
				enemyattack();
				creatureadvance();
			}
			if (c == 'f')
			{
				if (encounter[0].exists&&
					encounter[0].type == CREATURE_COP)
				{
					sitestory->crime.push_back(CRIME_FOOTCHASE);
					criminalizeparty(LAWFLAG_RESIST);
				}
				youattack();
				enemyattack();
				creatureadvance();
			}
			if (c == 'e') equip(activesquad->loot, -1);
			//HAVE YOU LOST ALL OF THEM?
			//THEN LEAVE
			partysize = squadsize(activesquad), partyalive = squadalive(activesquad);
			int baddiecount = 0;
			for (int e = 0; e < ENCMAX; e++)
			{
				if (encounter[e].enemy() &&
					encounter[e].alive&&
					encounter[e].exists)baddiecount++;
			}
			if (partyalive > 0 && baddiecount == 0)
			{
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				clearmessagearea();
				mvaddstrAlt(16, 1, lostThem, gamelog);
				gamelog.newline(); //New line.
				pressAnyKey();
				CreaturePool::getInstance().stopAllBleeding();
				mode = GAMEMODE_BASE;
				gamelog.newline();
				return 1;
			}
		}
	}
	mode = GAMEMODE_BASE;
	//All possible exits of the chase should be covered by a nextMessage() call.
	gamelog.nextMessage();
	return 1;
}
int driveskill(Creature &cr, int v);
int driveskill(Creature &cr, Vehicle &v)
{
	int driveskill = cr.skill_roll(PSEUDOSKILL_ESCAPEDRIVE);
	healthmodroll(driveskill, cr);
	if (driveskill < 0) driveskill = 0;
	driveskill *= static_cast<int>(cr.blood / 50.0);
	return driveskill;
}
void evasivedrive()
{
	const string CONST_chase047 = " brakes hard and nearly crashes!";
	const string CONST_chase046 = " backs off for safety.";
	const string CONST_chase045 = " skids out!";
	const string CONST_chase044 = " falls behind!";
	const string CONST_chase043 = "You make obscene gestures at the pursuers!";
	const string CONST_chase042 = "You boldly weave through oncoming traffic!";
	extern chaseseqst chaseseq;
	extern squadst *activesquad;
	extern short fieldskillrate;
	extern Log gamelog;
	extern Creature encounter[ENCMAX];
	vector<long> yourrolls, theirrolls, theirrolls_id, theirrolls_drv;
	long yourworst = 10000;
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] == NULL) continue;
		if (activesquad->squad[p]->alive&&
			activesquad->squad[p]->is_driver)
		{
			int v = id_getcar(activesquad->squad[p]->carid);
			yourrolls.push_back(driveskill(*activesquad->squad[p], v) + LCSrandom(DRIVING_RANDOMNESS));
			switch (fieldskillrate)
			{
			case FIELDSKILLRATE_FAST:
				activesquad->squad[p]->train(SKILL_DRIVING, LCSrandom(20)); break;
			case FIELDSKILLRATE_CLASSIC:
				activesquad->squad[p]->train(SKILL_DRIVING, LCSrandom(20)); break;
			case FIELDSKILLRATE_HARD:
				activesquad->squad[p]->train(SKILL_DRIVING, LCSrandom(max(1, 20 - activesquad->squad[p]->get_skill(SKILL_DRIVING)))); break;
			}
			if (yourworst > yourrolls.back()) yourworst = yourrolls.back();
		}
	}
	if (!len(yourrolls)) yourrolls.push_back(0); //error -- and for this you get a 0
	for (int e = 0; e < ENCMAX; e++)
	{
		if (encounter[e].carid != -1 &&
			encounter[e].enemy() &&
			encounter[e].alive&&
			encounter[e].exists&&
			encounter[e].is_driver)
		{
			for (int v = 0; v < len(chaseseq.enemycar); v++)
			{
				if (chaseseq.enemycar[v]->id() == encounter[e].carid)
				{
					theirrolls.push_back(driveskill(encounter[e], *chaseseq.enemycar[v]) + LCSrandom(DRIVING_RANDOMNESS));
					theirrolls_id.push_back(encounter[e].carid);
					theirrolls_drv.push_back(encounter[e].id);
				}
			}
		}
		else if (encounter[e].carid == -1) encounter[e].exists = false;
	}
	clearmessagearea();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	moveAlt(16, 1);
	switch (LCSrandom(car_speed.size() + 1))
	{
	case 0:
		if (yourworst > 15)
			addstrAlt(CONST_chase042, gamelog);
		else
			addstrAlt(CONST_chase043, gamelog);
		gamelog.newline(); //new line.
		break;
	default:
		addstrAlt(pickrandom(car_speed), gamelog);
		gamelog.newline(); //new line.
		break;
	}
	pressAnyKey();
	for (int i = 0; i < len(theirrolls); i++)
	{
		int cnt = pickrandom(yourrolls);
		if (theirrolls[i] < cnt)
		{
			clearmessagearea();
			set_color_easy(CYAN_ON_BLACK_BRIGHT);
			moveAlt(16, 1);
			for (int e = 0; e < ENCMAX; e++)
			{
				if (encounter[e].id == theirrolls_drv[i])
				{
					addstrAlt(encounter[e].name, gamelog);
					break;
				}
			}
			switch (LCSrandom(cnt / 5))
			{
			default:
				addstrAlt(CONST_chase044, gamelog);
				gamelog.newline(); //New line.
				break;
			case 1:
				addstrAlt(CONST_chase045, gamelog);
				gamelog.newline(); //New line.
				break;
			case 2:
				addstrAlt(CONST_chase046, gamelog);
				gamelog.newline(); //New line.
				break;
			case 3:
				addstrAlt(CONST_chase047, gamelog);
				gamelog.newline(); //New line.
				break;
			}
			for (int e = 0; e < ENCMAX; e++)
			{
				if (encounter[e].carid == theirrolls_id[i])
				{
					for (int e2 = e; e2 < ENCMAX - 1; e2++) encounter[e2] = encounter[e2 + 1];
					encounter[ENCMAX - 1].exists = 0;
					encounter[ENCMAX - 1].carid = -1;
					e--;
				}
			}
			for (int v = 0; v < len(chaseseq.enemycar); v++)
			{
				if (chaseseq.enemycar[v]->id() == theirrolls_id[i])
				{
					delete_and_remove(chaseseq.enemycar, v);
					break;
				}
			}
			printchaseencounter();
			pressAnyKey();
		}
		else
		{
			clearmessagearea();
			set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			moveAlt(16, 1);
			for (int e = 0; e < ENCMAX; e++)
			{
				if (encounter[e].id == theirrolls_drv[i])
				{
					addstrAlt(encounter[e].name, gamelog);
					break;
				}
			}
			addstrAlt(CONST_chase048, gamelog);
			gamelog.newline(); //Blarg. Newline.
			pressAnyKey();
		}
	}
}
void crashfriendlycar(int v)
{
	const string CONST_chase058 = " crawls free of the car, shivering with pain.";
	const string CONST_chase057 = " gasps in pain, but lives, for now.";
	const string CONST_chase056 = " feet.";
	const string CONST_chase055 = " wheelchair.";
	const string CONST_chase054 = " and struggles to ";
	const string CONST_chase053 = "car frame";
	const string CONST_chase052 = " grips the ";
	const string CONST_chase051 = " seat, out cold, and dies.";
	const string CONST_chase050 = " slumps in ";
	const string CONST_chase049 = "Your ";
	extern int stat_dead;
	extern chaseseqst chaseseq;
	extern squadst *activesquad;
	extern Log gamelog;
	//CRASH CAR
	clearmessagearea();
	set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
	mvaddstrAlt(16, 1, CONST_chase049, gamelog);
	addstrAlt(chaseseq.friendcar[v]->fullname(), gamelog);
	addstrAlt(pickrandom(car_crash_modes), gamelog);
	gamelog.newline(); //New line it.
	printparty();
	pressAnyKey();
	int victimsum = 0;
	for (int p = 0; p < 6; p++)
	{
		if (!activesquad->squad[p]) continue;
		if (activesquad->squad[p]->carid == chaseseq.friendcar[v]->id())
		{
			// Inflict injuries on Liberals
			for (int w = 0; w < BODYPARTNUM; w++)
				// If limb is intact
				if (!(activesquad->squad[p]->wound[w] & (WOUND_CLEANOFF | WOUND_NASTYOFF)))
				{
					// Inflict injuries
					if (LCSrandom(2))
					{
						activesquad->squad[p]->wound[w] |= (WOUND_TORN | WOUND_BLEEDING);
						activesquad->squad[p]->blood -= 1 + LCSrandom(25);
					}
					if (!LCSrandom(3))
					{
						activesquad->squad[p]->wound[w] |= (WOUND_CUT | WOUND_BLEEDING);
						activesquad->squad[p]->blood -= 1 + LCSrandom(25);
					}
					if (LCSrandom(2) || activesquad->squad[p]->wound[w] == 0)
					{
						activesquad->squad[p]->wound[w] |= WOUND_BRUISED;
						activesquad->squad[p]->blood -= 1 + LCSrandom(10);
					}
				}
			// Kill off hostages
			if (activesquad->squad[p]->prisoner)
			{
				// Instant death
				if (activesquad->squad[p]->prisoner->alive)
				{
					clearmessagearea();
					set_color_easy(RED_ON_BLACK_BRIGHT);
					mvaddstrAlt(16, 1, activesquad->squad[p]->prisoner->name, gamelog);
					addstrAlt(pickrandom(car_crash_fatalities), gamelog);
					gamelog.newline(); //New line.
					printparty();
					pressAnyKey();
				}
				activesquad->squad[p]->prisoner->die();
				activesquad->squad[p]->prisoner->location = -1;
				victimsum++;
				// Record death if living Liberal is hauled
				if (activesquad->squad[p]->prisoner->squadid != -1)
				{
					if (activesquad->squad[p]->prisoner->alive&&
						activesquad->squad[p]->prisoner->align == 1)stat_dead++;
					activesquad->squad[p]->prisoner->die();
					activesquad->squad[p]->prisoner->location = -1;
				}
				// Otherwise just kill them off and be done with it
				else delete activesquad->squad[p]->prisoner;
				activesquad->squad[p]->prisoner = NULL;
			}
			// Handle squad member death
			if (activesquad->squad[p]->blood <= 0)
			{
				// Inform the player
				clearmessagearea();
				set_color_easy(RED_ON_BLACK_BRIGHT);
				mvaddstrAlt(16, 1, activesquad->squad[p]->name, gamelog);
				switch (LCSrandom(die_in_car.size() + 1))
				{
					//TODO IsaacG Migrate Strings
				case 0:addstrAlt(CONST_chase050, gamelog);
					addstrAlt(activesquad->squad[p]->hisher(), gamelog);
					addstrAlt(CONST_chase051, gamelog); break;
				default:
					addstrAlt(pickrandom(die_in_car), gamelog);
					break;
				}
				gamelog.newline(); //New line.
				printparty();
				pressAnyKey();
				// Mark as dead
				activesquad->squad[p]->die();
				activesquad->squad[p]->location = -1;
				victimsum++;
				// Account for deaths for high score
				if (activesquad->squad[p]->align == ALIGN_LIBERAL)stat_dead++;
				// Remove dead Liberal from squad
				activesquad->squad[p] = NULL;
			}
			else
			{
				// Inform the player of character survival
				clearmessagearea();
				set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				mvaddstrAlt(16, 1, activesquad->squad[p]->name, gamelog);
				switch (LCSrandom(3))
				{
				case 0:
					addstrAlt(CONST_chase052, gamelog);
					if (activesquad->squad[p]->is_armed())
						addstrAlt(activesquad->squad[p]->get_weapon().get_shortname(), gamelog);
					else addstrAlt(CONST_chase053, gamelog);
					addstrAlt(CONST_chase054, gamelog);
					addstrAlt(activesquad->squad[p]->hisher(), gamelog);
					if (activesquad->squad[p]->flag & CREATUREFLAG_WHEELCHAIR)
						addstrAlt(CONST_chase055, gamelog);
					else addstrAlt(CONST_chase056, gamelog);
					break;
				case 1:
					addstrAlt(CONST_chase057, gamelog);
					break;
				case 2:addstrAlt(CONST_chase058, gamelog);
					activesquad->squad[p]->drop_weapon(NULL);
					break;
				}
				gamelog.newline(); //New line.
				printparty();
				pressAnyKey();
			}
		}
	}
	//CONSOLIDATE SQUAD
	for (int i = 0; i < 5; i++)
	{
		bool flipstart = 0;
		for (int pt = 0; pt < 6; pt++)
		{
			if (activesquad->squad[pt] == NULL && !flipstart)flipstart = 1;
			if (flipstart&&pt < 5)activesquad->squad[pt] = activesquad->squad[pt + 1];
		}
		if (flipstart)activesquad->squad[5] = NULL;
	}
	//GET RID OF CARS
	deleteVehicles(chaseseq.friendcar);
	for (int p = 0; p < 6; p++)
	{
		if (!activesquad->squad[p]) continue;
		activesquad->squad[p]->carid = -1;
	}
}
void crashenemycar(int v)
{
	const string CONST_chase063 = " hits a parked car and flips over.";
	const string CONST_chase062 = "The person inside is squashed into a cube.";
	const string CONST_chase061 = "Everyone inside is peeled off against the pavement.";
	const string CONST_chase060 = " spins out and crashes.";
	const string CONST_chase059 = " slams into a building.";
	extern chaseseqst chaseseq;
	extern Log gamelog;
	extern Creature encounter[ENCMAX];
	int victimsum = 0;
	for (int p = ENCMAX - 1; p >= 0; p--)
	{
		if (!encounter[p].exists) continue;
		if (encounter[p].carid == chaseseq.enemycar[v]->id())
		{
			victimsum++;
			delenc(p, 0);
		}
	}
	//CRASH CAR
	clearmessagearea();
	set_color_easy(CYAN_ON_BLACK_BRIGHT);
	mvaddstrAlt(16, 1, tag_The, gamelog);
	addstrAlt(chaseseq.enemycar[v]->fullname(), gamelog);
	switch (LCSrandom(3))
	{
	case 0:addstrAlt(CONST_chase059, gamelog); break;
	case 1:
		addstrAlt(CONST_chase060, gamelog);
		moveAlt(17, 1);
		if (victimsum > 1)addstrAlt(CONST_chase061, gamelog);
		else if (victimsum == 1)addstrAlt(CONST_chase062, gamelog);
		break;
	case 2:addstrAlt(CONST_chase063, gamelog); break;
	}
	gamelog.newline(); //New line.
	delete_and_remove(chaseseq.enemycar, v);
	printchaseencounter();
	pressAnyKey();
}
bool drivingupdate(short &obstacle)
{
	const string CONST_chase064 = " takes over the wheel.";
	extern chaseseqst chaseseq;
	extern squadst *activesquad;
	extern newsstoryst *sitestory;
	extern Log gamelog;
	extern Creature encounter[ENCMAX];
	//CHECK TO SEE WHICH CARS ARE BEING DRIVEN
	vector<int> passenger;
	int driver;
	for (int v = len(chaseseq.friendcar) - 1; v >= 0; v--)
	{
		passenger.clear();
		driver = -1;
		for (int p = 0; p < 6; p++)
		{
			if (activesquad->squad[p] == NULL) continue;
			if (activesquad->squad[p]->carid == chaseseq.friendcar[v]->id())
			{
				if (activesquad->squad[p]->is_driver)
				{
					if (activesquad->squad[p]->canwalk()) driver = p;
					else activesquad->squad[p]->is_driver = 0;
				}
				passenger.push_back(p);
			}
		}
		if (len(passenger) && driver == -1)
		{
			//MAKE BEST DRIVING PASSENGER INTO A DRIVER
			vector<int> goodp;
			int max = 0;
			for (int p = 0; p < len(passenger); p++)
				if (driveskill(*activesquad->squad[passenger[p]], *chaseseq.friendcar[v]) > max&&activesquad->squad[passenger[p]]->canwalk())
					max = driveskill(*activesquad->squad[passenger[p]], *chaseseq.friendcar[v]);
			for (int p = 0; p < len(passenger); p++)
				if (driveskill(*activesquad->squad[passenger[p]], *chaseseq.friendcar[v]) == max && activesquad->squad[passenger[p]]->canwalk())
					goodp.push_back(passenger[p]);
			if (len(goodp))
			{
				int p = pickrandom(goodp);
				activesquad->squad[p]->is_driver = 1;
				driver = p;
				clearmessagearea();
				set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				mvaddstrAlt(16, 1, activesquad->squad[p]->name, gamelog);
				addstrAlt(CONST_chase064, gamelog);
				gamelog.newline(); //New line.
				printparty();
				pressAnyKey();
			}
		}
		if (driver == -1)
		{
			crashfriendlycar(v);
			sitestory->crime.push_back(CRIME_CARCHASE);
			return 1;
		}
	}
	for (int v = len(chaseseq.enemycar) - 1; v >= 0; v--)
	{
		passenger.clear();
		driver = -1;
		for (int p = 0; p < ENCMAX; p++)
		{
			if (!encounter[p].exists) continue;
			if (encounter[p].carid == chaseseq.enemycar[v]->id())
			{
				if (encounter[p].is_driver)
				{
					if (encounter[p].canwalk()) driver = p;
					else encounter[p].is_driver = 0;
				}
				passenger.push_back(p);
			}
		}
		// Enemies don't take over the wheel when driver incapacitated
		if (driver == -1)
		{
			crashenemycar(v);
			sitestory->crime.push_back(CRIME_CARCHASE);
		}
	}
	//SET UP NEXT OBSTACLE
	if (!LCSrandom(3)) obstacle = LCSrandom(CARCHASE_OBSTACLENUM);
	else obstacle = -1;
	return 0;
}
bool dodgedrive()
{
	const string CONST_chase065 = "You swerve to avoid the obstacle!";
	extern chaseseqst chaseseq;
	extern squadst *activesquad;
	extern newsstoryst *sitestory;
	extern Log gamelog;
	extern Creature encounter[ENCMAX];
	clearmessagearea();
	set_color_easy(YELLOW_ON_BLACK_BRIGHT);
	mvaddstrAlt(16, 1, CONST_chase065, gamelog);
	gamelog.newline(); //New line.
	pressAnyKey();
	int driver;
	for (int v = len(chaseseq.friendcar) - 1; v >= 0; v--)
	{
		driver = -1;
		for (int p = 0; p < 6; p++)
		{
			if (!activesquad->squad[p]) continue;
			if (activesquad->squad[p]->carid == chaseseq.friendcar[v]->id())
			{
				if (activesquad->squad[p]->is_driver)
				{
					driver = p;
					break;
				}
			}
		}
		if (driver != -1)
		{
			if (!activesquad->squad[driver]->skill_check(PSEUDOSKILL_ESCAPEDRIVE, DIFFICULTY_EASY))
			{
				crashfriendlycar(v);
				sitestory->crime.push_back(CRIME_CARCHASE);
				return 1;
			}
		}
	}
	for (int v = len(chaseseq.enemycar) - 1; v >= 0; v--)
	{
		driver = -1;
		for (int p = 0; p < ENCMAX; p++)
		{
			if (!encounter[p].exists) continue;
			if (encounter[p].carid == chaseseq.enemycar[v]->id())
			{
				if (encounter[p].is_driver)
				{
					driver = p;
					break;
				}
			}
		}
		if (driver != -1)
			if (!encounter[driver].skill_check(PSEUDOSKILL_ESCAPEDRIVE, DIFFICULTY_EASY))
			{
				crashenemycar(v);
				sitestory->crime.push_back(CRIME_CARCHASE);
			}
	}
	return 0;
}
bool obstacledrive(short obstacle, char choice)
{
	const string CONST_chase072 = "Both sides refrain from endangering the child...";
	const string CONST_chase071 = "The Conservative bastards unleash a hail of gunfire!";
	const string CONST_chase070 = "You slow down and carefully avoid the kid.";
	const string CONST_chase069 = "The fruit seller is squashed!";
	const string CONST_chase068 = "Fruit smashes all over the windshield!";
	const string CONST_chase067 = "You slow down, and carefully evade the truck.";
	const string CONST_chase066 = "You slow down, and turn the corner.";
	extern Log gamelog;
	switch (obstacle)
	{
	case CARCHASE_OBSTACLE_CROSSTRAFFIC:
		if (choice == 0)
		{
			if (dodgedrive()) return 1;
		}
		else if (choice == 1)
		{
			clearmessagearea();
			set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_chase066, gamelog);
			gamelog.newline(); //New line.
			pressAnyKey();
			if (!LCSrandom(3))
			{
				set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				mvaddstrAlt(17, 1, hereTheyCome, gamelog);
				gamelog.newline(); //New line.
				pressAnyKey();
				enemyattack();
				youattack();
			}
		}
		break;
	case CARCHASE_OBSTACLE_TRUCKPULLSOUT:
		if (choice == 0)
		{
			if (dodgedrive()) return 1;
		}
		else if (choice == 1)
		{
			clearmessagearea();
			set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_chase067, gamelog);
			gamelog.newline(); //New line.
			pressAnyKey();
			if (!LCSrandom(3))
			{
				set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				mvaddstrAlt(17, 1, hereTheyCome, gamelog);
				gamelog.newline(); //New line.
				pressAnyKey();
				enemyattack();
				youattack();
			}
		}
		break;
	case CARCHASE_OBSTACLE_FRUITSTAND:
		if (choice == 0)
		{
			if (dodgedrive()) return 1;
		}
		else if (choice == 1)
		{
			clearmessagearea();
			set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_chase068, gamelog);
			gamelog.newline(); //New line.
			pressAnyKey();
			if (!LCSrandom(5))
			{
				set_color_easy(RED_ON_BLACK_BRIGHT);
				mvaddstrAlt(17, 1, CONST_chase069, gamelog);
				gamelog.newline(); //All this logging and lining...
				pressAnyKey();
				criminalizeparty(LAWFLAG_MURDER);
			}
		}
		break;
	case CARCHASE_OBSTACLE_CHILD:
		if (choice == 0)
		{
			if (dodgedrive()) return 1;
		}
		else if (choice == 1)
		{
			clearmessagearea();
			set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_chase070, gamelog);
			gamelog.newline(); //New line.
			pressAnyKey();
			if (!LCSrandom(3))
			{
				set_color_easy(RED_ON_BLACK_BRIGHT);
				mvaddstrAlt(17, 1, CONST_chase071, gamelog);
				gamelog.newline(); //New line.
				pressAnyKey();
				enemyattack();
				youattack();
			}
			else
			{
				set_color_easy(GREEN_ON_BLACK_BRIGHT);
				mvaddstrAlt(17, 1, CONST_chase072, gamelog);
				gamelog.newline(); //New line.
				pressAnyKey();
			}
		}
		break;
	}
	return 0;
}
void addCreatueVehiclesToCollection(Creature *cr[6], vector<Vehicle *> &veh);
bool chasesequence()
{
	const string CONST_chase086 = "attacks";
	const string CONST_chase085 = "  Found encounter driver %s in carID %d";
	const string CONST_chase084 = "  Found LCS driver %s in carID %d";
	const string CONST_chase083 = "Searching for %s's driver.  ";
	const string CONST_chase082 = "  Found enemycar with ID %d at index %d";
	const string CONST_chase081 = "  Found friendcar with ID %d at index %d";
	const string CONST_chase080 = "Searching for chase vehicle for ";
	const string CONST_chase078 = "P - Pull over";
	const string CONST_chase077 = "B - Bail out and run!";
	const string CONST_chase073 = "As you pull away from the site, you notice that you are ";
	extern MusicClass music;
	extern short mode;
	extern chaseseqst chaseseq;
	extern squadst *activesquad;
	extern short party_status;
	extern newsstoryst *sitestory;
	extern Log gamelog;
	extern Creature encounter[ENCMAX];
	int chasenum = 0;
	reloadparty();
	//NOTE: THIS FUNCTION RETURNS 1 IF ANYBODY ESCAPES
	//IT CAN DELETE CREATURES AND VEHICLES, BUT SHOULD NOT DELETE SQUADS
	//AS SQUADS MAY BE FICTITIOUS AND WILL BE DELETED LATER ANYWAY
	//BAIL IF NO CHASERS
	for (int e = 0; e < ENCMAX; e++) if (encounter[e].exists) chasenum++;
	if (!chasenum)
	{
		gamelog.newline();
		return 1;
	}
	chaseseq.friendcar.clear();
	addCreatueVehiclesToCollection(activesquad->squad, chaseseq.friendcar);
	mode = GAMEMODE_CHASECAR;
	music.play(MUSIC_CARCHASE);
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(0, 0, CONST_chase073, gamelog);
	mvaddstrAlt(1, 0, beingFollowedBySwine, gamelog);
	gamelog.newline(); //New line.
	pressAnyKey();
	if (LocationsPool::getInstance().getLocationParent(chaseseq.location) != -1)
		chaseseq.location = LocationsPool::getInstance().getLocationParent(chaseseq.location);
	short obstacle = -1;
	while (true)
	{
		int partysize = squadsize(activesquad), partyalive = squadalive(activesquad), encsize = 0;
		for (int e = 0; e < ENCMAX; e++) if (encounter[e].exists) encsize++;
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(0, 0, LocationsPool::getInstance().getLocationName(chaseseq.location));
		//PRINT PARTY
		if (partyalive == 0) party_status = -1;
		printparty();
		if (partyalive > 0)
		{
			//PRINT DRIVING SITUATION AND INSTRUCTIONS
			if (partysize > 1)set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(9, 40, change_squad_order);
			if (partysize > 0 && (party_status == -1 || partysize > 1))set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(10, 40, check_status_of_squad_liberal);
			if (party_status != -1)set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(11, 40, show_squad_liberal_status);
			if (obstacle == -1)
			{
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(9, 1, CONST_chase074);
				mvaddstrAlt(10, 1, CONST_chase075);
				mvaddstrAlt(11, 1, CONST_chase076);
			}
			else
			{
				set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
				mvaddstrAlt(9, 1, carchaseObstacles[obstacle][0]);
				gamelog.newline();
				mvaddstrAlt(10, 1, carchaseObstacles[obstacle][1]);
				mvaddstrAlt(11, 1, carchaseObstacles[obstacle][2]);
			}
			mvaddstrAlt(12, 1, CONST_chase077);
			if (chaseseq.canpullover)
			{
				mvaddstrAlt(13, 1, CONST_chase078);
			}
		}
		else
		{
			//DESTROY ALL CARS BROUGHT ALONG WITH PARTY
			deleteVehicles(chaseseq.friendcar);
			for (int p = 0; p < 6; p++)
			{
				if (activesquad->squad[p] == NULL) continue;
				activesquad->squad[p]->die();
				activesquad->squad[p]->location = -1;
				activesquad->squad[p] = NULL;
			}
			endcheck(END_BUT_NOT_END); // play the right music in case we're dead
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(9, 1, CONST_chase079);
		}
		//PRINT ENEMIES
		printchaseencounter();
		int c = getkeyAlt();
		if (partyalive == 0 && c == 'c')
		{
			if (!endcheck())
			{
				mode = GAMEMODE_BASE;
				gamelog.nextMessage(); //Next message.
				return 0;
			}
		}
		if (partyalive > 0)
		{
			if (c == 'o'&&partysize > 1)orderparty();
			if (c == '0')party_status = -1;
			if (c >= '1'&&c <= '6')
			{
				if (activesquad->squad[c - '1'] != NULL)
				{
					if (party_status == c - '1') fullstatus(party_status);
					else party_status = c - '1';
				}
			}
			if (c == 'b')
			{
				deleteVehicles(chaseseq.friendcar);
				for (int p = 0; p < 6; p++)
				{
					if (activesquad->squad[p] == NULL) continue;
					activesquad->squad[p]->carid = -1;
				}
				return footchase();
			}
			else if (c == 'p')
			{
				if (chaseseq.canpullover)
				{
					chase_giveup();
					mode = GAMEMODE_BASE;
					gamelog.nextMessage(); //Next message.
					return 0;
				}
			}
			else if (obstacle == -1)
			{
				if (c == 'd')
				{
					if (encounter[0].exists&&
						encounter[0].type == CREATURE_COP)
					{
						if (chaseseq.location) sitestory->crime.push_back(CRIME_CARCHASE);
						criminalizeparty(LAWFLAG_RESIST);
					}
					evasivedrive();
					enemyattack();
					youattack();
					creatureadvance();
					if (drivingupdate(obstacle))
					{
						partysize = squadsize(activesquad), partyalive = squadalive(activesquad);
						if (partyalive > 0) return footchase();
					}
				}
				if (c == 'f')
				{
					if (encounter[0].exists&&
						encounter[0].type == CREATURE_COP)
					{
						if (chaseseq.location) sitestory->crime.push_back(CRIME_CARCHASE);
						criminalizeparty(LAWFLAG_RESIST);
					}
					youattack();
					enemyattack();
					creatureadvance();
					if (drivingupdate(obstacle))
					{
						partysize = squadsize(activesquad), partyalive = squadalive(activesquad);
						if (partyalive > 0) return footchase();
					}
				}
				if (c == 'e') equip(activesquad->loot, -1);
			}
			else
			{
				switch (obstacle)
				{
				case CARCHASE_OBSTACLE_CHILD:
				case CARCHASE_OBSTACLE_CROSSTRAFFIC:
				case CARCHASE_OBSTACLE_TRUCKPULLSOUT:
				case CARCHASE_OBSTACLE_FRUITSTAND:
					if (c == 'd')
					{
						if (obstacledrive(obstacle, 0))
						{
							partysize = squadsize(activesquad), partyalive = squadalive(activesquad);
							if (partyalive > 0) return footchase();
						}
						creatureadvance();
						drivingupdate(obstacle);
					}
					if (c == 'f')
					{
						if (obstacledrive(obstacle, 1))
						{
							partysize = squadsize(activesquad), partyalive = squadalive(activesquad);
							if (partyalive > 0) return footchase();
						}
						creatureadvance();
						if (drivingupdate(obstacle))
						{
							partysize = squadsize(activesquad), partyalive = squadalive(activesquad);
							if (partyalive > 0) return footchase();
						}
					}
					break;
				}
			}
			//HAVE YOU LOST ALL OF THEM?
			//THEN LEAVE
			partysize = squadsize(activesquad), partyalive = squadalive(activesquad);
			int baddiecount = 0;
			for (int e = 0; e < ENCMAX; e++)
			{
				if (encounter[e].carid != -1 &&
					encounter[e].enemy() &&
					encounter[e].alive&&
					encounter[e].exists)baddiecount++;
			}
			if (partyalive > 0 && baddiecount == 0)
			{
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				clearmessagearea();
				mvaddstrAlt(16, 1, lostThem, gamelog);
				gamelog.newline(); //New line.
				pressAnyKey();
				CreaturePool::getInstance().stopAllBleeding();
				mode = GAMEMODE_BASE;
				//Make sure all possible exits of the chase have the nextMessage() call
				//to ensure that the gamelog is split properly into blocks.
				gamelog.nextMessage();
				return 1;
			}
		}
	}
	mode = GAMEMODE_BASE;
	//Make sure all possible exits of the chase have the nextMessage() call
	//to ensure that the gamelog is split properly into blocks.
	gamelog.nextMessage();
	return 1;
}
Vehicle* getChaseVehicle(const Creature &c)
{
	extern short mode;
	extern chaseseqst chaseseq;
	Vehicle* found = NULL;
	//addstrAlt(CONST_chase080, gamelog);
	//addstrAlt(c.name, gamelog);
	if (mode == GAMEMODE_CHASECAR && c.carid != -1)
	{
		for (int v2 = 0; v2 < len(chaseseq.friendcar); v2++)
			if (chaseseq.friendcar[v2]->id() == c.carid)
			{
				//addstr_fl(gamelog,CONST_chase081,c.carid, v2);
				found = chaseseq.friendcar[v2];
				break;
			}
		for (int v2 = 0; v2 < len(chaseseq.enemycar); v2++)
			if (chaseseq.enemycar[v2]->id() == c.carid)
			{
				//addstr_fl(gamelog,CONST_chase082,c.carid, v2);
				found = chaseseq.enemycar[v2];
				break;
			}
	}
	//gamelog.newline();
	return found;
}
Creature* getChaseDriver(const Creature &c)
{
	extern short mode;
	extern squadst *activesquad;
	extern Creature encounter[ENCMAX];
	Creature* found = NULL;
	if (mode == GAMEMODE_CHASECAR && c.carid != -1)
	{
		//addstr_fl(gamelog,CONST_chase083, c.name);
		int v = c.carid;
		// Check to see if the car we are in is being driven by an LCS member
		for (int p = 0; p < 6; p++)
		{
			if (activesquad->squad[p] == NULL) continue;
			if (activesquad->squad[p]->carid == v
				&& activesquad->squad[p]->is_driver)
			{
				//addstr_fl(gamelog,CONST_chase084,activesquad->squad[p]->name, v);
				found = activesquad->squad[p];
			}
		}
		// Check to see if the car we are in is being driven by an encounter creature.
		for (int p = 0; p < ENCMAX; p++)
		{
			if (!encounter[p].exists) continue;
			if (encounter[p].carid == v
				&& encounter[p].is_driver)
			{
				//addstr_fl(gamelog,CONST_chase085,encounter[p].name, v);
				found = &encounter[p];
			}
		}
	}
	//gamelog.newline();
	return found;
}

Vehicle* getVehicleOfThisType(int cartype);
void makechasers(long type, const long sitecriminality)
{
	const string CONST_chase094 = "STATIONWAGON";
	const string CONST_chase093 = "PICKUP";
	const string CONST_chase092 = "JEEP";
	const string CONST_chase091 = "SUV";
	const string CONST_chase090 = "AGENTCAR";
	const string CONST_chase088 = "HMMWV";
	extern char endgamestate;
	extern chaseseqst chaseseq;
	extern Creature encounter[ENCMAX];
	extern short lawList[LAWNUM];
	// 
	long sitecrime_chasers;
	if (sitecriminality > 10) {
		sitecrime_chasers = 0;
		long sitecrime_log = sitecriminality;
		while (sitecrime_log > 10) {
			sitecrime_log /= 2;
			sitecrime_chasers += 10;
		}
		sitecrime_chasers += sitecrime_log;
	}
	else {
		sitecrime_chasers = sitecriminality;
	}
	emptyEncounter();
	if (!sitecrime_chasers) return;
	//short encslot = 0;
	string cartype; //Temporary (transitionally) solution. -XML
	long pnum;
	chaseseq.canpullover = 0;
	// 50% of CCS harassing your teams once they reach the
	// CONST_chase086 stage (but not for activities, which are
	// law enforcement response specific)
	int crime_ratio;
	CreatureTypes chasing_enemy;
	int min_enemies;
	int max_enemies;
	if (type != -1 && (endgamestate == ENDGAME_CCS_SIEGES || endgamestate == ENDGAME_CCS_ATTACKS) && LCSrandom(2))
	{
		cartype = CONST_chase091; //A CCS property, not a vehicle property. Temporary solution -XML
		crime_ratio = 5;
		min_enemies = 1;
		max_enemies = 12;
		chasing_enemy = CREATURE_CCS_VIGILANTE;
	}
	else
	{
		switch (type)
		{
		case SITE_GOVERNMENT_ARMYBASE:
			cartype = CONST_chase088; //Site property? Temporary solution. -XML
			crime_ratio = 5;
			min_enemies = 3;
			max_enemies = 6;
			chasing_enemy = CREATURE_SOLDIER;
			break;
		case SITE_GOVERNMENT_WHITE_HOUSE:
			cartype = CONST_chase090; //Site property? Temporary solution. -XML
			crime_ratio = 5;
			min_enemies = 1;
			max_enemies = 6;
			chasing_enemy = CREATURE_SECRET_SERVICE;
			break;
		case SITE_GOVERNMENT_INTELLIGENCEHQ:
			cartype = CONST_chase090; //Site property? Temporary solution. -XML
			crime_ratio = 5;
			min_enemies = 1;
			max_enemies = 6;
			chasing_enemy = CREATURE_AGENT;
			break;
		case SITE_CORPORATE_HEADQUARTERS:
		case SITE_CORPORATE_HOUSE:
			if (LCSrandom(2))cartype = CONST_chase091; //Site property? Temporary solution. -XML
			else cartype = CONST_chase092; //Site property? Temporary solution. -XML
			crime_ratio = 5;
			min_enemies = 1;
			max_enemies = 6;
			chasing_enemy = CREATURE_MERC;
			break;
		case SITE_MEDIA_AMRADIO:
		case SITE_MEDIA_CABLENEWS:
			cartype = CONST_chase093; //Site property? Temporary solution. -XML
			crime_ratio = 3;
			min_enemies = 1;
			max_enemies = 18;
			chasing_enemy = CREATURE_HICK;
			break;
		case SITE_BUSINESS_CRACKHOUSE:
			cartype = CONST_chase094; //Site property? Temporary solution. -XML
			crime_ratio = 3;
			min_enemies = 1;
			max_enemies = 18;
			chasing_enemy = CREATURE_GANGMEMBER;
			break;
		default:
			chaseseq.canpullover = 1;
			cartype = tag_POLICECAR; //Police property? Temporary solution. -XML
			crime_ratio = 5;
			min_enemies = 1;
			max_enemies = 6;
			if (lawList[LAW_DEATHPENALTY] == -2 &&
				lawList[LAW_POLICEBEHAVIOR] == -2) {
				chasing_enemy = CREATURE_DEATHSQUAD;
				chaseseq.canpullover = 0;
			}
			else if (lawList[LAW_POLICEBEHAVIOR] <= -1)
			{
				chasing_enemy = CREATURE_GANGUNIT;
			}
			else
			{
				chasing_enemy = CREATURE_COP;
			}
			break;
		}
	}
	pnum = LCSrandom((sitecrime_chasers / crime_ratio) + 1) + min_enemies;
	if (pnum > max_enemies) pnum = max_enemies;
	for (int n = 0; n < pnum; n++) {
		makecreature(encounter[n], chasing_enemy);
	}
	for (int n = 0; n < pnum; n++) conservatise(encounter[n]);
	//ASSIGN CARS TO CREATURES
	int carnum;
	if (pnum <= 2) carnum = 1;
	else if (pnum <= 3) carnum = LCSrandom(2) + 1;
	else if (pnum <= 5) carnum = LCSrandom(2) + 2;
	else if (pnum <= 7) carnum = LCSrandom(2) + 3;
	else carnum = 4;
	for (int c = 0; c < carnum; c++)
	{
		Vehicle *v = getVehicleOfThisType(getvehicletype(cartype)); //If car type is unknown, due to change in xml file, the game will crash here. -XML
		chaseseq.enemycar.push_back(v);
		for (int n = 0; n < pnum; n++)
			if (encounter[n].carid == -1)
			{
				encounter[n].carid = v->id();
				encounter[n].is_driver = 1;
				break;
			}
	}
	long load[4] = { 0,0,0,0 };
	for (int n = 0; n < pnum; n++)
		if (encounter[n].carid == -1)
		{
			int v;
			do
			{
				v = LCSrandom(len(chaseseq.enemycar));
				encounter[n].carid = chaseseq.enemycar[v]->id();
				encounter[n].is_driver = 0;
			} while (load[v] >= 4);
			load[v]++;
		}
}
void removeCreatureFromSquad(Creature &cr, int oldsqid);
/* the next two functions force a chase sequence with a specific liberal */
bool footchase(Creature &cr)
{
	extern squadst *activesquad;
	extern short party_status;
	extern long cursquadid;
	long oldsqid = cr.squadid;
	Creature *crp = &cr;
	squadst *sq = new squadst;
	sq->squad[0] = &cr;
	sq->squad[0]->squadid = cursquadid; cursquadid++;
	cr.squadid = sq->squad[0]->squadid;
	cr.carid = -1;
	squadst *oact = activesquad;
	short ops = party_status;
	activesquad = sq;
	party_status = 0;
	bool ret = footchase();
	party_status = ops;
	delete sq;
	if (ret) cr.squadid = oldsqid;
	else if (oldsqid != -1)
	{
		removeCreatureFromSquad(*crp, oldsqid);
	}
	activesquad = oact;
	return ret;
}
bool chasesequence(Creature &cr, Vehicle &v)
{
	extern squadst *activesquad;
	extern short party_status;
	extern long cursquadid;
	extern Log gamelog;
	long oldsqid = cr.squadid;
	squadst *sq = new squadst;
	sq->squad[0] = &cr;
	sq->squad[0]->squadid = cursquadid;
	sq->id = cursquadid; cursquadid++;
	cr.carid = v.id();
	cr.is_driver = 1;
	squadst *oact = activesquad;
	short ops = party_status;
	activesquad = sq;
	party_status = 0;
	bool ret = chasesequence();
	party_status = ops;
	delete sq;
	if (ret)
	{
		cr.squadid = oldsqid;
		cr.carid = -1;
	}
	else if (oldsqid != -1)
	{
		removeCreatureFromSquad(cr, oldsqid);
	}
	activesquad = oact;
	gamelog.nextMessage(); //Next message.
	return ret;
}


const string CONST_clipB003 = ": ";
const string CONST_clip002 = "Unknown element for clip type ";

const string tag_ammo = "ammo";
const string tag_clip = "clip";
Clip::Clip(const ClipType& seed, int number) : Item(seed, number)
{ }
Clip::Clip(const std::string& inputXml) : Item(inputXml)
{
	/*CMarkup xml;
	xml.SetDoc(inputXml);
	xml.FindElem();
	xml.IntoElem();
	while(xml.FindElem())
	{
	std::string tag=xml.GetTagName();
	}*/
}
string Clip::showXml() const
{
	CMarkup xml;
	xml.AddElem(tag_clip);
	xml.IntoElem();
	addBaseValues(xml);
	return xml.GetDoc();
}
Clip* Clip::split(int number)
{
	if (number > number_) number = number_;
	Clip* newi = this->clone();
	newi->number_ = number;
	this->number_ -= number;
	return newi;
}
bool Clip::merge(Item& i)
{
	if (i.whatIsThis() == THIS_IS_CLIP && this->is_same_type(i))
	{
		this->increase_number(i.get_number());
		i.set_number(0);
		return true;
	}
	return false;
}
bool Clip::sort_compare_special(Item* other) const
{
	if (other)
	{
		int thisi = getcliptype(get_itemtypename());
		int otheri = getcliptype(other->get_itemtypename());
		if (thisi < otheri || otheri == -1) return false;
		else if (thisi > otheri&&otheri != -1) return true;
		else return false;
	}
	else return false;
}
string Clip::equip_title() const
{
	extern vector<ClipType *> cliptype;
	return cliptype[getcliptype(get_itemtypename())]->get_name();
}
const string& Clip::get_name() const
{
	extern vector<ClipType *> cliptype;
	return cliptype[getcliptype(get_itemtypename())]->get_name();
}
long Clip::get_fencevalue() const
{
	extern vector<ClipType *> cliptype;
	return cliptype[getcliptype(get_itemtypename())]->get_fencevalue();
}
int Clip::get_ammoamount() const
{
	extern vector<ClipType *> cliptype;
	return cliptype[getcliptype(get_itemtypename())]->get_ammoamount();
}
ClipType::ClipType(MCD_STR xmlstring) : ItemType(xmlstring), ammo_(1)
{
	CMarkup xml;
	xml.SetDoc(xmlstring);
	xml.FindElem();
	xml.IntoElem();
	while (xml.FindElem()) //Loop over all the elements inside the cliptype element.
	{
		std::string element = xml.GetTagName();
		if (element == tag_ammo)
			ammo_ = atoi(xml.GetData().c_str());
		/*else
		errorlog << CONST_clip002 << idname() << CONST_clipB003 << element << endl;*/
	}
}


// #include "../includes.h"
const string CONST_weapontypeB091 = "striking";
const string CONST_weapontype099 = "UNDEF";
const string CONST_weapontype098 = "INVALID SUBTYPE";
const string CONST_weapontype096 = "Unknown element for attack: ";
const string CONST_weapontype095 = "Unknown element for attack::fire: ";
const string CONST_weapontype094 = "Unknown element for attack::critical: ";
const string CONST_weapontype093 = "Invalid severtype for attack::critical::severtype: ";
const string CONST_weapontype092 = "Invalid boolean value for attack::damages_armor: ";
const string CONST_weapontype091 = "Invalid severtype for attack::severtype: ";
const string CONST_weapontype090 = "Invalid boolean value for attack::bleeding: ";
const string CONST_weapontype089 = "Invalid boolean value for attack::shoots: ";
const string CONST_weapontype088 = "Invalid boolean value for attack::burns: ";
const string CONST_weapontype087 = "Invalid boolean value for attack::cuts: ";
const string CONST_weapontype086 = "Invalid boolean value for attack::tears: ";
const string CONST_weapontype085 = "Invalid boolean value for attack::bruises: ";
const string CONST_weapontype084 = "Invalid skill name for attack::skill: ";
const string CONST_weapontype083 = "Invalid boolean value for attack::always_describe_hit: ";
const string CONST_weapontype082 = "Invalid boolean value for attack::thrown ";
const string CONST_weapontype081 = "Invalid boolean value for attack::ranged ";
const string CONST_weapontype080 = "assaults";
const string CONST_weapontype078 = ": ";
const string CONST_weapontype077 = "Unknown element for weapon type ";
const string CONST_weapontype076 = "::suspicious: ";
const string CONST_weapontype075 = "Invalid boolean value for weapon type ";
const string CONST_weapontype074 = "::auto_break_locks: ";
const string CONST_weapontype072 = "::graffiti: ";
const string CONST_weapontype070 = "::instrument: ";
const string CONST_weapontype068 = "::musical_attack: ";
const string CONST_weapontype066 = "::threatening: ";
const string CONST_weapontype064 = "::can_take_hostages: ";

const string tag_chance_causes_debris = "chance_causes_debris";
const string tag_chance = "chance";
const string tag_severtype = "severtype";
const string tag_fixed_damage = "fixed_damage";
const string tag_random_damage = "random_damage";
const string tag_hits_required = "hits_required";
const string tag_critical = "critical";
const string tag_no = "no";
const string tag_no_DR_for_limbs_chance = "no_damage_reduction_for_limbs_chance";
const string tag_armorpiercing = "armorpiercing";
const string tag_damages_armor = "damages_armor";
const string tag_bleeding = "bleeding";
const string tag_shoots = "shoots";
const string tag_burns = "burns";
const string tag_cuts = "cuts";
const string tag_tears = "tears";
const string tag_bruises = "bruises";
const string tag_strength = "strength";
const string tag_strength_max = "strength_max";
const string tag_strength_min = "strength_min";
const string tag_successive_attacks_difficulty = "successive_attacks_difficulty";
const string tag_number_attacks = "number_attacks";
const string tag_accuracy_bonus = "accuracy_bonus";
const string tag_hit_punctuation = "hit_punctuation";
const string tag_always_describe_hit = "always_describe_hit";
const string tag_hit_description = "hit_description";
const string tag_attack = "attack";
const string tag_attack_description = "attack_description";
const string tag_ammotype = "ammotype";
const string tag_can_backstab = "can_backstab";
const string tag_thrown = "thrown";
const string tag_ranged = "ranged";
const string tag_priority = "priority";
const string tag_size = "size";
const string tag_suspicious = "suspicious";
const string tag_auto_break_locks = "auto_break_locks";
const string tag_bashstrengthmod = "bashstrengthmod";
const string tag_legality = "legality";
const string tag_graffiti = "graffiti";
const string tag_instrument = "instrument";
const string tag_music = "music";
const string tag_musical_attack = "musical_attack";
const string tag_protects_against_kidnapping = "protects_against_kidnapping";
const string tag_can_threaten_hostages = "can_threaten_hostages";
const string tag_threatening = "threatening";
const string tag_can_take_hostages = "can_take_hostages";
const string tag_shortname_future = "shortname_future";
const string tag_shortname_future_sub_2 = "shortname_future_sub_2";
const string tag_shortname_future_sub_1 = "shortname_future_sub_1";
const string tag_shortname_sub_2 = "shortname_sub_2";
const string tag_shortname_sub_1 = "shortname_sub_1";
const string tag_name_future = "name_future";
const string tag_name_future_sub_2 = "name_future_sub_2";
const string tag_name_future_sub_1 = "name_future_sub_1";
const string tag_name_sub_2 = "name_sub_2";
const string tag_name_sub_1 = "name_sub_1";

WeaponType::WeaponType(MCD_STR xmlstring)
	: ItemType(xmlstring), name_sub_1_defined_(false), name_sub_2_defined_(false),
	name_future_sub_1_defined_(false), name_future_sub_2_defined_(false),
	shortname_(CONST_weapontype099), shortname_defined_(false), shortname_future_defined_(false),
	shortname_sub_1_defined_(false), shortname_sub_2_defined_(false),
	shortname_future_sub_1_defined_(false), shortname_future_sub_2_defined_(false),
	can_take_hostages_(false), threatening_(false), can_threaten_hostages_(true),
	protects_against_kidnapping_(true),
	musical_attack_(false), instrument_(false), legality_(2), bashstrengthmod_(1),
	suspicious_(true), size_(15), can_graffiti_(false), auto_break_lock_(false)
{
	CMarkup xml;
	xml.SetDoc(xmlstring);
	xml.FindElem();
	xml.IntoElem();
	while (xml.FindElem()) //Loop over all the elements inside the weapontype element.
	{
		std::string element = xml.GetTagName();
		if (element == tag_shortname)
		{
			shortname_ = xml.GetData();
			shortname_defined_ = true;
		}
		else if (element == tag_shortname_future)
		{
			shortname_future_ = xml.GetData();
			shortname_future_defined_ = true;
		}
		else if (element == tag_name_sub_1)
		{
			name_sub_1_ = xml.GetData();
			name_sub_1_defined_ = true;
		}
		else if (element == tag_name_sub_2)
		{
			name_sub_2_ = xml.GetData();
			name_sub_2_defined_ = true;
		}
		else if (element == tag_name_future_sub_1)
		{
			name_future_sub_1_ = xml.GetData();
			name_future_sub_1_defined_ = true;
		}
		else if (element == tag_name_future_sub_2)
		{
			name_future_sub_2_ = xml.GetData();
			name_future_sub_2_defined_ = true;
		}
		else if (element == tag_shortname_sub_1)
		{
			shortname_sub_1_ = xml.GetData();
			shortname_sub_1_defined_ = true;
		}
		else if (element == tag_shortname_sub_2)
		{
			shortname_sub_2_ = xml.GetData();
			shortname_sub_2_defined_ = true;
		}
		else if (element == tag_shortname_future_sub_1)
		{
			shortname_future_sub_1_ = xml.GetData();
			shortname_future_sub_1_defined_ = true;
		}
		else if (element == tag_shortname_future_sub_2)
		{
			shortname_future_sub_2_ = xml.GetData();
			shortname_future_sub_2_defined_ = true;
		}
		else if (element == tag_can_take_hostages)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				can_take_hostages_ = true;
			else if (b == 0)
				can_take_hostages_ = false;
			/*else
			errorlog << CONST_weapontype075 << idname()
			<< CONST_weapontype064 << xml.GetData() << endl;*/
		}
		else if (element == tag_threatening)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				threatening_ = true;
			else if (b == 0)
				threatening_ = false;
			/*else
			errorlog << CONST_weapontype075 << idname()
			<< CONST_weapontype066 << xml.GetData() << endl;*/
		}
		else if (element == tag_can_threaten_hostages)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				can_threaten_hostages_ = true;
			else if (b == 0)
				can_threaten_hostages_ = false;
		}
		else if (element == tag_protects_against_kidnapping)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				protects_against_kidnapping_ = true;
			else if (b == 0)
				protects_against_kidnapping_ = false;
		}
		else if (element == tag_musical_attack)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				musical_attack_ = true;
			else if (b == 0)
				musical_attack_ = false;
			/*else
			errorlog << CONST_weapontype075 << idname()
			<< CONST_weapontype068 << xml.GetData() << endl;*/
		}
		else if (element == tag_instrument)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				instrument_ = true;
			else if (b == 0)
				instrument_ = false;
			/*else
			errorlog << CONST_weapontype075 << idname()
			<< CONST_weapontype070 << xml.GetData() << endl;*/
		}
		else if (element == tag_graffiti)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				can_graffiti_ = true;
			else if (b == 0)
				can_graffiti_ = false;
			/*else
			errorlog << CONST_weapontype075 << idname()
			<< CONST_weapontype072 << xml.GetData() << endl;*/
		}
		else if (element == tag_legality)
			legality_ = atoi(xml.GetData());
		else if (element == tag_bashstrengthmod)
			bashstrengthmod_ = atoi(xml.GetData()) / 100.0;
		else if (element == tag_auto_break_locks)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				auto_break_lock_ = true;
			else if (b == 0)
				auto_break_lock_ = false;
			/*else
			errorlog << CONST_weapontype075 << idname()
			<< CONST_weapontype074 << xml.GetData() << endl;*/
		}
		else if (element == tag_suspicious)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				suspicious_ = true;
			else if (b == 0)
				suspicious_ = false;
			/*else
			errorlog << CONST_weapontype075 << idname()
			<< CONST_weapontype076 << xml.GetData() << endl;*/
		}
		else if (element == tag_size)
			size_ = atoi(xml.GetData());
		else if (element == tag_attack)
		{
			attackst* attack = new attackst(xml.GetSubDoc());
			int i;
			for (i = 0; i < len(attacks_) && attack->priority >= attacks_[i]->priority; i++);
			attacks_.insert(attacks_.begin() + i, attack);
		}
		/*else
		errorlog << CONST_weapontype077 << idname()
		<< CONST_weapontype078 << element << endl;*/
	}
	if (!shortname_defined_)
	{
		if ((uses_ammo() && len(name_) <= 9)
			|| len(name_) <= 14)
			shortname_ = name_;
	}
	else
	{
		if (len(shortname_) > 9 && uses_ammo())
			shortname_.resize(9);
		else if (len(shortname_) > 14)
			shortname_.resize(14);
	}
}
attackst::attackst(MCD_STR xmlstring)
	: priority(1), ranged(false), thrown(false), ammotype(CONST_weapontype099), uses_ammo(false),
	attack_description(CONST_weapontype080), hit_description(CONST_weapontypeB091),
	always_describe_hit(false), can_backstab(false), hit_punctuation(singleDot),
	skill(SKILL_CLUB), accuracy_bonus(0), number_attacks(1),
	successive_attacks_difficulty(0), strength_min(5), strength_max(10),
	random_damage(1), fixed_damage(1), bruises(false), tears(false), cuts(false),
	burns(false), shoots(false), bleeding(false), severtype(0), damages_armor(false),
	armorpiercing(0), no_damage_reduction_for_limbs_chance(0)
{
	CMarkup xml;
	xml.SetDoc(xmlstring);
	xml.FindElem();
	xml.IntoElem();
	while (xml.FindElem()) //Loop over all the elements inside the vehicletype element.
	{
		std::string element = xml.GetTagName();
		if (element == tag_priority)
			priority = atoi(xml.GetData());
		else if (element == tag_ranged)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				ranged = true;
			else if (b == 0)
				ranged = false;
			/*else
			errorlog << CONST_weapontype081 << xml.GetData() << endl;*/
		}
		else if (element == tag_thrown)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				thrown = true;
			else if (b == 0)
				thrown = false;
			/*else
			errorlog << CONST_weapontype082 << xml.GetData() << endl;*/
		}
		else if (element == tag_can_backstab)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				can_backstab = true;
			else if (b == 0)
				can_backstab = false;
		}
		else if (element == tag_ammotype)
		{
			ammotype = xml.GetData();
			uses_ammo = true;
		}
		else if (element == tag_attack_description)
			attack_description = xml.GetData();
		else if (element == tag_hit_description)
			hit_description = xml.GetData();
		else if (element == tag_always_describe_hit)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				always_describe_hit = true;
			else if (b == 0)
				always_describe_hit = false;
			/*else
			errorlog << CONST_weapontype083 << xml.GetData() << endl;*/
		}
		else if (element == tag_hit_punctuation)
			hit_punctuation = xml.GetData();
		else if (element == tag_skill)
		{
			int s = skill_string_to_enum(xml.GetData());
			if (s != -1)
				skill = s;
			/*else
			errorlog << CONST_weapontype084 << xml.GetData() << endl; */
		}
		else if (element == tag_accuracy_bonus)
			accuracy_bonus = atoi(xml.GetData());
		else if (element == tag_number_attacks)
			number_attacks = atoi(xml.GetData());
		else if (element == tag_successive_attacks_difficulty)
			successive_attacks_difficulty = atoi(xml.GetData());
		else if (element == tag_strength_min)
			strength_min = atoi(xml.GetData());
		else if (element == tag_strength_max)
			strength_max = atoi(xml.GetData());
		else if (element == tag_random_damage)
			random_damage = atoi(xml.GetData());
		else if (element == tag_fixed_damage)
			fixed_damage = atoi(xml.GetData());
		else if (element == tag_bruises)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				bruises = true;
			else if (b == 0)
				bruises = false;
			/*else
			errorlog << CONST_weapontype085 << xml.GetData() << endl;*/
		}
		else if (element == tag_tears)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				tears = true;
			else if (b == 0)
				tears = false;
			/*else
			errorlog << CONST_weapontype086 << xml.GetData() << endl;*/
		}
		else if (element == tag_cuts)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				cuts = true;
			else if (b == 0)
				cuts = false;
			/*else
			errorlog << CONST_weapontype087 << xml.GetData() << endl;*/
		}
		else if (element == tag_burns)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				burns = true;
			else if (b == 0)
				burns = false;
			/*else
			errorlog << CONST_weapontype088 << xml.GetData() << endl;*/
		}
		else if (element == tag_shoots)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				shoots = true;
			else if (b == 0)
				shoots = false;
			/*else
			errorlog << CONST_weapontype089 << xml.GetData() << endl;*/
		}
		else if (element == tag_bleeding)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				bleeding = true;
			else if (b == 0)
				bleeding = false;
			/*else
			errorlog << CONST_weapontype090 << xml.GetData() << endl;*/
		}
		else if (element == tag_severtype)
		{
			int s = severtype_string_to_enum(xml.GetData());
			if (s != -1)
				severtype = s;
			/*else
			errorlog << CONST_weapontype091 << xml.GetData() << endl; */
		}
		else if (element == tag_damages_armor)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				damages_armor = true;
			else if (b == 0)
				damages_armor = false;
			/*else
			errorlog << CONST_weapontype092 << xml.GetData() << endl;*/
		}
		else if (element == tag_armorpiercing)
			armorpiercing = atoi(xml.GetData());
		else if (element == tag_no_DR_for_limbs_chance)
			no_damage_reduction_for_limbs_chance = atoi(xml.GetData());
		else if (element == tag_critical)
		{
			xml.IntoElem();
			while (xml.FindElem())
			{
				element = xml.GetTagName();
				if (element == tag_chance)
					critical.chance = atoi(xml.GetData());
				else if (element == tag_hits_required)
					critical.hits_required = atoi(xml.GetData());
				else if (element == tag_random_damage)
				{
					critical.random_damage = atoi(xml.GetData());
					critical.random_damage_defined = true;
				}
				else if (element == tag_fixed_damage)
				{
					critical.fixed_damage = atoi(xml.GetData());
					critical.fixed_damage_defined = true;
				}
				else if (element == tag_severtype)
				{
					int s = severtype_string_to_enum(xml.GetData());
					if (s != -1)
					{
						critical.severtype = s;
						critical.severtype_defined = true;
					}
					/*else
					errorlog << CONST_weapontype093 << xml.GetData() << endl; */
				}
				/*else
				errorlog << CONST_weapontype094 << element << endl; */
			}
			xml.OutOfElem();
		}
		else if (element == tag_fire)
		{
			xml.IntoElem();
			while (xml.FindElem())
			{
				element = xml.GetTagName();
				if (element == tag_chance)
					fire.chance = atoi(xml.GetData());
				else if (element == tag_chance_causes_debris)
					fire.chance_causes_debris = atoi(xml.GetData());
				/*else
				errorlog << CONST_weapontype095 << element << endl; */
			}
			xml.OutOfElem();
		}
		/*else
		errorlog << CONST_weapontype096 << element << endl; */
	}
	if (!bruises && !tears && !cuts && !burns && !shoots)
		bruises = true; //If no type specified, then bruise.
}
attackst::criticalst::criticalst()
	: chance(0), hits_required(1), random_damage(1), random_damage_defined(false),
	fixed_damage(1), fixed_damage_defined(false), severtype(0), severtype_defined(false)
{
}
attackst::firest::firest()
	: chance(0), chance_causes_debris(0)
{
}
WeaponType::~WeaponType()
{
	delete_and_clear(attacks_);
}
const string& WeaponType::get_name(unsigned subtype) const
{
	extern int year;
	if (subtype == 0)
		return get_name();
	else if (subtype == 1)
	{
		if (name_future_sub_1_defined_ && year >= 2100)
			return name_future_sub_1_;
		else if (name_sub_1_defined_)
			return name_sub_1_;
		else
			return get_name();
	}
	else if (subtype == 2)
	{
		if (name_future_sub_2_defined_ && year >= 2100)
			return name_future_sub_2_;
		else if (name_sub_2_defined_)
			return name_sub_2_;
		else
			return get_name();
	}
	else
		return get_name(); //return CONST_weapontype098; //Reference to temporary. -XML
}
const string& WeaponType::get_shortname(unsigned subtype) const
{
	extern int year;
	if (subtype > 2)
		return shortname_; //return CONST_weapontype098; //Reference to temporary. -XML
	else if (subtype == 1)
	{
		if (shortname_future_sub_1_defined_ && year >= 2100)
			return shortname_future_sub_1_;
		else if (year >= 2100 && name_future_sub_1_defined_ && len(name_future_sub_1_) <= 14) //Too long for ammo using weapons. -XML
			return name_future_sub_1_;
		else if (shortname_sub_1_defined_)
			return shortname_sub_1_;
		else if (name_sub_1_defined_ && len(name_sub_1_) <= 14) //Too long for ammo using weapons. -XML
			return name_sub_1_;
	}
	else if (subtype == 2)
	{
		if (shortname_future_sub_2_defined_ && year >= 2100)
			return shortname_future_sub_2_;
		else if (year >= 2100 && name_future_sub_2_defined_ && len(name_future_sub_2_) <= 14) //Too long for ammo using weapons. -XML
			return name_future_sub_2_;
		else if (shortname_sub_2_defined_)
			return shortname_sub_2_;
		else if (name_sub_2_defined_ && len(name_sub_2_) <= 14) //Too long for ammo using weapons. -XML
			return name_sub_2_;
	}
	if (shortname_future_defined_ && year >= 2100)
		return shortname_future_;
	else if (year >= 2100 && name_future_defined_ && len(name_future_) <= 14) //Too long for ammo using weapons. -XML
		return name_future_;
	else //if (shortname_defined_)
		return shortname_;
	/*else if (len(name()) <= 14) //Too long for ammo using weapons. -XML
	return name();
	else
	return CONST_weapontype099;*/
}
bool WeaponType::uses_ammo() const
{
	for (int i = 0; i < len(attacks_); i++)
		if (attacks_[i]->uses_ammo)
			return true;
	return false;
}
bool WeaponType::acceptable_ammo(const string& clipname) const
{
	for (int i = 0; i < len(attacks_); i++)
		if (attacks_[i]->ammotype == clipname)
			return true;
	return false;
}
bool WeaponType::is_ranged() const
{
	for (int i = 0; i < len(attacks_); i++)
		if (attacks_[i]->ranged)
			return true;
	return false;
}
bool WeaponType::is_throwable() const
{
	for (int i = 0; i < len(attacks_); i++)
		if (attacks_[i]->thrown)
			return true;
	return false;
}
bool WeaponType::is_legal() const
{
	extern short lawList[LAWNUM];
	return legality_ >= lawList[LAW_GUNCONTROL];
}


// #include "../includes.h"
const string CONST_weaponB004 = ")";
const string CONST_weapon003 = " (";


const string tag_loaded_cliptype = "loaded_cliptype";
const string tag_weapon = "weapon";

Weapon::Weapon(const WeaponType& seed, int number) : Item(seed, number), ammo_(0)
{ }
Weapon::Weapon(const std::string& inputXml) : Item(inputXml)
{
	CMarkup xml;
	xml.SetDoc(inputXml);
	xml.FindElem();
	xml.IntoElem();
	while (xml.FindElem())
	{
		std::string tag = xml.GetTagName();
		if (tag == tag_loaded_cliptype)
			loaded_cliptype_ = xml.GetData();
		else if (tag == tag_ammo)
			ammo_ = atoi(xml.GetData().c_str());
	}
}
string Weapon::showXml() const
{
	CMarkup xml;
	xml.AddElem(tag_weapon);
	xml.IntoElem();
	addBaseValues(xml);
	xml.AddElem(tag_loaded_cliptype, loaded_cliptype_);
	xml.AddElem(tag_ammo, tostring(ammo_));
	return xml.GetDoc();
}
string Weapon::equip_title() const
{
	string et = get_name();
	if (ammo_ > 0) et += CONST_weapon003 + tostring(ammo_) + CONST_weaponB004;
	return et;
}
bool Weapon::reload(Clip& clip)
{
	if (acceptable_ammo(clip) && !clip.empty())
	{
		loaded_cliptype_ = clip.get_itemtypename();
		ammo_ = clip.get_ammoamount();
		clip.decrease_number(1);
		return true;
	}
	else return false;
}


Weapon* Weapon::split(int number)
{
	if (number > number_) number = number_;
	Weapon* newi = clone();
	newi->number_ = number;
	number_ -= number;
	return newi;
}
bool Weapon::merge(Item& i)
{
	if (i.whatIsThis() == THIS_IS_WEAPON && is_same_type(i))
	{
		Weapon& w = static_cast<Weapon&>(i); //cast -XML
		if ((loaded_cliptype_ == w.loaded_cliptype_&&ammo_ == w.ammo_) || (ammo_ == 0 && w.ammo_ == 0))
		{
			increase_number(w.get_number());
			w.set_number(0);
			return true;
		}
	}
	return false;
}
bool Weapon::sort_compare_special(Item* other) const
{
	if (other)
	{
		int thisi = getweapontype(get_itemtypename());
		int otheri = getweapontype(other->get_itemtypename());
		if (thisi < otheri || otheri == -1) return false;
		else if (thisi > otheri&&otheri != -1) return true;
		else if (other->whatIsThis() == THIS_IS_WEAPON)
		{
			Weapon* w = static_cast<Weapon*>(other); //cast -XML
			return ammo_ < w->ammo_;
		}
		else return false;
	}
	else return false;
}
const attackst* Weapon::get_attack(bool force_ranged, bool force_melee, bool force_no_reload) const
{
	extern vector<WeaponType *> weapontype;
	const vector<attackst*>& attacks = weapontype[getweapontype(get_itemtypename())]->get_attacks();
	for (int i = 0; i < len(attacks); i++)
	{
		if (force_ranged && !attacks[i]->ranged) continue;
		if (force_melee&&attacks[i]->ranged) continue;
		if (force_no_reload&&attacks[i]->uses_ammo && !ammo_) continue;
		if (attacks[i]->uses_ammo&&attacks[i]->ammotype != loaded_cliptype_ && ammo_) continue;
		return attacks[i];
	}
	return NULL;
}
bool Weapon::acceptable_ammo(const Item& c) const
{
	extern vector<WeaponType *> weapontype;
	return c.whatIsThis() == THIS_IS_CLIP && weapontype[getweapontype(get_itemtypename())]->acceptable_ammo(c.get_itemtypename());
}
const string& Weapon::get_name() const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->get_name();
}
const string& Weapon::get_name(unsigned subtype) const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->get_name(subtype);
}
const string& Weapon::get_shortname(unsigned subtype) const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->get_shortname(subtype);
}
long Weapon::get_fencevalue() const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->get_fencevalue();
}
bool Weapon::can_take_hostages() const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->can_take_hostages();
}
bool Weapon::is_threatening() const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->is_threatening();
}
bool Weapon::can_threaten_hostages() const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->can_threaten_hostages();
}
bool Weapon::protects_against_kidnapping() const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->protects_against_kidnapping();
}
bool Weapon::has_musical_attack() const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->has_musical_attack();
}
bool Weapon::is_instrument() const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->is_instrument();
}
int Weapon::get_legality() const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->get_legality();
}
float Weapon::get_bashstrengthmod() const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->get_bashstrengthmod();
}
bool Weapon::is_suspicious() const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->is_suspicious();
}
int Weapon::get_size() const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->get_size();
}
bool Weapon::can_graffiti() const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->can_graffiti();
}
bool Weapon::uses_ammo() const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->uses_ammo();
}
bool Weapon::acceptable_ammo(const Clip& c) const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->acceptable_ammo(c.get_itemtypename());
}
bool Weapon::acceptable_ammo(const ClipType& c) const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->acceptable_ammo(c);
}
bool Weapon::is_ranged() const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->is_ranged();
}
bool Weapon::is_throwable() const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->is_throwable();
}
bool Weapon::auto_breaks_locks() const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->auto_breaks_locks();
}
bool Weapon::is_legal() const
{
	extern vector<WeaponType *> weapontype;
	return weapontype[getweapontype(get_itemtypename())]->is_legal();
}

/* transforms a weapon type id into the index of that weapon type in the global vector */
int getweapontype(int id)
{
	extern vector<WeaponType *> weapontype;
	for (int i = 0; i < len(weapontype); i++) if (weapontype[i]->get_id() == id) return i;
	return -1;
}
/* transforms a weapon type name into the index of that weapon type in the global vector */
int getweapontype(const string &idname)
{
	extern vector<WeaponType *> weapontype;
	for (int i = 0; i < len(weapontype); i++) if (weapontype[i]->get_idname() == idname) return i;
	return -1;
}

void delete_and_clear_weapon_type() {
	extern vector<WeaponType *> weapontype;
	delete_and_clear(weapontype);
}


// #include "../includes.h"
const string CONST_sitemapC043 = "Export";

const string CONST_sitemapB042 = "mapCSV_ApartmentIndustrial2_Tiles.csv";
const string CONST_sitemapB041 = "3";
const string CONST_sitemapB040 = "csv";
const string CONST_sitemap039 = "ApartmentIndustrial2";
const string CONST_sitemap038 = "2";
const string CONST_sitemap037 = "mapCSV_ApartmentIndustrial_Tiles.csv";
const string CONST_sitemap036 = "ApartmentIndustrial";
const string CONST_sitemap035 = "mapCSV_[NAMEHERE]_Specials.csv";
const string CONST_sitemap034 = "mapCSV_[NAMEHERE]_Tiles.csv";
const string CONST_sitemap033 = "../art";
const string CONST_sitemap032 = "csvTilemap.lua";
const string CONST_sitemap031 = "Deadly Alien Map Editor";
const string CONST_sitemap030 = "GENERIC_UNSECURE";

const string tag_WEIGHT = "WEIGHT";
const string tag_Z = "Z";
const string tag_FREQ = "FREQ";
const string tag_ZEND = "ZEND";
const string tag_ZSTART = "ZSTART";
const string tag_Y = "Y";
const string tag_YEND = "YEND";
const string tag_YSTART = "YSTART";
const string tag_XEND = "XEND";
const string tag_XSTART = "XSTART";
const string tag_STAIRS_RANDOM = "STAIRS_RANDOM";
const string tag_STAIRS = "STAIRS";
const string tag_HALLWAY_YAXIS = "HALLWAY_YAXIS";
const string tag_ROOM = "ROOM";
const string tag_SUBTRACT = "SUBTRACT";
const string tag_ADD = "ADD";
const string tag_NOTE = "NOTE";
const string tag_LOOT = "LOOT";
const string tag_UNIQUE = "UNIQUE";
const string tag_SPECIAL = "SPECIAL";
const string tag_SCRIPT = "SCRIPT";
const string tag_TILE = "TILE";
const string tag_USE = "USE";
const string tag_NAME = "NAME";
const string tag_SITEMAP = "SITEMAP";


#include "../configfile.h"
// needed for something contained in sitemap.h
#include "../sitemode/sitemap.h"
//own header
void emptyEncounter();
void delete_and_clear_groundloot();
map<short, string> siteReadMap;
map<short, string> buildThisSite;
vector<configSiteMap *> sitemaps;
map<string, short> getUnique;
map<string, string> getLootString;
map<string, short> getSpecial;
void delete_and_clear_sitemaps() {
	delete_and_clear(sitemaps);
}
// Constructs the new object, returns a pointer to it
configurable* createObject(const std::string& objectType)
{
	configurable* object = 0;
	if (objectType == tag_SITEMAP)
		sitemaps.push_back(static_cast<configSiteMap*>(object = new configSiteMap));
	return object;
}
/* recursive dungeon-generating algorithm */
void generateroom(int rx, int ry, int dx, int dy, int z)
{
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	for (int x = rx; x < rx + dx; x++)
		for (int y = ry; y < ry + dy; y++)
			levelmap[x][y][z].flag &= ~SITEBLOCK_BLOCK;
	if ((dx <= 3 || dy <= 3) && !LCSrandom(2))return;
	if (dx <= 2 && dy <= 2)return;
	//LAY DOWN WALL AND ITERATE
	if ((!LCSrandom(2) || dy <= 2) && dx > 2)
	{
		int wx = rx + LCSrandom(dx - 2) + 1;
		for (int wy = 0; wy < dy; wy++)levelmap[wx][ry + wy][z].flag |= SITEBLOCK_BLOCK;
		int rny = LCSrandom(dy);
		levelmap[wx][ry + rny][z].flag &= ~SITEBLOCK_BLOCK;
		levelmap[wx][ry + rny][z].flag |= SITEBLOCK_DOOR;
		if (!LCSrandom(3))levelmap[wx][ry + rny][z].flag |= SITEBLOCK_LOCKED;
		generateroom(rx, ry, wx - rx, dy, z);
		generateroom(wx + 1, ry, rx + dx - wx - 1, dy, z);
	}
	else
	{
		int wy = ry + LCSrandom(dy - 2) + 1;
		for (int wx = 0; wx < dx; wx++)levelmap[rx + wx][wy][z].flag |= SITEBLOCK_BLOCK;
		int rnx = LCSrandom(dx);
		levelmap[rx + rnx][wy][z].flag &= ~SITEBLOCK_BLOCK;
		levelmap[rx + rnx][wy][z].flag |= SITEBLOCK_DOOR;
		if (!LCSrandom(3))levelmap[rx + rnx][wy][z].flag |= SITEBLOCK_LOCKED;
		generateroom(rx, ry, dx, wy - ry, z);
		generateroom(rx, wy + 1, dx, ry + dy - wy - 1, z);
	}
}
/////////////
/////////////
///////////// NEW SITEMAP BASED ON CONFIG FILE CODE:
/////////////
/////////////
// Builds a site based on the name provided
void build_site(const std::string& name)
{
	for (int i = 0; i < len(sitemaps); i++)
		if (*sitemaps[i] == name)
		{
			sitemaps[i]->build();
			return;
		}
	// Backup: use a generic
	build_site(CONST_sitemap030);
}
void addSemiPermanentChanges(Location &loc) {
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	/*******************************************************
	* Add semi-permanent changes inflicted by LCS and others
	*******************************************************/
	// Some sites need a minimum amount of graffiti
	int graffitiquota = 0;
	if (loc.type == SITE_OUTDOOR_PUBLICPARK)graffitiquota = 5;
	if (loc.type == SITE_BUSINESS_CRACKHOUSE)graffitiquota = 30;
	if (loc.type == SITE_RESIDENTIAL_TENEMENT)graffitiquota = 10;
	for (int i = 0; i < len(loc.changes); i++)
	{
		int x = loc.changes[i].x, y = loc.changes[i].y, z = loc.changes[i].z;
		switch (loc.changes[i].flag)
		{
		case SITEBLOCK_GRAFFITI_OTHER: // Other tags
		case SITEBLOCK_GRAFFITI_CCS: // CCS tags
		case SITEBLOCK_GRAFFITI: // LCS tags
			graffitiquota--;
			break;
		case SITEBLOCK_DEBRIS: // Smashed walls, ash
			levelmap[x][y][z].flag &= ~SITEBLOCK_BLOCK;
			levelmap[x][y][z].flag &= ~SITEBLOCK_DOOR;
			break;
		}
		levelmap[x][y][z].flag |= loc.changes[i].flag;
	}
	// If there isn't enough graffiti for this site type, add some
	while (graffitiquota > 0)
	{
		int x = LCSrandom(MAPX - 2) + 1, y = LCSrandom(MAPY - 2) + 1, z = 0;
		if (loc.type == SITE_RESIDENTIAL_TENEMENT)z = LCSrandom(6);
		if (!(levelmap[x][y][z].flag & SITEBLOCK_BLOCK) &&
			(!(levelmap[x][y][z].flag & SITEBLOCK_RESTRICTED) || loc.type == SITE_BUSINESS_CRACKHOUSE) &&
			!(levelmap[x][y][z].flag & SITEBLOCK_EXIT) &&
			!(levelmap[x][y][z].flag & SITEBLOCK_GRAFFITI) &&
			!(levelmap[x][y][z].flag & SITEBLOCK_GRAFFITI_OTHER) &&
			!(levelmap[x][y][z].flag & SITEBLOCK_GRAFFITI_CCS))
			if (levelmap[x + 1][y][z].flag & SITEBLOCK_BLOCK ||
				levelmap[x - 1][y][z].flag & SITEBLOCK_BLOCK ||
				levelmap[x][y + 1][z].flag & SITEBLOCK_BLOCK ||
				levelmap[x][y - 1][z].flag & SITEBLOCK_BLOCK)
			{
				sitechangest change(x, y, z, SITEBLOCK_GRAFFITI_OTHER);
				loc.changes.push_back(change);
				levelmap[x][y][z].flag |= SITEBLOCK_GRAFFITI_OTHER;
				graffitiquota--;
			}
	}
}
void addLootToLocation(Location &loc) {
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	for (int x = 2; x < MAPX - 2; x++)
		for (int y = 2; y < MAPY - 2; y++)
			for (int z = 0; z < MAPZ; z++)
				if (!(levelmap[x][y][0].flag & SITEBLOCK_DOOR) &&
					!(levelmap[x][y][0].flag & SITEBLOCK_BLOCK) &&
					(levelmap[x][y][0].flag & SITEBLOCK_RESTRICTED) &&
					!LCSrandom(10))
					switch (loc.type)
					{
					case SITE_BUSINESS_BANK:
					case SITE_RESIDENTIAL_SHELTER:
					case SITE_BUSINESS_CRACKHOUSE:
					case SITE_BUSINESS_JUICEBAR:
					case SITE_BUSINESS_CIGARBAR:
					case SITE_BUSINESS_LATTESTAND:
					case SITE_BUSINESS_VEGANCOOP:
					case SITE_BUSINESS_INTERNETCAFE:
					case SITE_INDUSTRY_WAREHOUSE:
					case SITE_BUSINESS_BARANDGRILL:
					case SITE_OUTDOOR_BUNKER:
					case SITE_RESIDENTIAL_BOMBSHELTER:               break;
					default: levelmap[x][y][z].flag |= SITEBLOCK_LOOT; break;
					}
}
void clearOutRestrictions(Location &loc) {
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	//Clear out restrictions
	char acted;
	do
	{
		acted = 0;
		for (int x = 2; x < MAPX - 2; x++)
			for (int y = 2; y < MAPY - 2; y++)
				for (int z = 0; z < MAPZ; z++)
				{  //Un-restrict blocks if they have neighboring
				   //unrestricted blocks
					if (!(levelmap[x][y][z].flag & SITEBLOCK_DOOR) &&
						!(levelmap[x][y][z].flag & SITEBLOCK_BLOCK) &&
						(levelmap[x][y][z].flag & SITEBLOCK_RESTRICTED))
					{
						if ((!(levelmap[x - 1][y][z].flag & SITEBLOCK_RESTRICTED) &&
							!(levelmap[x - 1][y][z].flag & SITEBLOCK_BLOCK)) ||
							(!(levelmap[x + 1][y][z].flag & SITEBLOCK_RESTRICTED) &&
								!(levelmap[x + 1][y][z].flag & SITEBLOCK_BLOCK)) ||
								(!(levelmap[x][y - 1][z].flag & SITEBLOCK_RESTRICTED) &&
									!(levelmap[x][y - 1][z].flag & SITEBLOCK_BLOCK)) ||
									(!(levelmap[x][y + 1][z].flag & SITEBLOCK_RESTRICTED) &&
										!(levelmap[x][y + 1][z].flag & SITEBLOCK_BLOCK)))
						{
							levelmap[x][y][z].flag &= ~SITEBLOCK_RESTRICTED;
							acted = 1;
							continue;
						}
					}
					//Un-restrict and unlock doors if they lead between two
					//unrestricted sections. If they lead between one
					//unrestricted section and a restricted section, lock
					//them instead.
					else if ((levelmap[x][y][z].flag & SITEBLOCK_DOOR) &&
						!(levelmap[x][y][z].flag & SITEBLOCK_BLOCK) &&
						(levelmap[x][y][z].flag & SITEBLOCK_RESTRICTED))
					{  //Unrestricted on two opposite sides?
						if (((!(levelmap[x - 1][y][z].flag & SITEBLOCK_RESTRICTED) && !(levelmap[x - 1][y][z].flag & SITEBLOCK_BLOCK)) &&
							(!(levelmap[x + 1][y][z].flag & SITEBLOCK_RESTRICTED) && !(levelmap[x + 1][y][z].flag & SITEBLOCK_BLOCK))) ||
							((!(levelmap[x][y - 1][z].flag & SITEBLOCK_RESTRICTED) && !(levelmap[x][y - 1][z].flag & SITEBLOCK_BLOCK)) &&
							(!(levelmap[x][y + 1][z].flag & SITEBLOCK_RESTRICTED) && !(levelmap[x][y + 1][z].flag & SITEBLOCK_BLOCK))))
						{  //Unlock and unrestrict
							levelmap[x][y][z].flag &= ~SITEBLOCK_LOCKED;
							levelmap[x][y][z].flag &= ~SITEBLOCK_RESTRICTED;
							acted = 1;
							continue;
						}
						//Unrestricted on at least one side and I'm not locked?
						else if ((!(levelmap[x - 1][y][z].flag & SITEBLOCK_RESTRICTED) ||
							!(levelmap[x + 1][y][z].flag & SITEBLOCK_RESTRICTED) ||
							!(levelmap[x][y - 1][z].flag & SITEBLOCK_RESTRICTED) ||
							!(levelmap[x][y + 1][z].flag & SITEBLOCK_RESTRICTED)) &&
							!(levelmap[x][y][z].flag   & SITEBLOCK_LOCKED))
						{  //Lock doors leading to restricted areas
							levelmap[x][y][z].flag |= SITEBLOCK_LOCKED;
							acted = 1;
							continue;
						}
					}
				}
	} while (acted);
}
void useOldMapMode(Location &loc) {
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	//ADD RESTRICTIONS
	//bool restricted=0;
	switch (loc.type)
	{
	case SITE_LABORATORY_COSMETICS:
	case SITE_LABORATORY_GENETIC:
	case SITE_GOVERNMENT_POLICESTATION:
	case SITE_GOVERNMENT_COURTHOUSE:
	case SITE_GOVERNMENT_PRISON:
	case SITE_GOVERNMENT_INTELLIGENCEHQ:
	case SITE_GOVERNMENT_ARMYBASE:
	case SITE_GOVERNMENT_WHITE_HOUSE:
	case SITE_MEDIA_AMRADIO:
	case SITE_MEDIA_CABLENEWS:
		//restricted=1;
		for (int x = 2; x < MAPX - 2; x++)
			for (int y = 2; y < MAPY - 2; y++)
				for (int z = 0; z < MAPZ; z++)
					levelmap[x][y][z].flag |= SITEBLOCK_RESTRICTED;
		break;
	}

}
void useOldMapModeP2(Location &loc) {
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	//ADD ACCESSORIES
	for (int x = 2; x < MAPX - 2; x++)
		for (int y = 2; y < MAPY - 2; y++)
			for (int z = 0; z < MAPZ; z++)
			{
				if (!(levelmap[x][y][0].flag & SITEBLOCK_DOOR) &&
					!(levelmap[x][y][0].flag & SITEBLOCK_BLOCK) &&
					!LCSrandom(10))
				{
					switch (loc.type)
					{
					case SITE_BUSINESS_BANK: // the valuables are in the vault
					case SITE_RESIDENTIAL_SHELTER:
					case SITE_BUSINESS_CRACKHOUSE:
					case SITE_BUSINESS_JUICEBAR:
					case SITE_BUSINESS_CIGARBAR:
					case SITE_BUSINESS_LATTESTAND:
					case SITE_BUSINESS_VEGANCOOP:
					case SITE_BUSINESS_INTERNETCAFE:
					case SITE_INDUSTRY_WAREHOUSE:
						//seem to be weird things happening with loot in CCS bases - would the CCS call the police on you for stealing?
						//and shouldn't you be able to loot everything from there anyway once you've won?
						//removing the loot.
					case SITE_BUSINESS_BARANDGRILL:
					case SITE_OUTDOOR_BUNKER:
					case SITE_RESIDENTIAL_BOMBSHELTER:               break;
					default: levelmap[x][y][z].flag |= SITEBLOCK_LOOT; break;
					}
				}
				if (!(levelmap[x][y][0].flag&SITEBLOCK_DOOR) &&
					!(levelmap[x][y][0].flag&SITEBLOCK_BLOCK) &&
					!(levelmap[x][y][0].flag&SITEBLOCK_LOOT) &&
					(levelmap[x][y][0].flag&SITEBLOCK_RESTRICTED) &&
					loc.type == SITE_LABORATORY_COSMETICS && !LCSrandom(10))
					levelmap[x][y][z].special = SPECIAL_LAB_COSMETICS_CAGEDANIMALS;
				if (!(levelmap[x][y][0].flag&SITEBLOCK_DOOR) &&
					!(levelmap[x][y][0].flag&SITEBLOCK_BLOCK) &&
					!(levelmap[x][y][0].flag&SITEBLOCK_LOOT) &&
					(levelmap[x][y][0].flag&SITEBLOCK_RESTRICTED) &&
					loc.type == SITE_LABORATORY_GENETIC && !LCSrandom(10))
					levelmap[x][y][z].special = SPECIAL_LAB_GENETIC_CAGEDANIMALS;
				if (levelmap[x][y][0].flag == 0 &&
					loc.type == SITE_INDUSTRY_SWEATSHOP && !LCSrandom(10))
					levelmap[x][y][z].special = SPECIAL_SWEATSHOP_EQUIPMENT;
				if (levelmap[x][y][0].flag == 0 &&
					loc.type == SITE_INDUSTRY_POLLUTER && !LCSrandom(10))
					levelmap[x][y][z].special = SPECIAL_POLLUTER_EQUIPMENT;
				if (levelmap[x][y][0].flag == 0 &&
					(loc.type == SITE_BUSINESS_JUICEBAR ||
						loc.type == SITE_BUSINESS_CIGARBAR ||
						loc.type == SITE_BUSINESS_LATTESTAND ||
						loc.type == SITE_BUSINESS_INTERNETCAFE) &&
					!LCSrandom(10))
					levelmap[x][y][z].special = SPECIAL_RESTAURANT_TABLE;
				if (levelmap[x][y][z].flag == 0 && loc.type == SITE_BUSINESS_INTERNETCAFE &&
					!LCSrandom(10))
					levelmap[x][y][z].special = SPECIAL_CAFE_COMPUTER;
			}
	int freex, freey, freez = 0;
	//ADD FIRST SPECIAL
	int count = 100000;
	do
	{
		freex = LCSrandom(MAPX - 4) + 2, freey = LCSrandom(MAPY - 4) + 2;
		if (freex >= (MAPX >> 1) - 2 && freex <= (MAPX >> 1) + 2)freey = LCSrandom(MAPY - 6) + 4;
		count--;
	} while ((levelmap[freex][freey][freez].flag & SITEBLOCK_DOOR ||
		levelmap[freex][freey][freez].flag & SITEBLOCK_BLOCK ||
		levelmap[freex][freey][freez].flag & SITEBLOCK_LOOT ||
		levelmap[freex][freey][freez].special != -1) && count > 0);
	map<int, int>  site_special_list = {
		map<int, int> ::value_type(SITE_INDUSTRY_NUCLEAR,           SPECIAL_NUCLEAR_ONOFF),
		map<int, int> ::value_type(SITE_GOVERNMENT_POLICESTATION,   SPECIAL_POLICESTATION_LOCKUP),
		map<int, int> ::value_type(SITE_GOVERNMENT_COURTHOUSE,      SPECIAL_COURTHOUSE_LOCKUP),
		map<int, int> ::value_type(SITE_GOVERNMENT_PRISON,          SPECIAL_PRISON_CONTROL),
		map<int, int> ::value_type(SITE_GOVERNMENT_INTELLIGENCEHQ,  SPECIAL_INTEL_SUPERCOMPUTER),
		map<int, int> ::value_type(SITE_CORPORATE_HEADQUARTERS,     SPECIAL_CORPORATE_FILES),
		map<int, int> ::value_type(SITE_CORPORATE_HOUSE,            SPECIAL_HOUSE_PHOTOS),
		map<int, int> ::value_type(SITE_GOVERNMENT_ARMYBASE,        SPECIAL_ARMORY),
		map<int, int> ::value_type(SITE_MEDIA_AMRADIO,              SPECIAL_RADIO_BROADCASTSTUDIO),
		map<int, int> ::value_type(SITE_MEDIA_CABLENEWS,            SPECIAL_NEWS_BROADCASTSTUDIO),
	};
	if (site_special_list.count(loc.type)) {
		levelmap[freex][freey][freez].special = site_special_list[loc.type];
	}
	count = 100000;
	//ADD SECOND SPECIAL
	do
	{
		freex = LCSrandom(MAPX - 4) + 2, freey = LCSrandom(MAPY - 4) + 2;
		if (freex >= (MAPX >> 1) - 2 && freex <= (MAPX >> 1) + 2)freey = LCSrandom(MAPY - 6) + 4;
		count--;
	} while ((levelmap[freex][freey][freez].flag & SITEBLOCK_DOOR ||
		levelmap[freex][freey][freez].flag & SITEBLOCK_BLOCK ||
		levelmap[freex][freey][freez].flag & SITEBLOCK_LOOT ||
		levelmap[freex][freey][freez].special != -1) && count > 0);
	switch (loc.type)
	{
	case SITE_GOVERNMENT_COURTHOUSE: levelmap[freex][freey][freez].special = SPECIAL_COURTHOUSE_JURYROOM; break;
	}

}
void clearBlockedStairwells(Location &loc) {
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	//CLEAR BLOCKED STAIRWELLS
	for (int x = 0; x < MAPX; x++)
		for (int y = 0; y < MAPY; y++)
			for (int z = 0; z < MAPZ; z++)
				if (levelmap[x][y][z].flag & SITEBLOCK_BLOCK && levelmap[x][y][z].special == SPECIAL_STAIRS_DOWN)
				{
					levelmap[x][y][z].flag &= ~SITEBLOCK_BLOCK;
				}
}
void deleteNonDoors(Location &loc) {
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	//DELETE NON-DOORS
	for (int x = 0; x < MAPX; x++)
		for (int y = 0; y < MAPY; y++)
			for (int z = 0; z < MAPZ; z++)
				if (levelmap[x][y][z].flag & SITEBLOCK_DOOR)
				{
					char block = BIT1 | BIT2 | BIT3 | BIT4;
					if (x > 0)if (!(levelmap[x - 1][y][z].flag&SITEBLOCK_BLOCK))block &= ~BIT2;
					if (x < MAPX - 1)if (!(levelmap[x + 1][y][z].flag&SITEBLOCK_BLOCK))block &= ~BIT3;
					if (y > 0)if (!(levelmap[x][y - 1][z].flag&SITEBLOCK_BLOCK))block &= ~BIT1;
					if (y < MAPY - 1)if (!(levelmap[x][y + 1][z].flag&SITEBLOCK_BLOCK))block &= ~BIT4;
					if ((block & BIT1) && (block & BIT4))continue;
					if ((block & BIT2) && (block & BIT3))continue;
					levelmap[x][y][z].flag &= ~SITEBLOCK_DOOR;
					levelmap[x][y][z].flag &= ~SITEBLOCK_LOCKED;
				}
}
void clearBlockedDoorways(Location &loc) {
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	//CLEAR AWAY BLOCKED DOORWAYS
	for (int x = 0; x < MAPX; x++)
		for (int y = 0; y < MAPY; y++)
			for (int z = 0; z < MAPZ; z++)
				if (levelmap[x][y][z].flag & SITEBLOCK_DOOR)
				{  // Check what sides are blocked around the door
					char block = BIT1 | BIT2 | BIT3 | BIT4;
					char opennum = 0;
					if (x > 0)if (!(levelmap[x - 1][y][z].flag&SITEBLOCK_BLOCK)) { block &= ~BIT2; opennum++; }
					if (x < MAPX - 1)if (!(levelmap[x + 1][y][z].flag&SITEBLOCK_BLOCK)) { block &= ~BIT3; opennum++; }
					if (y > 0)if (!(levelmap[x][y - 1][z].flag&SITEBLOCK_BLOCK)) { block &= ~BIT1; opennum++; }
					if (y < MAPY - 1)if (!(levelmap[x][y + 1][z].flag&SITEBLOCK_BLOCK)) { block &= ~BIT4; opennum++; }
					//if(opennum>=2)continue;
					// Blast open everything around a totally blocked door
					// (door will later be deleted)
					if (block == (BIT1 | BIT2 | BIT3 | BIT4))
					{
						if (x > 0)levelmap[x - 1][y][z].flag &= ~SITEBLOCK_BLOCK;
						if (x < MAPX - 1)levelmap[x + 1][y][z].flag &= ~SITEBLOCK_BLOCK;
						if (y > 0)levelmap[x][y - 1][z].flag &= ~SITEBLOCK_BLOCK;
						if (y < MAPY - 1)levelmap[x][y + 1][z].flag &= ~SITEBLOCK_BLOCK;
					}
					// Open up past doors that lead to walls
					if (!(block&BIT1))
					{
						if (y < MAPY - 1)
						{
							int y1 = y + 1;
							do
							{
								levelmap[x][y1][z].flag &= ~SITEBLOCK_BLOCK;
								levelmap[x][y1][z].flag &= ~SITEBLOCK_DOOR;
								y1++;
							} while (!(levelmap[x + 1][y1][z].flag & (SITEBLOCK_BLOCK | SITEBLOCK_DOOR)) &&
								!(levelmap[x - 1][y1][z].flag & (SITEBLOCK_BLOCK | SITEBLOCK_DOOR)));
						}
						else levelmap[x][y][z].flag |= SITEBLOCK_BLOCK;
					}
					else if (!(block&BIT4))
					{
						if (y > 0)
						{
							int y1 = y - 1;
							do
							{
								levelmap[x][y1][z].flag &= ~SITEBLOCK_BLOCK;
								levelmap[x][y1][z].flag &= ~SITEBLOCK_DOOR;
								y1--;
							} while (!(levelmap[x + 1][y1][z].flag & (SITEBLOCK_BLOCK | SITEBLOCK_DOOR)) &&
								!(levelmap[x - 1][y1][z].flag & (SITEBLOCK_BLOCK | SITEBLOCK_DOOR)));
						}
						else levelmap[x][y][z].flag |= SITEBLOCK_BLOCK;
					}
					else if (!(block&BIT2))
					{
						if (x < MAPX - 1)
						{
							int x1 = x + 1;
							do
							{
								levelmap[x1][y][z].flag &= ~SITEBLOCK_BLOCK;
								levelmap[x1][y][z].flag &= ~SITEBLOCK_DOOR;
								x1++;
							} while (!(levelmap[x1][y + 1][z].flag & (SITEBLOCK_BLOCK | SITEBLOCK_DOOR)) &&
								!(levelmap[x1][y - 1][z].flag & (SITEBLOCK_BLOCK | SITEBLOCK_DOOR)));
						}
						else levelmap[x][y][z].flag |= SITEBLOCK_BLOCK;
					}
					else if (!(block&BIT3))
					{
						if (x > 0)
						{
							int x1 = x - 1;
							do
							{
								levelmap[x1][y][z].flag &= ~SITEBLOCK_BLOCK;
								levelmap[x1][y][z].flag &= ~SITEBLOCK_DOOR;
								x1--;
							} while (!(levelmap[x1][y + 1][z].flag & (SITEBLOCK_BLOCK | SITEBLOCK_DOOR)) &&
								!(levelmap[x1][y - 1][z].flag & (SITEBLOCK_BLOCK | SITEBLOCK_DOOR)));
						}
						else levelmap[x][y][z].flag |= SITEBLOCK_BLOCK;
					}
				}
}
void generateRandomMap(Location &loc) {
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	// Last resort -- generate random map
	levelmap[MAPX >> 1][0][0].flag = SITEBLOCK_EXIT;
	levelmap[(MAPX >> 1) + 1][0][0].flag = SITEBLOCK_EXIT;
	levelmap[(MAPX >> 1) + 1][1][0].flag = SITEBLOCK_EXIT;
	levelmap[(MAPX >> 1) - 1][0][0].flag = SITEBLOCK_EXIT;
	levelmap[(MAPX >> 1) - 1][1][0].flag = SITEBLOCK_EXIT;
	levelmap[MAPX >> 1][1][0].flag = 0;
	levelmap[MAPX >> 1][2][0].flag = SITEBLOCK_DOOR;
	if (loc.type == SITE_RESIDENTIAL_APARTMENT_UPSCALE ||
		loc.type == SITE_RESIDENTIAL_APARTMENT ||
		loc.type == SITE_RESIDENTIAL_TENEMENT)
	{
		levelmap[MAPX >> 1][1][0].special = SPECIAL_SIGN_ONE;
		short height;
		int floors = LCSrandom(6) + 1;
		for (int z = 0; z < floors; z++)
		{
			for (int y = 3; y < MAPY - 3; y++)
			{
				levelmap[MAPX >> 1][y][z].flag = 0;
				if (y % 4 == 0)
				{
					height = y + LCSrandom(3) - 1;
					levelmap[(MAPX >> 1) - 1][height][z].flag = SITEBLOCK_DOOR;
					generateroom((MAPX >> 1) - 8, y - 1, 7, 3, z);
					height = y + LCSrandom(3) - 1;
					levelmap[(MAPX >> 1) + 1][height][z].flag = SITEBLOCK_DOOR;
					generateroom((MAPX >> 1) + 2, y - 1, 7, 3, z);
					if (y == 4 && z == 0)
					{
						levelmap[(MAPX >> 1) + 2][height][z].flag = 0;
						levelmap[(MAPX >> 1) + 2][height][z].special = SPECIAL_APARTMENT_LANDLORD;
					}
				}
			}
			int swap = (z % 2) * 2 - 1;
			if (z > 0)levelmap[(MAPX >> 1) + 1 * swap][MAPY - 4][z].flag = 0, levelmap[(MAPX >> 1) + 1 * swap][MAPY - 4][z].special = SPECIAL_STAIRS_DOWN;
			if (z < floors - 1)levelmap[(MAPX >> 1) - 1 * swap][MAPY - 4][z].flag = 0, levelmap[(MAPX >> 1) - 1 * swap][MAPY - 4][z].special = SPECIAL_STAIRS_UP;
		}
	}
	else
	{
		switch (loc.type)
		{
		case SITE_BUSINESS_LATTESTAND:
			for (int x = (MAPX >> 1) - 4; x <= (MAPX >> 1) + 4; x++)
				for (int y = 0; y < 7; y++)
					levelmap[x][y][0].flag = (x == (MAPX >> 1) - 4 || x == (MAPX >> 1) + 4 || y == 0 || y == 6 ? SITEBLOCK_EXIT : 0), levelmap[x][y][0].special = -1, levelmap[x][y][0].siegeflag = 0;
			break;
		case SITE_BUSINESS_JUICEBAR:
		case SITE_BUSINESS_CIGARBAR:
		case SITE_BUSINESS_VEGANCOOP:
		case SITE_BUSINESS_INTERNETCAFE:
			for (int x = (MAPX >> 1) - 4; x <= (MAPX >> 1) + 4; x++)
				for (int y = 3; y < 10; y++)
					levelmap[x][y][0].flag = 0, levelmap[x][y][0].special = -1, levelmap[x][y][0].siegeflag = 0;
			break;
		case SITE_BUSINESS_CRACKHOUSE:
		{
			int dx = LCSrandom(5) * 2 + 19, dy = LCSrandom(3) * 2 + 7, rx = (MAPX >> 1) - (dx >> 1), ry = 3;
			generateroom(rx, ry, dx, dy, 0);
			break;
		}
		default:
		{
			int dx = LCSrandom(5) * 2 + 35, dy = LCSrandom(3) * 2 + 15, rx = (MAPX >> 1) - (dx >> 1), ry = 3;
			generateroom(rx, ry, dx, dy, 0);
			break;
		}
		}
	}
	// End of old build code. SAV
}
bool isThereNoActivesquad();
void clearActiveSquadForceInc();

/* re-create site from seed before squad arrives */
void initsite(Location &loc)
{
	extern int oldMapMode;
	//PREP
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	extern unsigned long seed[RNG_SIZE];
	if (isThereNoActivesquad())return;
	emptyEncounter();
	clearActiveSquadForceInc();
	delete_and_clear_groundloot();

	//MAKE MAP
	unsigned long oldseed[RNG_SIZE];
	copyRNG(oldseed, seed);
	copyRNG(seed, loc.mapseed);
	// A short guide to how the new maps work...
	//
	//   Edit maps using DAME, the CONST_sitemap031. You can find a maps.dam file
	// to open with DAME in the /dev directory. You can find DAME here (try search engine if link
	// is out of date):
	//   http://dambots.com/dame-editor/
	//
	//   Open up the maps.dam file in DAME. On one side, in the layers listing, you'll see the existing
	// maps. Use the check boxes to hide and show maps. You can create new maps by copying the old ones;
	// right click a top-level group (like NuclearPlant) and select Duplicate. Rename the new map based
	// on the conventions described below.
	//   Editing using the Paint tool ('B') is easy; click the tile you want in the tiles panel, then click
	// the map view to paint with that tile. You may need to experiment a bit to figure out what the
	// specials icons represent, but I've tried to make it pretty self-explanatory. Box-drawing to fill
	// large areas is possible, but a little clunky -- use the Tile Matrix tool ('M') and fill the entire
	// matrix with the tile you want to use by dragging tiles from the tiles panel. You can then box-drag
	// to fill large areas.
	//   When you're done editing, save maps.dam and use File->Export to create the map source files the
	// game can run. In the Export Project dialog, use CONST_sitemap032 for the LUA exporter. CSV dir should
	// be CONST_sitemap033 and File Extension should be CONST_sitemapB040. These are probably the defaults. Press CONST_sitemapC043 and
	// it will automagically build the map source files. You're done -- run the game and visit that
	// location to view the results in-game. You don't even need to make a new game.
	//   To remove a map from the game and go back to the old map generation modes, just delete the .csv
	// files. You may also want to clean up the maps.dam file, removing any old maps you don't want, since
	// it'll try to generate them again next time you export.
	//
	//   Map naming conventions:
	// CONST_sitemap034 - Tile map
	// CONST_sitemap035 - Special locations (vault, equipment, lockup, etc.)
	//   [NAMEHERE] is the name in quotes below, and it's what the maps are called in the DAME layer list.
	// For example, for the industrial apartment, the DAME name is CONST_sitemap036, and the
	// exported file name is CONST_sitemap037. DAME should add the prefix and suffix
	// to the exported files automatically.
	//
	//   Additional Notes:
	// 1. All maps MUST have both a tile map and a special map, even if the special map is blank. This
	// goes for both first floor maps and otherwise.
	// 2. For multi-floor maps, add up stairs to the special map, then create a new set of maps for
	// each additional floor, appending CONST_sitemap038 to the location name for the second floor, CONST_sitemapB041 for
	// third floor, and so on. For example, a second floor to the industrial apartments would have the
	// name CONST_sitemap039 in DAME, and export as CONST_sitemapB042.
	//
	// With love,
	//   Fox
	// Try to load from a map file
	bool loaded = false;
	if (siteReadMap.count(loc.type)) {
		loaded = readMap(siteReadMap[loc.type]);
	}
	else {
	}
	if (!loaded)
	{
		for (int x = 0; x < MAPX; x++)
			for (int y = 0; y < MAPY; y++)
				for (int z = 0; z < MAPZ; z++)
				{
					levelmap[x][y][z].flag = SITEBLOCK_BLOCK;
					levelmap[x][y][z].special = -1;
					levelmap[x][y][z].siegeflag = 0;
				}
	}
	if (loaded)
	{
		if (loc.renting == RENTING_PERMANENT && loc.type != SITE_RESIDENTIAL_APARTMENT &&
			loc.type != SITE_RESIDENTIAL_APARTMENT_UPSCALE && loc.type != SITE_RESIDENTIAL_TENEMENT)
		{
			for (int x = 0; x < MAPX; x++)
				for (int y = 0; y < MAPY; y++)
					for (int z = 0; z < MAPZ; z++)
					{  // Clear high security, locked doors, alarms, and site specials
					   // from LCS non-apartment safehouses
						levelmap[x][y][z].flag &= ~SITEBLOCK_LOCKED;
						levelmap[x][y][z].flag &= ~SITEBLOCK_RESTRICTED;
						levelmap[x][y][z].flag &= ~SITEBLOCK_ALARMED;
						levelmap[x][y][z].special = -1;
					}
		}
	}
	else if (!oldMapMode) // Try to load from the sitemaps
	{
		if (buildThisSite.count(loc.type)) {
			build_site(buildThisSite[loc.type]);
		}
	}
	else {
		generateRandomMap(loc);
	}
	clearBlockedDoorways(loc);
	deleteNonDoors(loc);
	clearBlockedStairwells(loc);
	if (oldMapMode) {
		useOldMapMode(loc);
		copyRNG(seed, oldseed);
		useOldMapModeP2(loc);
	}
	// SAV - End more old map stuff.
	clearOutRestrictions(loc);
	//ADD LOOT
	copyRNG(seed, oldseed);
	addLootToLocation(loc);
	addSemiPermanentChanges(loc);
}
configSiteMap::~configSiteMap()
{
	delete_and_clear(commands);
}
void configSiteMap::configure(const std::string& command, const std::string& value)
{
	if (command == tag_NAME)name = value;
	else if (command == tag_USE)parent = value;
	else if (command == tag_TILE)
	{
		current_command = new configSiteTile(value);
		commands.push_back(current_command);
	}
	else if (command == tag_SCRIPT)
	{
		current_command = new configSiteScript(value);
		commands.push_back(current_command);
	}
	else if (command == tag_SPECIAL)
	{
		current_command = new configSiteSpecial(value);
		commands.push_back(current_command);
	}
	else if (command == tag_UNIQUE)
	{
		current_command = new configSiteUnique(value);
		commands.push_back(current_command);
	}
	else if (command == tag_LOOT)
	{
		current_command = new configSiteLoot(value);
		commands.push_back(current_command);
	}
	else current_command->configure(command, value);
}
void configSiteMap::build()
{
	if (len(parent)) build_site(parent);
	for (int step = 0; step < len(commands); step++) commands[step]->build();
}
map<string, short> site_tile_list;
configSiteTile::configSiteTile(const std::string& value)
	: xstart(0), xend(0), ystart(0), yend(0), zstart(0), zend(0), addtype(0)
{
	if (site_tile_list.count(value)) {
		tile = site_tile_list[value];
	}
}
void configSiteTile::configure(const std::string& command, const std::string& value)
{
	if (command == tag_XSTART)xstart = atoi(value.c_str()) + (MAPX >> 1);
	else if (command == tag_XEND)xend = atoi(value.c_str()) + (MAPX >> 1);
	else if (command == tag_X)xstart = xend = atoi(value.c_str()) + (MAPX >> 1);
	else if (command == tag_YSTART)ystart = atoi(value.c_str());
	else if (command == tag_YEND)yend = atoi(value.c_str());
	else if (command == tag_Y)ystart = yend = atoi(value.c_str());
	else if (command == tag_ZSTART)zstart = atoi(value.c_str());
	else if (command == tag_ZEND)zend = atoi(value.c_str());
	else if (command == tag_Z)zstart = zend = atoi(value.c_str());
	else if (command == tag_NOTE)
	{
		if (value == tag_ADD)addtype = SITEMAP_ADDTYPE_OR;
		else if (value == tag_SUBTRACT)addtype = SITEMAP_ADDTYPE_ANDNOT;
	}
}
void configSiteTile::build()
{
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	for (int x = xstart; x <= xend; x++)
		for (int y = ystart; y <= yend; y++)
			for (int z = zstart; z <= zend; z++)
				if (addtype == SITEMAP_ADDTYPE_OR)levelmap[x][y][z].flag |= tile;
				else if (addtype == SITEMAP_ADDTYPE_ANDNOT)levelmap[x][y][z].flag &= ~tile;
				else levelmap[x][y][z].flag = tile;
}
configSiteScript::configSiteScript(const std::string& value)
	: xstart(0), xend(0), ystart(0), yend(0), zstart(0), zend(0)
{
	if (value == tag_ROOM)script = SITEMAPSCRIPT_ROOM;
	else if (value == tag_HALLWAY_YAXIS)script = SITEMAPSCRIPT_HALLWAY_YAXIS;
	else if (value == tag_STAIRS)script = SITEMAPSCRIPT_STAIRS;
	else if (value == tag_STAIRS_RANDOM)script = SITEMAPSCRIPT_STAIRS_RANDOM;
}
void configSiteScript::configure(const std::string& command, const std::string& value)
{
	if (command == tag_XSTART)xstart = atoi(value.c_str()) + (MAPX >> 1);
	else if (command == tag_XEND)xend = atoi(value.c_str()) + (MAPX >> 1);
	else if (command == tag_YSTART)ystart = atoi(value.c_str());
	else if (command == tag_YEND)yend = atoi(value.c_str());
	else if (command == tag_ZSTART)zstart = atoi(value.c_str());
	else if (command == tag_ZEND)zend = atoi(value.c_str());
}
void configSiteScript::build()
{
	if (script == SITEMAPSCRIPT_ROOM)
		for (int z = zstart; z <= zend; z++)
			generateroom(xstart, ystart, xend - xstart, yend - ystart, z);
	else if (script == SITEMAPSCRIPT_HALLWAY_YAXIS)
		for (int z = zstart; z <= zend; z++)
			generatehallway_y(xstart, ystart, xend - xstart, yend - ystart, z);
	else if (script == SITEMAPSCRIPT_STAIRS)
		generatestairs(xstart, ystart, zstart, xend - xstart, yend - ystart, zend - zstart);
	else if (script == SITEMAPSCRIPT_STAIRS_RANDOM)
		generatestairsrandom(xstart, ystart, zstart, xend - xstart, yend - ystart, zend - zstart);
}
const int ROOMDIMENSION = 3;
/* recursive dungeon-generating algorithm */
void configSiteScript::generateroom(int rx, int ry, int dx, int dy, int z)
{
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	for (int x = rx; x < rx + dx; x++)
		for (int y = ry; y < ry + dy; y++)
			levelmap[x][y][z].flag &= ~SITEBLOCK_BLOCK;
	// Chance to stop iterating for large rooms
	if ((dx <= (ROOMDIMENSION + 1) || dy <= (ROOMDIMENSION + 1)) &&
		dx < dy * 2 && dy < dx * 2 && !LCSrandom(2))return;
	// Very likely to stop iterating for small rooms
	if (dx <= ROOMDIMENSION && dy <= ROOMDIMENSION)return;
	// Guaranteed to stop iterating for hallways
	if (dx <= 1 || dy <= 1)return;
	//LAY DOWN WALL AND ITERATE
	if ((!LCSrandom(2) || dy <= ROOMDIMENSION) && dx > ROOMDIMENSION)
	{
		int wx = rx + LCSrandom(dx - ROOMDIMENSION) + 1;
		for (int wy = 0; wy < dy; wy++)levelmap[wx][ry + wy][z].flag |= SITEBLOCK_BLOCK;
		int rny = LCSrandom(dy);
		levelmap[wx][ry + rny][z].flag &= ~SITEBLOCK_BLOCK;
		levelmap[wx][ry + rny][z].flag |= SITEBLOCK_DOOR;
		if (!LCSrandom(3))levelmap[wx][ry + rny][z].flag |= SITEBLOCK_LOCKED;
		generateroom(rx, ry, wx - rx, dy, z);
		generateroom(wx + 1, ry, rx + dx - wx - 1, dy, z);
	}
	else
	{
		int wy = ry + LCSrandom(dy - ROOMDIMENSION) + 1;
		for (int wx = 0; wx < dx; wx++)levelmap[rx + wx][wy][z].flag |= SITEBLOCK_BLOCK;
		int rnx = LCSrandom(dx);
		levelmap[rx + rnx][wy][z].flag &= ~SITEBLOCK_BLOCK;
		levelmap[rx + rnx][wy][z].flag |= SITEBLOCK_DOOR;
		if (!LCSrandom(3))levelmap[rx + rnx][wy][z].flag |= SITEBLOCK_LOCKED;
		generateroom(rx, ry, dx, wy - ry, z);
		generateroom(rx, wy + 1, dx, ry + dy - wy - 1, z);
	}
}
/* generates a hallway with rooms on either side */
void configSiteScript::generatehallway_y(int rx, int ry, int dx, int dy, int z)
{
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	for (int y = ry; y < ry + dy; y++)
	{  // Clear hallway
		levelmap[rx][y][z].flag = 0;
		// Every four tiles
		if (y % 4 == 0)
		{
			// Pick a door location for the left
			char door_y = y + LCSrandom(3) - 1;
			// Create the left door
			levelmap[rx - 1][(int)door_y][z].flag &= ~SITEBLOCK_BLOCK;
			levelmap[rx - 1][(int)door_y][z].flag |= SITEBLOCK_DOOR;
			// Construct apartment on the left
			generateroom(rx - dx - 1, y - 1, dx, 3, z);
			// Pick a door location for the right
			door_y = y + LCSrandom(3) - 1;
			// Create the right door
			levelmap[rx + 1][(int)door_y][z].flag &= ~SITEBLOCK_BLOCK;
			levelmap[rx + 1][(int)door_y][z].flag |= SITEBLOCK_DOOR;
			// Construct apartment on the right
			generateroom(rx + 2, y - 1, dx, 3, z);
		}
	}
}
/* generates a stairwell, must have (dx or dy) and dz at least 1 */
void configSiteScript::generatestairs(int rx, int ry, int rz, int dx, int dy, int dz)
{
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	for (int z = rz; z <= rz + dz; z++)
	{
		if (z > rz) // If not bottom floor, add down stairs
		{
			if (z % 2) // Causes stairwell to swap sides every other floor
			{  // Purge all tiles other than restriction, add stairs
				levelmap[rx + dx][ry + dy][z].flag &= SITEBLOCK_RESTRICTED;
				levelmap[rx + dx][ry + dy][z].special = SPECIAL_STAIRS_DOWN;
			}
			else
			{
				levelmap[rx][ry][z].flag &= SITEBLOCK_RESTRICTED;
				levelmap[rx][ry][z].special = SPECIAL_STAIRS_DOWN;
			}
		}
		if (z < rz + dz) // If not top floor, add up stairs
		{
			if (!(z % 2))
			{  // Purge all tiles other than restriction, add stairs
				levelmap[rx + dx][ry + dy][z].flag &= SITEBLOCK_RESTRICTED;
				levelmap[rx + dx][ry + dy][z].special = SPECIAL_STAIRS_UP;
			}
			else
			{
				levelmap[rx][ry][z].flag &= SITEBLOCK_RESTRICTED;
				levelmap[rx][ry][z].special = SPECIAL_STAIRS_UP;
			}
		}
	}
}
void configSiteScript::generatestairsrandom(int rx, int ry, int rz, int dx, int dy, int dz)
{
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	int x, y, z;
	vector< std::pair<int, int> > secure, secure_above, unsecure, unsecure_above;
	// Look through bottom level for secure and unsecure tiles.
	for (int xi = xstart; xi <= xend; xi++)
		for (int yi = ystart; yi <= yend; yi++)
			if (!(levelmap[xi][yi][0].flag & (SITEBLOCK_DOOR | SITEBLOCK_BLOCK | SITEBLOCK_EXIT | SITEBLOCK_OUTDOOR)) &&
				levelmap[xi][yi][0].special == SPECIAL_NONE)
			{
				if (levelmap[xi][yi][0].flag & SITEBLOCK_RESTRICTED)
					secure.push_back(std::make_pair(xi, yi));
				else unsecure.push_back(std::make_pair(xi, yi));
			}
	for (int zi = zstart + 1; zi <= zend; zi++)
	{
		// Look through level above for secure and unsecure tiles.
		for (int xi = xstart; xi <= xend; xi++)
			for (int yi = ystart; yi <= yend; yi++)
				if (!(levelmap[xi][yi][zi].flag & (SITEBLOCK_DOOR | SITEBLOCK_BLOCK | SITEBLOCK_EXIT | SITEBLOCK_OUTDOOR)) &&
					levelmap[xi][yi][zi].special == SPECIAL_NONE)
				{
					if (levelmap[xi][yi][zi].flag & SITEBLOCK_RESTRICTED)
						secure_above.push_back(std::make_pair(xi, yi));
					else unsecure_above.push_back(std::make_pair(xi, yi));
				}
		// Stairs in secure areas should only lead into secure areas.
		// Removing secure tiles without secure tiles above them.
		//int i, j;
		for (int i = len(unsecure) - 1; i >= 0; i--)
		{
			int j;
			for (j = 0; j < len(secure_above); j++)
			{
				if (secure_above[j] == secure[i]) break;
				else if ((secure_above[j].first == secure[i].first&&secure_above[j].second > secure[i].second)
					|| (secure_above[j].first > secure[i].first))
				{
					secure.erase(secure.begin() + i); break;
				}
			}
			if (j == len(secure_above)) secure.erase(secure.begin() + i);
		}
		// Stairs in unsecure areas should only lead into unsecure areas.
		// Removing unsecure tiles without unsecure tiles above them.
		for (int i = len(unsecure) - 1; i >= 0; i--)
		{
			int j;
			for (j = 0; j < len(unsecure_above); j++)
			{
				if (unsecure_above[j] == unsecure[i]) break;
				else if ((unsecure_above[j].first == unsecure[i].first&&unsecure_above[j].second > unsecure[i].second)
					|| (unsecure_above[j].first > unsecure[i].first))
				{
					unsecure.erase(unsecure.begin() + i); break;
				}
			}
			if (j == len(unsecure_above)) unsecure.erase(unsecure.begin() + i);
		}
		// Place stairs in secure area if possible, otherwise unsecure area.
		if (len(secure))
		{
			std::pair<int, int> &choice = pickrandom(secure);
			x = choice.first, y = choice.second, z = zi - 1;
			// The tile receiving the stairs down will not eligible for stairs
			// up later.
			for (int j = 0; j < len(secure_above); j++)
				if (secure_above[j].first == x && secure_above[j].second == y)
				{
					secure_above.erase(secure_above.begin() + j); break;
				}
		}
		else if (len(unsecure))
		{
			std::pair<int, int> &choice = pickrandom(unsecure);
			x = choice.first, y = choice.second, z = zi - 1;
			// The tile receiving the stairs down will not eligible for stairs
			// up later.
			for (int j = 0; j < len(unsecure_above); j++)
				if (unsecure_above[j].first == x && unsecure_above[j].second == y)
				{
					unsecure_above.erase(unsecure_above.begin() + j); break;
				}
		}
		else continue; //Nowhere to place stairs.
		levelmap[x][y][z].special = SPECIAL_STAIRS_UP, levelmap[x][y][z + 1].special = SPECIAL_STAIRS_DOWN;
		// Move up on level for next iteration.
		secure = secure_above;
		secure_above.clear();
		unsecure = unsecure_above;
		unsecure_above.clear();
	}
}
configSiteSpecial::configSiteSpecial(const std::string& value)
	: xstart(0), xend(0), ystart(0), yend(0), zstart(0), zend(0), freq(1)
{
	if (getSpecial.count(value)) {
		special = getSpecial[value];
	}
}
void configSiteSpecial::configure(const std::string& command, const std::string& value)
{
	if (command == tag_XSTART)xstart = atoi(value.c_str()) + (MAPX >> 1);
	else if (command == tag_XEND)xend = atoi(value.c_str()) + (MAPX >> 1);
	else if (command == tag_X)xstart = xend = atoi(value.c_str()) + (MAPX >> 1);
	else if (command == tag_YSTART)ystart = atoi(value.c_str());
	else if (command == tag_YEND)yend = atoi(value.c_str());
	else if (command == tag_Y)ystart = yend = atoi(value.c_str());
	else if (command == tag_ZSTART)zstart = atoi(value.c_str());
	else if (command == tag_ZEND)zend = atoi(value.c_str());
	else if (command == tag_Z)zstart = zend = atoi(value.c_str());
	else if (command == tag_FREQ)freq = atoi(value.c_str());
}
void configSiteSpecial::build()
{
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	for (int x = xstart; x <= xend; x++)
		for (int y = ystart; y <= yend; y++)
			for (int z = zstart; z <= zend; z++)
				if (!LCSrandom(freq))levelmap[x][y][z].special = special;
}
configSiteUnique::configSiteUnique(const std::string& value)
	: xstart((MAPX >> 1) - 5), xend((MAPX >> 1) + 5), ystart(10), yend(20), zstart(0), zend(0)
{
	if (getUnique.count(value)) {
		unique = getUnique[value];
	}
}
void configSiteUnique::configure(const std::string& command, const std::string& value)
{
	if (command == tag_Z)zstart = zend = atoi(value.c_str());
}
struct coordinates
{
	coordinates(int x1, int y1, int z1) : x(x1), y(y1), z(z1) { }
	int x, y, z;
};
void configSiteUnique::build()
{
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	//int count=0;
	vector<coordinates> secure, unsecure;
	//Clear out restrictions
	char acted;
	do
	{
		acted = 0;
		for (int x = 2; x < MAPX - 2; x++)
			for (int y = 2; y < MAPY - 2; y++)
				for (int z = 0; z < MAPZ; z++)
				{
					//Un-restrict blocks if they have neighboring
					//unrestricted blocks
					if (!(levelmap[x][y][z].flag & SITEBLOCK_DOOR) &&
						!(levelmap[x][y][z].flag & SITEBLOCK_BLOCK) &&
						(levelmap[x][y][z].flag & SITEBLOCK_RESTRICTED))
					{
						if ((!(levelmap[x - 1][y][z].flag & SITEBLOCK_RESTRICTED) &&
							!(levelmap[x - 1][y][z].flag & SITEBLOCK_BLOCK)) ||
							(!(levelmap[x + 1][y][z].flag & SITEBLOCK_RESTRICTED) &&
								!(levelmap[x + 1][y][z].flag & SITEBLOCK_BLOCK)) ||
								(!(levelmap[x][y - 1][z].flag & SITEBLOCK_RESTRICTED) &&
									!(levelmap[x][y - 1][z].flag & SITEBLOCK_BLOCK)) ||
									(!(levelmap[x][y + 1][z].flag & SITEBLOCK_RESTRICTED) &&
										!(levelmap[x][y + 1][z].flag & SITEBLOCK_BLOCK)))
						{
							levelmap[x][y][z].flag &= ~SITEBLOCK_RESTRICTED;
							acted = 1;
							continue;
						}
					}
					//Un-restrict and unlock doors if they lead between two
					//unrestricted sections. If they lead between one
					//unrestricted section and a restricted section, lock
					//them instead.
					else if ((levelmap[x][y][z].flag & SITEBLOCK_DOOR) &&
						!(levelmap[x][y][z].flag & SITEBLOCK_BLOCK) &&
						(levelmap[x][y][z].flag & SITEBLOCK_RESTRICTED))
					{  //Unrestricted on two opposite sides?
						if ((!(levelmap[x - 1][y][z].flag & SITEBLOCK_RESTRICTED) &&
							!(levelmap[x + 1][y][z].flag & SITEBLOCK_RESTRICTED)) ||
							(!(levelmap[x][y - 1][z].flag & SITEBLOCK_RESTRICTED) &&
								!(levelmap[x][y + 1][z].flag & SITEBLOCK_RESTRICTED)))
						{
							//Unlock and unrestrict
							levelmap[x][y][z].flag &= ~SITEBLOCK_LOCKED;
							levelmap[x][y][z].flag &= ~SITEBLOCK_RESTRICTED;
							acted = 1;
							continue;
						}
						//Unrestricted on at least one side and I'm not locked?
						else if ((!(levelmap[x - 1][y][z].flag & SITEBLOCK_RESTRICTED) ||
							!(levelmap[x + 1][y][z].flag & SITEBLOCK_RESTRICTED) ||
							!(levelmap[x][y - 1][z].flag & SITEBLOCK_RESTRICTED) ||
							!(levelmap[x][y + 1][z].flag & SITEBLOCK_RESTRICTED)) &&
							!(levelmap[x][y][z].flag & SITEBLOCK_LOCKED))
						{  //Lock doors leading to restricted areas
							levelmap[x][y][z].flag |= SITEBLOCK_LOCKED;
							acted = 1;
							continue;
						}
					}
				}
	} while (acted);
	// Place unique
	for (int x = xstart; x <= xend; x++)
		for (int y = ystart; y <= yend; y++)
			for (int z = zstart; z <= zend; z++)
				if (!(levelmap[x][y][z].flag & (SITEBLOCK_DOOR | SITEBLOCK_BLOCK | SITEBLOCK_EXIT | SITEBLOCK_OUTDOOR)) &&
					levelmap[x][y][z].special == SPECIAL_NONE)
				{
					if (levelmap[x][y][z].flag & SITEBLOCK_RESTRICTED)
						secure.push_back(coordinates(x, y, z));
					else unsecure.push_back(coordinates(x, y, z));
				}

	if (len(secure))
	{
		coordinates &choice = pickrandom(secure);
		levelmap[choice.x][choice.y][choice.z].special = unique;
	}
	else if (len(unsecure))
	{
		coordinates &choice = pickrandom(unsecure);
		levelmap[choice.x][choice.y][choice.z].special = unique;
	}
}
// Adds a loot type during map creation
configSiteLoot::configSiteLoot(const std::string& value)
	: weight(0)
{
	if (getLootString.count(value)) {
		loot = getLootString[value];
	}
}
void configSiteLoot::configure(const std::string& command, const std::string& value)
{
	if (command == tag_WEIGHT)weight = atoi(value.c_str());
}
void configSiteLoot::build()
{
	// currently no-op until loot system is revised
}

// // #include "../includes.h"
const string CONST_sitemode179 = "-D";
const string CONST_sitemode178 = "                                                                                ";
const string CONST_sitemode177 = "C - Reflect on your Conservative ineptitude";
const string CONST_sitemode176 = "R - Reorganize";
const string CONST_sitemode175 = "R - Release hostage";
const string CONST_sitemode174 = "R - Release oppressed";
const string CONST_sitemode173 = "F - Fight!";
const string CONST_sitemode172 = "E - Equip";
const string CONST_sitemode171 = "V - Evade";
const string CONST_sitemode170 = "V - Run";
const string CONST_sitemode169 = "V - Sneak";
const string CONST_sitemode168 = "U - Use";
const string CONST_sitemode167 = "U - Graffiti";
const string CONST_sitemode166 = "T - Talk";
const string CONST_sitemode165 = "K - Kidnap";
const string CONST_sitemode164 = "L - Reload";
const string CONST_sitemode163 = "S - Wait";
const string CONST_sitemode162 = "M - Map";
const string CONST_sitemode161 = "N - Options";
const string CONST_sitemode160 = "G - Get Loot";
const string CONST_sitemodeXRL = "J - Reload Empty";
const string CONST_sitemode159 = "W,A,D,X - Move";
const string CONST_sitemode158 = ": CONSERVATIVES SUSPICIOUS";
const string CONST_sitemode157 = ": CONSERVATIVES ALARMED";
const string CONST_sitemode156 = ": ALIENATED EVERYONE";
const string CONST_sitemode155 = ": ALIENATED MASSES";
const string CONST_sitemode154 = ": CONSERVATIVE REINFORCEMENTS INCOMING";
const string CONST_sitemode153 = ": POLICE RESPONDING";
const string CONST_sitemode152 = ": DEATH SQUADS RESPONDING";
const string CONST_sitemode151 = ": CCS VIGILANTIES RESPONDING";
const string CONST_sitemode150 = ": GANG MEMBERS RESPONDING";
const string CONST_sitemode149 = ": ANGRY MOB RESPONDING";
const string CONST_sitemode148 = ": MERCENARIES RESPONDING";
const string CONST_sitemode147 = ": AGENTS RESPONDING";
const string CONST_sitemode146 = ": SECRET SERVICE RESPONDING";
const string CONST_sitemode145 = ": SOLDIERS AND TANKS RESPONDING";
const string CONST_sitemode144 = ", Level ";
const string CONST_sitemode143 = ": Escape or Engage";
const string CONST_sitemode141 = "Prisoner";
const string CONST_sitemode140 = "There is a crowd of people passing by.";
const string CONST_sitemode139 = "There is a crowd of people up ahead.";
const string CONST_sitemode138 = "There is a group of people passing by.";
const string CONST_sitemode137 = "There is a group of people up ahead.";
const string CONST_sitemode136 = "There are a few people passing by.";
const string CONST_sitemode135 = "There are a few people up ahead.";
const string CONST_sitemode134 = "There is someone passing by.";
const string CONST_sitemode133 = "There is someone up ahead.";
const string CONST_sitemode132 = "The landlord is in.";
const string CONST_sitemode131 = "The landlord is out of the office.";
const string CONST_sitemode130 = "The CEO's study lies empty.";
const string CONST_sitemode129 = "The CEO is in his study.";
const string CONST_sitemode128 = "The CEO must have fled to a panic room.";
const string CONST_sitemode127 = "[Rats!] ";
const string CONST_sitemode126 = "Damn! ";
const string CONST_sitemode125 = "There are people sitting here.";
const string CONST_sitemode124 = "The bench is empty.";
const string CONST_sitemode123 = "The table is occupied.";
const string CONST_sitemode122 = "Some people are hiding under the table.";
const string CONST_sitemode121 = "The computer is occupied.";
const string CONST_sitemode120 = "The computer has been unplugged.";
const string CONST_sitemode119 = "the power of your Liberal Convictions!";
const string CONST_sitemode118 = "The Conservatives have shrunk back under ";
const string CONST_sitemode117 = "The CCS has been broken!";
const string CONST_sitemode116 = " has left ";
const string CONST_sitemode115 = "The squad sneaks past the conservatives!";
const string CONST_sitemode114 = "You find: ";
const string CONST_sitemode113 = " you, feeling safer getting out alone.";
const string CONST_sitemode112 = "One Liberal leaves";
const string CONST_sitemode111 = "The Liberal leaves";
const string CONST_sitemode110 = "Some leave";
const string CONST_sitemode109 = "They all leave";
const string CONST_sitemode108 = " from the Conservatives.";
const string CONST_sitemode107 = "an Oppressed Liberal";
const string CONST_sitemode106 = "some Oppressed Liberals";
const string CONST_sitemode105 = "You free ";
const string CONST_sitemode102 = "You have to deal with the enemies first.";
const string CONST_sitemode101 = " won't talk to you.";
const string CONST_sitemode100 = "To whom?";
const string CONST_sitemode099 = "Bluff";
const string CONST_sitemode098 = "Dating";
const string CONST_sitemode097 = "Issues";
const string CONST_sitemode096 = "Which Liberal will speak?";
const string CONST_sitemode095 = "[ ] M - Music";
const string CONST_sitemode094 = "[ ] E - Encounter warnings";
const string CONST_sitemode093 = "Site mode options";
const string CONST_sitemode092 = "Which way?  (W,A,D, and X to move, ENTER to abort)";
const string CONST_sitemode091 = "It opens easily. The alarm goes off!";
const string CONST_sitemode090 = "The alarm goes off!";
const string CONST_sitemode089 = "Force it open? (Yes or No)";
const string CONST_sitemode088 = "It's locked from the other side.";
const string CONST_sitemode087 = "locked.";
const string CONST_sitemode086 = "still ";
const string CONST_sitemode085 = "You shake the handle but it is ";
const string CONST_sitemode084 = "Your tampering sets off the alarm!";
const string CONST_sitemode083 = "Try to pick the lock? (Yes or No)";
const string CONST_sitemode082 = "You try the door, but it is locked.";
const string CONST_sitemode081 = "Try the door anyway? (Yes or No)";
const string CONST_sitemode080 = "EMERGENCY EXIT ONLY. ALARM WILL SOUND.";
const string CONST_sitemode079 = "This door appears to be wired up to an alarm.";
const string CONST_sitemode078 = "The vault door is impenetrable.";
const string CONST_sitemode077 = "too hot";
const string CONST_sitemode076 = "Your hostage is free.";
const string CONST_sitemode075 = "Your hostages are free.";
const string CONST_sitemode074 = "The police subdue and arrest the squad.";

const string tag_WEAPON_FLAMETHROWER = "WEAPON_FLAMETHROWER";
const string tag_LOOT_COMPUTER = "LOOT_COMPUTER";
const string tag_LOOT_CHEAPJEWELERY = "LOOT_CHEAPJEWELERY";
const string tag_LOOT_TRINKET = "LOOT_TRINKET";
const string tag_LOOT_SILVERWARE = "LOOT_SILVERWARE";
const string tag_LOOT_CELLPHONE = "LOOT_CELLPHONE";
const string tag_ARMOR_CIVILLIANARMOR = "ARMOR_CIVILLIANARMOR";
const string tag_ARMOR_SECURITYUNIFORM = "ARMOR_SECURITYUNIFORM";
const string tag_ARMOR_ARMYARMOR = "ARMOR_ARMYARMOR";
const string tag_ARMOR = "ARMOR";
const string tag_ARMOR_HEAVYARMOR = "ARMOR_HEAVYARMOR";
const string tag_ARMOR_CHEAPSUIT = "ARMOR_CHEAPSUIT";
const string tag_ARMOR_WORKCLOTHES = "ARMOR_WORKCLOTHES";
const string tag_ARMOR_CLOTHES = "ARMOR_CLOTHES";
const string tag_ARMOR_TRENCHCOAT = "ARMOR_TRENCHCOAT";
const string tag_WEAPON_AUTORIFLE_M16 = "WEAPON_AUTORIFLE_M16";
const string tag_WEAPON_SMG_MP5 = "WEAPON_SMG_MP5";
const string tag_WEAPON_CARBINE_M4 = "WEAPON_CARBINE_M4";
const string tag_WEAPON_REVOLVER_38 = "WEAPON_REVOLVER_38";
const string tag_WEAPON_REVOLVER_44 = "WEAPON_REVOLVER_44";
const string tag_WEAPON_SEMIPISTOL_9MM = "WEAPON_SEMIPISTOL_9MM";
const string tag_WEAPON_SEMIPISTOL_45 = "WEAPON_SEMIPISTOL_45";
const string tag_LOOT_PDA = "LOOT_PDA";
const string tag_LOOT_MICROPHONE = "LOOT_MICROPHONE";
const string tag_LOOT_CABLENEWSFILES = "LOOT_CABLENEWSFILES";
const string tag_LOOT_AMRADIOFILES = "LOOT_AMRADIOFILES";
const string tag_LOOT_FAMILYPHOTO = "LOOT_FAMILYPHOTO";
const string tag_LOOT_WATCH = "LOOT_WATCH";
const string tag_ARMOR_BONDAGEGEAR = "ARMOR_BONDAGEGEAR";
const string tag_ARMOR_EXPENSIVESUIT = "ARMOR_EXPENSIVESUIT";
const string tag_ARMOR_EXPENSIVEDRESS = "ARMOR_EXPENSIVEDRESS";
const string tag_LOOT_CORPFILES = "LOOT_CORPFILES";
const string tag_LOOT_CHEMICAL = "LOOT_CHEMICAL";
const string tag_LOOT_FINECLOTH = "LOOT_FINECLOTH";
const string tag_ARMOR_BUNKERGEAR = "ARMOR_BUNKERGEAR";
const string tag_LOOT_SECRETDOCUMENTS = "LOOT_SECRETDOCUMENTS";
const string tag_WEAPON_SHANK = "WEAPON_SHANK";
const string tag_ARMOR_PRISONER = "ARMOR_PRISONER";
const string tag_LOOT_JUDGEFILES = "LOOT_JUDGEFILES";
const string tag_LOOT_POLICERECORDS = "LOOT_POLICERECORDS";
const string tag_ARMOR_POLICEARMOR = "ARMOR_POLICEARMOR";
const string tag_ARMOR_SWATARMOR = "ARMOR_SWATARMOR";
const string tag_ARMOR_POLICEUNIFORM = "ARMOR_POLICEUNIFORM";
const string tag_ARMOR_DEATHSQUADUNIFORM = "ARMOR_DEATHSQUADUNIFORM";
const string tag_WEAPON_SHOTGUN_PUMP = "WEAPON_SHOTGUN_PUMP";
const string tag_WEAPON_NIGHTSTICK = "WEAPON_NIGHTSTICK";
const string tag_LOOT_LABEQUIPMENT = "LOOT_LABEQUIPMENT";
const string tag_LOOT_RESEARCHFILES = "LOOT_RESEARCHFILES";
const string tag_LOOT_EXPENSIVEJEWELERY = "LOOT_EXPENSIVEJEWELERY";
const string tag_ARMOR_BLACKROBE = "ARMOR_BLACKROBE";
const string tag_ARMOR_LABCOAT = "ARMOR_LABCOAT";
const string tag_ARMOR_BLACKDRESS = "ARMOR_BLACKDRESS";
const string tag_ARMOR_BLACKSUIT = "ARMOR_BLACKSUIT";
const string tag_WEAPON_SEMIRIFLE_AR15 = "WEAPON_SEMIRIFLE_AR15";
const string tag_WEAPON_COMBATKNIFE = "WEAPON_COMBATKNIFE";
const string tag_WEAPON_BASEBALLBAT = "WEAPON_BASEBALLBAT";
const string tag_WEAPON_DAISHO = "WEAPON_DAISHO";
const string tag_ARMOR_CLOWNSUIT = "ARMOR_CLOWNSUIT";
const string tag_ARMOR_DONKEYSUIT = "ARMOR_DONKEYSUIT";
const string tag_ARMOR_ELEPHANTSUIT = "ARMOR_ELEPHANTSUIT";
const string tag_ARMOR_CHEAPDRESS = "ARMOR_CHEAPDRESS";
const string tag_WEAPON_GUITAR = "WEAPON_GUITAR";
const string tag_LOOT_DIRTYSOCK = "LOOT_DIRTYSOCK";
const string tag_LOOT_KIDART = "LOOT_KIDART";
const string tag_ARMOR_TOGA = "ARMOR_TOGA";
const string tag_WEAPON_SYRINGE = "WEAPON_SYRINGE";
const string tag_WEAPON_CHAIN = "WEAPON_CHAIN";
const string tag_WEAPON_CROWBAR = "WEAPON_CROWBAR";


#define CH_FULL_BLOCK 0xdb
#define CH_UPWARDS_ARROW 0x18
#define CH_DOWNWARDS_ARROW 0x19
#define CH_BLACK_SMILING_FACE 0x02
#define CH_YEN_SIGN 0x9d
#define CH_BOX_DRAWINGS_DOUBLE_VERTICAL 0xba
#define CH_BOX_DRAWINGS_DOUBLE_HORIZONTAL 0xcd
#define CH_WHITE_SMILING_FACE 0x01

void special_bouncer_assess_squad();
void special_bouncer_greet_squad();
void special_lab_cosmetics_cagedanimals();
void special_readsign(int sign);
void special_nuclear_onoff();
void special_lab_genetic_cagedanimals();
void special_policestation_lockup();
void special_courthouse_lockup();
void special_courthouse_jury();
void special_prison_control(short prison_control_type);
void special_intel_supercomputer();
void special_sweatshop_equipment();
void special_polluter_equipment();
void special_house_photos();
void special_corporate_files();
void special_radio_broadcaststudio();
void special_news_broadcaststudio();
void special_graffiti();
void special_armory();
void special_display_case();
void special_security_checkpoint();
void special_security_metaldetectors();
void special_security_secondvisit();
void special_bank_teller();
void special_bank_money();
void special_bank_vault();
void special_ccs_boss();
void special_oval_office();
#include "../sitemode/stealth.h"
#include "../sitemode/miscactions.h"
//void reloadparty(bool wasteful = false);
// // #include "sitedisplay.h"
//// // #include "sitemode/newencounter.h"
void prepareencounter(short type, char sec);
char addsiegeencounter(char type);

//// // #include "common/equipment.h"
/* review squad equipment */
void equip(vector<Item *> &loot, int loc);
//// // #include "daily/daily.h"
/* daily - returns true if the site type supports high security */
char securityable(int type);
char talk(Creature &a, const int t);

void emptyEncounter();
void delete_and_clear_groundloot();
bool isThereGroundLoot();
//extern string singleSpace;
void deleteVehicle(int carid);
void deleteVehicles(vector<Vehicle *>& carid);
void fight_subdued()
{
	extern Log gamelog;
	extern squadst *activesquad;
	extern chaseseqst chaseseq;
	//int p;
	//int ps=find_police_station(chaseseq.location);
	deleteVehicles(chaseseq.friendcar);
	int hostages = 0;
	for (int p = 0; p < 6; p++)
		if (activesquad->squad[p] != NULL)
			if (activesquad->squad[p]->prisoner&&activesquad->squad[p]->prisoner->align != ALIGN_LIBERAL)
				hostages++;
	int stolen = 0;
	// Police assess stolen goods in inventory
	for (int l = 0; l < len(activesquad->loot); l++)
		if (activesquad->loot[l]->whatIsThis() == THIS_IS_LOOT)
			stolen++;
	for (int p = 0; p < 6; p++)
	{
		if (!activesquad->squad[p]) continue;
		activesquad->squad[p]->crimes_suspected[LAWFLAG_THEFT] += stolen;
		capturecreature(*(activesquad->squad[p]));
		activesquad->squad[p] = NULL;
	}
	CreaturePool::getInstance().stopAllBleeding();
	clearmessagearea();
	clearcommandarea();
	set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
	mvaddstrAlt(16, 1, CONST_sitemode074, gamelog);
	gamelog.newline();
	if (hostages > 0)
	{
		if (hostages > 1) {
			mvaddstrAlt(17, 1, CONST_sitemode075, gamelog);
		}
		else {
			mvaddstrAlt(17, 1, CONST_sitemode076, gamelog);
		}
	}
	gamelog.newline();
	pressAnyKey();
}

/* marks the area around the specified tile as explored */
void knowmap(int locx, int locy, int locz)
{
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	levelmap[locx][locy][locz].flag |= SITEBLOCK_KNOWN;
	if (locx > 0)levelmap[locx - 1][locy][locz].flag |= SITEBLOCK_KNOWN;
	if (locx < MAPX - 1)levelmap[locx + 1][locy][locz].flag |= SITEBLOCK_KNOWN;
	if (locy > 0)levelmap[locx][locy - 1][locz].flag |= SITEBLOCK_KNOWN;
	if (locy < MAPY - 1)levelmap[locx][locy + 1][locz].flag |= SITEBLOCK_KNOWN;
	if (locx > 0 && locy > 0)
		if (!(levelmap[locx - 1][locy][locz].flag & SITEBLOCK_BLOCK) ||
			!(levelmap[locx][locy - 1][locz].flag & SITEBLOCK_BLOCK))
			levelmap[locx - 1][locy - 1][locz].flag |= SITEBLOCK_KNOWN;
	if (locx < MAPX - 1 && locy>0)
		if (!(levelmap[locx + 1][locy][locz].flag & SITEBLOCK_BLOCK) ||
			!(levelmap[locx][locy - 1][locz].flag & SITEBLOCK_BLOCK))
			levelmap[locx + 1][locy - 1][locz].flag |= SITEBLOCK_KNOWN;
	if (locx > 0 && locy < MAPY - 1)
		if (!(levelmap[locx - 1][locy][locz].flag & SITEBLOCK_BLOCK) ||
			!(levelmap[locx][locy + 1][locz].flag & SITEBLOCK_BLOCK))
			levelmap[locx - 1][locy + 1][locz].flag |= SITEBLOCK_KNOWN;
	if (locx < MAPX - 1 && locy < MAPY - 1)
		if (!(levelmap[locx + 1][locy][locz].flag & SITEBLOCK_BLOCK) ||
			!(levelmap[locx][locy + 1][locz].flag & SITEBLOCK_BLOCK))
			levelmap[locx + 1][locy + 1][locz].flag |= SITEBLOCK_KNOWN;
}

void knowmap() {
	extern int locx;
	extern int locy;
	extern int locz;
	knowmap(locx, locy, locz);
}
/* site - determines spin on site news story, CONST_sitemode077 timer */
void resolvesite()
{
	extern squadst *activesquad;
	extern short cursite;
	extern int sitecrime;
	extern newsstoryst *sitestory;
	extern short sitealienate;
	if (sitealienate) sitestory->positive = 0;
	//removed the 'alarmed' requirement for high security buildings, on the principle that even if they didn't see you, they will presumably
	//notice later on that all their stuff has been stolen or whatever.
	if (/*sitealarm==1&&*/sitecrime > 5 + LCSrandom(95))//was 100 but that meant I could still steal everything from a building every day without anyone caring...
	{
		if (LocationsPool::getInstance().getRentingType(cursite) == RENTING_NOCONTROL)
		{
			// Capture a warehouse or crack den?
			if (LocationsPool::getInstance().getLocationType(cursite) == SITE_INDUSTRY_WAREHOUSE ||
				LocationsPool::getInstance().getLocationType(cursite) == SITE_BUSINESS_CRACKHOUSE)
			{
				LocationsPool::getInstance().captureSite(cursite);
			}
			else LocationsPool::getInstance().closeSite(cursite, sitecrime);
		}
		// Out sleepers
		if (LocationsPool::getInstance().getRentingType(cursite) == RENTING_CCS)
		{
			CreaturePool::getInstance().outSleepers(cursite, activesquad->squad[0]->base);
		}
	}
	else if (sitecrime > 10 && (LocationsPool::getInstance().getRentingType(cursite) == RENTING_NOCONTROL || LocationsPool::getInstance().getRentingType(cursite) > 500))
	{
		if (LocationsPool::getInstance().getLocationType(cursite) != SITE_RESIDENTIAL_BOMBSHELTER &&
			LocationsPool::getInstance().getLocationType(cursite) != SITE_BUSINESS_BARANDGRILL &&
			LocationsPool::getInstance().getLocationType(cursite) != SITE_OUTDOOR_BUNKER &&
			LocationsPool::getInstance().getLocationType(cursite) != SITE_INDUSTRY_WAREHOUSE &&
			LocationsPool::getInstance().getLocationType(cursite) != SITE_BUSINESS_CRACKHOUSE)
		{
			if (securityable(LocationsPool::getInstance().getLocationType(cursite)))
				LocationsPool::getInstance().isThisPlaceHighSecurity(cursite, sitecrime);
			else LocationsPool::getInstance().closeSite(cursite, 70);
		}
	}
}
/* behavior when the player bumps into a door in sitemode */
void open_door(bool restricted)
{
	extern Log gamelog;
	extern squadst *activesquad;
	extern short sitealarm;
	extern int sitecrime;
	extern short sitealarmtimer;
	extern int locx;
	extern int locy;
	extern int locz;
	extern newsstoryst *sitestory;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	bool locked = levelmap[locx][locy][locz].flag&SITEBLOCK_LOCKED,
		alarmed = levelmap[locx][locy][locz].flag&SITEBLOCK_ALARMED,
		vault_door = levelmap[locx][locy][locz].flag&SITEBLOCK_METAL,
		//   known_locked=levelmap[locx][locy][locz].flag&SITEBLOCK_KLOCK,
		cant_unlock = levelmap[locx][locy][locz].flag&SITEBLOCK_CLOCK;
	if (vault_door)
	{
		// Vault door, not usable by bumping
		clearmessagearea(false);
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, CONST_sitemode078, gamelog);
		gamelog.newline();
		pressAnyKey();
		return;
	}
	bool has_security = false;
	for (int i = 0; i < 6; i++)
	{
		if (activesquad->squad[i] &&
			activesquad->squad[i]->get_skill(SKILL_SECURITY) != 0)
		{
			has_security = true;
			break;
		}
	}
	if (alarmed)
	{
		// Unlocked but alarmed door, clearly marked as such
		clearmessagearea(false);
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		if (locked)
			mvaddstrAlt(16, 1, CONST_sitemode079, gamelog);
		else
			mvaddstrAlt(16, 1, CONST_sitemode080, gamelog);
		gamelog.newline();
		mvaddstrAlt(17, 1, CONST_sitemode081);
		while (true)
		{
			int c = getkeyAlt();
			if (c == 'y') break;
			else if (c == 'n') return;
		}
	}
	if (locked && !cant_unlock && has_security)
	{
		levelmap[locx][locy][locz].flag |= SITEBLOCK_KLOCK;
		while (true)
		{
			clearmessagearea(false);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode082, gamelog);
			gamelog.newline();
			mvaddstrAlt(17, 1, CONST_sitemode083);
			int c = getkeyAlt();
			clearmessagearea(false);
			if (c == 'y')
			{
				char actual; // 1 if an actual attempt was made, 0 otherwise
							 // If the unlock was successful
				if (unlock(UNLOCK_DOOR, actual))
				{
					// Unlock the door
					levelmap[locx][locy][locz].flag &= ~(SITEBLOCK_LOCKED | SITEBLOCK_ALARMED);
					sitestory->crime.push_back(CRIME_UNLOCKEDDOOR);
					if (sitealarmtimer < 0 || sitealarmtimer>50) sitealarmtimer = 50;
					//criminalizeparty(LAWFLAG_BREAKING);
				}
				// Else perma-lock it if an attempt was made
				else if (actual)
				{
					levelmap[locx][locy][locz].flag |= SITEBLOCK_CLOCK;
					if (levelmap[locx][locy][locz].flag&SITEBLOCK_ALARMED)
					{
						set_color_easy(WHITE_ON_BLACK_BRIGHT);
						mvaddstrAlt(17, 1, CONST_sitemode084, gamelog);
						gamelog.newline();
						sitealarm = 1;
						pressAnyKey();
					}
				}
				// Check for people noticing you fiddling with the lock
				if (actual)
				{
					alienationcheck(0);
					noticecheck(-1);
				}
				return;
			}
			else if (c == 'n') return;
		}
	}
	else if (locked || (!restricted && alarmed))
	{
		while (true)
		{
			clearmessagearea(false);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			if (locked)
			{
				mvaddstrAlt(16, 1, CONST_sitemode085, gamelog);
				if (has_security) addstrAlt(CONST_sitemode086, gamelog);
				addstrAlt(CONST_sitemode087, gamelog);
			}
			else mvaddstrAlt(16, 1, CONST_sitemode088, gamelog);
			gamelog.newline();
			mvaddstrAlt(17, 1, CONST_sitemode089);
			int c = getkeyAlt();
			if (c == 'y')
			{
				char actual;
				if (bash(BASH_DOOR, actual))
				{
					levelmap[locx][locy][locz].flag &= ~SITEBLOCK_DOOR;
					int time = 0;
					if (sitealarmtimer > time || sitealarmtimer == -1)sitealarmtimer = time;
					if (levelmap[locx][locy][locz].flag&SITEBLOCK_ALARMED)
					{
						clearmessagearea(false);
						set_color_easy(WHITE_ON_BLACK_BRIGHT);
						mvaddstrAlt(16, 1, CONST_sitemode090, gamelog);
						gamelog.newline();
						sitealarm = 1;
						pressAnyKey();
					}
					sitecrime++;
					sitestory->crime.push_back(CRIME_BROKEDOWNDOOR);
					criminalizeparty(LAWFLAG_BREAKING);
				}
				if (actual)
				{
					alienationcheck(1);
					noticecheck(-1, DIFFICULTY_HEROIC);
				}
				break;
			}
			else if (c == 'n')break;
		}
	}
	else
	{
		levelmap[locx][locy][locz].flag &= ~SITEBLOCK_DOOR;
		if (alarmed)
		{
			// Opened an unlocked but clearly marked emergency exit door
			clearmessagearea(false);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode091, gamelog);
			gamelog.newline();
			sitealarm = 1;
			pressAnyKey();
		}
	}
}
int whichWay() {
	int c = 0;
	clearmessagearea();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(16, 1, CONST_sitemode092);
	while (true)
	{
		int c2 = getkeyAlt();
		if (c2 == 'w' || c2 == 'a' || c2 == 'd' || c2 == 'x' ||
			c2 == KEY_LEFT || c2 == KEY_RIGHT || c2 == KEY_UP || c2 == KEY_DOWN)
		{
			c = c2;
			break;
		}
		if (c2 == ENTER || c2 == ESC || c2 == SPACEBAR)break;
	}
	return c;
}
void pressedKeyN() {
	extern MusicClass music;
	extern bool mapshowing;
	extern bool encounterwarnings;

	mapshowing = false;
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(0, 0, CONST_sitemode093);
	printparty();
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(10, 1, CONST_sitemode094);
	mvaddstrAlt(11, 1, CONST_sitemode095);
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(24, 1, enter_done);
	int c = 0;
	while (true)
	{
		if (c == 'e') encounterwarnings = !encounterwarnings;
		if (c == 'm') music.enableIf(!music.isEnabled());
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR)break;
		if (encounterwarnings)
			mvaddstrAlt(10, 2, tag_X);
		else mvaddstrAlt(10, 2, singleSpace);
		if (music.isEnabled())
			mvaddstrAlt(11, 2, tag_X);
		else mvaddstrAlt(11, 2, singleSpace);
		c = getkeyAlt();
	}
	mapshowing = true;

}
void pressedKeyU(const int enemy) {
	extern squadst *activesquad;
	extern short sitealarm;
	extern int locx;
	extern int locy;
	extern int locz;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	{
		if (levelmap[locx][locy][locz].special != -1)
		{
			switch (levelmap[locx][locy][locz].special)
			{
			case SPECIAL_LAB_COSMETICS_CAGEDANIMALS:special_lab_cosmetics_cagedanimals(); break;
			case SPECIAL_NUCLEAR_ONOFF:special_nuclear_onoff(); break;
			case SPECIAL_LAB_GENETIC_CAGEDANIMALS:special_lab_genetic_cagedanimals(); break;
			case SPECIAL_POLICESTATION_LOCKUP:special_policestation_lockup(); break;
			case SPECIAL_COURTHOUSE_LOCKUP:special_courthouse_lockup(); break;
			case SPECIAL_COURTHOUSE_JURYROOM:special_courthouse_jury(); break;
			case SPECIAL_PRISON_CONTROL:
			case SPECIAL_PRISON_CONTROL_LOW:
			case SPECIAL_PRISON_CONTROL_MEDIUM:
			case SPECIAL_PRISON_CONTROL_HIGH:
				special_prison_control(levelmap[locx][locy][locz].special); break;
			case SPECIAL_INTEL_SUPERCOMPUTER:special_intel_supercomputer(); break;
			case SPECIAL_SWEATSHOP_EQUIPMENT:special_sweatshop_equipment(); break;
			case SPECIAL_POLLUTER_EQUIPMENT:special_polluter_equipment(); break;
			case SPECIAL_HOUSE_PHOTOS:special_house_photos(); break;
			case SPECIAL_ARMORY:special_armory(); break;
			case SPECIAL_CORPORATE_FILES:special_corporate_files(); break;
			case SPECIAL_RADIO_BROADCASTSTUDIO:special_radio_broadcaststudio(); break;
			case SPECIAL_NEWS_BROADCASTSTUDIO:special_news_broadcaststudio(); break;
			case SPECIAL_SIGN_ONE:special_readsign(SPECIAL_SIGN_ONE); break;
			case SPECIAL_SIGN_TWO:special_readsign(SPECIAL_SIGN_TWO); break;
			case SPECIAL_SIGN_THREE:special_readsign(SPECIAL_SIGN_THREE); break;
			case SPECIAL_STAIRS_UP:locz++; break;
			case SPECIAL_STAIRS_DOWN:locz--; break;
			case SPECIAL_DISPLAY_CASE:special_display_case(); break;
			case SPECIAL_SECURITY_CHECKPOINT:special_security_checkpoint(); break;
			case SPECIAL_SECURITY_METALDETECTORS:special_security_metaldetectors(); break;
			case SPECIAL_SECURITY_SECONDVISIT:special_security_secondvisit(); break;
			case SPECIAL_BANK_VAULT:special_bank_vault(); break;
			case SPECIAL_BANK_TELLER:special_bank_teller(); break;
			case SPECIAL_BANK_MONEY:special_bank_money(); break;
			case SPECIAL_CCS_BOSS:special_ccs_boss(); break;
			case SPECIAL_OVAL_OFFICE_NW:
			case SPECIAL_OVAL_OFFICE_NE:
			case SPECIAL_OVAL_OFFICE_SW:
			case SPECIAL_OVAL_OFFICE_SE:special_oval_office(); break;
			}
		}
		else if (!(levelmap[locx][locy][locz].flag & (SITEBLOCK_GRAFFITI | SITEBLOCK_BLOODY2)) &&
			((levelmap[locx + 1][locy][locz].flag & SITEBLOCK_BLOCK) ||
			(levelmap[locx - 1][locy][locz].flag & SITEBLOCK_BLOCK) ||
				(levelmap[locx][locy + 1][locz].flag & SITEBLOCK_BLOCK) ||
				(levelmap[locx][locy - 1][locz].flag & SITEBLOCK_BLOCK)))
		{
			int spray = 0;
			for (int i = 0; i < 6; i++)
			{
				if (!activesquad->squad[i])break;
				if (activesquad->squad[i]->get_weapon().can_graffiti())
				{
					spray = 1;
					break;
				}
			}
			if (spray)
			{
				special_graffiti();
				if (enemy&&sitealarm)
				{
					enemyattack();
				}
			}
		}
	}
}
void pressedKeyL() {

	reloadparty(true);
	printparty();
	refreshAlt();
	creatureadvance();

}
void pressedKeyT(const int enemy, int& encounter_timer) {
	extern squadst *activesquad;
	extern short sitealarm;
	extern Creature encounter[ENCMAX];
	int forcesp = -1;
	int forcetk = -1;
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] != NULL)
		{
			if (activesquad->squad[p]->alive)
			{
				if (forcesp == -1)forcesp = p;
				else forcesp = -2;
			}
		}
	}
	for (int e = 0; e < ENCMAX; e++)
	{
		if (encounter[e].exists&&encounter[e].alive &&
			!(encounter[e].type == CREATURE_WORKER_SERVANT ||
				encounter[e].type == CREATURE_WORKER_SWEATSHOP))
		{
			if (encounter[e].cantbluff != 1 || sitealarm)
			{
				if (forcetk == -1)forcetk = e;
				else forcetk = -2;
			}
		}
	}
	if (forcetk != -1 && forcesp != -1)
	{
		int sp = -1;
		if (forcesp == -2)
		{
			clearcommandarea();
			clearmessagearea();
			clearmaparea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(9, 1, CONST_sitemode096);
			mvaddstrAlt(9, 50, CONST_sitemode097);
			mvaddstrAlt(9, 60, CONST_sitemode098);
			mvaddstrAlt(9, 70, CONST_sitemode099);
			int y = 11;
			for (int p = 0; p < 6; p++)
			{
				if (activesquad->squad[p] != NULL)
				{
					if (activesquad->squad[p]->alive)
					{
						mvaddcharAlt(y, 1, p + '1');
						addstrAlt(spaceDashSpace);
						addstrAlt(activesquad->squad[p]->name);
						mvaddstrAlt(y, 50, activesquad->squad[p]->get_attribute(ATTRIBUTE_CHARISMA, true) / 2 +
							activesquad->squad[p]->get_skill(SKILL_PERSUASION));
						mvaddstrAlt(y, 60, activesquad->squad[p]->get_attribute(ATTRIBUTE_CHARISMA, true) / 2 +
							activesquad->squad[p]->get_skill(SKILL_SEDUCTION));
						mvaddstrAlt(y++, 70, activesquad->squad[p]->get_attribute(ATTRIBUTE_CHARISMA, true) / 2 +
							activesquad->squad[p]->get_skill(SKILL_DISGUISE));
					}
				}
			}
			while (true)
			{
				int c = getkeyAlt();
				if (c >= '1'&&c <= '6')
				{
					sp = c - '1';
					if (activesquad->squad[sp] != NULL) if (activesquad->squad[sp]->alive) break;
				}
				if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) { sp = -1; break; }
			}
		}
		else sp = forcesp;
		if (sp != -1)
		{
			int tk = -1;
			if (forcetk == -2)
			{
				while (true)
				{
					clearcommandarea();
					clearmessagearea();
					clearmaparea();
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(9, 1, CONST_sitemode100);
					int x = 1, y = 11;
					for (int t = 0; t < ENCMAX; t++)
					{
						if (encounter[t].exists)
						{
							if (encounter[t].cantbluff != 1)
							{
								set_color_easy(WHITE_ON_BLACK_BRIGHT);
								mvaddcharAlt(y, x, t + 'A');
								addstrAlt(spaceDashSpace);
								switch (encounter[t].align)
								{
								case ALIGN_CONSERVATIVE:
									set_color_easy(RED_ON_BLACK_BRIGHT);
									break;
								case ALIGN_LIBERAL:
									set_color_easy(GREEN_ON_BLACK_BRIGHT);
									break;
								case ALIGN_MODERATE:
									set_color_easy(WHITE_ON_BLACK_BRIGHT);
									break;
								}
								addstrAlt(encounter[t].name);
								add_age(encounter[t]);
								y++;
								if (y == 17)
								{
									y = 11;
									x += 30;
								}
							}
							else
							{
								y++;
								if (y == 17)
								{
									y = 11;
									x += 30;
								}
							}
						}
					}
					int c = getkeyAlt();
					if (c >= 'a'&&c <= 'z')
					{
						tk = c - 'a';
						if (tk < ENCMAX)
						{
							if (encounter[tk].exists)
							{
								if (encounter[tk].alive &&
									!(encounter[tk].type == CREATURE_WORKER_SERVANT ||
										encounter[tk].type == CREATURE_WORKER_SWEATSHOP))
								{
									if (encounter[tk].cantbluff == 1 &&
										(!sitealarm || encounter[tk].animalgloss == ANIMALGLOSS_ANIMAL))
									{
										clearcommandarea();
										clearmessagearea();
										clearmaparea();
										set_color_easy(WHITE_ON_BLACK_BRIGHT);
										mvaddstrAlt(9, 1, encounter[tk].name);
										addstrAlt(CONST_sitemode101);
										pressAnyKey();
									}
									else if (!encounter[tk].enemy() && sitealarm&&enemy)
									{
										clearcommandarea();
										clearmessagearea();
										clearmaparea();
										set_color_easy(WHITE_ON_BLACK_BRIGHT);
										mvaddstrAlt(9, 1, CONST_sitemode102);
										pressAnyKey();
									}
									else break;
								}
							}
						}
					}
					if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) { tk = -1; break; }
				}
			}
			else tk = forcetk;
			if (tk != -1)
			{
				if (talk(*activesquad->squad[sp], tk))
				{
					if (enemy&&sitealarm)enemyattack();
					else if (enemy)disguisecheck(encounter_timer);
					creatureadvance();
					encounter_timer++;
				}
			}
		}
	}

}
void pressedKeyM() {
	extern short cursite;
	extern int locx;
	extern int locy;
	extern int locz;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	for (int x = 0; x < MAPX; x++)
	{
		for (int y = 0; y < MAPY; y++)
		{
			if (levelmap[x][y][locz].flag & SITEBLOCK_KNOWN)
			{
				if (x == locx && y == locy)
				{
					set_color_easy(GREEN_ON_BLACK_BRIGHT);
					mvaddchAlt(y + 1, x + 5, CH_WHITE_SMILING_FACE);
				}
				else
				{
					set_color_easy(WHITE_ON_BLACK);
					if (levelmap[x][y][locz].flag & SITEBLOCK_BLOCK)
					{
						set_color_easy(WHITE_ON_WHITE);
						mvaddchAlt(y + 1, x + 5, ' ');
					}
					else if (levelmap[x][y][locz].flag & SITEBLOCK_DOOR)
					{  // Pick color
						if (levelmap[x][y][locz].flag & SITEBLOCK_METAL)
							set_color_easy(WHITE_ON_WHITE_BRIGHT);
						else if (levelmap[x][y][locz].flag & SITEBLOCK_CLOCK
							&& levelmap[x][y][locz].flag & SITEBLOCK_LOCKED)
							set_color_easy(RED_ON_BLACK);
						else if (levelmap[x][y][locz].flag & SITEBLOCK_KLOCK
							&& levelmap[x][y][locz].flag & SITEBLOCK_LOCKED)
							set_color_easy(BLACK_ON_BLACK_BRIGHT);
						else set_color_easy(YELLOW_ON_BLACK);
						if ((levelmap[x + 1][y][locz].flag & SITEBLOCK_BLOCK) ||
							(levelmap[x - 1][y][locz].flag & SITEBLOCK_BLOCK))
							mvaddchAlt(y + 1, x + 5, CH_BOX_DRAWINGS_DOUBLE_HORIZONTAL);
						else mvaddchAlt(y + 1, x + 5, CH_BOX_DRAWINGS_DOUBLE_VERTICAL);
					}
					else if ((levelmap[x][y][locz].siegeflag & SIEGEFLAG_HEAVYUNIT) &&
						LocationsPool::getInstance().siteHasCameras(cursite))
					{
						set_color_easy(RED_ON_BLACK_BRIGHT);
						mvaddchAlt(y + 1, x + 5, CH_YEN_SIGN);
					}
					else if ((levelmap[x][y][locz].siegeflag & SIEGEFLAG_UNIT) &&
						LocationsPool::getInstance().siteHasCameras(cursite))
					{
						set_color_easy(RED_ON_BLACK_BRIGHT);
						mvaddchAlt(y + 1, x + 5, CH_BLACK_SMILING_FACE);
					}
					else if ((levelmap[x][y][locz].siegeflag & SIEGEFLAG_UNIT_DAMAGED) &&
						LocationsPool::getInstance().siteHasCameras(cursite))
					{
						set_color_easy(RED_ON_BLACK);
						mvaddchAlt(y + 1, x + 5, CH_BLACK_SMILING_FACE);
					}
					else if (levelmap[x][y][locz].special == SPECIAL_STAIRS_UP)
					{
						set_color_easy(YELLOW_ON_BLACK_BRIGHT);
						mvaddchAlt(y + 1, x + 5, CH_UPWARDS_ARROW);
					}
					else if (levelmap[x][y][locz].special == SPECIAL_STAIRS_DOWN)
					{
						set_color_easy(YELLOW_ON_BLACK_BRIGHT);
						mvaddchAlt(y + 1, x + 5, CH_DOWNWARDS_ARROW);
					}
					else if (levelmap[x][y][locz].special != -1)
					{
						set_color_easy(YELLOW_ON_BLACK_BRIGHT);
						mvaddchAlt(y + 1, x + 5, '!');
					}
					else if (levelmap[x][y][locz].siegeflag & SIEGEFLAG_TRAP)
					{
						set_color_easy(YELLOW_ON_BLACK_BRIGHT);
						mvaddchAlt(y + 1, x + 5, '!');
					}
					else if (levelmap[x][y][locz].flag & SITEBLOCK_LOOT)
					{
						set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
						mvaddchAlt(y + 1, x + 5, '$');
					}
					else mvaddchAlt(y + 1, x + 5, ' ');
				}
			}
			else
			{
				set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddchAlt(y + 1, x + 5, CH_FULL_BLOCK);
			}
		}
	}
	pressAnyKey();

}
void pressedKeyF(int& encounter_timer) {
	extern squadst *activesquad;
	extern Creature encounter[ENCMAX];
	// Don't subdue squad if someone is still in good condition.
	bool cannotsubdue = false;
	for (int j = 0; j < 6 && !cannotsubdue; j++)
	{
		if (activesquad->squad[j] &&
			activesquad->squad[j]->alive &&
			activesquad->squad[j]->blood > 40)
		{
			cannotsubdue = true;
		}
	}
	// Cops can subdue and arrest the squad.
	bool subdue = false;
	for (int i = 0; i < ENCMAX && (!cannotsubdue && !subdue); i++)
	{
		if (encounter[i].exists&&
			encounter[i].blood > 60 &&
			(encounter[i].type == CREATURE_COP))
		{
			subdue = true;
		}
	}
	if (subdue)
		fight_subdued();
	else
	{
		youattack();
		enemyattack();
		creatureadvance();
		encounter_timer++;
	}

}
int checkForPeopleWhoCanRecruit() {
	extern squadst *activesquad;
	// Check for people who can recruit followers
	for (int i = 0; i < 6; i++)
		if (activesquad->squad[i] != NULL)
			if (subordinatesleft(*activesquad->squad[i]))
				return i;
	return -1;
}
void addNewRecruit(int i, int e) {
	extern int stat_recruits;
	extern squadst *activesquad;
	extern Creature encounter[ENCMAX];
	Creature *newcr = new Creature;
	*newcr = encounter[e];
	newcr->namecreature();
	newcr->location = activesquad->squad[i]->location;
	newcr->base = activesquad->squad[i]->base;
	newcr->hireid = activesquad->squad[i]->id;
	addCreature(newcr);
	stat_recruits++;
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] == NULL)
		{
			activesquad->squad[p] = newcr;
			newcr->squadid = activesquad->id;
			break;
		}
	}
}
void pressedKeyR(const int freeable, const int libnum, const int enemy, const int hostages, int& partysize) {
	extern Log gamelog;
	extern squadst *activesquad;
	extern short sitealarmtimer;
	extern short sitealarm;
	extern short cursite;
	extern Creature encounter[ENCMAX];
	if (LocationsPool::getInstance().isThereASiegeHere(cursite) && libnum > 6)
	{
		assemblesquad(activesquad);
		autopromote(cursite);
	}
	else if (freeable && (!enemy || !sitealarm) && !LocationsPool::getInstance().isThereASiegeHere(cursite))
	{
		short followers = 0, actgot = 0;
		if (enemy)sitealarm = 1;
		bool freed;
		do
		{
			bool flipstart = 0;
			freed = 0;
			for (int e = 0; e < ENCMAX; e++)
			{
				if (!encounter[e].exists)break;
				if ((encounter[e].type == CREATURE_WORKER_SERVANT ||
					encounter[e].type == CREATURE_WORKER_FACTORY_CHILD ||
					encounter[e].type == CREATURE_WORKER_SWEATSHOP ||
					(strcmp(encounter[e].name, CONST_sitemode141.c_str()) == 0 && encounter[e].align == 1)) && !flipstart)
				{
					if (strcmp(encounter[e].name, CONST_sitemode141.c_str()) == 0)
					{
						sitealarm = 1; /* alarm for prisoner escape */
						criminalize(encounter[e], LAWFLAG_ESCAPED);
					}
					followers++, flipstart = 1, freed = 1;
					if (partysize < 6)
					{
						int i = checkForPeopleWhoCanRecruit();

						// If someone can, add this person as a newly recruited Liberal!
						if (i < 6 && i > -1)
						{
							addNewRecruit(i, e);
							actgot++;
							partysize++;
						}
					}
				}
				if (flipstart)
					if (e < ENCMAX - 1)encounter[e] = encounter[e + 1];
			}
			if (flipstart)encounter[ENCMAX - 1].exists = 0;
			if (freed)
			{
				int time = 20 + LCSrandom(10);
				if (time < 1)time = 1;
				if (sitealarmtimer > time || sitealarmtimer == -1)sitealarmtimer = time;
			}
		} while (freed);
		if (followers > 0)
		{
			clearmessagearea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode105, gamelog);
			if (followers > 1)addstrAlt(CONST_sitemode106, gamelog);
			else addstrAlt(CONST_sitemode107, gamelog);
			addstrAlt(CONST_sitemode108, gamelog);
			gamelog.newline();
			if (actgot < followers)
			{
				pressAnyKey();
				clearmessagearea();
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				if (actgot == 0 && followers > 1)mvaddstrAlt(16, 1, CONST_sitemode109, gamelog);
				else if (followers - actgot > 1)mvaddstrAlt(16, 1, CONST_sitemode110, gamelog);
				else if (actgot == 0)mvaddstrAlt(16, 1, CONST_sitemode111, gamelog);
				else mvaddstrAlt(16, 1, CONST_sitemode112, gamelog);
				addstrAlt(CONST_sitemode113, gamelog);
				gamelog.newline();
			}
			pressAnyKey();
		}
	}
	else if (hostages)
		releasehostage();
}
string getNewLootFromBank() {
	string newLootType;
	if (!LCSrandom(4))newLootType = tag_LOOT_WATCH;
	else if (!LCSrandom(3))newLootType = tag_LOOT_CELLPHONE;
	else if (!LCSrandom(2))newLootType = tag_LOOT_PDA;
	else newLootType = tag_LOOT_COMPUTER;
	return newLootType;
}
string getNewLootFromApartment() {
	string newLootType;

	if (!LCSrandom(5))newLootType = tag_LOOT_CELLPHONE;
	else if (!LCSrandom(4))newLootType = tag_LOOT_SILVERWARE;
	else if (!LCSrandom(3))newLootType = tag_LOOT_TRINKET;
	else if (!LCSrandom(2))newLootType = tag_LOOT_CHEAPJEWELERY;
	else newLootType = tag_LOOT_COMPUTER;

	return newLootType;
}
string getNewLootFromApartmentUpscale() {
	string newLootType;
	if (!LCSrandom(10))newLootType = tag_LOOT_EXPENSIVEJEWELERY;
	else if (!LCSrandom(5))newLootType = tag_LOOT_CELLPHONE;
	else if (!LCSrandom(4))newLootType = tag_LOOT_SILVERWARE;
	else if (!LCSrandom(3))newLootType = tag_LOOT_PDA;
	else if (!LCSrandom(2))newLootType = tag_LOOT_CHEAPJEWELERY;
	else newLootType = tag_LOOT_COMPUTER;

	return newLootType;
}

string getNewLootFromLab() {
	string newLootType;


	if (!LCSrandom(20))newLootType = tag_LOOT_RESEARCHFILES;
	else if (!LCSrandom(2))newLootType = tag_LOOT_LABEQUIPMENT;
	else if (!LCSrandom(2))newLootType = tag_LOOT_COMPUTER;
	else if (!LCSrandom(5))newLootType = tag_LOOT_PDA;
	else if (!LCSrandom(5))newLootType = tag_LOOT_CHEMICAL;
	else newLootType = tag_LOOT_COMPUTER;

	return newLootType;
}

string getNewLootFromPolice() {
	string newLootType;

	if (!LCSrandom(20))newLootType = tag_LOOT_POLICERECORDS;
	else if (!LCSrandom(3))newLootType = tag_LOOT_CELLPHONE;
	else if (!LCSrandom(2))newLootType = tag_LOOT_PDA;
	else newLootType = tag_LOOT_COMPUTER;


	return newLootType;
}
string getNewLootFromCourt() {
	string newLootType;



	if (!LCSrandom(20))newLootType = tag_LOOT_JUDGEFILES;
	else if (!LCSrandom(3))newLootType = tag_LOOT_CELLPHONE;
	else if (!LCSrandom(2))newLootType = tag_LOOT_PDA;
	else newLootType = tag_LOOT_COMPUTER;

	return newLootType;
}

string getNewLootFromWhiteHouse() {
	string newLootType;



	if (!LCSrandom(20))newLootType = tag_LOOT_SECRETDOCUMENTS;
	else if (!LCSrandom(3))newLootType = tag_LOOT_CELLPHONE;
	else if (!LCSrandom(2))newLootType = tag_LOOT_PDA;
	else newLootType = tag_LOOT_COMPUTER;

	return newLootType;
}
string getNewLootFromArmy() {
	string newLootType;


	if (!LCSrandom(20))newLootType = tag_LOOT_SECRETDOCUMENTS;
	else if (!LCSrandom(3))newLootType = tag_LOOT_CELLPHONE;
	else if (!LCSrandom(2))newLootType = tag_LOOT_WATCH;
	else newLootType = tag_LOOT_TRINKET;

	return newLootType;
}
string getNewLootFromIntelligence() {
	string newLootType;


	if (!LCSrandom(20))newLootType = tag_LOOT_SECRETDOCUMENTS;
	else if (!LCSrandom(3))newLootType = tag_LOOT_CELLPHONE;
	else if (!LCSrandom(2))newLootType = tag_LOOT_PDA;
	else newLootType = tag_LOOT_COMPUTER;

	return newLootType;
}
string getNewLootFromCorporate() {
	string newLootType;


	if (!LCSrandom(50))newLootType = tag_LOOT_CORPFILES;
	else if (!LCSrandom(3))newLootType = tag_LOOT_CELLPHONE;
	else if (!LCSrandom(2))newLootType = tag_LOOT_PDA;
	else newLootType = tag_LOOT_COMPUTER;

	return newLootType;
}

string getNewLootFromCorporateHouse() {
	string newLootType;

	if (!LCSrandom(8))newLootType = tag_LOOT_TRINKET;
	else if (!LCSrandom(7))newLootType = tag_LOOT_WATCH;
	else if (!LCSrandom(6))newLootType = tag_LOOT_PDA;
	else if (!LCSrandom(5))newLootType = tag_LOOT_CELLPHONE;
	else if (!LCSrandom(4))newLootType = tag_LOOT_SILVERWARE;
	else if (!LCSrandom(3))newLootType = tag_LOOT_CHEAPJEWELERY;
	else if (!LCSrandom(2))newLootType = tag_LOOT_FAMILYPHOTO;
	else newLootType = tag_LOOT_COMPUTER;


	return newLootType;
}

string getNewLootFromRadio() {
	string newLootType;


	if (!LCSrandom(20))newLootType = tag_LOOT_AMRADIOFILES;
	else if (!LCSrandom(4))newLootType = tag_LOOT_MICROPHONE;
	else if (!LCSrandom(3))newLootType = tag_LOOT_PDA;
	else if (!LCSrandom(2))newLootType = tag_LOOT_CELLPHONE;
	else newLootType = tag_LOOT_COMPUTER;

	return newLootType;
}

string getNewLootFromCable() {
	string newLootType;


	if (!LCSrandom(20))newLootType = tag_LOOT_CABLENEWSFILES;
	else if (!LCSrandom(4))newLootType = tag_LOOT_MICROPHONE;
	else if (!LCSrandom(3))newLootType = tag_LOOT_PDA;
	else if (!LCSrandom(2))newLootType = tag_LOOT_CELLPHONE;
	else newLootType = tag_LOOT_COMPUTER;

	return newLootType;
}

string getNewLootFromCCS() {
	string newLootType;


	if (!LCSrandom(5))newLootType = tag_LOOT_CELLPHONE;
	else if (!LCSrandom(4))newLootType = tag_LOOT_SILVERWARE;
	else if (!LCSrandom(3))newLootType = tag_LOOT_TRINKET;
	else if (!LCSrandom(2))newLootType = tag_LOOT_CHEAPJEWELERY;
	else newLootType = tag_LOOT_COMPUTER;

	return newLootType;
}

string getNewLootFromSITE_RESIDENTIAL_TENEMENT() {
	string newLootType;

	if (!LCSrandom(3))newLootType = tag_LOOT_KIDART;
	else if (!LCSrandom(2))newLootType = tag_LOOT_DIRTYSOCK;
	else newLootType = tag_LOOT_FAMILYPHOTO;

	return newLootType;
}
void getRandomLoot(int cursite);
Weapon* spawnNewWeapon(string newWeaponType);
Armor* spawnNewArmor(string newArmorType);

void getThatGroundLoot() {
	extern Log gamelog;
	extern short sitealarm;
	extern short cursite;
	extern short sitealarmtimer;
	extern short sitetype;
	extern squadst *activesquad;
	extern short lawList[LAWNUM];

	int time = 20 + LCSrandom(10);
	if (time < 1)time = 1;
	if (sitealarmtimer > time || sitealarmtimer == -1)sitealarmtimer = time;
	Item *item;
	string newLootType, newWeaponType, newArmorType;
	switch (sitetype)
	{
	case SITE_RESIDENTIAL_TENEMENT:
		if (!LCSrandom(25))
		{
			string rndWeps[] = { tag_WEAPON_BASEBALLBAT, tag_WEAPON_CROWBAR, tag_WEAPON_SHANK,
				tag_WEAPON_SYRINGE, tag_WEAPON_CHAIN, tag_WEAPON_GUITAR,tag_WEAPON_SPRAYCAN };
			newWeaponType = pickrandom(rndWeps);
		}
		else if (!LCSrandom(20))
		{
			string rndArmors[] = { tag_ARMOR_CHEAPDRESS, tag_ARMOR_CHEAPSUIT, tag_ARMOR_CLOTHES, tag_ARMOR_TRENCHCOAT,
				tag_ARMOR_WORKCLOTHES, tag_ARMOR_TOGA, tag_ARMOR_PRISONER };
			newArmorType = pickrandom(rndArmors);
		}
		else newLootType = getNewLootFromSITE_RESIDENTIAL_TENEMENT();
		break;
	case SITE_BUSINESS_BANK:
		newLootType = getNewLootFromBank();
		break;
	case SITE_RESIDENTIAL_APARTMENT:
		if (!LCSrandom(25))
		{
			string rndWeps[] = { tag_WEAPON_BASEBALLBAT, tag_WEAPON_REVOLVER_38,
				tag_WEAPON_REVOLVER_44, tag_WEAPON_NIGHTSTICK, tag_WEAPON_GUITAR };
			newWeaponType = pickrandom(rndWeps);
		}
		else if (!LCSrandom(20))
		{
			string rndArmors[] = { tag_ARMOR_CHEAPDRESS, tag_ARMOR_CHEAPSUIT, tag_ARMOR_CLOTHES, tag_ARMOR_TRENCHCOAT,
				tag_ARMOR_WORKCLOTHES, tag_ARMOR_CLOWNSUIT, tag_ARMOR_ELEPHANTSUIT, tag_ARMOR_DONKEYSUIT };
			newArmorType = pickrandom(rndArmors);
		}
		else newLootType = getNewLootFromApartment();
		break;
	case SITE_RESIDENTIAL_APARTMENT_UPSCALE:
		if (!LCSrandom(30))
		{
			string rndWeps[] = { tag_WEAPON_BASEBALLBAT, tag_WEAPON_COMBATKNIFE, tag_WEAPON_DAISHO, tag_WEAPON_SHOTGUN_PUMP,
				tag_WEAPON_REVOLVER_44, tag_WEAPON_SEMIPISTOL_45, tag_WEAPON_SEMIRIFLE_AR15, tag_WEAPON_AUTORIFLE_M16 };
			//make sure the number of types matches the random range...
			newWeaponType = rndWeps[LCSrandom(6 - lawList[LAW_GUNCONTROL])];
		}
		else if (!LCSrandom(20))
		{
			string rndArmors[] = { tag_ARMOR_EXPENSIVEDRESS, tag_ARMOR_BLACKDRESS, tag_ARMOR_EXPENSIVESUIT, tag_ARMOR_BLACKSUIT,
				tag_ARMOR_BONDAGEGEAR, tag_ARMOR_CIVILLIANARMOR, tag_ARMOR_BLACKROBE, tag_ARMOR_LABCOAT };
			newArmorType = pickrandom(rndArmors);
		}
		else newLootType = getNewLootFromApartmentUpscale();
		break;
	case SITE_LABORATORY_COSMETICS:
	case SITE_INDUSTRY_NUCLEAR:
	case SITE_LABORATORY_GENETIC:
		newLootType = getNewLootFromLab();
		break;
	case SITE_GOVERNMENT_POLICESTATION:
		if (!LCSrandom(25))
		{
			string rndWeps[] = { tag_WEAPON_NIGHTSTICK, tag_WEAPON_NIGHTSTICK, tag_WEAPON_SHOTGUN_PUMP, tag_WEAPON_SEMIPISTOL_9MM,
				tag_WEAPON_SMG_MP5, tag_WEAPON_CARBINE_M4, tag_WEAPON_AUTORIFLE_M16, tag_WEAPON_AUTORIFLE_M16 };
			//make sure the number of types matches the random range...
			newWeaponType = rndWeps[LCSrandom(4) + 2 - lawList[LAW_GUNCONTROL]];
		}
		else if (!LCSrandom(25))
		{
			string rndArmors[] = { tag_ARMOR_POLICEUNIFORM, tag_ARMOR_POLICEUNIFORM, tag_ARMOR_POLICEARMOR, tag_ARMOR_POLICEUNIFORM,
				tag_ARMOR_SWATARMOR, tag_ARMOR_POLICEUNIFORM, tag_ARMOR_POLICEARMOR, tag_ARMOR_DEATHSQUADUNIFORM };
			//make sure the number of types matches the random range...
			newArmorType = rndArmors[LCSrandom(4) + 2 - lawList[LAW_GUNCONTROL]];
		}
		else newLootType = getNewLootFromPolice();
		break;
	case SITE_GOVERNMENT_COURTHOUSE:
		newLootType = getNewLootFromCourt();
		break;
	case SITE_GOVERNMENT_PRISON:
		if (!LCSrandom(5))
			newArmorType = tag_ARMOR_PRISONER;
		else newWeaponType = tag_WEAPON_SHANK;
		break;
	case SITE_GOVERNMENT_WHITE_HOUSE:
		newLootType = getNewLootFromWhiteHouse();
		break;
	case SITE_GOVERNMENT_ARMYBASE:
		if (!LCSrandom(3))
		{
			string rndWeps[] = { tag_WEAPON_SEMIPISTOL_9MM, tag_WEAPON_CARBINE_M4, tag_WEAPON_AUTORIFLE_M16 };
			newWeaponType = pickrandom(rndWeps);
		}
		else if (!LCSrandom(2))
		{
			string rndArmors[] = { tag_ARMOR_ARMYARMOR };
			newArmorType = pickrandom(rndArmors);
		}
		else newLootType = getNewLootFromArmy(); 
		break;
	case SITE_GOVERNMENT_INTELLIGENCEHQ:
		if (!LCSrandom(24))
		{
			string rndWeps[] = { tag_WEAPON_FLAMETHROWER, tag_WEAPON_SEMIPISTOL_45,
				tag_WEAPON_SMG_MP5, tag_WEAPON_CARBINE_M4, tag_WEAPON_AUTORIFLE_M16 };
			newWeaponType = pickrandom(rndWeps);
		}
		else if (!LCSrandom(30))
		{
			string rndArmors[] = { tag_ARMOR_HEAVYARMOR };
			newArmorType = pickrandom(rndArmors);
		}
		else newLootType = getNewLootFromIntelligence(); 
		
		break;
	case SITE_GOVERNMENT_FIRESTATION:
		if (!LCSrandom(25)) newArmorType = tag_ARMOR_BUNKERGEAR;
		else if (LCSrandom(2))newLootType = tag_LOOT_TRINKET;
		else newLootType = tag_LOOT_COMPUTER;
		break;
	case SITE_INDUSTRY_SWEATSHOP:
		newLootType = tag_LOOT_FINECLOTH;
		break;
	case SITE_INDUSTRY_POLLUTER:
		newLootType = tag_LOOT_CHEMICAL;
		break;
	case SITE_CORPORATE_HEADQUARTERS:
		newLootType = getNewLootFromCorporate();
		break;
	case SITE_CORPORATE_HOUSE:
		if (!LCSrandom(50))
		{
			string rndArmors[] = { tag_ARMOR_EXPENSIVEDRESS, tag_ARMOR_EXPENSIVESUIT, tag_ARMOR_EXPENSIVESUIT,
				tag_ARMOR_EXPENSIVESUIT, tag_ARMOR_BONDAGEGEAR };
			newArmorType = pickrandom(rndArmors);
		}else
		newLootType = getNewLootFromCorporateHouse();
		break;
	case SITE_MEDIA_AMRADIO:
		newLootType = getNewLootFromRadio();
		break;
	case SITE_MEDIA_CABLENEWS:
		newLootType = getNewLootFromCable();
		break;
	case SITE_BUSINESS_BARANDGRILL:
	case SITE_OUTDOOR_BUNKER:
	case SITE_RESIDENTIAL_BOMBSHELTER:
		//storming a CCS stronghold. Logically you ought to get all the leftover stuff if you win...
		string rndWeps[] = { tag_WEAPON_SEMIPISTOL_9MM, tag_WEAPON_SEMIPISTOL_45, tag_WEAPON_REVOLVER_38, tag_WEAPON_REVOLVER_44,
			tag_WEAPON_SMG_MP5, tag_WEAPON_CARBINE_M4, tag_WEAPON_AUTORIFLE_M16 };
		string rndArmors[] = { tag_ARMOR_CHEAPSUIT, tag_ARMOR_CLOTHES, tag_ARMOR_TRENCHCOAT, tag_ARMOR_WORKCLOTHES,
			tag_ARMOR_SECURITYUNIFORM, tag_ARMOR_CIVILLIANARMOR, tag_ARMOR_ARMYARMOR, tag_ARMOR_HEAVYARMOR };
		switch (LCSrandom(3))
		{
		case 0:
			newWeaponType = pickrandom(rndWeps);
			break;
		case 1:
			newArmorType = pickrandom(rndArmors);
			break;
		default:
			newLootType = getNewLootFromCCS();
			break;
		}
		break;
	}
	item = NULL;
	if (len(newLootType))
	{
		item = getNewLoot(newLootType);
		activesquad->loot.push_back(item);
	}
	if (len(newArmorType))
	{
		item = spawnNewArmor(newArmorType);
		activesquad->loot.push_back(item);
	}
	if (len(newWeaponType))
	{

		item = spawnNewWeapon(newWeaponType);
		activesquad->loot.push_back(item);
	}
	if (item)
	{
		string s = item->equip_title();
		clearmessagearea();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(16, 1, CONST_sitemode114, gamelog);
		mvaddstrAlt(17, 1, s, gamelog);
		gamelog.newline();
		pressAnyKey(); //wait for key press before clearing.
	}
}
void pressedKeyG(const int enemy, int& encounter_timer) {
	extern Log gamelog;
	extern newsstoryst *sitestory;
	extern squadst *activesquad;
	extern short lawList[LAWNUM];
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	extern vector<Item *> groundloot;
	extern short sitealarm;
	extern int locx;
	extern int locy;
	extern int locz;
	extern int sitecrime;
	extern short cursite;
	if ((isThereGroundLoot() || (levelmap[locx][locy][locz].flag&SITEBLOCK_LOOT)))
	{
		bool tookground = 0;
		if (levelmap[locx][locy][locz].flag&SITEBLOCK_LOOT)
		{
			levelmap[locx][locy][locz].flag &= ~SITEBLOCK_LOOT;
			if (LocationsPool::getInstance().isThereASiegeHere(cursite))
			{
				//GRAB SOME OF THE BASE LOOT
				int lcount = 1; //1 FROM THE ONE DELETED ABOVE
				for (int x = 0; x < MAPX; x++)
					for (int y = 0; y < MAPY; y++)
						for (int z = 0; z < MAPZ; z++)
							if (levelmap[x][y][z].flag&SITEBLOCK_LOOT)
								lcount++;
				int lplus = LocationsPool::getInstance().lenloot(cursite) / lcount;
				if (lcount == 1) lplus = LocationsPool::getInstance().lenloot(cursite);
				for (; lplus > 0; lplus--)
				{
					getRandomLoot(cursite);
				}
			}
			else
			{
				getThatGroundLoot();
			}
			tookground = 1;
		}
		//MAKE GROUND LOOT INTO MISSION LOOT
		for (int l = 0; l < len(groundloot); l++)
			activesquad->loot.push_back(groundloot[l]);
		groundloot.clear();
		if (enemy&&sitealarm)enemyattack();
		else if (enemy)disguisecheck(encounter_timer);
		if (tookground)
		{
			// If the party steals from the ground, party member 0 gets the blame
			juiceparty(1, 200);
			alienationcheck(0);
			noticecheck(-1);
			sitecrime++;
			sitestory->crime.push_back(CRIME_STOLEGROUND);
			if (enemy)
				criminalize(*(activesquad->squad[0]), LAWFLAG_THEFT);
		}
		creatureadvance();
		encounter_timer++;
	}
}
void putBackSpecials(const int olocx, const int olocy, const int olocz) {
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	extern Creature encounter[ENCMAX];
	//PUT BACK SPECIALS
	for (int e = 0; e < ENCMAX; e++)
		if (encounter[e].exists)
		{
			if (!encounter[e].cantbluff&&encounter[e].type == CREATURE_LANDLORD)
				levelmap[olocx][olocy][olocz].special = SPECIAL_APARTMENT_LANDLORD;
			if (!encounter[e].cantbluff&&encounter[e].type == CREATURE_BANK_TELLER)
				levelmap[olocx][olocy][olocz].special = SPECIAL_BANK_TELLER;
			encounter[e].exists = 0;
		}
}
void enemyAttemptsFreeShots(int& encounter_timer) {
	extern Log gamelog;
	extern squadst *activesquad;
	extern short fieldskillrate;
	extern short sitealarm;
	extern Creature encounter[ENCMAX];
	//ENEMIES SHOULD GET FREE SHOTS NOW
	if (sitealarm)
	{
		bool snuck_away = true;
		// Try to sneak past
		for (int e = 0; e < ENCMAX && snuck_away; e++)
		{
			if (encounter[e].exists &&
				encounter[e].alive  &&
				encounter[e].cantbluff == 2)
			{
				// You can't sneak past this person; they already know you're there
				snuck_away = false;
			}
		}
		// If you can sneak past all enemies
		if (snuck_away)
		{
			for (int e = 0; e < ENCMAX && snuck_away; e++)
			{
				if (!encounter[e].exists)continue;
				for (int i = 0; i < 6; i++)
				{
					if (activesquad->squad[i])
					{
						int roll = activesquad->squad[i]->skill_roll(SKILL_STEALTH);
						if (roll + 1 == DIFFICULTY_HARD && fieldskillrate == FIELDSKILLRATE_HARD)
							activesquad->squad[i]->train(SKILL_STEALTH, 10);
						if (roll < DIFFICULTY_HARD)
						{
							snuck_away = false;
							break;
						}
					}
				}
			}
		}
		// If snuck past everyone
		if (snuck_away)
		{
			for (int i = 0; i < 6; i++)
			{
				if (activesquad->squad[i] != NULL)
				{
					switch (fieldskillrate)
					{
					case FIELDSKILLRATE_FAST:
						activesquad->squad[i]->train(SKILL_STEALTH, 40); break;
					case FIELDSKILLRATE_CLASSIC:
						activesquad->squad[i]->train(SKILL_STEALTH, 10); break;
					case FIELDSKILLRATE_HARD:
						activesquad->squad[i]->train(SKILL_STEALTH, 0); break;
					}
				}
			}
			clearmessagearea();
			set_color_easy(CYAN_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode115, gamelog);
			gamelog.newline();
			pressAnyKey();
		}
		else
			enemyattack();
	}
	else disguisecheck(encounter_timer);
}
void bailUponVictory() {
	extern Log gamelog;
	extern short cursite;
	extern newsstoryst *sitestory;
	extern squadst *activesquad;
	extern MusicClass music;
	music.play(MUSIC_CONQUER);
	if (LocationsPool::getInstance().isThisUnderAttack(cursite))sitestory->type = NEWSSTORY_SQUAD_DEFENDED;
	else sitestory->type = NEWSSTORY_SQUAD_BROKESIEGE;
	if (LocationsPool::getInstance().getSiegeType(cursite) == SIEGE_CCS)
	{
		// CCS DOES NOT capture the warehouse -- reverse earlier assumption of your defeat!
		if (LocationsPool::getInstance().getLocationType(cursite) == SITE_INDUSTRY_WAREHOUSE || LocationsPool::getInstance().getLocationType(cursite) == SITE_BUSINESS_CRACKHOUSE)
			LocationsPool::getInstance().setRenting(cursite, RENTING_PERMANENT);
		else if (LocationsPool::getInstance().getLocationType(cursite) == SITE_RESIDENTIAL_TENEMENT)
			LocationsPool::getInstance().setRenting(cursite, 200);
		else if (LocationsPool::getInstance().getLocationType(cursite) == SITE_RESIDENTIAL_APARTMENT)
			LocationsPool::getInstance().setRenting(cursite, 650);
		else if (LocationsPool::getInstance().getLocationType(cursite) == SITE_RESIDENTIAL_APARTMENT_UPSCALE)
			LocationsPool::getInstance().setRenting(cursite, 1500);
	}
	//DEAL WITH PRISONERS AND STOP BLEEDING
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] == NULL)continue;
		if (activesquad->squad[p]->prisoner != NULL)
		{
			if (activesquad->squad[p]->prisoner->squadid != -1)
			{
				//RESTORE POOL MEMBER
				activesquad->squad[p]->prisoner->squadid = -1;
				//MUST LOCATE THE MEMBER
				activesquad->squad[p]->prisoner->location = activesquad->squad[p]->base;
				activesquad->squad[p]->prisoner->base = activesquad->squad[p]->base;
			}
			else
			{
				//CONVERT KIDNAP VICTIM
				kidnaptransfer(*activesquad->squad[p]->prisoner);
				delete activesquad->squad[p]->prisoner;
			}
			activesquad->squad[p]->prisoner = NULL;
		}
	}
	//Clear all bleeding and prison escape flags
	CreaturePool::getInstance().clearAllBleedingAndEscapeFlags();
	//INFORM
	clearmessagearea();
	set_color_easy(GREEN_ON_BLACK_BRIGHT);
	mvaddstrAlt(16, 1, CONST_sitemode118, gamelog);
	mvaddstrAlt(17, 1, CONST_sitemode119, gamelog);
	gamelog.newline();
	pressAnyKey();
	conquertext();
	escapesiege(1);
}
void bailOnBase() {
	extern Log gamelog;
	extern squadst *activesquad;
	extern short postalarmtimer;
	extern short sitetype;
	extern int sitecrime;
	extern short sitealarm;
	extern short cursite;
	extern chaseseqst chaseseq;
	extern char showcarprefs;
	extern newsstoryst *sitestory;
	// Seperate logging message.
	gamelog.record(activesquad->name);
	gamelog.record(CONST_sitemode116);
	if (LocationsPool::getInstance().isThisAFront(cursite) != -1)
		gamelog.record(LocationsPool::getInstance().getFrontName(cursite));
	else
		gamelog.record(LocationsPool::getInstance().getLocationName(cursite));
	gamelog.record(singleDot);
	gamelog.nextMessage();
	//RESET MODE PRIOR TO CHASE
	showcarprefs = 0;
	//CHASE SEQUENCE OR FOOT CHASE
	chaseseq.clean();
	chaseseq.location = cursite;
	long level = sitecrime;
	if (sitealarm == 0)level = 0;
	if (LCSrandom(3) && level < 4)level = 0;
	if (LCSrandom(2) && level < 8)level = 0;
	if (postalarmtimer < 10 + (int)LCSrandom(20))level = 0;
	else if (postalarmtimer < 20 + (int)LCSrandom(20) && LCSrandom(3))level = 0;
	else if (postalarmtimer < 40 + (int)LCSrandom(20) && !LCSrandom(3))level = 0;
	if (LocationsPool::getInstance().isThereASiegeHere(cursite))level = 1000;
	//MAKE SURE YOU ARE GUILTY OF SOMETHING
	bool guilty = 0;
	for (int p = 0; p < 6; p++)
		if (activesquad->squad[p] != NULL)
			if (iscriminal(*activesquad->squad[p]))guilty = 1;
	if (!guilty)level = 0;
	makechasers(sitetype, level);
	bool havecar = 0;
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] != NULL)
		{
			if (activesquad->squad[p]->carid != -1)
			{
				havecar = 1;
				for (int i = 0; i < 6; i++)
				{
					if (activesquad->squad[i] != NULL &&
						activesquad->squad[i]->carid == -1)
					{
						activesquad->squad[i]->carid = activesquad->squad[p]->carid;
					}
				}
				break;
			}
		}
	}
	bool gotout;
	if (havecar)gotout = chasesequence();
	else gotout = footchase();
	//If you survived
	if (gotout)
	{
		//Check for hauled prisoners/corpses
		for (int p = 0; p < 6; p++)
		{
			if (activesquad->squad[p] == NULL)continue;
			if (activesquad->squad[p]->prisoner != NULL)
			{
				//If this is an LCS member or corpse being hauled (marked as in the squad)
				if (activesquad->squad[p]->prisoner->squadid != -1)
				{
					//Take them out of the squad
					activesquad->squad[p]->prisoner->squadid = -1;
					//Set base and current location to squad's safehouse
					activesquad->squad[p]->prisoner->location = activesquad->squad[p]->base;
					activesquad->squad[p]->prisoner->base = activesquad->squad[p]->base;
				}
				else //A kidnapped conservative
				{
					//Convert them into a prisoner
					kidnaptransfer(*activesquad->squad[p]->prisoner);
					delete activesquad->squad[p]->prisoner;
				}
				activesquad->squad[p]->prisoner = NULL;
			}
		}
		//Clear all bleeding and prison escape flags
		CreaturePool::getInstance().clearAllBleedingAndEscapeFlags();
		//END SITE MODE
		if (LocationsPool::getInstance().isThereASiegeHere(cursite))
		{
			//Special handling for escaping siege
			escapesiege(0);
		}
		else
		{
			resolvesite();
		}
	}
	//You didn't survive -- handle squad death (unless that ended the game)
	else if (!endcheck())
	{
		if (LocationsPool::getInstance().isThereASiegeHere(cursite))
		{
			//Report on squad killed during siege
			if (LocationsPool::getInstance().isThisUnderAttack(cursite))sitestory->type = NEWSSTORY_SQUAD_KILLED_SIEGEATTACK;
			else sitestory->type = NEWSSTORY_SQUAD_KILLED_SIEGEESCAPE;
			LocationsPool::getInstance().isThereASiegeHere(cursite, 0);
		}
		else
		{
			//Or report on your failed raid
			sitestory->type = NEWSSTORY_SQUAD_KILLED_SITE;
			//Would juice the party here, but you're all dead, so...
			resolvesite();
		}
	}
}
void bailUponDefeatCCS() {
	extern Log gamelog;
	extern short cursite;
	extern char ccs_kills;
	extern squadst *activesquad;
	extern char endgamestate;
	extern MusicClass music;
	music.play(MUSIC_CONQUER);
	//DEAL WITH PRISONERS AND STOP BLEEDING
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] == NULL)continue;
		if (activesquad->squad[p]->prisoner != NULL)
		{
			if (activesquad->squad[p]->prisoner->squadid != -1)
			{
				//RESTORE POOL MEMBER
				activesquad->squad[p]->prisoner->squadid = -1;
				//MUST LOCATE THE MEMBER
				activesquad->squad[p]->prisoner->location = activesquad->squad[p]->base;
				activesquad->squad[p]->prisoner->base = activesquad->squad[p]->base;
			}
			else
			{
				//CONVERT KIDNAP VICTIM
				kidnaptransfer(*activesquad->squad[p]->prisoner);
				delete activesquad->squad[p]->prisoner;
			}
			activesquad->squad[p]->prisoner = NULL;
		}
	}
	//Clear all bleeding and prison escape flags
	CreaturePool::getInstance().clearAllBleedingAndEscapeFlags();
	//INFORM
	clearmessagearea();
	set_color_easy(GREEN_ON_BLACK_BRIGHT);
	mvaddstrAlt(16, 1, CONST_sitemode117, gamelog);
	gamelog.newline();
	pressAnyKey();
	LocationsPool::getInstance().captureSite(cursite);
	// CCS Safehouse killed?
	if (LocationsPool::getInstance().getLocationType(cursite) == SITE_RESIDENTIAL_BOMBSHELTER ||
		LocationsPool::getInstance().getLocationType(cursite) == SITE_BUSINESS_BARANDGRILL ||
		LocationsPool::getInstance().getLocationType(cursite) == SITE_OUTDOOR_BUNKER)
	{
		ccs_kills++;
		if (ccs_kills < 3) endgamestate--;
		else endgamestate = ENDGAME_CCS_DEFEATED;
	}
	conquertextccs();
}
int attemptResolveSiege(const int olocx, const int olocy, const int olocz) {
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	extern int locx;
	extern int locy;
	extern int locz;
	extern short cursite;

	if (locx != olocx || locy != olocy || locz != olocz)
		emptyEncounter();
	//MOVE SIEGE UNITS AROUND
	//MOVE UNITS
	vector<int> unitx, unity, unitz;
	for (int x = 0; x < MAPX; x++) for (int y = 0; y < MAPY; y++) for (int z = 0; z < MAPZ; z++)
		if (levelmap[x][y][z].siegeflag&SIEGEFLAG_UNIT)
			unitx.push_back(x), unity.push_back(y), unitz.push_back(z);
	int sx = 0, sy = 0, sz = 0;
	for (int u = 0; u < len(unitx); u++)
	{
		// don't leave tile if player is here
		if (unitx[u] == locx && unity[u] == locy && unitz[u] == locz) continue;
		// move into player's tile if possible
		if ((((unitx[u] == locx - 1 || unitx[u] == locx + 1) &&
			unity[u] == locy) ||
			((unity[u] == locy - 1 || unity[u] == locy + 1) &&
				unitx[u] == locx))
			&& unitz[u] == locz)
		{
			levelmap[unitx[u]][unity[u]][unitz[u]].siegeflag &= ~SIEGEFLAG_UNIT;
			//Get torched
			if (levelmap[locx][locy][locz].flag & SITEBLOCK_FIRE_PEAK)
				levelmap[locx][locy][locz].siegeflag |= SIEGEFLAG_UNIT_DAMAGED;
			//BLOW TRAPS
			if (levelmap[locx][locy][locz].siegeflag & SIEGEFLAG_TRAP)
			{
				levelmap[locx][locy][locz].siegeflag &= ~SIEGEFLAG_TRAP;
				levelmap[locx][locy][locz].siegeflag |= SIEGEFLAG_UNIT_DAMAGED;
			}
			else levelmap[locx][locy][locz].siegeflag |= SIEGEFLAG_UNIT;
			continue;
		}
		sz = 0;
		switch (LCSrandom(4))
		{
		case 0: sx = -1, sy = 0; break;
		case 1: sx = 1, sy = 0; break;
		case 2: sx = 0, sy = 1; break;
		case 3: sx = 0, sy = -1; break;
		}
		sx += unitx[u], sy += unity[u], sz += unitz[u];
		if (sx >= 0 && sx < MAPX&&sy >= 0 && sy < MAPY&&sz >= 0 && sz < MAPZ)
			if (!(levelmap[sx][sy][sz].flag&SITEBLOCK_BLOCK))
			{
				if ((levelmap[sx][sy][sz].flag&SITEBLOCK_DOOR))
					levelmap[sx][sy][sz].flag &= ~(SITEBLOCK_DOOR | SITEBLOCK_LOCKED | SITEBLOCK_KLOCK | SITEBLOCK_CLOCK);
				else
				{  //BLOCK PASSAGE
					if (!(levelmap[sx][sy][sz].siegeflag&(SIEGEFLAG_UNIT | SIEGEFLAG_HEAVYUNIT)))
					{
						levelmap[unitx[u]][unity[u]][unitz[u]].siegeflag &= ~SIEGEFLAG_UNIT;
						//BLOW TRAPS
						if (levelmap[sx][sy][sz].siegeflag&SIEGEFLAG_TRAP)
						{
							levelmap[sx][sy][sz].siegeflag &= ~SIEGEFLAG_TRAP;
							levelmap[sx][sy][sz].siegeflag |= SIEGEFLAG_UNIT_DAMAGED;
						}
						else levelmap[sx][sy][sz].siegeflag |= SIEGEFLAG_UNIT;
					}
				}
			}
	}
	unitx.clear(), unity.clear(), unitz.clear();
	for (int u = 0; u < len(unitx); u++)
	{
		sz = 0;
		switch (LCSrandom(4))
		{
		case 0: sx = -1, sy = 0; break;
		case 1: sx = 1, sy = 0; break;
		case 2: sx = 0, sy = 1; break;
		case 3: sx = 0, sy = -1; break;
		}
		sx += unitx[u], sy += unity[u], sz += unitz[u];
		if (sx >= 0 && sx < MAPX&&sy >= 0 && sy < MAPY&&sz >= 0 && sz < MAPZ)
			if (!(levelmap[sx][sy][sz].flag&SITEBLOCK_BLOCK) && (levelmap[sx][sy][sz].flag&SITEBLOCK_DOOR))
				levelmap[sx][sy][sz].flag &= ~(SITEBLOCK_DOOR | SITEBLOCK_LOCKED | SITEBLOCK_KLOCK | SITEBLOCK_CLOCK);
	}
	unitx.clear(), unity.clear(), unitz.clear();
	//NEW WAVES
	//IF THERE AREN'T ENOUGH UNITS AROUND
	//AND THEY HAVEN'T BEEN SCARED OFF
	//MORE WAVES WILL ATTACK
	//AND IT GETS WORSE AND WORSE
	//but not as bad as it used to get,
	//since the extra waves are small
	LocationsPool::getInstance().tickAttackTime(cursite);
	if ((LocationsPool::getInstance().getAttackTime(cursite) >= 100 + LCSrandom(10) &&
		(locz != 0 || locx<(MAPX / 2 - 3) || locx>(MAPX / 2 + 3) ||
			locy > 5)))
	{
		LocationsPool::getInstance().resetAttackTime(cursite);
		int existingUnits = 0;
		for (int x = 0; x < MAPX; x++) for (int y = 0; y < MAPY; y++) for (int z = 0; z < MAPZ; z++)
			if (levelmap[x][y][z].siegeflag&(SIEGEFLAG_UNIT | SIEGEFLAG_HEAVYUNIT))
				existingUnits++;
		//PLACE UNITS
		int lx, ly, lz, unitnum = 7 - existingUnits, count = 10000;
		if (unitnum < 0)unitnum = 0;
		for (int t = 0; t < unitnum; t++)
		{
			count = 10000;
			do
			{
				lx = LCSrandom(7) + (MAPX / 2) - 3, ly = LCSrandom(5), lz = 0, count--;
				if (count == 0) break;
			} while ((levelmap[lx][ly][lz].flag & (SITEBLOCK_BLOCK | SITEBLOCK_DOOR | SITEBLOCK_EXIT)) ||
				(levelmap[lx][ly][lz].siegeflag & (SIEGEFLAG_UNIT | SIEGEFLAG_HEAVYUNIT | SIEGEFLAG_TRAP)));
			levelmap[lx][ly][lz].siegeflag |= SIEGEFLAG_UNIT;
		}
		if (!LocationsPool::getInstance().doWeHaveTankTraps(cursite) &&
			LocationsPool::getInstance().getSiegeType(cursite) == SIEGE_POLICE &&
			LocationsPool::getInstance().getSiegeEscalationState(cursite) >= 2)
		{
			count = 10000;
			int hunitnum = 1;
			for (int t = 0; t < hunitnum; t++)
			{
				do
				{
					lx = LCSrandom(7) + (MAPX / 2) - 3, ly = LCSrandom(5), lz = 0, count--;
					if (count == 0) break;
				} while ((levelmap[lx][ly][lz].flag&(SITEBLOCK_BLOCK | SITEBLOCK_DOOR | SITEBLOCK_EXIT)) ||
					(levelmap[lx][ly][lz].siegeflag&(SIEGEFLAG_UNIT | SIEGEFLAG_HEAVYUNIT | SIEGEFLAG_TRAP)));
				levelmap[lx][ly][lz].siegeflag |= SIEGEFLAG_HEAVYUNIT;
				LocationsPool::getInstance().spawnATank(cursite);
			}
		}
	}
	//CHECK FOR SIEGE UNITS
	//INCLUDING DAMAGED ONES
	if (levelmap[locx][locy][locz].siegeflag&SIEGEFLAG_UNIT)
	{
		if (addsiegeencounter(SIEGEFLAG_UNIT))
			levelmap[locx][locy][locz].siegeflag &= ~SIEGEFLAG_UNIT;
	}
	if (levelmap[locx][locy][locz].siegeflag&SIEGEFLAG_HEAVYUNIT)
	{
		if (addsiegeencounter(SIEGEFLAG_HEAVYUNIT))
			levelmap[locx][locy][locz].siegeflag &= ~SIEGEFLAG_HEAVYUNIT;
	}
	if (levelmap[locx][locy][locz].siegeflag&SIEGEFLAG_UNIT_DAMAGED)
	{
		if (addsiegeencounter(SIEGEFLAG_UNIT_DAMAGED))
			levelmap[locx][locy][locz].siegeflag &= ~SIEGEFLAG_UNIT_DAMAGED;
	}
	//BAIL UPON VICTORY
	if (LocationsPool::getInstance().getSiegeKills(cursite) >= 10 &&
		LocationsPool::getInstance().getSiegeTanks(cursite) < 1 &&
		LocationsPool::getInstance().isThereASiegeHere(cursite))
	{
		bailUponVictory();
		return 1;
	}
	return 0;
}
void encounterSpecial(const int makespecial, const int olocx, const int olocy, const int olocz) {
	extern Log gamelog;
	extern int locx;
	extern int locy;
	extern int locz;
	extern bool encounterwarnings;
	extern short sitetype;
	extern short cursite;
	extern short sitealienate;
	extern short sitealarm;
	extern UniqueCreatures uniqueCreatures;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	extern Creature encounter[ENCMAX];
	extern short lawList[LAWNUM];
	switch (makespecial)
	{
	case SPECIAL_CAFE_COMPUTER:
		if (sitealarm || sitealienate)
		{
			clearmessagearea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode120, gamelog);
			gamelog.newline();
			levelmap[locx][locy][locz].special = -1;
			pressAnyKey();
		}
		else
		{
			clearmessagearea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode121, gamelog);
			gamelog.newline();
			levelmap[locx][locy][locz].special = -1;
			pressAnyKey();
			prepareencounter(sitetype, 0);
			emptyEncounter();
		}
		break;
	case SPECIAL_RESTAURANT_TABLE:
		if (sitealarm || sitealienate)
		{
			clearmessagearea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode122, gamelog);
			gamelog.newline();
			levelmap[locx][locy][locz].special = -1;
			pressAnyKey();
			prepareencounter(sitetype, 0);
		}
		else
		{
			clearmessagearea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode123, gamelog);
			gamelog.newline();
			levelmap[locx][locy][locz].special = -1;
			pressAnyKey();
			prepareencounter(sitetype, 0);
		}
		break;
	case SPECIAL_PARK_BENCH:
		if (sitealarm || sitealienate)
		{
			clearmessagearea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode124, gamelog);
			gamelog.newline();
			levelmap[locx][locy][locz].special = -1;
			pressAnyKey();
		}
		else
		{
			clearmessagearea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode125, gamelog);
			gamelog.newline();
			levelmap[locx][locy][locz].special = -1;
			pressAnyKey();
			prepareencounter(sitetype, 0);
		}
		break;
	case SPECIAL_SECURITY_CHECKPOINT:
		special_security_checkpoint();
		break;
	case SPECIAL_SECURITY_METALDETECTORS:
		special_security_metaldetectors();
		break;
	case SPECIAL_SECURITY_SECONDVISIT:
		special_security_secondvisit();
		break;
	case SPECIAL_CLUB_BOUNCER:
		special_bouncer_assess_squad();
		break;
	case SPECIAL_CLUB_BOUNCER_SECONDVISIT:
		special_bouncer_greet_squad();
		break;
	case SPECIAL_HOUSE_CEO:
		if ((sitealarm || sitealienate || LocationsPool::getInstance().isThereASiegeHere(cursite)) &&
			uniqueCreatures.CEO_state == UNIQUECREATURE_ALIVE)
		{
			clearmessagearea(false);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			if (lawList[LAW_FREESPEECH] != ALIGN_ARCHCONSERVATIVE)
				mvaddstrAlt(16, 1, CONST_sitemode126, gamelog);
			else
				mvaddstrAlt(16, 1, CONST_sitemode127, gamelog);
			addstrAlt(CONST_sitemode128, gamelog);
			gamelog.newline();
			levelmap[locx][locy][locz].special = -1;
			pressAnyKey();
		}
		else
		{
			switch (uniqueCreatures.CEO_state)
			{
			case UNIQUECREATURE_ALIVE:
				clearmessagearea(false);
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(16, 1, CONST_sitemode129, gamelog);
				gamelog.newline();
				levelmap[locx][locy][locz].special = -1;
				pressAnyKey();
				emptyEncounter();
				encounter[0] = uniqueCreatures.CEO();
				encounter[0].exists = true;
				break;
			case UNIQUECREATURE_DEAD:
			case UNIQUECREATURE_LIBERAL:
				clearmessagearea(false);
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(16, 1, CONST_sitemode130, gamelog);
				gamelog.newline();
				levelmap[locx][locy][locz].special = -1;
				pressAnyKey();
				break;
			}
		}
		break;
	case SPECIAL_APARTMENT_LANDLORD:
		if (sitealarm || sitealienate ||
			LocationsPool::getInstance().isThereASiegeHere(cursite))
		{
			clearmessagearea(false);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode131, gamelog);
			gamelog.newline();
			levelmap[locx][locy][locz].special = -1;
			pressAnyKey();
		}
		else
		{
			clearmessagearea(false);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_sitemode132, gamelog);
			gamelog.newline();
			levelmap[locx][locy][locz].special = -1;
			pressAnyKey();
			emptyEncounter();
			makecreature(encounter[0], CREATURE_LANDLORD);
		}
		break;
	case SPECIAL_BANK_TELLER:
		special_bank_teller();
		break;
	case SPECIAL_CCS_BOSS:
		special_ccs_boss();
		break;
	case SPECIAL_OVAL_OFFICE_NW:
	case SPECIAL_OVAL_OFFICE_NE:
	case SPECIAL_OVAL_OFFICE_SW:
	case SPECIAL_OVAL_OFFICE_SE:
		special_oval_office();
		break;
	default:
		bool squadmoved = (olocx != locx || olocy != locy || olocz != locz);
		if (squadmoved &&
			(LocationsPool::getInstance().getLocationType(cursite) == SITE_RESIDENTIAL_APARTMENT ||
				LocationsPool::getInstance().getLocationType(cursite) == SITE_RESIDENTIAL_TENEMENT ||
				LocationsPool::getInstance().getLocationType(cursite) == SITE_RESIDENTIAL_APARTMENT_UPSCALE))
		{
			if (LCSrandom(3))break; // Rarely encounter someone in apartments.
		}
		prepareencounter(sitetype, LocationsPool::getInstance().isThisPlaceHighSecurity(cursite));
		int numenc = 0;
		// TODO This is bizarre
		// the for loop breaks if it finds an empty encounter
		for (int e = 0; e < ENCMAX; e++)
		{
			if (encounter[e].exists) numenc++;
			else break;
		}
		if (encounterwarnings&&numenc > 0)
		{  // show an encounter warning, based on whether the squad moved or not and the size of the encounter
			clearmessagearea(false);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			string weMoved;
			string weDidntMove;
			if (numenc == 1)
			{
				weMoved = CONST_sitemode133;
				weDidntMove = CONST_sitemode134;
			}
			else if (numenc <= 3)
			{
				weMoved = CONST_sitemode135;
				weDidntMove = CONST_sitemode136;
			}
			else if (numenc <= 6)
			{
				weMoved = CONST_sitemode137;
				weDidntMove = CONST_sitemode138;
			}
			else
			{
				weMoved = CONST_sitemode139;
				weDidntMove = CONST_sitemode140;
			}
			if (squadmoved) {
				mvaddstrAlt(16, 1, weMoved, gamelog);
			}
			else {
				mvaddstrAlt(16, 1, weDidntMove, gamelog);
			}
			gamelog.newline();
			pressAnyKey();
		}
		break;
	}
}
void pressedKeyShiftL() {

	reloadparty();
	printparty();
	refreshAlt();
	creatureadvance();

}
// return true if leaving site
int moveOrWaitThenCheckForExit(const int olocx, const int olocy, const int olocz, const char c, const int encsize, char& hostcheck) {

	extern int locx;
	extern int locy;
	extern int locz;
	extern short postalarmtimer;
	extern char showcarprefs;
	extern short cursite;
	extern int ccs_boss_kills;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	extern Creature encounter[ENCMAX];




	//SEE IF THERE IS AN ENCOUNTER
	char newenc = 0;
	// 10% chance of encounter normally (100% if waiting)
	// 20% chance of encounter after massive response
	// 0% chance of encounter during sieges
	if (!LocationsPool::getInstance().isThereASiegeHere(cursite))
	{
		if (postalarmtimer > 80) { if (!LCSrandom(5)) newenc = 1; }
		else if (!LCSrandom(10) || c == 's') newenc = 1;
	}
	for (int e = 0; e < ENCMAX; e++) if (encounter[e].exists) newenc = 0;
	// Handle special tiles that activate when you step on them
	// (rather than those that must be manually activated)
	long makespecial = -1;
	switch (levelmap[locx][locy][locz].special)
	{
	case SPECIAL_SECURITY_CHECKPOINT:
	case SPECIAL_SECURITY_METALDETECTORS:
	case SPECIAL_SECURITY_SECONDVISIT:
	case SPECIAL_CLUB_BOUNCER:
	case SPECIAL_CLUB_BOUNCER_SECONDVISIT:
	case SPECIAL_APARTMENT_LANDLORD:
	case SPECIAL_HOUSE_CEO:
	case SPECIAL_RESTAURANT_TABLE:
	case SPECIAL_CAFE_COMPUTER:
	case SPECIAL_PARK_BENCH:
	case SPECIAL_BANK_TELLER:
	case SPECIAL_CCS_BOSS:
	case SPECIAL_OVAL_OFFICE_NW:
	case SPECIAL_OVAL_OFFICE_NE:
	case SPECIAL_OVAL_OFFICE_SW:
	case SPECIAL_OVAL_OFFICE_SE:
		makespecial = levelmap[locx][locy][locz].special;
		newenc = 1;
		break;
	}
	//DO DOORS
	if (levelmap[locx][locy][locz].flag & SITEBLOCK_DOOR)
	{
		open_door(levelmap[olocx][olocy][olocz].flag&SITEBLOCK_RESTRICTED);
		locx = olocx, locy = olocy, locz = olocz;
		if (encsize > 0) newenc = 0;
	}
	//BAIL UPON VICTORY (version 2 -- defeated CCS safehouse)
	if (ccs_boss_kills >= 1 &&
		!LocationsPool::getInstance().isThereASiegeHere(cursite) &&
		LocationsPool::getInstance().getRentingType(cursite) == RENTING_CCS)
	{
		bailUponDefeatCCS();
		showcarprefs = 0;
		return 1;
	}
	if (LocationsPool::getInstance().isThereASiegeHere(cursite)) // *JDS* police response added
	{
		if (attemptResolveSiege(olocx, olocy, olocz)) {
			showcarprefs = 0;
			return 1;
		}
	}
	if (!LocationsPool::getInstance().isThereASiegeHere(cursite) && newenc)
	{
		encounterSpecial(makespecial, olocx, olocy, olocz);
		hostcheck = 1;
	}
	if (!LocationsPool::getInstance().isThereASiegeHere(cursite))
		if ((locx != olocx || locy != olocy || locz != olocz) && !newenc)
			putBackSpecials(olocx, olocy, olocz);

	if (locx != olocx || locy != olocy || locz != olocz)
	{
		//NUKE GROUND LOOT
		delete_and_clear_groundloot();
		//MOVE BLOOD
		if (levelmap[olocx][olocy][olocz].flag&SITEBLOCK_BLOODY2)
			levelmap[locx][locy][locz].flag |= SITEBLOCK_BLOODY;
	}
	knowmap();


	return 0;
}
void mode_site() {
	extern short cursite;
	extern squadst *activesquad;
	extern Log gamelog;
	extern MusicClass music;
	extern short postalarmtimer;
	extern short sitealarmtimer;
	extern short mode;
	extern bool mapshowing;
	extern short party_status;
	extern char foughtthisround;
	extern int sitecrime;
	extern int locx;
	extern int locy;
	extern int locz;
	extern short sitealarm;
	extern short sitealienate;
	extern newsstoryst *sitestory;
	extern char showcarprefs;
	extern short offended_amradio;
	extern short offended_cablenews;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	extern Creature encounter[ENCMAX];
	extern short lawList[LAWNUM];
	if (isThereNoActivesquad())return;
	reloadparty();
	showcarprefs = -1;
	char bail_on_base = 1;
	if (cursite == activesquad->squad[0]->base)bail_on_base = 0;
	knowmap();
	char hostcheck = 0;
	int encounter_timer = 0;
	while (true)
	{
		int partysize = squadsize(activesquad), partyalive = squadalive(activesquad), hostages = 0, encsize = 0, freeable = 0, enemy = 0, majorenemy = 0, talkers = 0;
		for (int p = 0; p < 6; p++)
			if (activesquad->squad[p] != NULL)
				if (activesquad->squad[p]->prisoner&&activesquad->squad[p]->prisoner->align != ALIGN_LIBERAL)
					hostages++;
		for (int e = 0; e < ENCMAX; e++)
		{
			if (encounter[e].exists)
			{
				encsize++;
				if (encounter[e].enemy())enemy++;
				if (encounter[e].type == CREATURE_WORKER_SERVANT ||
					encounter[e].type == CREATURE_WORKER_FACTORY_CHILD ||
					encounter[e].type == CREATURE_WORKER_SWEATSHOP ||
					(strcmp(encounter[e].name, CONST_sitemode141.c_str()) == 0 && encounter[e].align == 1))freeable++;
				else if ((encounter[e].cantbluff != 1 || sitealarm) && !(encounter[e].align == 1 && sitealarm&&enemy))talkers++;
				if (encounter[e].type == CREATURE_CORPORATE_CEO ||
					encounter[e].type == CREATURE_RADIOPERSONALITY ||
					encounter[e].type == CREATURE_NEWSANCHOR ||
					encounter[e].type == CREATURE_SCIENTIST_EMINENT ||
					encounter[e].type == CREATURE_JUDGE_CONSERVATIVE)majorenemy++;
			}
		}
		//If in combat, do a second check
		if (talkers&&sitealarm&&enemy)
		{
			talkers = 0;
			for (int e = 0; e < ENCMAX; e++)
				if (encounter[e].exists)
					if (encounter[e].enemy() && (encounter[e].cantbluff == 0 || encounter[e].animalgloss == ANIMALGLOSS_ANIMAL)) talkers++;
		}
		int libnum = CreaturePool::getInstance().countLiberals(cursite);
		// Let the squad stop stressing out over the encounter if there are no enemies this round
		if (!enemy) encounter_timer = 0;
		eraseAlt();
		{
			if (LocationsPool::getInstance().isThereASiegeHere(cursite))
			{
				music.play(MUSIC_DEFENSE);
				set_color_easy(RED_ON_BLACK_BRIGHT);
				mvaddstrAlt(0, 0, LocationsPool::getInstance().getLocationNameWithGetnameMethod(cursite, -1, true));
				addstrAlt(CONST_sitemode144);
				addstrAlt(locz + 1);
				addstrAlt(CONST_sitemode143);
			}
			else
			{
				if (postalarmtimer > 80) set_color_easy(RED_ON_BLACK_BRIGHT);
				else if (postalarmtimer > 60) set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				else set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(0, 0, LocationsPool::getInstance().getLocationNameWithGetnameMethod(cursite, -1, true));
				addstrAlt(CONST_sitemode144);
				addstrAlt(locz + 1);
				if (postalarmtimer > 80)
				{
					switch (LocationsPool::getInstance().getLocationType(cursite))
					{
					case SITE_GOVERNMENT_ARMYBASE:
						addstrAlt(CONST_sitemode145);
						break;
					case SITE_GOVERNMENT_WHITE_HOUSE:
						addstrAlt(CONST_sitemode146);
						break;
					case SITE_GOVERNMENT_INTELLIGENCEHQ:
						addstrAlt(CONST_sitemode147);
						break;
					case SITE_CORPORATE_HEADQUARTERS:
					case SITE_CORPORATE_HOUSE:
						addstrAlt(CONST_sitemode148);
						break;
					case SITE_MEDIA_AMRADIO:
					case SITE_MEDIA_CABLENEWS:
						addstrAlt(CONST_sitemode149);
						break;
					case SITE_BUSINESS_CRACKHOUSE:
						addstrAlt(CONST_sitemode150);
						break;
					case SITE_GOVERNMENT_POLICESTATION:
					default:
						if (LocationsPool::getInstance().getRentingType(cursite) == RENTING_CCS)
						{
							addstrAlt(CONST_sitemode151);
						}
						else if (lawList[LAW_DEATHPENALTY] == -2 &&
							lawList[LAW_POLICEBEHAVIOR] == -2)addstrAlt(CONST_sitemode152);
						else addstrAlt(CONST_sitemode153);
						break;
					}
					music.play(MUSIC_HEAVYCOMBAT);
				}
				else if (postalarmtimer > 60) { addstrAlt(CONST_sitemode154); music.play(MUSIC_ALARMED); }
				else if (sitealienate == 1) { addstrAlt(CONST_sitemode155); music.play(MUSIC_ALARMED); }
				else if (sitealienate == 2) { addstrAlt(CONST_sitemode156); music.play(MUSIC_ALARMED); }
				else if (sitealarm) { addstrAlt(CONST_sitemode157); music.play(MUSIC_ALARMED); }
				else if (sitealarmtimer == 0) { addstrAlt(CONST_sitemode158); music.play(MUSIC_SUSPICIOUS); }
				else music.play(MUSIC_SITEMODE);
			}
		}
		{
			//PRINT PARTY
			if (partyalive == 0)party_status = -1;
			printparty();
			//PRINT SITE INSTRUCTIONS
			if (partyalive > 0)
			{
				if (!enemy || !sitealarm)set_color_easy(WHITE_ON_BLACK);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(9, 1, CONST_sitemode159);
				if (partysize > 1)set_color_easy(WHITE_ON_BLACK);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(11, 1, change_squad_order);
				if (partysize > 0 && (party_status == -1 || partysize > 1))set_color_easy(WHITE_ON_BLACK);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(12, 1, check_status_of_squad_liberal);
				if (party_status != -1)set_color_easy(WHITE_ON_BLACK);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(13, 1, show_squad_liberal_status);
				if (isThereGroundLoot() || (levelmap[locx][locy][locz].flag&SITEBLOCK_LOOT))
					set_color_easy(WHITE_ON_BLACK);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(9, 17, CONST_sitemode160);
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(10, 17, CONST_sitemode161);
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(9, 32, CONST_sitemode162);
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(10, 32, CONST_sitemode163);
				if (!enemy || !sitealarm) set_color_easy(WHITE_ON_BLACK);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(10, 42, CONST_sitemode164);
				mvaddstrAlt(10, 1, CONST_sitemodeXRL);
				if (enemy) set_color_easy(WHITE_ON_BLACK);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(13, 42, CONST_sitemode165);
				if (talkers) set_color_easy(WHITE_ON_BLACK);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(14, 17, CONST_sitemode166);
				bool graffiti = 0;
				if (levelmap[locx][locy][locz].special != -1 &&
					levelmap[locx][locy][locz].special != SPECIAL_CLUB_BOUNCER_SECONDVISIT)set_color_easy(WHITE_ON_BLACK);
				else if (!(levelmap[locx][locy][locz].flag & (SITEBLOCK_GRAFFITI | SITEBLOCK_BLOODY2)))
				{
					if ((levelmap[locx + 1][locy][locz].flag & SITEBLOCK_BLOCK) ||
						(levelmap[locx - 1][locy][locz].flag & SITEBLOCK_BLOCK) ||
						(levelmap[locx][locy + 1][locz].flag & SITEBLOCK_BLOCK) ||
						(levelmap[locx][locy - 1][locz].flag & SITEBLOCK_BLOCK))
					{
						bool can_graffiti = false;
						for (int i = 0; i < 6 && !can_graffiti; i++)
						{
							if (!activesquad->squad[i]) i = 6;
							else can_graffiti = activesquad->squad[i]->get_weapon().can_graffiti();

						}
						if (can_graffiti) {

							set_color_easy(WHITE_ON_BLACK);
							graffiti = 1;

						}
						else set_color_easy(BLACK_ON_BLACK_BRIGHT);
					}
					else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				}
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				if (graffiti)mvaddstrAlt(11, 42, CONST_sitemode167);
				else mvaddstrAlt(11, 42, CONST_sitemode168);
				if (enemy&&sitealarm)
				{
					bool evade = false;
					set_color_easy(WHITE_ON_BLACK);
					for (int e = 0; e < ENCMAX; e++)
					{
						if (encounter[e].exists &&
							encounter[e].alive  &&
							encounter[e].cantbluff == 2)
						{
							// You can't sneak past this person; they already know you're there
							evade = true;
							break;
						}
					}
					if (!evade)
						mvaddstrAlt(12, 42, CONST_sitemode169);
					else
						mvaddstrAlt(12, 42, CONST_sitemode170);
				}
				else
				{
					set_color_easy(BLACK_ON_BLACK_BRIGHT);
					mvaddstrAlt(12, 42, CONST_sitemode171);
				}
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(9, 42, CONST_sitemode172);
				if (enemy)set_color_easy(WHITE_ON_BLACK);
				else set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(14, 1, CONST_sitemode173);
				if (!LocationsPool::getInstance().isThereASiegeHere(cursite))
				{
					if (freeable && (!enemy || !sitealarm))
					{
						set_color_easy(WHITE_ON_BLACK);
						mvaddstrAlt(14, 32, CONST_sitemode174);
					}
					else
					{
						if (hostages) set_color_easy(WHITE_ON_BLACK);
						else set_color_easy(BLACK_ON_BLACK_BRIGHT);
						mvaddstrAlt(14, 32, CONST_sitemode175);
					}
				}
				else
				{
					if (libnum > 6)set_color_easy(WHITE_ON_BLACK);
					else set_color_easy(BLACK_ON_BLACK_BRIGHT);
					mvaddstrAlt(14, 32, CONST_sitemode176);
				}
			}
			else
			{
				//DESTROY ALL CARS BROUGHT ALONG WITH PARTY
				if (!LocationsPool::getInstance().isThereASiegeHere(cursite))
				{
					for (int p = 0; p < 6; p++)
					{
						if (!activesquad->squad[p]) continue;
						if (activesquad->squad[p]->carid != -1)
							deleteVehicle(id_getcar(activesquad->squad[p]->carid));
					}
				}
				for (int p = 0; p < 6; p++)
				{
					if (!activesquad->squad[p]) continue;
					activesquad->squad[p]->die();
					activesquad->squad[p]->location = -1;
					activesquad->squad[p] = NULL;
				}
				endcheck(END_BUT_NOT_END); // play the right music in case we're dead
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(9, 1, CONST_sitemode177);
			}
			//PRINT SITE MAP
			printsitemap(locx, locy, locz);
			//CHECK IF YOU HAVE A SQUIRMING AMATEUR HOSTAGE
			//hostcheck SHOULD ONLY BE 1 WHEN A NEWENC IS CREATED
			if (hostcheck)
			{
				char havehostage = 0;
				//Check your whole squad
				for (int p = 0; p < 6; p++)
				{
					if (activesquad->squad[p] != NULL)
					{
						//If they're unarmed and dragging someone
						if (activesquad->squad[p]->prisoner != NULL &&
							!activesquad->squad[p]->get_weapon().can_threaten_hostages())
						{
							//And that someone is not an LCS member
							if (activesquad->squad[p]->prisoner->squadid == -1)
							{
								//They scream for help -- flag them kidnapped, cause alarm
								activesquad->squad[p]->prisoner->flag |= CREATUREFLAG_KIDNAPPED;
								if (activesquad->squad[p]->type == CREATURE_RADIOPERSONALITY)offended_amradio = 1;
								if (activesquad->squad[p]->type == CREATURE_NEWSANCHOR)offended_cablenews = 1;
								havehostage = 1;
							}
						}
					}
				}
				if (havehostage)
				{
					alienationcheck(1);
					sitecrime += 5;
					criminalizeparty(LAWFLAG_KIDNAPPING);
				}
				hostcheck = 0;
				clearmessagearea();
			}
			// check if we fought the previous loop; if so, add a blank gamelog line
			if (foughtthisround)gamelog.newline();
			foughtthisround = 0;
		}
		{
			int c;
			if (levelmap[locx][locy][locz].special == SPECIAL_CLUB_BOUNCER)
			{
				if (LocationsPool::getInstance().getRentingType(cursite) == RENTING_PERMANENT)
				{
					levelmap[locx][locy][locz].special = SPECIAL_NONE;
					c = getkeyAlt();
				}
				else
					c = 's';
			}
			else c = getkeyAlt();
			if (partyalive == 0 && c == 'c')
			{
				//END OF GAME CHECK
				if (!endcheck())
				{
					if (LocationsPool::getInstance().isThereASiegeHere(cursite))
					{
						if (LocationsPool::getInstance().isThisUnderAttack(cursite))sitestory->type = NEWSSTORY_SQUAD_KILLED_SIEGEATTACK;
						else sitestory->type = NEWSSTORY_SQUAD_KILLED_SIEGEESCAPE;
					}
					else
						if (!LocationsPool::getInstance().isThereASiegeHere(cursite))
						{
							sitestory->type = NEWSSTORY_SQUAD_KILLED_SITE;
							resolvesite();
						}
					mode = GAMEMODE_BASE;
					showcarprefs = 0;
					return;
				}
			}
			else if (partyalive > 0) {
				int olocx = locx, olocy = locy, olocz = locz;
				bool canMove = !enemy || !sitealarm;
				{
					if (c == 'v'&&enemy&&sitealarm)
					{
						char override = whichWay();
						if (override) {
							c = override;
							canMove = true;
						}

					}
				}
				switch (c) {
				case 'w':
				case KEY_UP:
					if (canMove && locy > 0 && !(levelmap[locx][locy - 1][locz].flag & SITEBLOCK_BLOCK))locy--;
					break;
				case 'a':
				case KEY_LEFT:
					if (canMove && !(levelmap[locx - 1][locy][locz].flag & SITEBLOCK_BLOCK))locx--;
					break;
				case 'd':
				case KEY_RIGHT:
					if (canMove && !(levelmap[locx + 1][locy][locz].flag & SITEBLOCK_BLOCK))locx++;
					break;
				case 'x':
				case KEY_DOWN:
					if (canMove && !(levelmap[locx][locy + 1][locz].flag & SITEBLOCK_BLOCK))locy++;
					break;
				case 'k':
					if (enemy) { kidnapattempt(); }
					break;
				case 'u':
					pressedKeyU(enemy);
					break;
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
					if (activesquad->squad[c - '1'] != NULL)
					{
						if (party_status == c - '1')fullstatus(party_status);
						else party_status = c - '1';
					}
					break;
				case 'e':
					mapshowing = false;
					equip(activesquad->loot, -1);
					if (enemy&&sitealarm)enemyattack();
					else if (enemy)disguisecheck(encounter_timer);
					creatureadvance();
					encounter_timer++;
					mapshowing = true;
					break;
				case 'n':
					pressedKeyN();
					break;
				case 'l':
					if ((!enemy || !sitealarm)) {
						pressedKeyL();
						encounter_timer++;
					}
					break;
				case 'j':
					if ((!enemy || !sitealarm)) {
						pressedKeyShiftL();
						encounter_timer++;
					}
					break;
				case 't':
					if (talkers) {
						pressedKeyT(enemy, encounter_timer);
					}
					break;
				case 'o':
					if (partysize > 1)orderparty();
					break;
				case '0':
					party_status = -1;
					break;
				case 'm':
					pressedKeyM();
					break;
				case 'f':
					if (enemy) { pressedKeyF(encounter_timer); }
					break;
				case 'r':
					pressedKeyR(freeable, libnum, enemy, hostages, partysize);
					break;
				case 'g':
					pressedKeyG(enemy, encounter_timer);
					break;
				}

				if (locx != olocx || locy != olocy || locz != olocz || c == 's') {

					int cbase = -1;
					if (activesquad->squad[0] != NULL)
					{
						cbase = activesquad->squad[0]->base;
					}
					//NEED TO GO BACK TO OLD LOCATION IN CASE COMBAT
					//REFRESHES THE SCREEN
					long nlocx = locx, nlocy = locy, nlocz = locz;
					locx = olocx, locy = olocy, locz = olocz;
					if (enemy) {
						enemyAttemptsFreeShots(encounter_timer);
					}
					creatureadvance();
					encounter_timer++;
					partyalive = squadalive(activesquad);
					if (partyalive) {
						//AFTER DEATH CHECK CAN MOVE BACK TO NEW LOCATION
						locx = nlocx, locy = nlocy, locz = nlocz;
						//CHECK FOR EXIT
						if ((levelmap[locx][locy][locz].flag & SITEBLOCK_EXIT) ||
							(cbase == cursite && !LocationsPool::getInstance().isThereASiegeHere(cursite) &&
								bail_on_base))
						{
							bailOnBase();
							sitealarm = 0;
							return;
						}
						if (moveOrWaitThenCheckForExit(olocx, olocy, olocz, c, encsize, hostcheck)) {
							//RESET MODE
							mode = GAMEMODE_BASE;
							return;
						}
					}
				}
			}
		}
	}
}
newsstoryst* lastNewsStory();
void mode_site(short loc)
{
	extern short postalarmtimer;
	extern short sitealarmtimer;
	extern short siteonfire;
	extern short cursite;
	extern short sitealarm;
	extern int sitecrime;
	extern short sitetype;
	extern short mode;
	extern int ccs_siege_kills;
	extern int ccs_boss_kills;
	extern squadst *activesquad;
	extern MusicClass music;
	extern int locx;
	extern int locy;
	extern int locz;
	extern short sitealienate;
	extern newsstoryst *sitestory;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	sitetype = LocationsPool::getInstance().getLocationType(loc);
	cursite = loc;
	sitealarm = 0;
	sitealarmtimer = -1;
	postalarmtimer = 0;
	siteonfire = 0;
	sitealienate = 0;
	sitecrime = 0;
	LocationsPool::getInstance().initSite(loc);
	sitestory = lastNewsStory();
	mode = GAMEMODE_SITE;
	if (!LocationsPool::getInstance().isThereASiegeHere(loc))
	{
		music.play(MUSIC_SITEMODE);
		ccs_siege_kills = 0;
		ccs_boss_kills = 0;
		//Low profile site action?
		if (activesquad->stance == SQUADSTANCE_ANONYMOUS)
			sitestory->claimed = 0;
		//Start at entrance to map
		locx = MAPX >> 1;
		locy = 1;
		locz = 0;
		// Second floor start of White House
		if (LocationsPool::getInstance().getLocationType(loc) == SITE_GOVERNMENT_WHITE_HOUSE && levelmap[locx][locy][locz].flag & SITEBLOCK_BLOCK)
			locz++;
		//check for sleeper infiltration or map knowledge
		if (CreaturePool::getInstance().doesAnyoneLiveHere(loc) || LocationsPool::getInstance().isLocationMapped(loc))
		{
			//make entire site known
			for (int x = 0; x < MAPX; x++)
				for (int y = 0; y < MAPY; y++)
					for (int z = 0; z < MAPZ; z++)
						levelmap[x][y][z].flag |= SITEBLOCK_KNOWN;
		}
	}
	else
	{
		music.play(MUSIC_DEFENSE);
		sitealarm = 1;
		LocationsPool::getInstance().turnOffSiege(loc);
		//PLACE YOU
		//int maxy=0;
		for (int x = 0; x < MAPX; x++)
			for (int y = 0; y < MAPY; y++)
			{
				for (int z = 0; z < MAPZ; z++)
				{
					if (!(LocationsPool::getInstance().lightsOff(loc)))levelmap[x][y][z].flag |= SITEBLOCK_KNOWN;
					levelmap[x][y][z].flag &= ~SITEBLOCK_LOCKED;
					levelmap[x][y][z].flag &= ~SITEBLOCK_LOOT;
				}
				//if(!(levelmap[x][y][0].flag & (SITEBLOCK_BLOCK|SITEBLOCK_DOOR)))maxy=y;
			}
		//Cops have tanks; firemen have fire.
		if (LocationsPool::getInstance().getSiegeType(loc) == SIEGE_FIREMEN)
		{
			int firesstarted = 0, firex, firey;
			do
			{
				firex = LCSrandom(MAPX), firey = LCSrandom(MAPY);
				firesstarted++;
				levelmap[firex][firey][0].flag |= SITEBLOCK_FIRE_START;
			} while (!(levelmap[firex][firey][0].flag&(SITEBLOCK_BLOCK | SITEBLOCK_DOOR | SITEBLOCK_EXIT)) &&
				firesstarted < 4);
		}
		do
		{
			// Some bugs with degenerate spawn outside the map are occurring
			// Unknown why, but hard-coding limits to spawn location should help
			//locx=LCSrandom(MAPX);
			//locy=maxy-LCSrandom(3);
			locx = MAPX / 2 + LCSrandom(25) - 12;
			locy = 15 - LCSrandom(3);
			//if(locy<3) locy=3;
			locz = 0;
		} while (levelmap[locx][locy][locz].flag&(SITEBLOCK_BLOCK | SITEBLOCK_DOOR |
			SITEBLOCK_FIRE_START | SITEBLOCK_FIRE_PEAK | SITEBLOCK_FIRE_END));
		//PLACE LOOT
		int lootnum = LocationsPool::getInstance().lenloot(loc);
		if (lootnum > 10) lootnum = 10;
		int lx, ly, lz;
		for (int l = 0; l < lootnum; l++)
		{
			do lx = LCSrandom(MAPX), ly = LCSrandom(MAPY), lz = 0;
			while (levelmap[lx][ly][lz].flag&(SITEBLOCK_BLOCK | SITEBLOCK_DOOR | SITEBLOCK_EXIT));
			levelmap[lx][ly][lz].flag |= SITEBLOCK_LOOT;
		}
		//PLACE TRAPS

		if (LocationsPool::getInstance().hasTraps(loc))
		{
			int trapnum = 30;
			for (int t = 0; t < trapnum; t++)
			{
				do lx = LCSrandom(MAPX), ly = LCSrandom(MAPY), lz = 0;
				while (levelmap[lx][ly][lz].flag&(SITEBLOCK_BLOCK | SITEBLOCK_DOOR | SITEBLOCK_EXIT | SITEBLOCK_LOOT));
				levelmap[lx][ly][lz].siegeflag |= SIEGEFLAG_TRAP;
			}
		}
		//PLACE UNITS
		int unitnum = 6;
		int count = 50000;
		for (int t = 0; t < unitnum; t++)
		{
			do
			{
				lx = LCSrandom(11) + (MAPX / 2) - 5;
				ly = LCSrandom(8);
				lz = 0;
				count--;
				if (count == 0) break;
			} while ((levelmap[lx][ly][lz].flag&(SITEBLOCK_BLOCK | SITEBLOCK_DOOR | SITEBLOCK_EXIT)) ||
				(levelmap[lx][ly][lz].siegeflag&(SIEGEFLAG_UNIT | SIEGEFLAG_HEAVYUNIT | SIEGEFLAG_TRAP)));
			levelmap[lx][ly][lz].siegeflag |= SIEGEFLAG_UNIT;
		}
		if (!(LocationsPool::getInstance().doWeHaveTankTraps(loc)) &&
			LocationsPool::getInstance().getSiegeType(loc) == SIEGE_POLICE &&
			LocationsPool::getInstance().getSiegeEscalationState(loc) >= 2)
		{
			levelmap[MAPX / 2][1][0].siegeflag |= SIEGEFLAG_HEAVYUNIT;
			LocationsPool::getInstance().spawnATank(loc, 1);
		}
	}
	mode_site();
}
/* prints the names of creatures you see in car chases */
void printchaseencounter()
{
	extern chaseseqst chaseseq;
	extern Creature encounter[ENCMAX];
	for (int i = 19; i <= 24; i++)
		mvaddstrAlt(i, 0, CONST_sitemode178); // 80 spaces
	if (len(chaseseq.enemycar))
	{
		int carsy[4] = { 20,20,20,20 };
		for (int v = 0; v < len(chaseseq.enemycar); v++)
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(19, v * 20 + 1, chaseseq.enemycar[v]->fullname(true));
		}
		for (int e = 0; e < ENCMAX; e++) if (encounter[e].exists)
			for (int v = 0; v < len(chaseseq.enemycar); v++)
				if (chaseseq.enemycar[v]->id() == encounter[e].carid)
				{
					set_color_easy(RED_ON_BLACK_BRIGHT);
					mvaddstrAlt(carsy[v], v * 20 + 1, encounter[e].name);
					if (encounter[e].is_driver) addstrAlt(CONST_sitemode179);
					carsy[v]++;
				}
	}
	else printencounter();
}


/* end the game and clean up */
void end_game(int err = EXIT_SUCCESS);

/* common - tests if the person is a wanted criminal */
// *JDS* Checks if the character is a criminal
bool iscriminal(Creature &cr)
{
	for (int i = 0; i < LAWFLAGNUM; i++) if (cr.crimes_suspected[i]) return true;
	return false;
}
/* common - determines how long a creature's injuries will take to heal */
int clinictime(Creature &g)
{
	int time = 0;
	for (int w = 0; w < BODYPARTNUM; w++)
		if ((g.wound[w] & WOUND_NASTYOFF) && (g.blood < 100))
			time++;
	if (g.blood <= 10)time++;
	if (g.blood <= 50)time++;
	if (g.blood < 100)time++;
	if (!g.special[SPECIALWOUND_RIGHTLUNG])time++;
	if (!g.special[SPECIALWOUND_LEFTLUNG])time++;
	if (!g.special[SPECIALWOUND_HEART])time += 2;
	if (!g.special[SPECIALWOUND_LIVER])time++;
	if (!g.special[SPECIALWOUND_STOMACH])time++;
	if (!g.special[SPECIALWOUND_RIGHTKIDNEY])time++;
	if (!g.special[SPECIALWOUND_LEFTKIDNEY])time++;
	if (!g.special[SPECIALWOUND_SPLEEN])time++;
	if (g.special[SPECIALWOUND_RIBS] < RIBNUM)time++;
	if (!g.special[SPECIALWOUND_NECK])time++;
	if (!g.special[SPECIALWOUND_UPPERSPINE])time++;
	if (!g.special[SPECIALWOUND_LOWERSPINE])time++;
	return time;
}
/* common - sends somebody to the hospital */
/***************************************************
* *JDS* Hospitalize -- sends current person to the *
* specified clinic or hospital.                    *
***************************************************/
void hospitalize(int loc, Creature &patient)
{
	const string CONST_commonactions008 = "harmful speech";
	const string CONST_commonactions007 = "month";
	const string CONST_commonactions006 = "months";
	const string CONST_commonactions005 = " for ";
	const string CONST_commonactions004 = " will be at ";
	extern Log gamelog;
	extern vector<squadst *> squad;
	// He's dead, Jim
	if (!patient.alive)return;
	int time = clinictime(patient);
	if (time > 0)
	{
		squadst* patientsquad = NULL;
		if (patient.squadid != -1)
			patientsquad = squad[getsquad(patient.squadid)];
		patient.clinic = time;
		patient.squadid = -1;
		patient.location = loc;
		// Inform about the hospitalization
		makedelimiter();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, patient.name, gamelog);
		addstrAlt(CONST_commonactions004, gamelog);
		addstrAlt(LocationsPool::getInstance().getLocationName(loc), gamelog);
		addstrAlt(CONST_commonactions005, gamelog);
		addstrAlt(time, gamelog);
		addstrAlt(singleSpace, gamelog);
		if (time > 1)addstrAlt(CONST_commonactions006, gamelog);
		else addstrAlt(CONST_commonactions007, gamelog);
		addstrAlt(singleDot, gamelog);
		gamelog.nextMessage(); //Time for the next message.
		pressAnyKey();
		if (patientsquad)
		{  // Reorganize patient's former squad
			bool flipstart = 0;
			for (int p = 0; p < 6; p++)
			{
				if (patientsquad->squad[p] == &patient)
				{
					patientsquad->squad[p] = NULL;
					flipstart = 1;
				}
				if (flipstart&&p < 5) patientsquad->squad[p] = patientsquad->squad[p + 1];
			}
			if (flipstart) patientsquad->squad[5] = NULL;
		}
	}
}
/* returns the amount of heat associated with a given crime */
int lawflagheat(int lawflag)
{
	// Note that for the purposes of this function, we're not looking at how severe the crime is,
	// but how vigorously it is pursued by law enforcement. This determines how quickly they raid
	// you for it, and how much of a penalty you get in court for it. Some crimes are inflated
	// heat, others are deflated (such as the violent crimes).
	//
	// - Jonathan S. Fox
	switch (lawflag)
	{
	case LAWFLAG_TREASON:return 100;
	case LAWFLAG_TERRORISM:return 100;
	case LAWFLAG_MURDER:return 20;
	case LAWFLAG_KIDNAPPING:return 20;
	case LAWFLAG_BANKROBBERY:return 20;
	case LAWFLAG_ARSON:return 50;
	case LAWFLAG_BURNFLAG:return 0;
	case LAWFLAG_SPEECH:return 0;
	case LAWFLAG_BROWNIES:return 50;
	case LAWFLAG_ESCAPED:return 50;
	case LAWFLAG_HELPESCAPE:return 50;
	case LAWFLAG_JURY:return 0;
	case LAWFLAG_RACKETEERING:return 50;
	case LAWFLAG_EXTORTION:return 20;
	case LAWFLAG_ARMEDASSAULT:return 0;   // XXX: This is on the same level as CONST_commonactions008?
	case LAWFLAG_ASSAULT:return 0;        // Fox: Yes. You get too many assault charges to put heat on it.
	case LAWFLAG_CARTHEFT:return 0;
	case LAWFLAG_CCFRAUD:return 20;
	case LAWFLAG_THEFT:return 0;
	case LAWFLAG_PROSTITUTION:return 0;
	case LAWFLAG_HIREILLEGAL:return 10;
		//case LAWFLAG_GUNUSE:return 1;
		//case LAWFLAG_GUNCARRY:return 0;
	case LAWFLAG_COMMERCE:return 20;
	case LAWFLAG_INFORMATION:return 50;
	case LAWFLAG_BURIAL:return 0;
	case LAWFLAG_BREAKING:return 0;
	case LAWFLAG_VANDALISM:return 0;
	case LAWFLAG_RESIST:return 10;
	case LAWFLAG_DISTURBANCE:return 0;
	case LAWFLAG_PUBLICNUDITY:return 0;
	case LAWFLAG_LOITERING:return 0;
	default:return 0;
	}
}
/* common - applies a crime to a person */
void criminalize(Creature &cr, short crime)
{
	extern short mode;
	extern short cursite;
	if (mode == GAMEMODE_SITE)
	{
		if (LocationsPool::getInstance().isThereASiegeHere(cursite))
		{
			// Do not criminalize the LCS for self-defense against
			// extrajudicial raids
			if (LocationsPool::getInstance().getSiegeType(cursite) != SIEGE_POLICE)
				return;
		}
		else if (LocationsPool::getInstance().getRentingType(cursite) == RENTING_CCS)
			// Do not criminalize the LCS for crimes against the CCS
			return;
	}
	cr.crimes_suspected[crime]++;
	cr.heat += lawflagheat(crime);
}
/* common - applies a crime to everyone in the active party */
void criminalizeparty(short crime)
{
	extern squadst *activesquad;
	if (!activesquad) return;
	for (int p = 0; p < 6; p++)
		if (activesquad->squad[p])
		{
			if (!activesquad->squad[p]->alive) continue;
			criminalize(*(activesquad->squad[p]), crime);
		}
}

// *JDS* Scarefactor is the severity of the case against you; if you're a really
// nasty person with a wide variety of major charges against you, then scarefactor
// can get up there
int scare_factor(int lawflag, int crimenumber) {
	return lawflagheat(lawflag) * crimenumber;
}
void addjuice(Creature &cr, long juice, long cap);
/* common - gives juice to everyone in the active party */
void juiceparty(long juice, long cap)
{
	extern squadst *activesquad;
	if (activesquad != NULL)
		for (int p = 0; p < 6; p++)
			if (activesquad->squad[p] != NULL)
				if (activesquad->squad[p]->alive)
					addjuice(*activesquad->squad[p], juice, cap);
}
/* common - removes the liberal from all squads */
void removesquadinfo(Creature &cr)
{
	extern vector<squadst *> squad;
	if (cr.squadid != -1)
	{
		long sq = getsquad(cr.squadid);
		if (sq != -1)
		{
			bool flipstart = 0;
			for (int pt = 0; pt < 6; pt++)
			{
				if (squad[sq]->squad[pt] == &cr)flipstart = 1;
				if (flipstart&&pt < 5)squad[sq]->squad[pt] = squad[sq]->squad[pt + 1];
			}
			if (flipstart)squad[sq]->squad[5] = NULL;
		}
		cr.squadid = -1;
	}
}

// Picks a random option, based on the weights provided
int choose_one(const int * weight_list, int number_of_options, int default_value)
{
	int weight_total = 0;
	for (int option = 0; option < number_of_options; option++)
		weight_total += weight_list[option];
	if (weight_total < 1) return default_value; // No acceptable results; use default
	int choose = LCSrandom(weight_total);
	for (int option = 0; option < number_of_options; option++)
	{
		choose -= weight_list[option];
		if (choose < 0)return option;
	}
	return number_of_options;
}
/* common - assigns a new base to all members of a squad */
void basesquad(squadst *st, long loc)
{
	for (int p = 0; p < 6; p++) if (st->squad[p] != NULL) st->squad[p]->base = loc;
}

// Determines the number of subordinates a creature may command
int maxsubordinates(const Creature& cr)
{
	//brainwashed recruits can't recruit normally
	if (cr.flag & CREATUREFLAG_BRAINWASHED)return 0;
	int recruitcap = 0;
	//Cap based on juice
	if (cr.juice >= 500)      recruitcap += 6;
	else if (cr.juice >= 200) recruitcap += 5;
	else if (cr.juice >= 100) recruitcap += 3;
	else if (cr.juice >= 50)  recruitcap += 1;
	//Cap for founder
	if (cr.hireid == -1 && cr.align == 1) recruitcap += 6;
	return recruitcap;
}
int loveslaves(const Creature& cr);
// Determines the number of love slaves a creature may recruit,
// based on max minus number they already command
int loveslavesleft(const Creature& cr)
{
	// Get maximum lovers
	int loveslavecap = cr.get_skill(SKILL_SEDUCTION) / 2 + 1;
	// -1 if they're a love slave (their boss is a lover)
	if (cr.flag & CREATUREFLAG_LOVESLAVE) loveslavecap--;
	// Subtract number of love slaves they have
	loveslavecap -= loveslaves(cr);
	// If they can have more, return that number
	if (loveslavecap > 0) return loveslavecap;
	// If they're at 0 or less, return 0
	else return 0;
}

/* common - Sort a list of creatures.*/
inline bool sort_name(const Creature* first, const Creature* second) { return strcmp(first->name, second->name) < 0; }
bool sort_locationandname(const Creature* first, const Creature* second)
{
	return first->location < second->location
		|| (first->location == second->location
			&&sort_name(first, second));
}
bool sort_squadorname(const Creature* first, const Creature* second)
{
	extern vector<squadst *> squad;
	// Use getsquad to treat members of a new squad being assembled as if not in a squad.
	bool first_in_squad = getsquad(first->squadid) != -1;
	bool second_in_squad = getsquad(second->squadid) != -1;
	bool a = ((first_in_squad && !second_in_squad) //Squad member should come before squadless.
		|| (first_in_squad
			&& first->squadid < second->squadid) //Older squads above newer.
		|| (!first_in_squad && !second_in_squad
			&& sort_name(first, second))); //Sort squadless by name.
										   //Sort members of same squad in the order they are in the squad.
	if (first_in_squad && first->squadid == second->squadid)
		for (int j = 0; j < 6; j++)
			if (squad[getsquad(first->squadid)]->squad[j]->id == first->id) return true;
			else if (squad[getsquad(first->squadid)]->squad[j]->id == second->id) return false;
			return a;
}
bool sort_none(const Creature* first, const Creature* second);
void sortliberals(std::vector<Creature *>& liberals, short sortingchoice, bool dosortnone)
{
	if (!dosortnone&&sortingchoice == SORTING_NONE) return;
	switch (sortingchoice)
	{
	case SORTING_NONE: sort(liberals.begin(), liberals.end(), sort_none); break;
	case SORTING_NAME: sort(liberals.begin(), liberals.end(), sort_name); break;
	case SORTING_LOCATION_AND_NAME: sort(liberals.begin(), liberals.end(), sort_locationandname); break;
	case SORTING_SQUAD_OR_NAME: sort(liberals.begin(), liberals.end(), sort_squadorname); break;
	}
}
map<short, string> trainingActivitySorting;
vector<string> methodOfSorting;
const string CONST_commonactions009 = "methodOfSorting.txt";
vector<file_and_text_collection> common_text_file_collection = {
	customText(&methodOfSorting, mostlyendings + CONST_commonactions009),
};
/* common - Prompt to decide how to sort liberals.*/
void sorting_prompt(short listforsorting)
{
	const string CONST_commonactions010 = "Choose how to sort list of ";
	extern short activesortingchoice[SORTINGCHOICENUM];
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(1, 1, CONST_commonactions010);
	if (trainingActivitySorting.count(listforsorting)) {
		addstrAlt(trainingActivitySorting[listforsorting]);
	}
	else {
		addstrAlt(trainingActivitySorting[SORTINGCHOICENUM]);
	}
	for (int i = 0; i < len(methodOfSorting); i++) {
		mvaddstrAlt(3 + i, 2, methodOfSorting[i]);
	}
	while (true)
	{
		int c = getkeyAlt();
		if (c == 'a')
		{
			activesortingchoice[listforsorting] = SORTING_NONE; break;
		}
		else if (c == 'b')
		{
			activesortingchoice[listforsorting] = SORTING_NAME; break;
		}
		else if (c == 'c')
		{
			activesortingchoice[listforsorting] = SORTING_LOCATION_AND_NAME; break;
		}
		else if (c == 'd')
		{
			activesortingchoice[listforsorting] = SORTING_SQUAD_OR_NAME; break;
		}
		else if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
	}
}
/* common - Returns appropriate sortingchoice enum value for a reviewmode enum value.
Is currently unnecessary unless the enums are changed.*/
short reviewmodeenum_to_sortingchoiceenum(short reviewmode)
{
	switch (reviewmode)
	{
	case REVIEWMODE_LIBERALS: return SORTINGCHOICE_LIBERALS;
	case REVIEWMODE_HOSTAGES: return SORTINGCHOICE_HOSTAGES;
	case REVIEWMODE_CLINIC: return SORTINGCHOICE_CLINIC;
	case REVIEWMODE_JUSTICE: return SORTINGCHOICE_JUSTICE;
	case REVIEWMODE_SLEEPERS: return SORTINGCHOICE_SLEEPERS;
	case REVIEWMODE_DEAD: return SORTINGCHOICE_DEAD;
	case REVIEWMODE_AWAY: return SORTINGCHOICE_AWAY;
	default: return 0;//-1;
	}
}
string selectA;
string selectAn;
string enterDash;
/* common - Displays options to choose from and returns an int corresponding
to the index of the option in the vector. */
int choiceprompt(const string &firstline, const string &secondline,
	const vector<string> &option, const string &optiontypename,
	bool allowexitwochoice, const string &exitstring)
{
	extern short interface_pgup;
	extern short interface_pgdn;
	int page = 0;
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, firstline);
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(1, 0, secondline);
		//Write options
		for (int p = page * 19, y = 2; p < len(option) && p < page * 19 + 19; p++, y++)
		{
			mvaddcharAlt(y, 0, 'A' + y - 2); addstrAlt(spaceDashSpace);
			addstrAlt(option[p]);
		}
		set_color_easy(WHITE_ON_BLACK);
		moveAlt(22, 0);
		switch (optiontypename[0])
		{
		case 'a': case 'e': case 'i': case 'o': case 'u':
		case 'A': case 'E': case 'I': case 'O': case 'U':
			addstrAlt(selectAn + optiontypename); break;
		default:
			addstrAlt(selectA + optiontypename); break;
		}
		mvaddstrAlt(23, 0, addpagestr());
		moveAlt(24, 0);
		if (allowexitwochoice) addstrAlt(enterDash + exitstring);
		int c = getkeyAlt();
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0) page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 19 < len(option)) page++;
		if (c >= 'a'&&c <= 's')
		{
			int p = page * 19 + c - 'a';
			if (p < len(option)) return p;
		}
		if (allowexitwochoice && (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR)) break;
	}
	return -1;
}
/* common - Displays a list of things to buy and returns an int corresponding
to the index of the chosen thing in the nameprice vector. */
int buyprompt(const string &firstline, const string &secondline,
	const vector< pair<string, int> > &nameprice, int namepaddedlength,
	const string &producttype, const string &exitstring)
{
	const string CONST_commonactions012 = "$";
	extern short interface_pgup;
	extern short interface_pgdn;
	extern class Ledger ledger;
	int page = 0;
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(0, 0, firstline);
		mvaddstrAlt(1, 0, secondline);
		//Write wares and prices
		for (int p = page * 19, y = 2; p < len(nameprice) && p < page * 19 + 19; p++)
		{
			if (nameprice[p].second > ledger.get_funds())
				set_color_easy(BLACK_ON_BLACK_BRIGHT);
			else set_color_easy(WHITE_ON_BLACK);
			mvaddcharAlt(y, 0, 'A' + y - 2); addstrAlt(spaceDashSpace);
			addstrAlt(nameprice[p].first);
			moveAlt(y++, namepaddedlength + 4); //Add 4 for start of line, eg A - .
			addstrAlt(CONST_commonactions012 + tostring(nameprice[p].second));
		}
		set_color_easy(WHITE_ON_BLACK);
		moveAlt(22, 0);
		switch (producttype[0])
		{
		case 'a': case 'e': case 'i': case 'o': case 'u':
		case 'A': case 'E': case 'I': case 'O': case 'U':
			addstrAlt(selectAn + producttype); break;
		default:
			addstrAlt(selectA + producttype); break;
		}
		mvaddstrAlt(23, 0, addpagestr());
		mvaddstrAlt(24, 0, enterDash + exitstring);
		int c = getkeyAlt();
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0) page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 19 < len(nameprice)) page++;
		if (c >= 'a'&&c <= 's')
		{
			int p = page * 19 + c - 'a';
			if (p < len(nameprice) && nameprice[p].second <= ledger.get_funds())
				return p;
		}
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
	}
	return -1;
}
/* tells how many total members a squad has (including dead members) */
int squadsize(const squadst *st)
{
	int partysize = 0;
	if (st) for (int p = 0; p < 6; p++) if (st->squad[p]) partysize++;
	return partysize;
}
/* tells how many members a squad has who are alive */
int squadalive(const squadst *st)
{
	int partyalive = 0;
	if (st) for (int p = 0; p < 6; p++) if (st->squad[p]) if (st->squad[p]->alive) partyalive++;
	return partyalive;
}

int ptime = GetTickCount();
void alarmset(int t)
{
	ptime = GetTickCount() + t;
}
void alarmwait()
{
	while (ptime > (int)GetTickCount());
}
void pause_ms(int t)
{
	alarmset(t);
	refreshAlt();
	alarmwait();
}
// FNV-1a 32-bit hash function (fast and effective) -- helper function for getSeed()
void fnvHash(unsigned long &fnv_hash, unsigned long num)
{
	fnv_hash *= 16777619UL; // multiply by the FNV-1a hash's 32-bit prime
	fnv_hash &= 0xffffffffUL; // keep the number 32-bit (we could be on a 64-bit system)
	fnv_hash ^= (num & 0xffUL); // xor together with number's 1st byte
	num >>= 8; // right shift number to 2nd byte
	fnv_hash *= 16777619UL; // multiply by the FNV-1a hash's 32-bit prime
	fnv_hash &= 0xffffffffUL; // keep the number 32-bit (we could be on a 64-bit system)
	fnv_hash ^= (num & 0xffUL); // xor together with number's 2nd byte
	num >>= 8; // right shift number to 3rd byte
	fnv_hash *= 16777619UL; // multiply by the FNV-1a hash's 32-bit prime
	fnv_hash &= 0xffffffffUL; // keep the number 32-bit (we could be on a 64-bit system)
	fnv_hash ^= (num & 0xffUL); // xor together with number's 3rd byte
	num >>= 8; // right shift number to 4th byte
	fnv_hash *= 16777619UL; // multiply by the FNV-1a hash's 32-bit prime
	fnv_hash &= 0xffffffffUL; // keep the number 32-bit (we could be on a 64-bit system)
	fnv_hash ^= (num & 0xffUL); // xor together with number's 4th byte
}
// A high-quality RNG seed with multiple sources of entropy hashed together with FNV-1a hash
unsigned long getSeed()
{
	unsigned long _seed = 2166136261UL; // start out at the FNV-1a hash's 32-bit offset basis
#ifdef GO_PORTABLE // we have access to time.h's functions as entropy sources
	fnvHash(_seed, time(NULL)); /* Seconds since 1970-01-01 00:00:00 */
	fnvHash(_seed, clock()); /* clock ticks since LCS was launched (clock ticks are some fraction of a second that varies on different implementations) */
#endif // GO_PORTABLE
#ifdef WIN32 // We're on Windows and can use the Win32 API as entropy sources
	fnvHash(_seed, GetTickCount()); /* ms since system boot */
	fnvHash(_seed, GetCurrentProcessId()); /* process ID for current process */
	SYSTEM_INFO info; /* a whole bunch of system info */
	GetSystemInfo(&info); /* get the system info */
	fnvHash(_seed, (unsigned long)info.lpMinimumApplicationAddress); /* pointer to minimum accessible memory location */
	fnvHash(_seed, (unsigned long)info.lpMaximumApplicationAddress); /* pointer to maximum accessible memory location */
#else // we're on a POSIX system and can use POSIX API entropy sources
#if defined(_SC_AVPHYS_PAGES) && defined(_SC_PAGESIZE) // might or might not be defined... optional in POSIX
	fnvHash(_seed, sysconf(_SC_AVPHYS_PAGES)*sysconf(_SC_PAGESIZE)); /* current available memory */
#endif // defined(_SC_AVPHYS_PAGES) && defined(_SC_PAGESIZE)
#ifdef _SC_NPROCESSORS_ONLN // might or might not be defined... optional in POSIX
	fnvHash(_seed, sysconf(_SC_NPROCESSORS_ONLN));
#endif // _SC_NPROCESSORS_ONLN
#endif // WIN32
	return _seed;
}
// Return a random number from 1 to 0xffffffff (any 32-bit integer except 0), using all of seed[].
// This is a 32-bit version of George Marsaglia's xorshift pseudorandom number generator with 128-bit state space.
// 32-bit xorshift RNGs produce values in the range from 1 to 0xffffffff (any 32-bit integer except 0),
// and don't allow the values to be zero... if they do return zero they've been improperly initialized,
// and would continue to output nothing but zeros forever unless the problem is rectified.
// So there's a recovery mechanism in place in case it's about to return a zero value, to fix that.
// It's a nice ultrafast 32-bit pseudorandom number generator with good randomness properties, small state space, and very short code.
unsigned long r_num()
{
	// Re-seed the Random Number Generator every time it's called
	extern bool MORERANDOM;
	extern unsigned long seed[RNG_SIZE];
	while (true) // this loop is in case of error, so the recovery mechanism can work... it'll exit with a return value upon success
	{
		unsigned long t = seed[0] ^ ((seed[0] << 11) & 0xffffffff); // set temp variable and keep it within 32 bits
		if (MORERANDOM) {
			t ^= getSeed(); // add entropy
		}// MORERANDOM
		seed[0] = seed[1]; seed[1] = seed[2]; seed[2] = seed[3]; // shift variables
		seed[3] = seed[3] ^ (seed[3] >> 19) ^ t ^ (t >> 8); // calculate random number
		if (seed[3]) return seed[3]; // return a number unless it's zero, in which case it was initialized wrong
		initMainRNG(); // recovery mechanism in case things were badly initialized
	}
}
// Picks a random number from 0 to max-1
long LCSrandom(long max)
{  // This expects r_num() to return a random number between 1 and 0xffffffff (any 32-bit integer except 0)... which it does
	return (long)(max*(((long double)(r_num() - 1)) / ((long double)0xffffffffUL)));
}
// Returns a random number from 0 to 0xffffffff (any 32-bit integer), only using seed[0].
// This is a linear congruential generator using parameters suggested in a paper by Pierre L'Ecuyer
// that has better randomness characteristics than most linear congruential generators (the simplest type of RNG).
// No linear congruential generators is very random though, so this is just used to help initialize the xorshift RNG.
unsigned long r_num2()
{
	extern unsigned long seed[RNG_SIZE];
	return seed[0] = (seed[0] * 32310901UL + 433494437UL) & 0xffffffff; // return a random number, kept within 32 bits
}
// Initializes the xorshift Random Number Generator with help getSeed() and r_num2()
void initMainRNG()
{
	extern unsigned long seed[RNG_SIZE];
	// we got 4 integers to initialize, which we'll get from a well-seeded linear congruential generator
	seed[0] = getSeed(); // seed the linear congruential generator
	for (int i = RNG_SIZE - 1; i >= 0; i--) seed[i] = r_num2(); // initialize all the integers
}
// Copies a xorshift Random Number Generator from src to dest
void copyRNG(unsigned long(&dest)[RNG_SIZE], unsigned long(&src)[RNG_SIZE])
{
	for (int i = 0; i < RNG_SIZE; i++) dest[i] = src[i]; // copy all the integers
}
// Sets up another xorshift Random Number Generator whose state space is passed as an argument
void initOtherRNG(unsigned long(&rng)[RNG_SIZE])
{
	extern unsigned long seed[RNG_SIZE];
	r_num(); // randomize main xorshift RNG beforehand
	copyRNG(rng, seed); // copy main xorshift RNG to the one we're setting up
	r_num(); // randomize main xorshift RNG afterwards
}


// #include "../includes.h"
const string CONST_commondisplay000 = ",";
const string CONST_commondisplay202 = " (";
const string CONST_commondisplay201 = "Name: ";
const string CONST_commondisplay200 = "Code name: ";
const string CONST_commondisplay212 = ": ";
const string CONST_commondisplay199 = "%2d.00";
const string CONST_commondisplay198 = "99+";
const string CONST_commondisplay197 = "00";
const string CONST_commondisplay196 = "%2d.";
const string CONST_commondisplay194 = "NOW   MAX";
const string CONST_commondisplay193 = "SKILL";
const string CONST_commondisplay003 = "On \"Foot\"";
const string CONST_commondisplay158 = "On Foot";
const string CONST_commondisplay157 = "Wheelchair";
const string CONST_commondisplay156 = "-D";
const string CONST_commondisplay220 = "                                                                                ";
const string CONST_commondisplay153 = "Weapon: ";
const string CONST_commondisplay119 = "Cut";
const string CONST_commondisplay118 = "Bruised";
const string CONST_commondisplay117 = "Shot";
const string CONST_commondisplay116 = "Liberal";
const string CONST_commondisplay115 = "Animal";
const string CONST_commondisplay114 = "Severed";
const string CONST_commondisplay113 = "Ripped off";
const string CONST_commondisplay112 = "Left Leg:";
const string CONST_commondisplay111 = "Right Leg:";
const string CONST_commondisplay110 = "Left Arm:";
const string CONST_commondisplay109 = "Right Arm:";
const string CONST_commondisplay108 = "Body:";
const string CONST_commondisplay107 = "Head:";
const string CONST_commondisplay154 = "Clothes: ";
const string CONST_commondisplay180 = "Missing Teeth";
const string CONST_commondisplay178 = "No Teeth";
const string CONST_commondisplay177 = "No Tongue";



const string tag_0 = "0";

std::string gettitle(Creature &cr);
map<int, map<bool, ColorSetup> > alignmentColors = {
	// Liberal activism
	map<int,  map<bool, ColorSetup> >::value_type(ALIGN_ARCHCONSERVATIVE, {map<bool, ColorSetup>::value_type(true, RED_ON_BLACK_BRIGHT)}),
	map<int,  map<bool, ColorSetup> >::value_type(ALIGN_CONSERVATIVE, {map<bool, ColorSetup>::value_type(true, MAGENTA_ON_BLACK_BRIGHT), map<bool, ColorSetup>::value_type(false, RED_ON_BLACK_BRIGHT)}),
	map<int,  map<bool, ColorSetup> >::value_type(ALIGN_MODERATE, {map<bool, ColorSetup>::value_type(true, YELLOW_ON_BLACK_BRIGHT)}),
	map<int,  map<bool, ColorSetup> >::value_type(ALIGN_LIBERAL, {map<bool, ColorSetup>::value_type(true, CYAN_ON_BLACK_BRIGHT), map<bool, ColorSetup>::value_type(false, GREEN_ON_BLACK_BRIGHT)}),
	map<int,  map<bool, ColorSetup> >::value_type(ALIGN_ELITELIBERAL, {map<bool, ColorSetup>::value_type(true, GREEN_ON_BLACK_BRIGHT)}),
	map<int,  map<bool, ColorSetup> >::value_type(ALIGN_STALINIST, {map<bool, ColorSetup>::value_type(true, RED_ON_BLACK_BRIGHT)}),
};
// Sets the text color to the thematic color for the given alignment
// extended_range forces colors to be set on a 5 point scale instead
// of just basic liberal-moderate-conservative
void set_alignment_color(short alignment, bool extended_range)
{
	if (alignmentColors.count(alignment)) {
		if (alignmentColors[alignment].count(extended_range)) {
			set_color_easy(alignmentColors[alignment][extended_range]);
		}
		else {
			set_color_easy(alignmentColors[alignment][true]);
		}
	}
	else {
		// This should not happen! Set a strange color to indicate an error!
		set_color_easy(YELLOW_ON_RED_BRIGHT_BLINK);
	}
}
map<int, ColorSetup> activityColors = {
	// Liberal activism
	map<int, ColorSetup>::value_type(ACTIVITY_SLEEPER_LIBERAL, GREEN_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_TROUBLE, GREEN_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_GRAFFITI, GREEN_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_DOS_ATTACKS, GREEN_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_HACKING, GREEN_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_WRITE_LETTERS, GREEN_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_WRITE_GUARDIAN, GREEN_ON_BLACK_BRIGHT),
	// Recruitment
	map<int, ColorSetup>::value_type(ACTIVITY_RECRUITING, GREEN_ON_BLACK),
	// Less exciting liberal activities
	map<int, ColorSetup>::value_type(ACTIVITY_SLEEPER_SPY, BLUE_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_COMMUNITYSERVICE, BLUE_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_POLLS, BLUE_ON_BLACK_BRIGHT),
	// Stealing things
	map<int, ColorSetup>::value_type(ACTIVITY_SLEEPER_STEAL, CYAN_ON_BLACK),
	map<int, ColorSetup>::value_type(ACTIVITY_WHEELCHAIR, CYAN_ON_BLACK),
	map<int, ColorSetup>::value_type(ACTIVITY_STEALCARS, CYAN_ON_BLACK),
	// Illegal fundraising
	map<int, ColorSetup>::value_type(ACTIVITY_SLEEPER_EMBEZZLE, RED_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_SELL_DRUGS, RED_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_PROSTITUTION, RED_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_CCFRAUD, RED_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_DOS_RACKET, RED_ON_BLACK_BRIGHT),
	// Legal fundraising
	map<int, ColorSetup>::value_type(ACTIVITY_DONATIONS, CYAN_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_SELL_TSHIRTS, CYAN_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_SELL_ART, CYAN_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_SELL_MUSIC, CYAN_ON_BLACK_BRIGHT),
	// Clothing/garment stuff
	map<int, ColorSetup>::value_type(ACTIVITY_REPAIR_ARMOR, CYAN_ON_BLACK),
	map<int, ColorSetup>::value_type(ACTIVITY_MAKE_ARMOR, CYAN_ON_BLACK),
	// Teaching
	map<int, ColorSetup>::value_type(ACTIVITY_TEACH_POLITICS, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_TEACH_FIGHTING, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_TEACH_COVERT, MAGENTA_ON_BLACK_BRIGHT),
	//and studying
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_DEBATING, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_MARTIAL_ARTS, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_DRIVING, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_PSYCHOLOGY, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_FIRST_AID, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_LAW, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_DISGUISE, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_SCIENCE, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_BUSINESS, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_GYMNASTICS, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_ART, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_MUSIC, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_TEACHING, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_WRITING, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_LOCKSMITHING, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_COMPUTERS, MAGENTA_ON_BLACK_BRIGHT),
	//map<int, ColorSetup>::value_type(ACTIVITY_STUDY_COOKING, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_FENCING, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_WEAVING, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_RELIGION, MAGENTA_ON_BLACK_BRIGHT),
	//map<int, ColorSetup>::value_type(ACTIVITY_STUDY_MAGIC, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_CLUB, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_STREETSENSE, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_THROWING, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_STEALTH, MAGENTA_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_STUDY_SEDUCTION, MAGENTA_ON_BLACK_BRIGHT),
	// Interrogating
	map<int, ColorSetup>::value_type(ACTIVITY_HOSTAGETENDING, YELLOW_ON_BLACK_BRIGHT),
	// Dealing with your injuries
	map<int, ColorSetup>::value_type(ACTIVITY_CLINIC, RED_ON_BLACK),
	// Doing something Conservative
	map<int, ColorSetup>::value_type(ACTIVITY_SLEEPER_CONSERVATIVE, RED_ON_BLACK_BRIGHT),
	// Dealing with the dead
	map<int, ColorSetup>::value_type(ACTIVITY_BURY, BLACK_ON_BLACK_BRIGHT),
	// Nothing terribly important
	map<int, ColorSetup>::value_type(ACTIVITY_HEAL, WHITE_ON_BLACK),// Identical to none in practice
	map<int, ColorSetup>::value_type(ACTIVITY_NONE, WHITE_ON_BLACK),
	// Going somewhere
	map<int, ColorSetup>::value_type(ACTIVITY_VISIT, YELLOW_ON_BLACK_BRIGHT),
	// Quitting being a sleeper to join the LCS
	map<int, ColorSetup>::value_type(ACTIVITY_SLEEPER_JOINLCS, RED_ON_BLACK_BRIGHT),
	map<int, ColorSetup>::value_type(ACTIVITY_AUGMENT, BLUE_ON_BLACK_BRIGHT),
};
// Sets the text color per activity type
void set_activity_color(long activity_type)
{
	if (activityColors.count(activity_type)) {
		set_color_easy(activityColors[activity_type]);
	}
	else {
		// This should not happen! Set a strange color to indicate an error!
		set_color_easy(YELLOW_ON_RED_BRIGHT);

	}
}
/* draws a horizontal line across the screen */
//void makedelimiter(int y = 8, int x = 0);
/* draws a horizontal line across the screen */
void makedelimiter(int y, int x)
{
	const string CONST_commondisplay005 = "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ";
	const string CONST_commondisplay004 = "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂ";
	extern short mode;
	extern bool mapshowing;
	set_color_easy(WHITE_ON_BLACK);
	if (mode == GAMEMODE_SITE && y == 8 && x == 0 && mapshowing) // special case: there is a map on the right in site mode
		mvaddstrAlt(y, x, CONST_commondisplay004); // 80 characters
	else // normal delimiter
		mvaddstrAlt(y, x, CONST_commondisplay005); // 80 characters
}
/* prints a character's health description (One Leg, Liberal, NearDETH...) */
void printhealthstat(Creature &g, int y, int x, char smll)
{
	const string CONST_commondisplay044 = "Moderate";
	const string CONST_commondisplay043 = "Conservative";
	const string CONST_commondisplay042 = "Consrvtv";
	const string CONST_commondisplay040 = "MisTeeth";
	const string CONST_commondisplay037 = "NoTongue";
	const string CONST_commondisplay036 = "Missing Eye";
	const string CONST_commondisplay035 = "One Eye";
	const string CONST_commondisplay034 = "Missing Nose";
	const string CONST_commondisplay033 = "NoseGone";
	const string CONST_commondisplay032 = "Face Mutilated";
	const string CONST_commondisplay031 = "FaceMutl";
	const string CONST_commondisplay030 = "Blind";
	const string CONST_commondisplay029 = "One Leg";
	const string CONST_commondisplay028 = "One Arm";
	const string CONST_commondisplay027 = "One Arm, One Leg";
	const string CONST_commondisplay026 = "1Arm1Leg";
	const string CONST_commondisplay025 = "No Legs";
	const string CONST_commondisplay024 = "No Arms";
	const string CONST_commondisplay023 = "One Limb";
	const string CONST_commondisplay022 = "No Limbs";
	const string CONST_commondisplay021 = "Face Gone";
	const string CONST_commondisplay020 = "FaceGone";
	const string CONST_commondisplay019 = "Paraplegic";
	const string CONST_commondisplay018 = "Parapleg";
	const string CONST_commondisplay017 = "Quadraplegic";
	const string CONST_commondisplay016 = "Quadpleg";
	const string CONST_commondisplay015 = "Neck Broken";
	const string CONST_commondisplay014 = "NckBroke";
	const string CONST_commondisplay013 = "Lightly Wounded";
	const string CONST_commondisplay012 = "LtWound";
	const string CONST_commondisplay011 = "Wounded";
	const string CONST_commondisplay010 = "Badly Wounded";
	const string CONST_commondisplay009 = "BadWound";
	const string CONST_commondisplay008 = "Near Death";
	const string CONST_commondisplay007 = "NearDETH";
	const string CONST_commondisplay006 = "Deceased";
	short woundsum = 0;
	bool bleeding = false;
	for (int w = 0; w < BODYPARTNUM; w++)
	{
		if (g.wound[w] != 0)woundsum++;
		if (g.wound[w] & WOUND_BLEEDING)bleeding = true;
	}
	int armok = 2, legok = 2;
	if ((g.wound[BODYPART_ARM_RIGHT] & WOUND_NASTYOFF) ||
		(g.wound[BODYPART_ARM_RIGHT] & WOUND_CLEANOFF))armok--;
	if ((g.wound[BODYPART_ARM_LEFT] & WOUND_NASTYOFF) ||
		(g.wound[BODYPART_ARM_LEFT] & WOUND_CLEANOFF))armok--;
	if ((g.wound[BODYPART_LEG_RIGHT] & WOUND_NASTYOFF) ||
		(g.wound[BODYPART_LEG_RIGHT] & WOUND_CLEANOFF))legok--;
	if ((g.wound[BODYPART_LEG_LEFT] & WOUND_NASTYOFF) ||
		(g.wound[BODYPART_LEG_LEFT] & WOUND_CLEANOFF))legok--;
	moveAlt(y, x);
	if (bleeding)set_color_easy(RED_ON_BLACK_BRIGHT);
	else set_color_easy(WHITE_ON_BLACK_BRIGHT);
	if (!g.alive)
	{
		set_color_easy(BLACK_ON_BLACK_BRIGHT);
		addstrAlt(CONST_commondisplay006);
	}
	else if (g.blood <= 20)
	{
		if (smll)addstrAlt(CONST_commondisplay007);
		else addstrAlt(CONST_commondisplay008);
	}
	else if (g.blood <= 50)
	{
		if (smll)addstrAlt(CONST_commondisplay009);
		else addstrAlt(CONST_commondisplay010);
	}
	else if (g.blood <= 75)
	{
		addstrAlt(CONST_commondisplay011);
	}
	else if (g.blood < 100)
	{
		if (smll)addstrAlt(CONST_commondisplay012);
		else addstrAlt(CONST_commondisplay013);
	}
	else if (g.special[SPECIALWOUND_NECK] == 2)
	{
		if (!bleeding)set_color_easy(GREEN_ON_BLACK);
		if (smll)addstrAlt(CONST_commondisplay014);
		else addstrAlt(CONST_commondisplay015);
	}
	else if (g.special[SPECIALWOUND_UPPERSPINE] == 2)
	{
		if (!bleeding)set_color_easy(GREEN_ON_BLACK);
		if (smll)addstrAlt(CONST_commondisplay016);
		else addstrAlt(CONST_commondisplay017);
	}
	else if (g.special[SPECIALWOUND_LOWERSPINE] == 2)
	{
		if (!bleeding)set_color_easy(GREEN_ON_BLACK);
		if (smll)addstrAlt(CONST_commondisplay018);
		else addstrAlt(CONST_commondisplay019);
	}
	else if (g.special[SPECIALWOUND_RIGHTEYE] == 0 &&
		g.special[SPECIALWOUND_LEFTEYE] == 0 &&
		g.special[SPECIALWOUND_NOSE] == 0)
	{
		if (!bleeding)set_color_easy(GREEN_ON_BLACK);
		if (smll)addstrAlt(CONST_commondisplay020);
		else addstrAlt(CONST_commondisplay021);
	}
	else if (legok == 0 && armok == 0)
	{
		if (!bleeding)set_color_easy(GREEN_ON_BLACK);
		addstrAlt(CONST_commondisplay022);
	}
	else if ((legok == 1 && armok == 0) || (armok == 1 && legok == 0))
	{
		if (!bleeding)set_color_easy(GREEN_ON_BLACK);
		addstrAlt(CONST_commondisplay023);
	}
	else if (legok == 2 && armok == 0)
	{
		if (!bleeding)set_color_easy(GREEN_ON_BLACK);
		addstrAlt(CONST_commondisplay024);
	}
	else if (legok == 0 && armok == 2)
	{
		if (!bleeding)set_color_easy(GREEN_ON_BLACK);
		addstrAlt(CONST_commondisplay025);
	}
	else if (legok == 1 && armok == 1)
	{
		if (!bleeding)set_color_easy(GREEN_ON_BLACK);
		if (smll)addstrAlt(CONST_commondisplay026);
		else addstrAlt(CONST_commondisplay027);
	}
	else if (armok == 1)
	{
		if (!bleeding)set_color_easy(GREEN_ON_BLACK);
		addstrAlt(CONST_commondisplay028);
	}
	else if (legok == 1)
	{
		if (!bleeding)set_color_easy(GREEN_ON_BLACK);
		addstrAlt(CONST_commondisplay029);
	}
	else if (g.special[SPECIALWOUND_RIGHTEYE] == 0 &&
		g.special[SPECIALWOUND_LEFTEYE] == 0)
	{
		if (!bleeding)set_color_easy(GREEN_ON_BLACK);
		addstrAlt(CONST_commondisplay030);
	}
	else if ((g.special[SPECIALWOUND_RIGHTEYE] == 0 ||
		g.special[SPECIALWOUND_LEFTEYE] == 0) &&
		g.special[SPECIALWOUND_NOSE] == 0)
	{
		if (!bleeding)set_color_easy(GREEN_ON_BLACK);
		if (smll)addstrAlt(CONST_commondisplay031);
		else addstrAlt(CONST_commondisplay032);
	}
	else if (g.special[SPECIALWOUND_NOSE] == 0)
	{
		if (!bleeding)set_color_easy(GREEN_ON_BLACK);
		if (smll)addstrAlt(CONST_commondisplay033);
		else addstrAlt(CONST_commondisplay034);
	}
	else if (g.special[SPECIALWOUND_RIGHTEYE] == 0 ||
		g.special[SPECIALWOUND_LEFTEYE] == 0)
	{
		if (!bleeding)set_color_easy(GREEN_ON_BLACK);
		if (smll)addstrAlt(CONST_commondisplay035);
		else addstrAlt(CONST_commondisplay036);
	}
	else if (g.special[SPECIALWOUND_TONGUE] == 0)
	{
		if (!bleeding)set_color_easy(GREEN_ON_BLACK);
		if (smll)addstrAlt(CONST_commondisplay037);
		else addstrAlt(CONST_commondisplay177);
	}
	else if (g.special[SPECIALWOUND_TEETH] == 0)
	{
		if (!bleeding)set_color_easy(GREEN_ON_BLACK);
		addstrAlt(CONST_commondisplay178);
	}
	else if (g.special[SPECIALWOUND_TEETH] < TOOTHNUM)
	{
		if (!bleeding)set_color_easy(GREEN_ON_BLACK);
		if (smll)addstrAlt(CONST_commondisplay040);
		else addstrAlt(CONST_commondisplay180);
	}
	else
	{
		if (g.align == -1)
		{
			set_color_easy(RED_ON_BLACK_BRIGHT);
			if (smll)addstrAlt(CONST_commondisplay042);
			else addstrAlt(CONST_commondisplay043);
		}
		else if (g.align == 0)
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			addstrAlt(CONST_commondisplay044);
		}
		else
		{
			set_color_easy(GREEN_ON_BLACK_BRIGHT);
			if (g.animalgloss == ANIMALGLOSS_ANIMAL)
				addstrAlt(CONST_commondisplay115);
			else addstrAlt(CONST_commondisplay116);
		}
	}
}
//void printcreatureinfo(Creature *cr, unsigned char knowledge = 255);
string getVehicleShortname(int i);
/* character info at top of screen */
void printcreatureinfo(Creature *cr, unsigned char knowledge)
{
	const string CONST_commondisplay092 = "Brn";
	const string CONST_commondisplay091 = "Trn";
	const string CONST_commondisplay089 = "Brs";
	const string CONST_commondisplay088 = "Sht";
	const string CONST_commondisplay085 = "Clean sever";
	const string CONST_commondisplay077 = "Top Skills:";
	const string CONST_commondisplay075 = "???????";
	const string CONST_commondisplay068 = "Trans: ";
	const string CONST_commondisplay067 = "?";
	const string CONST_commondisplay066 = "Char:   ";
	const string CONST_commondisplay064 = "Str:    ";
	const string CONST_commondisplay062 = "Agi:    ";
	const string CONST_commondisplay060 = "Hlth:   ";
	const string CONST_commondisplay058 = "Wis:    ";
	const string CONST_commondisplay056 = "Int:    ";
	const string CONST_commondisplay054 = "Hrt:    ";
	const string CONST_commondisplay053 = "an angry Hangin' Judge";
	const string CONST_commondisplay052 = "a frightened Eminent Scientist";
	const string CONST_commondisplay051 = "a smarmy News Anchor";
	const string CONST_commondisplay050 = "a crying Radio Personality";
	const string CONST_commondisplay049 = "a squirming CEO";
	const string CONST_commondisplay048 = "a cursing Politician";
	const string CONST_commondisplay047 = ", holding ";
	extern short sitealarm;
	extern short sitealarmtimer;
	extern int year;
	extern short mode;
	extern char showcarprefs;
	char str[200];
	makedelimiter(1);
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(1, 2, cr->name);
	addstrAlt(commaSpace);
	addstrAlt(gettitle(*cr));
	if (cr->prisoner != NULL)
	{
		addstrAlt(CONST_commondisplay047);
		switch (cr->prisoner->type)
		{
		case CREATURE_POLITICIAN:addstrAlt(CONST_commondisplay048); break;
		case CREATURE_CORPORATE_CEO:addstrAlt(CONST_commondisplay049); break;
		case CREATURE_RADIOPERSONALITY:addstrAlt(CONST_commondisplay050); break;
		case CREATURE_NEWSANCHOR:addstrAlt(CONST_commondisplay051); break;
		case CREATURE_SCIENTIST_EMINENT:addstrAlt(CONST_commondisplay052); break;
		case CREATURE_JUDGE_CONSERVATIVE:addstrAlt(CONST_commondisplay053); break;
		default:
			addstrAlt(cr->prisoner->name);
			break;
		}
	}
	mvaddstrAlt(2, 0, CONST_commondisplay054);
	if (knowledge > 0)
		addstrAlt(cr->get_attribute(ATTRIBUTE_HEART, true));
	else addstrAlt(CONST_commondisplay067);
	mvaddstrAlt(3, 0, CONST_commondisplay056);
	if (knowledge > 0)
		addstrAlt(cr->get_attribute(ATTRIBUTE_INTELLIGENCE, true));
	else addstrAlt(CONST_commondisplay067);
	mvaddstrAlt(4, 0, CONST_commondisplay058);
	if (knowledge > 0)
		addstrAlt(cr->get_attribute(ATTRIBUTE_WISDOM, true));
	else addstrAlt(CONST_commondisplay067);
	mvaddstrAlt(5, 0, CONST_commondisplay060);
	if (knowledge > 1)
		addstrAlt(cr->get_attribute(ATTRIBUTE_HEALTH, true));
	else addstrAlt(CONST_commondisplay067);
	mvaddstrAlt(2, 11, CONST_commondisplay062);
	if (knowledge > 1)
		addstrAlt(cr->get_attribute(ATTRIBUTE_AGILITY, true));
	else addstrAlt(CONST_commondisplay067);
	mvaddstrAlt(3, 11, CONST_commondisplay064);
	if (knowledge > 1)
		addstrAlt(cr->get_attribute(ATTRIBUTE_STRENGTH, true));
	else addstrAlt(CONST_commondisplay067);
	mvaddstrAlt(4, 11, CONST_commondisplay066);
	if (knowledge > 0)
		addstrAlt(cr->get_attribute(ATTRIBUTE_CHARISMA, true));
	else addstrAlt(CONST_commondisplay067);
	mvaddstrAlt(5, 11, CONST_commondisplay068);
	long v = -1;
	if (showcarprefs == 1)v = id_getcar(cr->pref_carid);
	else v = id_getcar(cr->carid);
	if (v != -1 && showcarprefs != -1)
	{
		strcpy(str, getVehicleShortname(v).c_str());
		char d;
		if (showcarprefs == 1)d = cr->pref_is_driver;
		else d = cr->is_driver;
		if (d)strcat(str, CONST_commondisplay156.c_str());
	}
	else
	{
		int legok = 2;
		if ((cr->wound[BODYPART_LEG_RIGHT] & WOUND_NASTYOFF) ||
			(cr->wound[BODYPART_LEG_RIGHT] & WOUND_CLEANOFF))legok--;
		if ((cr->wound[BODYPART_LEG_LEFT] & WOUND_NASTYOFF) ||
			(cr->wound[BODYPART_LEG_LEFT] & WOUND_CLEANOFF))legok--;
		if (cr->flag & CREATUREFLAG_WHEELCHAIR)strcpy(str, CONST_commondisplay157.c_str());
		else if (legok >= 1)strcpy(str, CONST_commondisplay158.c_str());
		else strcpy(str, CONST_commondisplay003.c_str());
	}
	addstrAlt(str);
	moveAlt(6, 0);
	if (mode != GAMEMODE_SITE) set_color_easy(WHITE_ON_BLACK);
	else switch (weaponcheck(*cr))
	{
	case -1:
	case 0:set_color_easy(GREEN_ON_BLACK_BRIGHT); break;
	case 1:set_color_easy(YELLOW_ON_BLACK_BRIGHT); break;
	case 2:set_color_easy(RED_ON_BLACK_BRIGHT); break;
	}
	addstrAlt(CONST_commondisplay153);
	addstrAlt(cr->get_weapon_string(1));
	moveAlt(7, 0);
	if (mode != GAMEMODE_SITE)
	{
		int fg = COLOR_WHITE;
		int bg = COLOR_BLACK;
		int in = 1;
		if (cr->get_armor().is_bloody())
		{
			bg = COLOR_RED;  in = 0;
		}
		if (cr->get_armor().get_quality() > cr->get_armor().get_quality_levels())
		{
			fg = COLOR_BLACK;
		}
		else if (cr->get_armor().is_damaged())
		{
			fg = COLOR_YELLOW; in = 1;
		}
		else if (cr->get_armor().get_quality() > 1)
		{
			fg = COLOR_YELLOW; in = (bg == COLOR_RED);
		}
		if (fg == COLOR_WHITE && bg == COLOR_BLACK)
			in = 0;
		set_color(fg, bg, in);
	}
	else
	{
		switch (hasdisguise(*cr))
		{
		case 1:set_color_easy(GREEN_ON_BLACK_BRIGHT); break;
		case 2:set_color_easy(YELLOW_ON_BLACK_BRIGHT); break;
		default:
			if (cr->get_armor().get_stealth_value() > 1)
				set_color_easy(BLACK_ON_BLACK_BRIGHT);
			else set_color_easy(RED_ON_BLACK_BRIGHT);
		}
		if (sitealarmtimer >= 0 || sitealarm == 1)
			if (cr->get_armor().get_stealth_value() > 1)
				set_color_easy(BLACK_ON_BLACK_BRIGHT);
	}
	addstrAlt(CONST_commondisplay154);
	addstrAlt(cr->get_armor_string(false));
	set_color_easy(WHITE_ON_BLACK);
	char used[SKILLNUM];
	memset(used, 0, sizeof(char)*SKILLNUM);
	int snum = 5;
	char printed = 1;
	while (snum > 0 && printed)
	{
		printed = 0;
		int max = 0;
		long maxs = -1;
		for (int s = 0; s < SKILLNUM; s++)
		{
			if ((cr->get_skill(s) * 10000 + cr->get_skill_ip(s)) > max && !used[s])
			{
				max = (cr->get_skill(s) * 10000 + cr->get_skill_ip(s));
				maxs = s;
			}
		}
		if (maxs != -1)
		{
			used[maxs] = 1;
			printed = 1;
			// Maxed skills are cyan
			if (cr->skill_cap(maxs, true) != 0 && cr->get_skill(maxs) >= cr->skill_cap(maxs, true))set_color_easy(CYAN_ON_BLACK_BRIGHT);
			// About to level up skills are white
			else if (cr->get_skill_ip(maxs) >= 100 + (10 * cr->get_skill(maxs)) &&
				cr->get_skill(maxs) < cr->skill_cap(maxs, true))set_color_easy(WHITE_ON_BLACK_BRIGHT);
			// <1 skills are dark gray
			else if (cr->get_skill(maxs) < 1)set_color_easy(BLACK_ON_BLACK_BRIGHT);
			// >=1 skills are light gray
			else set_color_easy(WHITE_ON_BLACK);
			moveAlt(3 + 5 - snum, 31);
			if (knowledge > 5 - snum)
				addstrAlt(skill_enum_to_string(maxs));
			else addstrAlt(CONST_commondisplay075);
			addstrAlt(CONST_commondisplay212);
			if (knowledge > 7 - snum)
				addstrAlt(cr->get_skill(maxs));
			else addcharAlt('?');
			if (snum == 5 && printed)
			{
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(2, 31, CONST_commondisplay077);
			}
		}
		snum--;
	}
	int woundsum = 0;
	for (int w = 0; w < BODYPARTNUM; w++)
		if (cr->wound[w] != 0)woundsum++;
	printhealthstat(*cr, 1, 49, FALSE);
	if (woundsum > 0)
	{
		for (int w = 0; w < BODYPARTNUM; w++)
		{
			if (cr->wound[w] & WOUND_BLEEDING)set_color_easy(RED_ON_BLACK_BRIGHT);
			else set_color_easy(WHITE_ON_BLACK);
			moveAlt(2 + w, 49);
			switch (w)
			{
			case BODYPART_HEAD:addstrAlt(CONST_commondisplay107); break;
			case BODYPART_BODY:addstrAlt(CONST_commondisplay108); break;
			case BODYPART_ARM_RIGHT:addstrAlt(CONST_commondisplay109); break;
			case BODYPART_ARM_LEFT:addstrAlt(CONST_commondisplay110); break;
			case BODYPART_LEG_RIGHT:addstrAlt(CONST_commondisplay111); break;
			case BODYPART_LEG_LEFT:addstrAlt(CONST_commondisplay112); break;
			}
			moveAlt(2 + w, 61);
			if (cr->wound[w] & WOUND_NASTYOFF)addstrAlt(CONST_commondisplay113);
			else if (cr->wound[w] & WOUND_CLEANOFF)addstrAlt(CONST_commondisplay085);
			else
			{
				int sum = 0;
				if (cr->wound[w] & WOUND_SHOT)sum++;
				if (cr->wound[w] & WOUND_CUT)sum++;
				if (cr->wound[w] & WOUND_BRUISED)sum++;
				if (cr->wound[w] & WOUND_BURNED)sum++;
				if (cr->wound[w] & WOUND_TORN)sum++;
				if (sum == 0)
				{
					set_color_easy(GREEN_ON_BLACK_BRIGHT);
					if (cr->animalgloss == ANIMALGLOSS_ANIMAL)
						addstrAlt(CONST_commondisplay115);
					else addstrAlt(CONST_commondisplay116);
				}
				if (cr->wound[w] & WOUND_SHOT) { addstrAlt(CONST_commondisplay088); sum--; if (sum > 0)addstrAlt(CONST_commondisplay000); }
				if (cr->wound[w] & WOUND_BRUISED) { addstrAlt(CONST_commondisplay089); sum--; if (sum > 0)addstrAlt(CONST_commondisplay000); }
				if (cr->wound[w] & WOUND_CUT) { addstrAlt(CONST_commondisplay119); sum--; if (sum > 0)addstrAlt(CONST_commondisplay000); }
				if (cr->wound[w] & WOUND_TORN) { addstrAlt(CONST_commondisplay091); sum--; if (sum > 0)addstrAlt(CONST_commondisplay000); }
				if (cr->wound[w] & WOUND_BURNED) { addstrAlt(CONST_commondisplay092); sum--; if (sum > 0)addstrAlt(CONST_commondisplay000); }
			}
		}
		set_color_easy(WHITE_ON_BLACK);
	}
}
/* party info at top of screen */
void printparty()
{
	const string CONST_commondisplay101 = " (1)";
	const string CONST_commondisplay100 = " (XX)";
	const string CONST_commondisplay097 = "/";
	const string CONST_commondisplay096 = "+H";
	const string CONST_commondisplay094 = "#ÄCODE NAMEÄÄÄÄÄÄÄÄÄÄÄÄSKILLÄÄÄWEAPONÄÄÄÄÄÄÄÄÄARMORÄÄÄÄÄÄÄÄÄÄHEALTHÄÄÄTRANSPORTÄ";
	extern squadst *activesquad;
	extern short party_status;
	extern char showcarprefs;
	extern short mode;
	extern bool mapshowing;
	extern short sitealarm;
	extern short sitealarmtimer;
	Creature *party[6] = { NULL,NULL,NULL,NULL,NULL,NULL };
	if (activesquad != NULL)
		for (int p = 0; p < 6; p++)party[p] = activesquad->squad[p];
	set_color_easy(WHITE_ON_BLACK);
	for (int i = 2; i < 8; i++)
	{
		mvaddstrAlt(i, 0, CONST_commondisplay220); // 80 spaces
	}
	if (party_status != -1 && party[party_status] == NULL)party_status = -1;
	if (party_status != -1)
	{
		printcreatureinfo(party[party_status]);
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(1, 0, party_status + 1);
	}
	else
	{
		char str[200];
		mvaddstrAlt(1, 0, CONST_commondisplay094); // 80 characters
		for (int p = 0; p < 6; p++)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(p + 2, 0, CONST_commondisplay220); // 80 spaces
			mvaddcharAlt(p + 2, 0, '1' + p);
			if (party[p] != NULL)
			{
				if (party[p]->prisoner != NULL)set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
				else set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(p + 2, 2, party[p]->name);
				if (party[p]->prisoner != NULL)addstrAlt(CONST_commondisplay096);
				int skill = 0;
				char bright = 0;
				for (int sk = 0; sk < SKILLNUM; sk++)
				{
					skill += (int)party[p]->get_skill(sk);
					if (party[p]->get_skill_ip(sk) >= 100 + (10 * party[p]->get_skill(sk)) &&
						party[p]->get_skill(sk) < party[p]->skill_cap(sk, true))bright = 1;
				}
				set_color_easy(bright ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
				mvaddstrAlt(p + 2, 23, skill);
				addstrAlt(CONST_commondisplay097);
				addstrAlt(party[p]->get_weapon_skill());
				moveAlt(p + 2, 31);
				if (mode != GAMEMODE_SITE)set_color_easy(WHITE_ON_BLACK);
				else switch (weaponcheck(*party[p]))
				{
				case -1:
				case 0:set_color_easy(GREEN_ON_BLACK_BRIGHT); break;
				case 1:set_color_easy(YELLOW_ON_BLACK_BRIGHT); break;
				case 2:set_color_easy(RED_ON_BLACK_BRIGHT); break;
				}
				if (party[p]->has_thrown_weapon && len(party[p]->extra_throwing_weapons))
					addstrAlt(party[p]->extra_throwing_weapons[0]->get_shortname(0));
				else addstrAlt(party[p]->get_weapon().get_shortname(0));
				//set_color_easy(WHITE_ON_BLACK);
				if (party[p]->get_weapon().get_ammoamount() > 0)
				{
					//set_color_easy(WHITE_ON_BLACK);
					addstrAlt(CONST_commondisplay202);
					addstrAlt(party[p]->get_weapon().get_ammoamount());
					addstrAlt(closeParenthesis);
				}
				else if (party[p]->get_weapon().uses_ammo())
				{
					set_color_easy(BLACK_ON_BLACK_BRIGHT);
					if (len(party[p]->clips))
					{
						addstrAlt(CONST_commondisplay202);
						addstrAlt(party[p]->count_clips());
						addstrAlt(closeParenthesis);
					}
					else
						addstrAlt(CONST_commondisplay100);
				}
				else if (party[p]->get_weapon().is_throwable() && !party[p]->has_thrown_weapon)
					addstrAlt(CONST_commondisplay101);
				else if (party[p]->has_thrown_weapon && len(party[p]->extra_throwing_weapons))
				{
					set_color_easy(BLACK_ON_BLACK_BRIGHT);
					addstrAlt(CONST_commondisplay202);
					addstrAlt(party[p]->count_weapons() - party[p]->is_armed());
					addstrAlt(closeParenthesis);
				}
				if (mode != GAMEMODE_SITE)
				{
					int fg = COLOR_WHITE;
					int bg = COLOR_BLACK;
					int in = 1;
					if (party[p]->get_armor().is_bloody())
					{
						bg = COLOR_RED;  in = 1;
					}
					if (party[p]->get_armor().get_quality() > party[p]->get_armor().get_quality_levels())
					{
						fg = COLOR_BLACK;
					}
					else if (party[p]->get_armor().is_damaged())
					{
						fg = COLOR_YELLOW; in = 1;
					}
					else if (party[p]->get_armor().get_quality() > 1)
					{
						fg = COLOR_YELLOW; in = (bg == COLOR_RED);
					}
					if (fg == COLOR_WHITE && bg == COLOR_BLACK)
						in = 0;
					set_color(fg, bg, in);
				}
				else
				{
					switch (hasdisguise(*party[p]))
					{
					case 1:set_color_easy(GREEN_ON_BLACK_BRIGHT); break;
					case 2:set_color_easy(YELLOW_ON_BLACK_BRIGHT); break;
					default:
						if (party[p]->get_armor().get_stealth_value() > 1)
							set_color_easy(BLACK_ON_BLACK_BRIGHT);
						else set_color_easy(RED_ON_BLACK_BRIGHT);
						break;
					}
					if (sitealarmtimer >= 0 || sitealarm == 1)
						if (party[p]->get_armor().get_stealth_value() > 1)
							set_color_easy(BLACK_ON_BLACK_BRIGHT);
				}
				mvaddstrAlt(p + 2, 46, party[p]->get_armor().get_shortname());
				printhealthstat(*party[p], p + 2, 61, TRUE);
				set_color_easy(WHITE_ON_BLACK);
				moveAlt(p + 2, 70);
				long v = -1;
				if (showcarprefs == 1)v = id_getcar(party[p]->pref_carid);
				else v = id_getcar(party[p]->carid);
				if (v != -1 && showcarprefs != -1)
				{
					strcpy(str, getVehicleShortname(v).c_str());
					if (showcarprefs == 1 ? party[p]->pref_is_driver : party[p]->is_driver)strcat(str, CONST_commondisplay156.c_str());
				}
				else
				{
					int legok = 2;
					if ((party[p]->wound[BODYPART_LEG_RIGHT] & WOUND_NASTYOFF) ||
						(party[p]->wound[BODYPART_LEG_RIGHT] & WOUND_CLEANOFF))legok--;
					if ((party[p]->wound[BODYPART_LEG_LEFT] & WOUND_NASTYOFF) ||
						(party[p]->wound[BODYPART_LEG_LEFT] & WOUND_CLEANOFF))legok--;
					if (party[p]->flag & CREATUREFLAG_WHEELCHAIR)strcpy(str, CONST_commondisplay157.c_str());
					else if (legok >= 1)strcpy(str, CONST_commondisplay158.c_str());
					else strcpy(str, CONST_commondisplay003.c_str());
				}
				addstrAlt(str);
			}
		}
	}
	makedelimiter();
}
void printwoundstat(Creature &cr, int y, int x)
{
	const string CONST_commondisplay121 = "Burned";
	const string CONST_commondisplay120 = "Torn";
	// Add wound status
	for (int w = 0; w < BODYPARTNUM; w++)
	{
		if (cr.wound[w] & WOUND_BLEEDING)set_color_easy(RED_ON_BLACK_BRIGHT);
		else set_color_easy(WHITE_ON_BLACK);
		moveAlt(y + w, x);
		switch (w)
		{
		case BODYPART_HEAD:addstrAlt(CONST_commondisplay107); break;
		case BODYPART_BODY:addstrAlt(CONST_commondisplay108); break;
		case BODYPART_ARM_RIGHT:addstrAlt(CONST_commondisplay109); break;
		case BODYPART_ARM_LEFT:addstrAlt(CONST_commondisplay110); break;
		case BODYPART_LEG_RIGHT:addstrAlt(CONST_commondisplay111); break;
		case BODYPART_LEG_LEFT:addstrAlt(CONST_commondisplay112); break;
		}
		moveAlt(y + w, x + 11);
		if (cr.wound[w] & WOUND_NASTYOFF)addstrAlt(CONST_commondisplay113);
		else if (cr.wound[w] & WOUND_CLEANOFF)addstrAlt(CONST_commondisplay114);
		else
		{
			int sum = 0;
			if (cr.wound[w] & WOUND_SHOT)sum++;
			if (cr.wound[w] & WOUND_CUT)sum++;
			if (cr.wound[w] & WOUND_BRUISED)sum++;
			if (cr.wound[w] & WOUND_BURNED)sum++;
			if (cr.wound[w] & WOUND_TORN)sum++;
			if (sum == 0)
			{
				set_color_easy(GREEN_ON_BLACK_BRIGHT);
				if (cr.animalgloss == ANIMALGLOSS_ANIMAL)
					addstrAlt(CONST_commondisplay115);
				else addstrAlt(CONST_commondisplay116);
			}
			if (cr.wound[w] & WOUND_SHOT) { addstrAlt(CONST_commondisplay117); sum--; if (sum > 0)addstrAlt(CONST_commondisplay000); }
			if (cr.wound[w] & WOUND_BRUISED) { addstrAlt(CONST_commondisplay118); sum--; if (sum > 0)addstrAlt(CONST_commondisplay000); }
			if (cr.wound[w] & WOUND_CUT) { addstrAlt(CONST_commondisplay119); sum--; if (sum > 0)addstrAlt(CONST_commondisplay000); }
			if (cr.wound[w] & WOUND_TORN) { addstrAlt(CONST_commondisplay120); sum--; if (sum > 0)addstrAlt(CONST_commondisplay000); }
			if (cr.wound[w] & WOUND_BURNED) { addstrAlt(CONST_commondisplay121); sum--; if (sum > 0)addstrAlt(CONST_commondisplay000); }
		}
	}
}
/* full screen character sheet */
void printliberalstats(Creature &cr)
{
	const string CONST_commondisplay188 = "Broken Ribs";
	const string CONST_commondisplay187 = "Broken Rib";
	const string CONST_commondisplay186 = "All Ribs Broken";
	const string CONST_commondisplay185 = "Busted Spleen";
	const string CONST_commondisplay184 = "Stomach Injured";
	const string CONST_commondisplay183 = "L. Kidney Damaged";
	const string CONST_commondisplay182 = "R. Kidney Damaged";
	const string CONST_commondisplay181 = "Liver Damaged";
	const string CONST_commondisplay179 = "Missing a Tooth";
	const string CONST_commondisplay176 = "No Nose";
	const string CONST_commondisplay175 = "No Left Eye";
	const string CONST_commondisplay174 = "No Right Eye";
	const string CONST_commondisplay173 = "Broken Lw Spine";
	const string CONST_commondisplay172 = "Broken Up Spine";
	const string CONST_commondisplay171 = "Broken Neck";
	const string CONST_commondisplay170 = "L. Lung Collapsed";
	const string CONST_commondisplay169 = "R. Lung Collapsed";
	const string CONST_commondisplay168 = "Heart Punctured";
	const string CONST_commondisplay167 = "Scheduled Dates:    ";
	const string CONST_commondisplay166 = "s";
	const string CONST_commondisplay165 = " Romantic Interest";
	const string CONST_commondisplay164 = "Scheduled Meetings: ";
	const string CONST_commondisplay163 = "Can't Recruit";
	const string CONST_commondisplay162 = "Enlightened ";
	const string CONST_commondisplay161 = " Max";
	const string CONST_commondisplay160 = " Recruits / ";
	const string CONST_commondisplay155 = "Car: ";
	const string CONST_commondisplay145 = "Charisma: ";
	const string CONST_commondisplay144 = "Strength: ";
	const string CONST_commondisplay143 = "Agility: ";
	const string CONST_commondisplay142 = "Health: ";
	const string CONST_commondisplay141 = "Wisdom: ";
	const string CONST_commondisplay140 = "Intelligence: ";
	const string CONST_commondisplay139 = "Heart: ";
	const string CONST_commondisplay138 = "1000";
	const string CONST_commondisplay137 = "500";
	const string CONST_commondisplay136 = "200";
	const string CONST_commondisplay135 = "100";
	const string CONST_commondisplay134 = "50";
	const string CONST_commondisplay133 = "10";
	const string CONST_commondisplay132 = "Next:  ";
	const string CONST_commondisplay131 = "Juice: ";
	const string CONST_commondisplay130 = "*";
	const string CONST_commondisplay129 = ", Genderqueer";
	const string CONST_commondisplay128 = ", Female";
	const string CONST_commondisplay127 = ", Male";
	const string CONST_commondisplay126 = " (Age ";
	const string CONST_commondisplay125 = "Born ";
	extern int year;
	extern int day;
	extern int month;
	extern char showcarprefs;
	set_color_easy(WHITE_ON_BLACK);
	// Add name
	mvaddstrAlt(2, 0, CONST_commondisplay201);
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	addstrAlt(cr.name);
	set_color_easy(WHITE_ON_BLACK);
	if (strcmp(cr.propername, cr.name) != 0)
	{
		//The names do not match, print real name as well
		addstrAlt(CONST_commondisplay202);
		addstrAlt(cr.propername);
		addstrAlt(closeParenthesis);
	}
	addstrAlt(commaSpace);
	addstrAlt(gettitle(cr));
	addstrAlt(CONST_commondisplay202);
	addstrAlt(cr.get_type_name());
	addstrAlt(closeParenthesis);
	moveAlt(3, 0);
	// Add birthdate
	addstrAlt(CONST_commondisplay125);
	addstrAlt(getmonth(cr.birthday_month));
	addstrAlt(singleSpace);
	addstrAlt(cr.birthday_day);
	addstrAlt(commaSpace);
	if (cr.birthday_month < month ||
		(cr.birthday_month == month && cr.birthday_day <= day))
		addstrAlt(year - cr.age);
	else addstrAlt(year - 1 - cr.age);
	// Add age
	addstrAlt(CONST_commondisplay126);
	addstrAlt(cr.age);
	// Assess their gender in an Elite Liberal way
	if (cr.gender_liberal == GENDER_MALE)
		addstrAlt(CONST_commondisplay127);
	else if (cr.gender_liberal == GENDER_FEMALE)
		addstrAlt(CONST_commondisplay128);
	else addstrAlt(CONST_commondisplay129);
	// DON'T Note if there's some conflict with Conservative society's perceptions
	//if(cr.gender_liberal != cr.gender_conservative && cr.gender_liberal != GENDER_NEUTRAL)
	//   addstrAlt(CONST_commondisplay130);
	addstrAlt(closeParenthesis);
	moveAlt(3, 46);
	statebrokenlaws(cr);
	set_color_easy(WHITE_ON_BLACK);
	// Add juice
	mvaddstrAlt(10, 16, CONST_commondisplay131);
	addstrAlt(cr.juice);
	if (cr.juice < 1000)
	{
		mvaddstrAlt(11, 16, CONST_commondisplay132);
		if (cr.juice < 0)addstrAlt(tag_0);
		else if (cr.juice < 10)addstrAlt(CONST_commondisplay133);
		else if (cr.juice < 50)addstrAlt(CONST_commondisplay134);
		else if (cr.juice < 100)addstrAlt(CONST_commondisplay135);
		else if (cr.juice < 200)addstrAlt(CONST_commondisplay136);
		else if (cr.juice < 500)addstrAlt(CONST_commondisplay137);
		else addstrAlt(CONST_commondisplay138);
	}
	// Add attributes
	mvaddstrAlt(5, 0, CONST_commondisplay139);
	addstrAlt(cr.get_attribute(ATTRIBUTE_HEART, true));
	mvaddstrAlt(6, 0, CONST_commondisplay140);
	addstrAlt(cr.get_attribute(ATTRIBUTE_INTELLIGENCE, true));
	mvaddstrAlt(7, 0, CONST_commondisplay141);
	addstrAlt(cr.get_attribute(ATTRIBUTE_WISDOM, true));
	mvaddstrAlt(8, 0, CONST_commondisplay142);
	addstrAlt(cr.get_attribute(ATTRIBUTE_HEALTH, true));
	mvaddstrAlt(9, 0, CONST_commondisplay143);
	addstrAlt(cr.get_attribute(ATTRIBUTE_AGILITY, true));
	mvaddstrAlt(10, 0, CONST_commondisplay144);
	addstrAlt(cr.get_attribute(ATTRIBUTE_STRENGTH, true));
	mvaddstrAlt(11, 0, CONST_commondisplay145);
	addstrAlt(cr.get_attribute(ATTRIBUTE_CHARISMA, true));
	// Add highest skills
	char used[SKILLNUM];
	memset(used, 0, sizeof(char)*SKILLNUM);
	int skills_max = 16;
	char printed = 1;
	mvaddstrAlt(5, 28, CONST_commondisplay193);
	mvaddstrAlt(5, 43, CONST_commondisplay194);
	for (int skills_shown = 0; skills_shown < skills_max&&printed; skills_shown++)
	{
		printed = 0;
		int max = 0;
		long maxs = -1;
		for (int s = 0; s < SKILLNUM; s++)
		{
			if ((cr.get_skill(s) * 10000 + cr.get_skill_ip(s)) > max && !used[s])
			{
				max = (cr.get_skill(s) * 10000 + cr.get_skill_ip(s));
				maxs = s;
			}
		}
		if (maxs != -1)
		{
			used[maxs] = 1;
			printed = 1;
			// Maxed skills are cyan
			if (cr.skill_cap(maxs, true) != 0 && cr.get_skill(maxs) >= cr.skill_cap(maxs, true))set_color_easy(CYAN_ON_BLACK_BRIGHT);
			// About to level up skills are white
			else if (cr.get_skill_ip(maxs) >= 100 + (10 * cr.get_skill(maxs)) &&
				cr.get_skill(maxs) < cr.skill_cap(maxs, true))set_color_easy(WHITE_ON_BLACK_BRIGHT);
			// <1 skills are dark gray
			else if (cr.get_skill(maxs) < 1)set_color_easy(BLACK_ON_BLACK_BRIGHT);
			// >=1 skills are light gray
			else set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(6 + skills_shown, 28, skill_enum_to_string(maxs));
			addstrAlt(CONST_commondisplay212);
			moveAlt(6 + skills_shown, 42);
			addstr_f(CONST_commondisplay196.c_str(), cr.get_skill(maxs));
			if (cr.get_skill_ip(maxs) < 100 + (10 * cr.get_skill(maxs)))
			{
				if ((cr.get_skill_ip(maxs) * 100) / (100 + (10 * cr.get_skill(maxs))) != 0)
				{
					if ((cr.get_skill_ip(maxs) * 100) / (100 + (10 * cr.get_skill(maxs))) < 10)
						addcharAlt('0');
					addstrAlt((cr.get_skill_ip(maxs) * 100) / (100 + (10 * cr.get_skill(maxs))));
				}
				else addstrAlt(CONST_commondisplay197);
			}
			else addstrAlt(CONST_commondisplay198);
			if (cr.skill_cap(maxs, true) == 0 || cr.get_skill(maxs) < cr.skill_cap(maxs, true))
				set_color_easy(BLACK_ON_BLACK_BRIGHT);
			moveAlt(6 + skills_shown, 48);
			addstr_f(CONST_commondisplay199.c_str(), cr.skill_cap(maxs, true));
		}
	}
	set_color_easy(WHITE_ON_BLACK);
	// Add weapon
	mvaddstrAlt(13, 0, CONST_commondisplay153);
	addstrAlt(cr.get_weapon_string(0));
	// Add clothing
	mvaddstrAlt(14, 0, CONST_commondisplay154);
	addstrAlt(cr.get_armor_string(true));
	// Add vehicle
	mvaddstrAlt(15, 0, CONST_commondisplay155);
	long v = -1;
	if (showcarprefs == 1)v = id_getcar(cr.pref_carid);
	else v = id_getcar(cr.carid);
	if (v != -1 && showcarprefs != -1)
	{
		addstrAlt(getVehicleShortname(v));
		char d;
		if (showcarprefs == 1)d = cr.pref_is_driver;
		else d = cr.is_driver;
		if (d)addstrAlt(CONST_commondisplay156);
	}
	else
	{
		int legok = 2;
		if ((cr.wound[BODYPART_LEG_RIGHT] & WOUND_NASTYOFF) ||
			(cr.wound[BODYPART_LEG_RIGHT] & WOUND_CLEANOFF))legok--;
		if ((cr.wound[BODYPART_LEG_LEFT] & WOUND_NASTYOFF) ||
			(cr.wound[BODYPART_LEG_LEFT] & WOUND_CLEANOFF))legok--;
		if (cr.flag & CREATUREFLAG_WHEELCHAIR)addstrAlt(CONST_commondisplay157);
		else if (legok >= 1)addstrAlt(CONST_commondisplay158);
		else addstrAlt(CONST_commondisplay003);
	}
	// Add recruit stats
	if (cr.flag != CREATUREFLAG_BRAINWASHED)
	{
		mvaddstrAlt(18, 55, maxsubordinates(cr) - subordinatesleft(cr));
		addstrAlt(CONST_commondisplay160);
		addstrAlt(maxsubordinates(cr));
		addstrAlt(CONST_commondisplay161);
	}
	else
	{
		mvaddstrAlt(18, 55, CONST_commondisplay162);
		addstrAlt(CONST_commondisplay163);
	}
	// Any meetings with potential recruits scheduled?
	if (scheduledmeetings(cr))
	{
		mvaddstrAlt(20, 55, CONST_commondisplay164);
		addstrAlt(scheduledmeetings(cr));
	}
	// Add seduction stats
	moveAlt(19, 55);
	int lovers = loveslaves(cr);
	if (cr.flag & CREATUREFLAG_LOVESLAVE)
		lovers++;
	if (lovers)
	{
		addstrAlt(lovers);
		addstrAlt(CONST_commondisplay165);
		if (lovers > 1)addstrAlt(CONST_commondisplay166);
	}
	// Any dates with potential love interests scheduled?
	if (scheduleddates(cr))
	{
		mvaddstrAlt(21, 55, CONST_commondisplay167);
		addstrAlt(scheduleddates(cr));
	}
	printwoundstat(cr, 5, 55);
	//SPECIAL WOUNDS
	set_color_easy(RED_ON_BLACK);
	int y = 17;
	int x = 0;
	if (cr.special[SPECIALWOUND_HEART] != 1)
	{
		mvaddstrAlt(y++, x, CONST_commondisplay168);
	}
	if (cr.special[SPECIALWOUND_RIGHTLUNG] != 1)
	{
		mvaddstrAlt(y++, x, CONST_commondisplay169);
	}
	if (cr.special[SPECIALWOUND_LEFTLUNG] != 1)
	{
		mvaddstrAlt(y++, x, CONST_commondisplay170);
	}
	if (cr.special[SPECIALWOUND_NECK] != 1)
	{
		mvaddstrAlt(y++, x, CONST_commondisplay171);
	}
	if (cr.special[SPECIALWOUND_UPPERSPINE] != 1)
	{
		mvaddstrAlt(y++, x, CONST_commondisplay172);
	}
	if (cr.special[SPECIALWOUND_LOWERSPINE] != 1)
	{
		mvaddstrAlt(y++, x, CONST_commondisplay173);
	}
	if (cr.special[SPECIALWOUND_RIGHTEYE] != 1)
	{
		mvaddstrAlt(y++, x, CONST_commondisplay174);
	}
	if (cr.special[SPECIALWOUND_LEFTEYE] != 1)
	{
		mvaddstrAlt(y++, x, CONST_commondisplay175);
	}
	if (cr.special[SPECIALWOUND_NOSE] != 1)
	{
		mvaddstrAlt(y++, x, CONST_commondisplay176);
	}
	if (cr.special[SPECIALWOUND_TONGUE] != 1)
	{
		mvaddstrAlt(y++, x, CONST_commondisplay177);
	}
	if (cr.special[SPECIALWOUND_TEETH] != TOOTHNUM)
	{
		moveAlt(y++, x);
		if (cr.special[SPECIALWOUND_TEETH] == 0)addstrAlt(CONST_commondisplay178);
		else if (cr.special[SPECIALWOUND_TEETH] == TOOTHNUM - 1)addstrAlt(CONST_commondisplay179);
		else if (cr.special[SPECIALWOUND_TEETH] < TOOTHNUM)addstrAlt(CONST_commondisplay180);
	}
	if (cr.special[SPECIALWOUND_LIVER] != 1)
	{
		mvaddstrAlt(y++, x, CONST_commondisplay181);
	}
	if (cr.special[SPECIALWOUND_RIGHTKIDNEY] != 1)
	{
		mvaddstrAlt(y++, x, CONST_commondisplay182);
	}
	if (cr.special[SPECIALWOUND_LEFTKIDNEY] != 1)
	{
		mvaddstrAlt(y++, x, CONST_commondisplay183);
	}
	if (cr.special[SPECIALWOUND_STOMACH] != 1)
	{
		mvaddstrAlt(y++, x, CONST_commondisplay184);
	}
	if (cr.special[SPECIALWOUND_SPLEEN] != 1)
	{
		mvaddstrAlt(y++, x, CONST_commondisplay185);
	}
	if (cr.special[SPECIALWOUND_RIBS] != RIBNUM)
	{
		moveAlt(y++, x);
		if (cr.special[SPECIALWOUND_RIBS] == 0)addstrAlt(CONST_commondisplay186);
		else if (cr.special[SPECIALWOUND_RIBS] == RIBNUM - 1)addstrAlt(CONST_commondisplay187);
		else if (cr.special[SPECIALWOUND_RIBS] < RIBNUM)addstrAlt(CONST_commondisplay188);
	}
	set_color_easy(WHITE_ON_BLACK);
	for (int i = 0, y = 12; i < AUGMENTATIONNUM; i++, y++)
	{
		if (cr.get_augmentation(i).type == -1) continue;
		mvaddstrAlt(y, 55, Augmentation::get_name(i));
		addstrAlt(CONST_commondisplay212);
		addstrAlt(cr.get_augmentation(i).name);
	}
}
/* Full screen character sheet, skills only edition */
void printliberalskills(Creature &cr)
{
	// Add name
	set_color_easy(WHITE_ON_BLACK);
	moveAlt(2, 0);
	if (strcmp(cr.propername, cr.name) != 0)
		addstrAlt(CONST_commondisplay200);
	else addstrAlt(CONST_commondisplay201);
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	addstrAlt(cr.name);
	set_color_easy(WHITE_ON_BLACK);
	addstrAlt(commaSpace);
	addstrAlt(gettitle(cr));
	addstrAlt(CONST_commondisplay202);
	addstrAlt(cr.get_type_name());
	addstrAlt(closeParenthesis);
	// Add all skills
	for (int s = 0; s < SKILLNUM; s++)
	{
		if (s % 3 == 0 && s < 9)
		{
			set_color_easy(WHITE_ON_BLACK);
			moveAlt(4, 27 * (s / 3));
			addstrAlt(CONST_commondisplay193);
			moveAlt(4, 15 + 27 * (s / 3));
			addstrAlt(CONST_commondisplay194);
		}
		// Maxed skills are cyan
		if (cr.skill_cap(s, true) != 0 && cr.get_skill(s) >= cr.skill_cap(s, true))set_color_easy(CYAN_ON_BLACK_BRIGHT);
		// About to level up skills are white
		else if (cr.get_skill_ip(s) >= 100 + (10 * cr.get_skill(s)) &&
			cr.get_skill(s) < cr.skill_cap(s, true))set_color_easy(WHITE_ON_BLACK_BRIGHT);
		// <1 skills are dark gray
		else if (cr.get_skill(s) < 1)set_color_easy(BLACK_ON_BLACK_BRIGHT);
		// >=1 skills are light gray
		else set_color_easy(WHITE_ON_BLACK);
		moveAlt(5 + s / 3, 27 * (s % 3));
		addstrAlt(skill_enum_to_string(s));
		addstrAlt(CONST_commondisplay212);
		moveAlt(5 + s / 3, 14 + 27 * (s % 3));
		addstr_f(CONST_commondisplay196.c_str(), cr.get_skill(s));
		if (cr.get_skill_ip(s) < 100 + (10 * cr.get_skill(s)))
		{
			if ((cr.get_skill_ip(s) * 100) / (100 + (10 * cr.get_skill(s))) != 0)
			{
				if ((cr.get_skill_ip(s) * 100) / (100 + (10 * cr.get_skill(s))) < 10)
					addstrAlt(tag_0);
				addstrAlt((cr.get_skill_ip(s) * 100) / (100 + (10 * cr.get_skill(s))));
			}
			else addstrAlt(CONST_commondisplay197);
		}
		else addstrAlt(CONST_commondisplay198);
		if (cr.skill_cap(s, true) == 0 || cr.get_skill(s) < cr.skill_cap(s, true))
			set_color_easy(BLACK_ON_BLACK_BRIGHT);
		moveAlt(5 + s / 3, 20 + 27 * (s % 3));
		addstr_f(CONST_commondisplay199.c_str(), cr.skill_cap(s, true));
	}
	set_color_easy(WHITE_ON_BLACK);
}
/* Full screen character sheet, crime sheet */
void printliberalcrimes(Creature &cr)
{
	const string CONST_commondisplay213 = "%2d";
	const string CONST_commondisplay211 = "NUM";
	const string CONST_commondisplay210 = "CRIME";
	const string CONST_commondisplay209 = " months in prison.";
	const string CONST_commondisplay208 = "Sentenced to ";
	const string CONST_commondisplay207 = "Serving ";
	const string CONST_commondisplay206 = "Sentenced to life in prison";
	const string CONST_commondisplay205 = "Serving life in prison";
	const string CONST_commondisplay204 = "Sentenced to DEATH";
	const string CONST_commondisplay203 = "On DEATH ROW";
	// Add name
	set_color_easy(WHITE_ON_BLACK);
	if (strcmp(cr.propername, cr.name) != 0)
		mvaddstrAlt(2, 0, CONST_commondisplay200);
	else mvaddstrAlt(2, 0, CONST_commondisplay201);
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	addstrAlt(cr.name);
	set_color_easy(WHITE_ON_BLACK);
	addstrAlt(commaSpace);
	addstrAlt(gettitle(cr));
	addstrAlt(CONST_commondisplay202);
	addstrAlt(cr.get_type_name());
	addstrAlt(closeParenthesis);
	// Show outstanding convictions in addition to untried crimes
	if (cr.deathpenalty)
	{
		set_color_easy(RED_ON_BLACK_BRIGHT);
		if (LocationsPool::getInstance().getLocationType(cr.location) == SITE_GOVERNMENT_PRISON)
			mvaddstrAlt(3, 0, CONST_commondisplay203);
		else mvaddstrAlt(3, 0, CONST_commondisplay204);
	}
	else if (cr.sentence < 0)
	{
		set_color_easy(RED_ON_BLACK_BRIGHT);
		if (LocationsPool::getInstance().getLocationType(cr.location) == SITE_GOVERNMENT_PRISON)
			mvaddstrAlt(3, 0, CONST_commondisplay205);
		else mvaddstrAlt(3, 0, CONST_commondisplay206);
	}
	else if (cr.sentence > 0)
	{
		set_color_easy(YELLOW_ON_BLACK_BRIGHT);
		if (LocationsPool::getInstance().getLocationType(cr.location) == SITE_GOVERNMENT_PRISON)
			mvaddstrAlt(3, 0, CONST_commondisplay207);
		else mvaddstrAlt(3, 0, CONST_commondisplay208);
		addstrAlt(cr.sentence);
		addstrAlt(CONST_commondisplay209);
	}
	// Add all crimes
	for (int i = 0; i < LAWFLAGNUM; i++)
	{
		if (i % 2 == 0 && i < 4)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(4, 40 * (i / 2), CONST_commondisplay210);
			mvaddstrAlt(4, 30 + 40 * (i / 2), CONST_commondisplay211);
		}
		// Commited crimes are yellow
		if (cr.crimes_suspected[i] > 0)
			set_color_easy(YELLOW_ON_BLACK_BRIGHT);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(5 + i / 2, 40 * (i % 2), getlawflag(i) + CONST_commondisplay212);
		mvaddstr_f(5 + i / 2, 30 + 40 * (i % 2), CONST_commondisplay213.c_str(), cr.crimes_suspected[i]);
	}
	set_color_easy(WHITE_ON_BLACK);
}
/* full character sheet (with surrounding interface) */
void fullstatus(int p)
{
	const string CONST_commondisplay219 = "What is the new code name?                                                      ";
	const string CONST_commondisplay218 = "    UP/DOWN  - More Info";
	const string CONST_commondisplay217 = "Press any other key to continue the Struggle";
	const string CONST_commondisplay216 = "    LEFT/RIGHT - Other Liberals";
	const string CONST_commondisplay215 = "N - Change Code Name      G - Fix Gender Label";
	const string CONST_commondisplay214 = "Profile of a Liberal";
	extern squadst *activesquad;
	if (isThereNoActivesquad())return;
	const int pagenum = 3;
	int page = 0;
	while (true)
	{
		eraseAlt();
		set_color_easy(GREEN_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, CONST_commondisplay214);
		if (page == 0) printliberalstats(*activesquad->squad[p]);
		else if (page == 1) printliberalskills(*activesquad->squad[p]);
		else if (page == 2) printliberalcrimes(*activesquad->squad[p]);
		mvaddstrAlt(23, 0, CONST_commondisplay215);
		if (activesquad->squad[1] != NULL)
			addstrAlt(CONST_commondisplay216);
		mvaddstrAlt(24, 0, CONST_commondisplay217);
		addstrAlt(CONST_commondisplay218);
		int c = getkeyAlt();
		if (activesquad->squad[1] != NULL && ((c == KEY_LEFT) || (c == KEY_RIGHT)))
		{
			int sx = (c == KEY_LEFT) ? -1 : 1;
			do p = (p + 6 + sx) % 6; while (activesquad->squad[p] == NULL);
		}
		else if (c == KEY_DOWN)
		{
			page++;
			page %= pagenum;
		}
		else if (c == KEY_UP)
		{
			page--;
			if (page < 0) page = pagenum - 1;
			page %= pagenum;
		}
		else if (c == 'n')
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(23, 0, CONST_commondisplay219); // 80 characters
			mvaddstrAlt(24, 0, CONST_commondisplay220); // 80 spaces
			enter_name(24, 0, activesquad->squad[p]->name, CREATURE_NAMELEN, activesquad->squad[p]->propername);
		}
		else if (c == 'g')
		{
			activesquad->squad[p]->gender_liberal++;
			if (activesquad->squad[p]->gender_liberal > 2)
				activesquad->squad[p]->gender_liberal = 0;
		}
		else break;
	}
}

int addstr_f(const char * format, ...)
{
	char sbuf[81];
	va_list args;
	va_start(args, format);
	vsnprintf(sbuf, 81, format, args);
	va_end(args);
	return addstrAlt(sbuf);
}
/*	mvaddstr with formatted output	*/
int mvaddstr_f(int y, int x, const char * format, ...)
{
	char sbuf[81];
	va_list args;
	va_start(args, format);
	vsnprintf(sbuf, 81, format, args);
	va_end(args);
	return mvaddstrAlt(y, x, sbuf);
}
/*	addstr with formatted output and logging	*/
int addstr_fl(Log &log, const char * format, ...)
{
	char sbuf[81];
	va_list args;
	va_start(args, format);
	vsnprintf(sbuf, 81, format, args);
	va_end(args);
	return addstrAlt(sbuf, log);
}
/*	mvaddstr with formatted output and logging	*/
int mvaddstr_fl(int y, int x, Log &log, const char * format, ...)
{
	char sbuf[81];
	va_list args;
	va_start(args, format);
	vsnprintf(sbuf, 81, format, args);
	va_end(args);
	return mvaddstrAlt(y, x, sbuf, log);
}

//#include "includes.h"
const string CONST_configfile008 = "_Specials.csv";
const string CONST_configfile007 = "_Tiles.csv";
const string CONST_configfile006 = "mapCSV_Bank2_Tiles.csv";
const string CONST_configfile003 = "mapCSV_Bank_Tiles.csv";
const string CONST_configfile002 = "mapCSV_";
const string CONST_configfile001 = "OBJECT";
const string CONST_configfile000 = "Attempting to open filename: ";

string attemptingToOpenFile = CONST_configfile000;
std::ifstream* openFile(const std::string& filename, std::ios_base::openmode format)
{
	extern char artdir[MAX_PATH_SIZE];
	std::ifstream* file = new std::ifstream();
	addstrAlt(attemptingToOpenFile);
	addstrAlt(filename);
	addstrAlt(singleSpace);
	file->open((artdir + filename).c_str(), format);
	return file;
}
// Reads in an entire configuration file
// Returns true for read successful, returns false if failed read
int readConfigFile(const std::string& filename)
{
	std::string command, value;
	configurable* object = 0;
	std::ifstream* file = openFile(filename, ios::in);
	if (!file->is_open())
	{
		delete file;
		return false; // Unable to open; failed read
	}
	// loop through lines
	while (readLine(*file, command, value))
		// if COMMAND is OBJECT,
		// call a object creator factory, passing VALUE
		// (record pointer to that object)
		if (command == CONST_configfile001) object = createObject(value);
	// if I have an object,
	// pass COMMAND and VALUE to the object
		else if (object) object->configure(command, value);
		else
		{
			file->close();
			delete file;
			return false; // Unknown command and no object to give it to; failed read
		}
	file->close();
	delete file;
	return true;
}
// readLine reads a line from the file, parses it
int readLine(std::ifstream& file, std::string& command, std::string& value)
{
	std::string line;
	int source = 0;
	// Search for a non-comment, non-empty line
	do
	{
		if (file.eof()) return false;
		getline(file, line);
		line.erase(std::remove(line.begin(), line.end(), '\r'), line.end());
		line.erase(std::remove(line.begin(), line.end(), '\n'), line.end());
	} while (!len(line) || line[0] == '#');
	// Parse the line
	command.clear();
	value.clear();
	// Leading whitespace
	for (; source < len(line) && (line[source] == ' ' || line[source] == '\t'); source++);
	// Command
	for (; source < len(line) && (line[source] != ' '&&line[source] != '\t'); command.push_back(line[source++]));
	// Delimiting whitespace
	for (; source < len(line) && (line[source] == ' ' || line[source] == '\t'); source++);
	// Value
	for (; source < len(line) && (line[source] != ' '&&line[source] != '\t'); value.push_back(line[source++]));
	return true;
}
void readMapCBSpecials(int x, int y, int z, int i)
{
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	switch (i)
	{
	default:
	case 0: levelmap[x][y][z].special = SPECIAL_NONE; break;
	case 1: levelmap[x][y][z].special = SPECIAL_LAB_COSMETICS_CAGEDANIMALS; break;
	case 2: levelmap[x][y][z].special = SPECIAL_LAB_GENETIC_CAGEDANIMALS; break;
	case 3: levelmap[x][y][z].special = SPECIAL_POLICESTATION_LOCKUP; break;
	case 4: levelmap[x][y][z].special = SPECIAL_COURTHOUSE_LOCKUP; break;
	case 5: levelmap[x][y][z].special = SPECIAL_COURTHOUSE_JURYROOM; break;
	case 6: levelmap[x][y][z].special = SPECIAL_PRISON_CONTROL; break;
	case 7: levelmap[x][y][z].special = SPECIAL_PRISON_CONTROL_LOW; break;
	case 8: levelmap[x][y][z].special = SPECIAL_PRISON_CONTROL_MEDIUM; break;
	case 9: levelmap[x][y][z].special = SPECIAL_PRISON_CONTROL_HIGH; break;
	case 10: levelmap[x][y][z].special = SPECIAL_INTEL_SUPERCOMPUTER; break;
	case 11: levelmap[x][y][z].special = SPECIAL_SWEATSHOP_EQUIPMENT; break;
	case 12: levelmap[x][y][z].special = SPECIAL_POLLUTER_EQUIPMENT; break;
	case 13: levelmap[x][y][z].special = SPECIAL_NUCLEAR_ONOFF; break;
	case 14: levelmap[x][y][z].special = SPECIAL_HOUSE_PHOTOS; break;
	case 15: levelmap[x][y][z].special = SPECIAL_HOUSE_CEO; break;
	case 16: levelmap[x][y][z].special = SPECIAL_CORPORATE_FILES; break;
	case 17: levelmap[x][y][z].special = SPECIAL_RADIO_BROADCASTSTUDIO; break;
	case 18: levelmap[x][y][z].special = SPECIAL_NEWS_BROADCASTSTUDIO; break;
	case 19: levelmap[x][y][z].special = SPECIAL_APARTMENT_LANDLORD; break;
	case 20: levelmap[x][y][z].special = SPECIAL_SIGN_ONE; break;
	case 21: levelmap[x][y][z].special = SPECIAL_RESTAURANT_TABLE; break;
	case 22: levelmap[x][y][z].special = SPECIAL_CAFE_COMPUTER; break;
	case 23: levelmap[x][y][z].special = SPECIAL_PARK_BENCH; break;
	case 24: levelmap[x][y][z].special = SPECIAL_STAIRS_UP; break;
	case 25: levelmap[x][y][z].special = SPECIAL_STAIRS_DOWN; break;
	case 26: levelmap[x][y][z].special = SPECIAL_CLUB_BOUNCER; break;
	case 27: levelmap[x][y][z].special = SPECIAL_CLUB_BOUNCER_SECONDVISIT; break;
	case 28: levelmap[x][y][z].special = SPECIAL_ARMORY; break;
	case 29: levelmap[x][y][z].special = SPECIAL_DISPLAY_CASE; break;
	case 30: levelmap[x][y][z].special = SPECIAL_SIGN_TWO; break;
	case 31: levelmap[x][y][z].special = SPECIAL_SIGN_THREE; break;
	case 32: levelmap[x][y][z].special = SPECIAL_SECURITY_CHECKPOINT; break;
	case 33: levelmap[x][y][z].special = SPECIAL_SECURITY_METALDETECTORS; break;
	case 34: levelmap[x][y][z].special = SPECIAL_SECURITY_SECONDVISIT; break;
	case 35: levelmap[x][y][z].special = SPECIAL_BANK_VAULT; break;
	case 36: levelmap[x][y][z].special = SPECIAL_BANK_TELLER; break;
	case 37: levelmap[x][y][z].special = SPECIAL_BANK_MONEY; break;
	case 38: levelmap[x][y][z].special = SPECIAL_CCS_BOSS; break;
	case 39: levelmap[x][y][z].special = SPECIAL_OVAL_OFFICE_NW; break;
	case 40: levelmap[x][y][z].special = SPECIAL_OVAL_OFFICE_NE; break;
	case 41: levelmap[x][y][z].special = SPECIAL_OVAL_OFFICE_SW; break;
	case 42: levelmap[x][y][z].special = SPECIAL_OVAL_OFFICE_SE; break;
	}
}
void makeDoor(int x, int y, int z, int flags = 0)
{
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	levelmap[x][y][z].flag = SITEBLOCK_DOOR | flags;
	if ((x > 0 && (levelmap[x - 1][y][z].flag&SITEBLOCK_RESTRICTED)) ||
		(y > 0 && (levelmap[x][y - 1][z].flag&SITEBLOCK_RESTRICTED)))
		levelmap[x][y][z].flag |= SITEBLOCK_RESTRICTED;
}
void readMapCBTiles(int x, int y, int z, int i)
{
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	switch (i)
	{
	default:
	case 0: levelmap[x][y][z].flag = 0; break;
	case 2: levelmap[x][y][z].flag = SITEBLOCK_BLOCK; break;
	case 3: levelmap[x][y][z].flag = SITEBLOCK_EXIT; break;
	case 4: levelmap[x][y][z].flag = SITEBLOCK_GRASSY; break;
	case 5: makeDoor(x, y, z); break;
	case 6: makeDoor(x, y, z, SITEBLOCK_LOCKED); break;
	case 7:
		levelmap[x][y][z].flag = SITEBLOCK_RESTRICTED;
		if (x > 0 && (levelmap[x - 1][y][z].flag&SITEBLOCK_DOOR))
			levelmap[x - 1][y][z].flag |= SITEBLOCK_RESTRICTED;
		if (y > 0 && (levelmap[x][y - 1][z].flag&SITEBLOCK_DOOR))
			levelmap[x][y - 1][z].flag |= SITEBLOCK_RESTRICTED;
		break;
	case 8: levelmap[x][y][z].flag = SITEBLOCK_CHAINLINK; break;
	case 9: makeDoor(x, y, z, SITEBLOCK_LOCKED | SITEBLOCK_ALARMED); break;
	case 10: levelmap[x][y][z].flag = SITEBLOCK_BLOCK | SITEBLOCK_METAL; break;
	case 11: makeDoor(x, y, z, SITEBLOCK_LOCKED | SITEBLOCK_METAL); break;
	}
}
bool readMapFile(const string &filename, const int zLevel, void(*callback)(int, int, int, int))
{
	// open the file in question
	std::ifstream* file = openFile(filename, ios::in);
	// abort if the file couldn't be opened
	if (!file->is_open())
	{
		delete file;
		return false;
	}
	for (int y = 0, z = zLevel; !file->eof(); y++)
	{
		std::string line;
		getline(*file, line);
		line.erase(std::remove(line.begin(), line.end(), '\r'), line.end());
		line.erase(std::remove(line.begin(), line.end(), '\n'), line.end());
		for (int x = 0, i = 0, j = 0; j < len(line); x++, i = ++j)
		{
			for (; j < len(line) && line[j] != ','; j++);
			if (j < len(line))
			{
				line[j] = 0;
				(*callback)(x, y, z, atoi(line.substr(i).c_str()));
			}
		}
	}
	file->close();
	delete file;
	return true;
}
bool readMap(const std::string& filename)
{
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	std::string prefix = std::string(CONST_configfile002);
	// clear any old map data
	for (int x = 0; x < MAPX; x++)
		for (int y = 0; y < MAPY; y++)
			for (int z = 0; z < MAPZ; z++)
			{
				levelmap[x][y][z].flag = 0;
				levelmap[x][y][z].special = SPECIAL_NONE;
				levelmap[x][y][z].siegeflag = 0;
			}
	// Try first floor (eg CONST_configfile003), abort this method if it doesn't exist
	if (!readMapFile(prefix + filename + CONST_configfile007, 0, readMapCBTiles)) return false;
	if (!readMapFile(prefix + filename + CONST_configfile008, 0, readMapCBSpecials)) return false;
	// Try upper levels (eg CONST_configfile006), but don't sweat it if they don't exist
	for (int z = 1; z < MAPZ; z++)
	{
		std::string str = tostring(z + 1);
		if (!readMapFile(prefix + filename + str + CONST_configfile007, z, readMapCBTiles)) break;
		if (!readMapFile(prefix + filename + str + CONST_configfile008, z, readMapCBSpecials)) break;
	}
	return true;
}


// #include "../includes.h"
const string CONST_creatureD162 = "z";

const string CONST_creatureC161 = "x";

const string CONST_creatureB162 = "/";
const string CONST_creatureB161 = "selves";
const string CONST_creatureB160 = "them";
const string CONST_creatureB159 = "her";
const string CONST_creatureB158 = "themself";
const string CONST_creatureB157 = "hers";
const string CONST_creatureB154 = "heANDshe";
const string CONST_creatureB153 = "xyr";
const string CONST_creatureB066 = "xem";
const string CONST_creature151 = "?";
const string CONST_creature150 = ", Ambiguous";
const string CONST_creature149 = ", Female";
const string CONST_creature148 = ", Male";
const string CONST_creature147 = "Very Old";
const string CONST_creature146 = "80s";
const string CONST_creature145 = "70s";
const string CONST_creature144 = "60s";
const string CONST_creature143 = "50s";
const string CONST_creature142 = "40s";
const string CONST_creature141 = "30s";
const string CONST_creature140 = "20s";
const string CONST_creature138 = " (";
const string CONST_creature137 = " (?)";
const string CONST_creature136 = "None";
const string CONST_creature135 = " (0/";
const string CONST_creature134 = " (1/";
const string CONST_creature132 = "self";
const string CONST_creature131 = "xemself";
const string CONST_creature130 = "Xem";
const string CONST_creature129 = "Her";
const string CONST_creature128 = "Him";
const string CONST_creature127 = "s";
const string CONST_creature126 = "xyrs";
const string CONST_creature125 = "Xyr";
const string CONST_creature123 = "His";
const string CONST_creature122 = "zemself";
const string CONST_creature121 = "zurz";
const string CONST_creature120 = "zem";
const string CONST_creature119 = "zur";
const string CONST_creature118 = "zee";
const string CONST_creature117 = "xe";
const string CONST_creature116 = "Xe";
const string CONST_creature115 = "She";
const string CONST_creature114 = "He";
const string CONST_creature113 = "President ";
const string CONST_creature112 = "CCS Heavy";
const string CONST_creature111 = "Soldier";
const string CONST_creature110 = "Elite Security";
const string CONST_creature109 = "Enlightened Judge";
const string CONST_creature108 = "New Union Worker";
const string CONST_creature107 = "Jaded Liberal Judge";
const string CONST_creature106 = "Ex-Union Worker";
const string CONST_creature105 = ", IMPOSSIBLE";
const string CONST_creature104 = ", Difficulty ";
const string CONST_creature103 = " SkillCheck(";
const string CONST_creature102 = ", Outcome of ";
const string CONST_creature101 = "Adjusted Attribute Value ";
const string CONST_creature100 = "automatic failure";
const string CONST_creature099 = ", Skill Value ";
const string CONST_creature098 = " SkillRoll(";
const string CONST_creature097 = "-=ILLEGAL SKILL ROLL=-";
const string CONST_creature094 = " AttributeCheck(";
const string CONST_creature092 = ", Attribute Level ";
const string CONST_creature091 = " AttributeRoll(";
const string CONST_creature090 = "%f";
const string CONST_creature089 = "Scruffy";
const string CONST_creature087 = "CREATURE_WORKER_JANITOR";
const string CONST_creature086 = "ccs_covername_other.txt";
const string CONST_creature085 = "ccs_covername_shotgun.txt";
const string CONST_creatureX01 = "he";
const string CONST_creatureX02 = "she";
const string CONST_creatureX03 = "his";
const string CONST_creatureX04 = "her";
const string CONST_creatureX05 = "xyr";
const string CONST_creatureX06 = "him";
const string CONST_creatureX07 = "xem";

const string tag_ARMOR_NONE = "ARMOR_NONE";
const string tag_WEAPON_NONE = "WEAPON_NONE";
const string tag_Pres = "Pres";
const string tag_Pres_state = "Pres_state";
const string tag_Pres_ID = "Pres_ID";
const string tag_CEO = "CEO";
const string tag_CEO_state = "CEO_state";
const string tag_CEO_ID = "CEO_ID";
const string tag_uniquecreatures = "uniquecreatures";
const string tag_reports_to_police = "reports_to_police";
const string tag_kidnap_resistant = "kidnap_resistant";
const string tag_talkreceptive = "talkreceptive";
const string tag_seethroughstealth = "seethroughstealth";
const string tag_seethroughdisguise = "seethroughdisguise";
const string tag_dontname = "dontname";
const string tag_flag = "flag";
const string tag_pref_is_driver = "pref_is_driver";
const string tag_pref_carid = "pref_carid";
const string tag_is_driver = "is_driver";
const string tag_carid = "carid";
const string tag_arg = "arg";
const string tag_arg2 = "arg2";
const string tag_activity = "activity";
const string tag_cantbluff = "cantbluff";
const string tag_worklocation = "worklocation";
const string tag_location = "location";
const string tag_crimes_suspected = "crimes_suspected";
const string tag_special = "special";
const string tag_wound = "wound";
const string tag_income = "income";
const string tag_juice = "juice";
const string tag_money = "money";
const string tag_has_thrown_weapon = "has_thrown_weapon";
const string tag_stunned = "stunned";
const string tag_forceinc = "forceinc";
const string tag_meetings = "meetings";
const string tag_hireid = "hireid";
const string tag_deathdays = "deathdays";
const string tag_joindays = "joindays";
const string tag_deathpenalty = "deathpenalty";
const string tag_confessions = "confessions";
const string tag_sentence = "sentence";
const string tag_prisoner = "prisoner";
const string tag_trainingsubject = "trainingsubject";
const string tag_trainingtime = "trainingtime";
const string tag_hiding = "hiding";
const string tag_dating = "dating";
const string tag_clinic = "clinic";
const string tag_specialattack = "specialattack";
const string tag_animalgloss = "animalgloss";
const string tag_infiltration = "infiltration";
const string tag_type_idname = "type_idname";
const string tag_alive = "alive";
const string tag_align = "align";
const string tag_exists = "exists";
const string tag_birthday_day = "birthday_day";
const string tag_birthday_month = "birthday_month";
const string tag_age = "age";
const string tag_squadid = "squadid";
const string tag_gender = "gender";
const string tag_gender_liberal = "gender_liberal";
const string tag_gender_conservative = "gender_conservative";
const string tag_propername = "propername";
const string tag_skill_experience = "skill_experience";
const string tag_creature = "creature";

//// #include "../common/stringconversion.h"
string attribute_enum_to_string(int attribute);
/* politics -- promotes the Vice President to President, and replaces VP */
void promoteVP();
vector<string> ccs_covername_shotgun;
vector<string> ccs_covername_other;
const string creature = "creature\\";
vector<file_and_text_collection> creature_text_file_collection = {
	/*creature.cpp*/
	customText(&ccs_covername_shotgun, creature + CONST_creature085),
	customText(&ccs_covername_other, creature + CONST_creature086),
};
//extern string commaSpace;
Creature& Creature::operator=(const Creature& rhs)
{
	if (this != &rhs)
	{
		delete weapon;
		delete armor;
		delete_and_clear(clips);
		delete_and_clear(extra_throwing_weapons);
		copy(rhs);
	}
	return *this;
}
int Creature::get_disguise_difficulty() {
	return seethroughdisguise;
}
int	Creature::get_stealth_difficulty() {
	return seethroughstealth;
}
void Creature::copy(const Creature& org)
{
	for (int i = 0; i < ATTNUM; i++)
		attributes[i] = org.attributes[i];
	for (int i = 0; i < SKILLNUM; i++)
	{
		skills[i] = org.skills[i];
		skill_experience[i] = org.skill_experience[i];
	}
	for (int i = 0; i < BODYPARTNUM; i++)
		wound[i] = org.wound[i];
	for (int i = 0; i < SPECIALWOUNDNUM; i++)
		special[i] = org.special[i];
	for (int i = 0; i < LAWFLAGNUM; i++)
		crimes_suspected[i] = org.crimes_suspected[i];
	if (org.weapon) weapon = new Weapon(*org.weapon);
	else weapon = NULL;
	if (org.armor) armor = new Armor(*org.armor);
	else armor = NULL;
	for (int i = 0; i < len(org.extra_throwing_weapons); i++)
		extra_throwing_weapons.push_back(new Weapon(*org.extra_throwing_weapons[i]));
	for (int i = 0; i < len(org.clips); i++)
		clips.push_back(new Clip(*org.clips[i]));
	strcpy(name, org.name);
	strcpy(propername, org.propername);
	gender_conservative = org.gender_conservative;
	gender_liberal = org.gender_liberal;
	squadid = org.squadid;
	age = org.age;
	birthday_month = org.birthday_month;
	birthday_day = org.birthday_day;
	exists = org.exists;
	align = org.align;
	alive = org.alive;
	type = org.type;
	type_idname = org.type_idname;
	infiltration = org.infiltration;
	animalgloss = org.animalgloss;
	specialattack = org.specialattack;
	clinic = org.clinic;
	dating = org.dating;
	hiding = org.hiding;
	trainingtime = org.trainingtime;
	trainingsubject = org.trainingsubject;
	sentence = org.sentence;
	confessions = org.confessions;
	deathpenalty = org.deathpenalty;
	joindays = org.joindays;
	deathdays = org.deathdays;
	id = org.id;
	hireid = org.hireid;
	meetings = org.meetings;
	forceinc = org.forceinc;
	stunned = org.stunned;
	has_thrown_weapon = org.has_thrown_weapon;
	money = org.money;
	juice = org.juice;
	income = org.income;
	blood = org.blood;
	heat = org.heat;
	location = org.location;
	worklocation = org.worklocation;
	cantbluff = org.cantbluff;
	base = org.base;
	activity = org.activity;
	carid = org.carid;
	is_driver = org.is_driver;
	pref_carid = org.pref_carid;
	pref_is_driver = org.pref_is_driver;
	flag = org.flag;
	dontname = org.dontname;
	prisoner = NULL; //Not copying prisoner.
	seethroughdisguise = org.seethroughdisguise;
	seethroughstealth = org.seethroughstealth;
	istalkreceptive = org.istalkreceptive;
	iskidnap_resistant = org.iskidnap_resistant;
	isreports_to_police = org.isreports_to_police;
}
bool Creature::kidnap_resistant() const
{
	return iskidnap_resistant;
}
bool Creature::reports_to_police() const
{
	return isreports_to_police;
}
bool Creature::is_lcs_sleeper() const
{
	return(alive && align == ALIGN_LIBERAL && clinic == 0 &&
		dating == 0 && hiding == 0 && (flag & CREATUREFLAG_SLEEPER));
}
bool Creature::canwalk() const
{
	if (!alive) return false;
	if ((wound[BODYPART_LEG_RIGHT] & (WOUND_NASTYOFF | WOUND_CLEANOFF))
		&& (wound[BODYPART_LEG_LEFT] & (WOUND_NASTYOFF | WOUND_CLEANOFF))) return false;
	if (special[SPECIALWOUND_NECK] != 1 ||
		special[SPECIALWOUND_UPPERSPINE] != 1 ||
		special[SPECIALWOUND_LOWERSPINE] != 1) return false;
	return true;
}
void Creature::creatureinit()
{
	extern long curcreatureid;
	dontname = false;
	hireid = -1;
	worklocation = 0;
	juice = 0;
	flag = 0;
	age = 18 + LCSrandom(40);
	gender_liberal = gender_conservative = LCSrandom(2) + 1;
	birthday_month = LCSrandom(12) + 1;
	switch (birthday_month)
	{
	case 4:
	case 6:
	case 9:
	case 11:
		birthday_day = LCSrandom(30) + 1;
		break;
	case 2:
		birthday_day = LCSrandom(28) + 1;  //TODO Allow birthday to be leap year
		break;
	default:
		birthday_day = LCSrandom(31) + 1;
		break;
	}
	carid = -1;
	is_driver = 0;
	pref_carid = -1;
	pref_is_driver = 0;
	id = curcreatureid++;
	joindays = 0;
	deathdays = 0;
	squadid = -1;
	cantbluff = 0;
	location = 0;
	base = 0;
	activity.type = ACTIVITY_NONE;
	for (int i = 0; i < LAWFLAGNUM; i++)
		crimes_suspected[i] = 0;
	heat = 0;
	confessions = 0;
	clinic = 0;
	dating = 0;
	hiding = 0;
	trainingtime = 0;
	trainingsubject = -1;
	specialattack = -1;
	animalgloss = ANIMALGLOSS_NONE;
	prisoner = NULL;
	alive = true;
	blood = 100;
	stunned = 0;
	for (int w = 0; w < BODYPARTNUM; w++)wound[w] = 0;
	weapon = NULL;
	has_thrown_weapon = false;
	armor = NULL;//new Armor(*armortype[getarmortype(tag_ARMOR_CLOTHES)]); //Causes crash for global uniqueCreature -XML
	for (int a = 0; a < ATTNUM; a++)
	{
		//attributes[a].set_type(a);
		attributes[a] = 1;
	}
	int attnum = 32;
	while (attnum > 0)
	{
		int a = LCSrandom(ATTNUM);
		if (attributes[a] < 10)
		{
			attributes[a]++;
			attnum--;
		}
	}
	for (int s = 0; s < SKILLNUM; s++)
	{
		//skills[s].set_type(s);
		skills[s] = 0;
		skill_experience[s] = 0;
	}
	special[SPECIALWOUND_TEETH] = TOOTHNUM;
	special[SPECIALWOUND_RIGHTEYE] = 1;
	special[SPECIALWOUND_LEFTEYE] = 1;
	special[SPECIALWOUND_NOSE] = 1;
	special[SPECIALWOUND_TONGUE] = 1;
	special[SPECIALWOUND_RIGHTLUNG] = 1;
	special[SPECIALWOUND_LEFTLUNG] = 1;
	special[SPECIALWOUND_HEART] = 1;
	special[SPECIALWOUND_LIVER] = 1;
	special[SPECIALWOUND_STOMACH] = 1;
	special[SPECIALWOUND_RIGHTKIDNEY] = 1;
	special[SPECIALWOUND_LEFTKIDNEY] = 1;
	special[SPECIALWOUND_SPLEEN] = 1;
	special[SPECIALWOUND_RIBS] = RIBNUM;
	special[SPECIALWOUND_NECK] = 1;
	special[SPECIALWOUND_UPPERSPINE] = 1;
	special[SPECIALWOUND_LOWERSPINE] = 1;
	seethroughstealth = 3;
	seethroughdisguise = 3;
	istalkreceptive = 0;
	iskidnap_resistant = 0;
	isreports_to_police = 0;
	forceinc = 0;
	sentence = 0;
	deathpenalty = 0;
	money = 0;
	income = 0;
	exists = true;
	vector<int> randomAlignments = { Alignment::ALIGN_CONSERVATIVE, Alignment::ALIGN_MODERATE, Alignment::ALIGN_LIBERAL };
	align = pickrandom(randomAlignments);
	infiltration = 0.0f;
	type = CREATURE_WORKER_JANITOR;
	type_idname = CONST_creature087;
	meetings = 0;
	strcpy(name, CONST_creature089.c_str());
	strcpy(propername, CONST_creature089.c_str());
}
Creature::Creature(const std::string& inputXml)
	: weapon(NULL), armor(NULL), prisoner(NULL)
{
	map<string, char *> creature_XML_Chars = {
		map<string, char *>::value_type(tag_gender_conservative, &gender_conservative),
		map<string, char *>::value_type(tag_gender_liberal, &gender_liberal),
		map<string, char *>::value_type(tag_animalgloss, &animalgloss),
		map<string, char *>::value_type(tag_confessions, &confessions),
		map<string, char *>::value_type(tag_deathpenalty, &deathpenalty),
		map<string, char *>::value_type(tag_forceinc, &forceinc),
		map<string, char *>::value_type(tag_cantbluff, &cantbluff),
		map<string, char *>::value_type(tag_is_driver, &is_driver),
		map<string, char *>::value_type(tag_pref_is_driver, &pref_is_driver),
	};
	map<string, int *> creature_XML_Integers = {
		map<string, int *>::value_type(tag_flag, &flag),
		map<string, int *>::value_type(tag_seethroughdisguise, &seethroughdisguise),
		map<string, int *>::value_type(tag_seethroughstealth, &seethroughstealth),
		map<string, int *>::value_type(tag_pref_carid, &pref_carid),
		map<string, int *>::value_type(tag_base, &base),
		map<string, int *>::value_type(tag_carid, &carid),
		map<string, int *>::value_type(tag_stunned, &stunned),
		map<string, int *>::value_type(tag_money, &money),
		map<string, int *>::value_type(tag_juice, &juice),
		map<string, int *>::value_type(tag_income, &income),
		map<string, int *>::value_type(tag_blood, &blood),
		map<string, int *>::value_type(tag_heat, &heat),
		map<string, int *>::value_type(tag_location, &location),
		map<string, int *>::value_type(tag_worklocation, &worklocation),
		map<string, int *>::value_type(tag_squadid, &squadid),
		map<string, int *>::value_type(tag_age, &age),
		map<string, int *>::value_type(tag_birthday_month, &birthday_month),
		map<string, int *>::value_type(tag_birthday_day, &birthday_day),
		map<string, int *>::value_type(tag_align, &align),
		map<string, int *>::value_type(tag_type, &type),
		map<string, int *>::value_type(tag_specialattack, &specialattack),
		map<string, int *>::value_type(tag_clinic, &clinic),
		map<string, int *>::value_type(tag_dating, &dating),
		map<string, int *>::value_type(tag_hiding, &hiding),
		map<string, int *>::value_type(tag_trainingtime, &trainingtime),
		map<string, int *>::value_type(tag_trainingsubject, &trainingsubject),
		map<string, int *>::value_type(tag_sentence, &sentence),
		map<string, int *>::value_type(tag_joindays, &joindays),
		map<string, int *>::value_type(tag_deathdays, &deathdays),
		map<string, int *>::value_type(tag_id, &id),
		map<string, int *>::value_type(tag_hireid, &hireid),
		map<string, int *>::value_type(tag_meetings, &meetings),
	};
	map<string, bool *> creature_XML_Bools = {
		map<string, bool *>::value_type(tag_alive, &alive),
		map<string, bool *>::value_type(tag_exists, &exists),
		map<string, bool *>::value_type(tag_has_thrown_weapon, &has_thrown_weapon),
		map<string, bool *>::value_type(tag_dontname, &dontname),
		map<string, bool *>::value_type(tag_talkreceptive, &istalkreceptive),
		map<string, bool *>::value_type(tag_kidnap_resistant, &iskidnap_resistant),
		map<string, bool *>::value_type(tag_reports_to_police, &isreports_to_police),
	};
	CMarkup xml;
	xml.SetDoc(inputXml);
	xml.FindElem();
	xml.IntoElem();
	int attributesi = 0, skillsi = 0, skill_experiencei = 0, woundi = 0, speciali = 0, crimesi = 0, augi = 0;
	while (xml.FindElem())
	{
		std::string tag = xml.GetTagName();
		if (creature_XML_Integers.count(tag)) {
			*creature_XML_Integers[tag] = atoi(xml.GetData().c_str());
		}
		else if (creature_XML_Chars.count(tag)) {
			*creature_XML_Chars[tag] = atoi(xml.GetData().c_str());
		}
		else if (creature_XML_Bools.count(tag)) {
			*creature_XML_Bools[tag] = atoi(xml.GetData().c_str());
		}
		else if (tag == tag_attribute && attributesi < ATTNUM)
			attributes[attributesi++] = get_XML_value(xml.GetSubDoc());
		else if (tag == tag_skill && skillsi < SKILLNUM)
			skills[skillsi++] = get_XML_value(xml.GetSubDoc());
		else if (tag == tag_skill_experience && skill_experiencei < SKILLNUM)
			skill_experience[skill_experiencei++] = atoi(xml.GetData().c_str());
		else if (tag == tag_weapon)
		{
			Weapon w(xml.GetSubDoc());
			if (getweapontype(w.get_itemtypename()) != -1) //Check weapon is a valid type.
				give_weapon(w, NULL);
		}
		else if (tag == tag_armor)
		{
			armor = new Armor(xml.GetSubDoc());
			if (getarmortype(armor->get_itemtypename()) == -1) //Check armor is a valid type.
				delete_and_nullify(armor);
		}
		else if (tag == tag_augmentation)
			augmentations[augi++] = Augmentation(xml.GetSubDoc());
		else if (tag == tag_name)
			strcpy(name, xml.GetData().c_str());
		else if (tag == tag_propername)
			strcpy(propername, xml.GetData().c_str());
		else if (tag == tag_type_idname)
			type_idname = xml.GetData();
		else if (tag == tag_infiltration)
			infiltration = atof(xml.GetData().c_str());
		else if (tag == tag_prisoner)
		{
			xml.IntoElem();
			prisoner = new Creature(xml.GetSubDoc());
			xml.OutOfElem();
		}
		else if (tag == tag_clip)
		{
			Clip* c = new Clip(xml.GetSubDoc());
			if (getcliptype(c->get_itemtypename()) != -1)
				clips.push_back(c);
			else
				delete c;
		}
		else if (tag == tag_activity)
		{
			xml.IntoElem();
			while (xml.FindElem())
			{
				tag = xml.GetTagName();
				if (tag == tag_type)
					activity.type = atoi(xml.GetData().c_str());
				else if (tag == tag_arg)
					activity.arg = atoi(xml.GetData().c_str());
				else if (tag == tag_arg2)
					activity.arg2 = atoi(xml.GetData().c_str());
			}
			xml.OutOfElem();
		}
		else if (tag == tag_wound && woundi < BODYPARTNUM)
			wound[woundi++] = atoi(xml.GetData().c_str());
		else if (tag == tag_special && speciali < SPECIALWOUNDNUM)
			special[speciali++] = atoi(xml.GetData().c_str());
		else if (tag == tag_crimes_suspected && crimesi < LAWFLAGNUM)
			crimes_suspected[crimesi++] = atoi(xml.GetData().c_str());
	}
}
//extern string closeParenthesis;
string Creature::showXml() const
{
	CMarkup xml;
	xml.AddElem(tag_creature);
	xml.IntoElem();
	for (int i = 0; i < ATTNUM; i++)
		xml.AddSubDoc(showXmlAttribute(i, attributes[i]));
	for (int i = 0; i < SKILLNUM; i++)
		xml.AddSubDoc(showXmlSkill(i, skills[i]));
	for (int i = 0; i < SKILLNUM; i++)
		xml.AddElem(tag_skill_experience, skill_experience[i]); //Bad, relies on their order in the xml file. -XML 
	if (weapon) xml.AddSubDoc(weapon->showXml());
	if (armor) xml.AddSubDoc(armor->showXml());
	for (const auto &aug : augmentations)
		xml.AddSubDoc(aug.showXml());
	xml.AddElem(tag_name, name);
	xml.AddElem(tag_propername, propername);
	xml.AddElem(tag_gender_conservative, gender_conservative);
	xml.AddElem(tag_gender_liberal, gender_liberal);
	xml.AddElem(tag_squadid, squadid);
	xml.AddElem(tag_age, age);
	xml.AddElem(tag_birthday_month, birthday_month);
	xml.AddElem(tag_birthday_day, birthday_day);
	xml.AddElem(tag_exists, exists);
	xml.AddElem(tag_align, align);
	xml.AddElem(tag_alive, alive);
	xml.AddElem(tag_type, type);
	xml.AddElem(tag_type_idname, type_idname);
	char buf[256];
	snprintf(buf, 255, CONST_creature090.c_str(), infiltration);
	xml.AddElem(tag_infiltration, buf);
	xml.AddElem(tag_animalgloss, animalgloss);
	xml.AddElem(tag_specialattack, specialattack);
	xml.AddElem(tag_clinic, clinic);
	xml.AddElem(tag_dating, dating);
	xml.AddElem(tag_hiding, hiding);
	xml.AddElem(tag_trainingtime, trainingtime);
	xml.AddElem(tag_trainingsubject, trainingsubject);
	if (prisoner) //Should never be true when saving.
	{
		xml.AddElem(tag_prisoner);
		xml.IntoElem();
		xml.AddSubDoc(prisoner->showXml());
		xml.OutOfElem();
	}
	xml.AddElem(tag_sentence, sentence);
	xml.AddElem(tag_confessions, confessions);
	xml.AddElem(tag_deathpenalty, deathpenalty);
	xml.AddElem(tag_joindays, joindays);
	xml.AddElem(tag_deathdays, deathdays);
	xml.AddElem(tag_id, id);
	xml.AddElem(tag_hireid, hireid);
	xml.AddElem(tag_meetings, meetings);
	xml.AddElem(tag_forceinc, forceinc);
	xml.AddElem(tag_stunned, stunned);
	for (int i = 0; i < len(extra_throwing_weapons); i++)
		xml.AddSubDoc(extra_throwing_weapons[i]->showXml());
	for (int i = 0; i < len(clips); i++)
		xml.AddSubDoc(clips[i]->showXml());
	xml.AddElem(tag_has_thrown_weapon, has_thrown_weapon);
	xml.AddElem(tag_money, money);
	xml.AddElem(tag_juice, juice);
	xml.AddElem(tag_income, income);
	for (int i = 0; i < BODYPARTNUM; i++) //Bad, relies on their order in the xml file. -XML
		xml.AddElem(tag_wound, wound[i]);
	xml.AddElem(tag_blood, blood);
	for (int i = 0; i < SPECIALWOUNDNUM; i++) //Bad, relies on their order in the xml file. -XML
		xml.AddElem(tag_special, special[i]);
	for (int i = 0; i < LAWFLAGNUM; i++) //Bad, relies on their order in the xml file. -XML
		xml.AddElem(tag_crimes_suspected, crimes_suspected[i]);
	xml.AddElem(tag_heat, heat);
	xml.AddElem(tag_location, location);
	xml.AddElem(tag_worklocation, worklocation);
	xml.AddElem(tag_cantbluff, cantbluff);
	xml.AddElem(tag_base, base);
	xml.AddElem(tag_activity);
	xml.IntoElem();
	xml.AddElem(tag_type, activity.type);
	xml.AddElem(tag_arg, activity.arg);
	xml.AddElem(tag_arg2, activity.arg2);
	xml.OutOfElem();
	xml.AddElem(tag_carid, carid);
	xml.AddElem(tag_is_driver, is_driver);
	xml.AddElem(tag_pref_carid, pref_carid);
	xml.AddElem(tag_pref_is_driver, pref_is_driver);
	xml.AddElem(tag_flag, flag);
	xml.AddElem(tag_dontname, dontname);
	xml.AddElem(tag_seethroughdisguise, seethroughdisguise);
	xml.AddElem(tag_seethroughstealth, seethroughdisguise);
	xml.AddElem(tag_talkreceptive, istalkreceptive);
	xml.AddElem(tag_kidnap_resistant, iskidnap_resistant);
	xml.AddElem(tag_reports_to_police, isreports_to_police);
	return xml.GetDoc();
}
int Creature::get_true_attribute(int attribute) const {
	return attributes[attribute];
}
int Creature::get_attribute(int attribute, bool usejuice) const
{
	int ret = attributes[attribute];
	// Special modifications to attributes based on age
	switch (attribute)
	{
	case ATTRIBUTE_STRENGTH:
		if (age < 11)ret >>= 1;     // Strength is lowest at the beginning and end of life
		else if (age < 16)ret -= 1;
		else if (age > 70)ret -= 6;
		else if (age > 52)ret -= 3;
		else if (age > 35)ret -= 1;
		break;
	case ATTRIBUTE_AGILITY:
		if (age > 70)ret -= 6;      // Agility is weakened with age
		else if (age > 52)ret -= 3;
		else if (age > 35)ret -= 1;
		break;
	case ATTRIBUTE_HEALTH:
		if (age < 11)ret -= 2;
		else if (age < 16)ret -= 1; // Physical immaturity weakens health
									// Aging actually damages base health and eventually kills, so no aging effects here
		break;
	case ATTRIBUTE_CHARISMA:
		if (age < 11)ret += 2;      // Lots of folks like kids
		else if (age < 16)ret -= 1; // Teenagers have communication difficulties and image issues
		else if (age > 70)ret += 3; // Authority and experience in life then enhance Charisma with age
		else if (age > 52)ret += 2;
		else if (age > 35)ret += 1;
		break;
	case ATTRIBUTE_INTELLIGENCE:
		if (age < 11)ret -= 3;      // Experience enhances Intelligence with age
		else if (age < 16)ret -= 1;
		else if (age > 70)ret += 3;
		else if (age > 52)ret += 2;
		else if (age > 35)ret += 1;
		break;
	case ATTRIBUTE_WISDOM:
		if (age < 11)ret -= 2;      // Experience grants Wisdom with age
		else if (age < 16)ret -= 1;
		else if (age > 70)ret += 2;
		else if (age > 52)ret += 1;
		break;
	case ATTRIBUTE_HEART:
		if (age < 11)ret += 2;      // Experience saps Heart with age due to cynicism
		else if (age < 16)ret += 1; // No wonder it's typically the young who are most Liberal...
		else if (age > 70)ret -= 2;
		else if (age > 52)ret -= 1;
		break;
	}
	// Physical stats want to know: Are you paralyzed?
	if (attribute == ATTRIBUTE_STRENGTH ||
		attribute == ATTRIBUTE_AGILITY ||
		attribute == ATTRIBUTE_HEALTH)
	{
		if (special[SPECIALWOUND_NECK] != 1 ||
			special[SPECIALWOUND_UPPERSPINE] != 1)
			ret = 1;
		else if (special[SPECIALWOUND_LOWERSPINE] != 1)ret >>= 2;
	}
	// Agility wants to know: Do you have legs?
	if (attribute == ATTRIBUTE_AGILITY)
	{
		int legok = 2;
		if ((wound[BODYPART_LEG_RIGHT] & WOUND_NASTYOFF) ||
			(wound[BODYPART_LEG_RIGHT] & WOUND_CLEANOFF))legok--;
		if ((wound[BODYPART_LEG_LEFT] & WOUND_NASTYOFF) ||
			(wound[BODYPART_LEG_LEFT] & WOUND_CLEANOFF))legok--;
		if (legok == 0)ret >>= 2;
		else if (legok == 1)ret >>= 1;
	}
	// Charisma wants to know: How fucked up does your face look?
	if (attribute == ATTRIBUTE_CHARISMA)
	{
		long disfigs = 0;
		if (special[SPECIALWOUND_TEETH] < TOOTHNUM)disfigs++;
		if (special[SPECIALWOUND_TEETH] < TOOTHNUM / 2)disfigs++;
		if (special[SPECIALWOUND_TEETH] == 0)disfigs++;
		if (special[SPECIALWOUND_RIGHTEYE] == 0)disfigs += 2;
		if (special[SPECIALWOUND_LEFTEYE] == 0)disfigs += 2;
		if (special[SPECIALWOUND_TONGUE] == 0)disfigs += 3;
		if (special[SPECIALWOUND_NOSE] == 0)disfigs += 3;
		ret -= disfigs;
	}
	// Finish now if not using juice to avoid bounds check.
	if (!usejuice)return ret;
	// Never use juice to increase stats for the opposite ideology!
	if (attribute == ATTRIBUTE_WISDOM && align != ALIGN_CONSERVATIVE)usejuice = false;
	if (attribute == ATTRIBUTE_HEART && align != ALIGN_LIBERAL)usejuice = false;
	// Effects of juice on the character's attributes
	if (usejuice)
	{
		if (juice <= -50)ret = 1; // Damn worthless
		else if (juice <= -10)ret = static_cast<int>(ret*0.6); // Society's dregs
		else if (juice < 0)ret = static_cast<int>(ret*0.8);    // Punk
		else if (juice >= 10)
		{
			if (juice < 50)ret += 1; // Activist
			else if (juice < 100)ret = static_cast<int>(ret*1.1 + 2); // Socialist Threat
			else if (juice < 200)ret = static_cast<int>(ret*1.2 + 3); // Revolutionary
			else if (juice < 500)ret = static_cast<int>(ret*1.3 + 4); // Urban Guerrilla
			else if (juice < 1000)ret = static_cast<int>(ret*1.4 + 5); // Liberal Guardian
			else ret = static_cast<int>(ret*1.5 + 6); // Elite Liberal
		}
		// Debilitations for temporary injuries in attributes based
		// on physical appearance or performance, because people who
		// are bleeding all over are less strong, agile, and charismatic
		// it is also hard to think when you are in severe pain
		if (attribute == ATTRIBUTE_STRENGTH ||
			attribute == ATTRIBUTE_AGILITY ||
			attribute == ATTRIBUTE_CHARISMA ||
			attribute == ATTRIBUTE_INTELLIGENCE)
		{
			//         if(blood<=20)ret>>=2;
			//         else if(blood<=50){ret>>=1;}
			//         else if(blood<=75){ret*=3;ret>>=2;}
			ret = (int)((0.5 + (float)ret)*(float)blood / 100.0);
		}
	}
	// Bounds check attributes
	if (ret < 1) ret = 1;
	if (ret > MAXATTRIBUTE) ret = MAXATTRIBUTE;
	return ret;
}
int Creature::roll_check(int skill)
{
	// This die rolling system (and the associated difficulty
	// ratings) is adapted from EABA, which uses a system of
	// rolling a number of six-sided dice equal to the ability
	// score divided by three. The top three dice are used,
	// the rest discarded. Finally, any additional points that
	// didn't divide evenly into creating a die contribute to
	// odd-shaped dice that don't exist in the real world. This
	// system gives diminishing returns for high skill levels.
	// EABA actually just adds the remainder to the die total,
	// but there are some statistical problems with that system.
	// It is not possible to roll above an 18 using this system.
	// It is possible to roll below a 3, if you don't have at
	// least 9 skill.
	int dice = skill / 3;
	int total = 0;
	int roll[3] = { 0,0,0 };
	for (int i = 0; i < dice + 1; i++)
	{
		int newroll = 0;
		// Roll d6 for every three skill
		if (i < dice)
			newroll = LCSrandom(6) + 1;
		// Partial dice for the remainder -- d3 for +1, d5 for +2
		else if (skill % 3)
			newroll = LCSrandom((skill % 3) * 2 + 1) + 1;
		// Keep the top three dice
		if (i < 3)
			roll[i] = newroll;
		else
			for (int j = 0; j < 3; j++)
				if (newroll > roll[j])
				{
					int temp = roll[j];
					roll[j] = newroll;
					newroll = temp;
				}
	}
	for (int i = 0; i < 3; i++)
		total += roll[i];
	return total;
}
int Creature::attribute_roll(int attribute) const
{
	// Show die rolls, 100% accurate poll numbers
	extern bool SHOWMECHANICS;
	int return_value = roll_check(get_attribute(attribute, true));
	if (SHOWMECHANICS) {
		mvaddstrAlt(8, 1, CONST_creature091);
		addstrAlt(attribute_enum_to_string(attribute));
		addstrAlt(CONST_creature092);
		addstrAlt(get_attribute(attribute, true));
		addstrAlt(CONST_creature102);
		addstrAlt(return_value);
		addstrAlt(closeParenthesis);
		pressAnyKey();
	}
	// Roll on the attribute value
	return return_value;
}
bool Creature::attribute_check(int attribute, int difficulty) const
{
	// Show die rolls, 100% accurate poll numbers
	extern bool SHOWMECHANICS;
	if (SHOWMECHANICS) {
		mvaddstrAlt(8, 1, CONST_creature094);
		addstrAlt(attribute_enum_to_string(attribute));
		if (difficulty < 21)
		{
			addstrAlt(CONST_creature104);
			addstrAlt(difficulty);
		}
		else addstrAlt(CONST_creature105);
		addstrAlt(closeParenthesis);
		pressAnyKey();
	}
	return(attribute_roll(attribute) >= difficulty);
}
int Creature::skill_roll(int skill) const
{
	extern Log gamelog;
	// Show die rolls, 100% accurate poll numbers
	extern bool SHOWMECHANICS;
	int pseudoskill = 0;
	// Handle Pseudoskills
	if (skill < 0)
	{
		switch (skill)
		{
		default:
			set_color_easy(YELLOW_ON_RED_BRIGHT);
			addstrAlt(CONST_creature097, gamelog);
			pressAnyKey();
			break;
		case PSEUDOSKILL_ESCAPEDRIVE:
		case PSEUDOSKILL_DODGEDRIVE:
			pseudoskill = skill;   // Remember the details.
			skill = SKILL_DRIVING; // Base skill is driving.
			break;
		}
	}
	// Take skill strength
	int skill_value = skills[skill];
	// plus the skill's associate attribute
	int attribute_value = get_attribute(get_associated_attribute(skill), true);
	int adjusted_attribute_value;
	switch (skill)
	{
		// most attributes get halved when applied to skills, capped by relative skill level...
	default:
		adjusted_attribute_value = min(attribute_value / 2, skill_value + 3);
		break;
		// ...and some may be so specialized that they ignore attributes, instead counting skill double
	case SKILL_SECURITY:
		adjusted_attribute_value = skill_value;
		break;
	}
	Vehicle* v = getChaseVehicle(*this);
	switch (pseudoskill)
	{
	case PSEUDOSKILL_ESCAPEDRIVE:
		if (v != NULL)
		{
			skill_value = v->modifieddriveskill(skill_value + adjusted_attribute_value); // combine values and modify by vehicle stats
			adjusted_attribute_value = 0;
		}
		else
		{
			skill_value = adjusted_attribute_value = 0; // Can't drive without a car
		}
		break;
	case PSEUDOSKILL_DODGEDRIVE:
		if (v != NULL)
		{
			skill_value = v->modifieddodgeskill(skill_value + adjusted_attribute_value); // combine values and modify by vehicle stats
			adjusted_attribute_value = 0;
		}
		else
		{
			skill_value = adjusted_attribute_value = 0; // Can't drive without a car
		}
		break;
	}
	// add the adjusted attribute and skill to get the adjusted skill total
	// that will be rolled on
	int return_value = roll_check(skill_value + adjusted_attribute_value);
	// Special skill handling
	switch (skill)
	{
		// Skills that cannot be used if zero skill:
	case SKILL_PSYCHOLOGY:
	case SKILL_LAW:
	case SKILL_SECURITY:
	case SKILL_COMPUTERS:
	case SKILL_MUSIC:
	case SKILL_ART:
	case SKILL_RELIGION:
	case SKILL_SCIENCE:
	case SKILL_BUSINESS:
	case SKILL_TEACHING:
	case SKILL_FIRSTAID:
		if (skills[skill] == 0)
		{
			return_value = 0; // Automatic failure
			break;
		}
		break;
		// Skills that should depend on clothing:
	case SKILL_STEALTH:
	{
		double stealth = (double)get_armor().get_stealth_value();
		for (int i = 1; i < get_armor().get_quality(); i++) stealth *= 0.8;
		if (get_armor().is_damaged()) stealth *= 0.5;
		return_value *= static_cast<int>(stealth);
		return_value /= 2;
		// Shredded clothes get you no stealth.
		if (get_armor().get_quality() > get_armor().get_quality_levels())
			return_value = 0;
	}
	break;
	case SKILL_SEDUCTION:
	case SKILL_PERSUASION:
		break;
		// Unique disguise handling
	case SKILL_DISGUISE:
	{
		// Check for appropriate uniform
		char uniformed = hasdisguise(*this);
		// Ununiformed disguise checks automatically fail
		if (!uniformed) { return_value = 0; break; }
		// reduce effectiveness for 'partial' uniforms (police uniforms when trespassing)
		else { if (uniformed == 2) return_value >>= 1; }
		// Bloody, damaged clothing hurts disguise check
		if (get_armor().is_bloody()) { return_value >>= 1; }
		if (get_armor().is_damaged()) { return_value >>= 1; }
		// Carrying corpses or having hostages is very bad for disguise
		if (prisoner != NULL) { return_value >>= 2; break; }
	}
	}
	if (SHOWMECHANICS) {
		mvaddstrAlt(8, 1, CONST_creature098);
		addstrAlt(skill_enum_to_string(skill));
		addstrAlt(CONST_creature099);
		addstrAlt(skills[skill]);
		addstrAlt(commaSpace);
		if (return_value == 0)
			addstrAlt(CONST_creature100);
		else
		{
			addstrAlt(CONST_creature101);
			addstrAlt(adjusted_attribute_value);
			addstrAlt(CONST_creature102);
			addstrAlt(return_value);
		}
		addstrAlt(closeParenthesis);
		pressAnyKey();
	}
	return return_value;
}
bool Creature::skill_check(int skill, int difficulty) const
{
	// Show die rolls, 100% accurate poll numbers
	extern bool SHOWMECHANICS;
	if (SHOWMECHANICS) {
		mvaddstrAlt(8, 1, CONST_creature103);
		addstrAlt(skill_enum_to_string(skill));
		if (difficulty < 21)
		{
			addstrAlt(CONST_creature104);
			addstrAlt(difficulty);
		}
		else addstrAlt(CONST_creature105);
		addstrAlt(closeParenthesis);
		pressAnyKey();
	}
	return(skill_roll(skill) >= difficulty);
}
void Creature::train(int trainedskill, int experience, int upto)
{
	// Do we allow animals to gain skills? Right now, yes
	//if(animalgloss==ANIMALGLOSS_ANIMAL)return;
	// Don't give experience if already maxed out or requested to give none
	if (skill_cap(trainedskill, true) <= skills[trainedskill] || upto <= skills[trainedskill] || experience == 0) { return; }
	else {
		// Skill gain scaled by ability in the area
		skill_experience[trainedskill] += max(1, static_cast<int>(experience * skill_cap(trainedskill, false) / 6.0));
		int abovenextlevel;
		// only allow gaining experience on the new level if it doesn't put us over a level limit
		if (skills[trainedskill] >= (upto - 1) ||
			skills[trainedskill] >= (skill_cap(trainedskill, true) - 1))
		{
			abovenextlevel = 0;
		}
		else
		{
			abovenextlevel = 50 + 5 * (1 + skills[trainedskill]);
		} // enough skill points to get halfway through the next skill level
		skill_experience[trainedskill] = min(skill_experience[trainedskill], 100 + 10 * skills[trainedskill] + abovenextlevel);
	}
}
void Creature::skill_up()
{
	for (int s = 0; s < SKILLNUM; s++)
	{
		while (skill_experience[s] >= 100 + 10 * skills[s] &&
			skills[s] < skill_cap(s, true))
		{
			skill_experience[s] -= 100 + 10 * skills[s];
			skills[s]++;
		}
		if (skills[s] == skill_cap(s, true))
			skill_experience[s] = 0;
	}
}
/* turns a creature into a conservative */
void conservatise(Creature &cr)
{
	if (cr.align == ALIGN_LIBERAL && cr.juice > 0)cr.juice = 0;
	cr.align = ALIGN_CONSERVATIVE;
	switch (cr.type)
	{
	case CREATURE_WORKER_FACTORY_UNION:
		strcpy(cr.name, CONST_creature106.c_str());
		break;
	case CREATURE_JUDGE_LIBERAL:
		strcpy(cr.name, CONST_creature107.c_str());
		break;
	}
}
/* turns a creature into a liberal */
void liberalize(Creature &cr, bool rename)
{
	extern UniqueCreatures uniqueCreatures;
	if (cr.align == ALIGN_CONSERVATIVE && cr.juice > 0)cr.juice = 0;
	cr.align = ALIGN_LIBERAL;
	if (cr.id == uniqueCreatures.CEO().id)
		uniqueCreatures.newCEO();
	if (rename)
		switch (cr.type)
		{
		case CREATURE_WORKER_FACTORY_NONUNION:
			strcpy(cr.name, CONST_creature108.c_str());
			break;
			//    case CREATURE_JUDGE_CONSERVATIVE:
			//       strcpy(cr.name,CONST_creature109.c_str());
			//       break;
		}
}
/* gives a CCS member a cover name */
void nameCCSMember(Creature &cr)
{
	if (cr.get_armor().get_itemtypename() == tag_ARMOR_CIVILLIANARMOR)
		strcpy(cr.name, CONST_creature110.c_str());
	else if (cr.get_armor().get_itemtypename() == tag_ARMOR_ARMYARMOR)
		strcpy(cr.name, CONST_creature111.c_str());
	else if (cr.get_armor().get_itemtypename() == tag_ARMOR_HEAVYARMOR)
		strcpy(cr.name, CONST_creature112.c_str());
	else if (cr.get_weapon().get_itemtypename() == tag_WEAPON_SHOTGUN_PUMP || LCSrandom(2))
		strcpy(cr.name, pickrandom(ccs_covername_shotgun).data());
	else
		strcpy(cr.name, pickrandom(ccs_covername_other).data());
}
/* are they interested in talking about the issues? */
bool Creature::talkreceptive() const
{
	return !enemy() && istalkreceptive;
}
/* are the characters close enough in age to date? */
bool Creature::can_date(const Creature &a) const
{
	// Make age not matter for dating or prostitution
	extern bool ZEROMORAL;
	if (!ZEROMORAL) {
		// Assume age appropriate for animals, tanks, etc.
		// (use other restrictions for these, like humorous rejections)
		if (animalgloss || a.animalgloss) return true;
		// Prohibit anyone 10 or younger
		if (age < 11 || a.age < 11) return false;
		// Allow 11-15 year olds only if the other partner is
		// within 4 years age difference
		if (age < 16 || a.age < 16) return abs(age - a.age) < 5;
	}
	// Allow anyone 16 or older
	return true;
}
void Creature::die()
{
	extern UniqueCreatures uniqueCreatures;
	extern char execname[EXECNUM][POLITICIAN_NAMELEN];
	extern char oldPresidentName[POLITICIAN_NAMELEN];
	alive = 0, blood = 0;
	if (id == uniqueCreatures.CEO().id)
		uniqueCreatures.newCEO();
	if (id == uniqueCreatures.President().id)
	{
		strcpy(oldPresidentName, execname[EXEC_PRESIDENT]);
		promoteVP();
		uniqueCreatures.newPresident();
	}
}
void UniqueCreatures::newCEO()
{
	makecreature(CEO_, CREATURE_CORPORATE_CEO);
	CEO_ID = CEO_.id, CEO_state = UNIQUECREATURE_ALIVE;
}
void UniqueCreatures::newPresident()
{
	extern char execname[EXECNUM][POLITICIAN_NAMELEN];
	extern short exec[EXECNUM];
	makecreature(Pres_, CREATURE_POLITICIAN);
	Pres_ID = Pres_.id, Pres_state = UNIQUECREATURE_ALIVE, Pres_.dontname = true;
	//Turn into President (not just random pol)
	std::string pres_name = execname[EXEC_PRESIDENT];
	strcpy(Pres_.name, (((string)CONST_creature113) + pres_name.substr(pres_name.find(' ') + 1)).c_str());
	strcpy(Pres_.propername, execname[EXEC_PRESIDENT]);
	switch (exec[EXEC_PRESIDENT])
	{ // we don't do anything for ALIGN_ARCHCONSERVATIVE or ALIGN_CONSERVATIVE so having them here is unnecessary
	case ALIGN_MODERATE:
		Pres_.align = ALIGN_MODERATE;
		Pres_.set_attribute(ATTRIBUTE_WISDOM, Pres_.get_attribute(ATTRIBUTE_WISDOM, false) / 2);
		Pres_.set_attribute(ATTRIBUTE_HEART, Pres_.get_attribute(ATTRIBUTE_WISDOM, false));
		break;
	case ALIGN_LIBERAL:
	case ALIGN_ELITELIBERAL:
		Pres_.align = ALIGN_LIBERAL;
		Pres_.set_attribute(ATTRIBUTE_HEART, Pres_.get_attribute(ATTRIBUTE_WISDOM, false));
		Pres_.set_attribute(ATTRIBUTE_WISDOM, 1);
		break;
	}
}
UniqueCreatures::UniqueCreatures(const std::string& inputXml)
{
	CMarkup xml;
	xml.SetDoc(inputXml);
	xml.FindElem();
	xml.IntoElem();
	while (xml.FindElem())
	{
		std::string tag = xml.GetTagName();
		if (tag == tag_CEO || tag == tag_Pres)
		{
			xml.IntoElem();
			xml.FindElem();
			if (tag == tag_CEO)
				CEO_ = Creature(xml.GetSubDoc());
			else
				Pres_ = Creature(xml.GetSubDoc());
			xml.OutOfElem();
		}
		else if (tag == tag_CEO_ID)
			CEO_ID = atoi(xml.GetData().c_str());
		else if (tag == tag_CEO_state)
			CEO_state = atoi(xml.GetData().c_str());
		else if (tag == tag_Pres_ID)
			Pres_ID = atoi(xml.GetData().c_str());
		else if (tag == tag_Pres_state)
			Pres_state = atoi(xml.GetData().c_str());
	}
}
string UniqueCreatures::showXml() const
{
	CMarkup xml;
	xml.AddElem(tag_uniquecreatures);
	xml.IntoElem();
	xml.AddElem(tag_CEO_ID, CEO_ID);
	xml.AddElem(tag_CEO_state, CEO_state);
	xml.AddElem(tag_CEO);
	xml.AddChildSubDoc(CEO_.showXml());
	xml.AddElem(tag_Pres_ID, CEO_ID);
	xml.AddElem(tag_Pres_state, CEO_state);
	xml.AddElem(tag_Pres);
	xml.AddChildSubDoc(Pres_.showXml());
	return xml.GetDoc();
}
const char* Creature::heshe(bool capitalize) const
{  // subject pronoun (nominative case)
	switch (gender_liberal)
	{
	case GENDER_MALE: return capitalize ? CONST_creature114.c_str() : CONST_creatureX01.c_str();
	case GENDER_FEMALE: return capitalize ? CONST_creature115.c_str() : CONST_creatureX02.c_str();
	default: return capitalize ? CONST_creature116.c_str() : CONST_creature117.c_str(); // Elite Liberal gender-neutral pronoun... it is pronounced CONST_creature118 rhyming with CONST_creatureB154
																						// see http://homepage.ntlworld.com/jonathan.deboynepollard/FGA/sex-neutral-pronouns.html (great reference on this)
																						// or http://en.wiktionary.org/wiki/xe or http://en.wikipedia.org/wiki/Gender-specific_and_gender-neutral_pronouns#Summary (wiki references)
																						// or http://genderneutralpronoun.wordpress.com/about/alice/xe/ (examples of it being used in text)
																						// full conjugation of CONST_creature117/CONST_creatureB153/CONST_creatureB066 (the CONST_creatureC161es are pronounced like CONST_creatureD162s):
																						// subject prononoun (nominative case):          xe      (pronounced CONST_creature118 rhyming with CONST_creatureB154)
																						// pronominal adjective (possessive determiner): xyr     (pronounced CONST_creature119 rhyming with CONST_creatureB159)
																						// object pronoun (oblique case);                xem     (pronounced CONST_creature120 rhyming with CONST_creatureB160)
																						// possessive pronoun:                           xyrs    (pronounced CONST_creature121 rhyming with CONST_creatureB157)
																						// reflexive pronoun:                            xemself (pronounced CONST_creature122 rhyming with CONST_creatureB158)
																						// public schools in Vancouver, British Columbia in Canada officially use these pronouns:
																						// http://news.nationalpost.com/2014/06/17/vancouver-school-boards-genderless-pronouns-not-likely-to-stick-if-history-is-any-indication/
	}
}
const char* Creature::hisher(bool capitalize) const
{  // pronominal adjective (possessive determiner)
	switch (gender_liberal)
	{
	case GENDER_MALE: return capitalize ? CONST_creature123.c_str() : CONST_creatureX03.c_str();
	case GENDER_FEMALE: return capitalize ? CONST_creature129.c_str() : CONST_creatureX04.c_str();
	default: return capitalize ? CONST_creature125.c_str() : CONST_creatureX05.c_str(); // Elite Liberal gender-neutral pronoun... it is pronounced CONST_creature119 rhyming with CONST_creatureB159
																						// see http://homepage.ntlworld.com/jonathan.deboynepollard/FGA/sex-neutral-pronouns.html (great reference on this)
																						// or http://en.wiktionary.org/wiki/xyr or http://en.wikipedia.org/wiki/Gender-specific_and_gender-neutral_pronouns#Summary (wiki references)
																						// or http://genderneutralpronoun.wordpress.com/about/alice/xe/ (examples of it being used in text)
																						// the possessive pronoun is based on this pronominal adjective in all standard third-person pronouns (so CONST_creature126 is correct):
																						// his -> his, her -> hers, their -> theirs, and likewise xyr -> xyrs... just add CONST_creature127 at the end if it doesn't already have an CONST_creature127 at the end
	}
}
const char* Creature::himher(bool capitalize) const
{  // object pronoun (oblique case)
	switch (gender_liberal)
	{
	case GENDER_MALE: return capitalize ? CONST_creature128.c_str() : CONST_creatureX06.c_str();
	case GENDER_FEMALE: return capitalize ? CONST_creature129.c_str() : CONST_creatureX04.c_str();
	default: return capitalize ? CONST_creature130.c_str() : CONST_creatureX07.c_str(); // Elite Liberal gender-neutral pronoun... it is pronounced CONST_creature120 rhyming with CONST_creatureB160
																						// see http://homepage.ntlworld.com/jonathan.deboynepollard/FGA/sex-neutral-pronouns.html (great reference on this)
																						// or http://en.wiktionary.org/wiki/xem or http://en.wikipedia.org/wiki/Gender-specific_and_gender-neutral_pronouns#Summary (wiki references)
																						// or http://genderneutralpronoun.wordpress.com/about/alice/xe/ (examples of it being used in text)
																						// the reflexive pronoun is based on this object pronoun in all standard third-person pronouns (so CONST_creature131 is correct):
																						// him -> himself, her -> herself, them -> themselves, it -> itself, one -> oneself, and likewise xem -> xemself... just add CONST_creature132 unless plural in which case add CONST_creatureB161
																						// some people mistakenly use xyrself instead of xemself but this is wrong as it doesn't follow the pattern used by ALL standard third-person pronouns,
																						// instead following the first-and-second-person pronoun pattern (my -> myself, your -> yourself/yourselves, our -> ourselves, thy -> thyself, and likewise xyr -> xyrself)
	}
}

Armor& Creature::armor_none()
{
	static Armor naked(getarmortype(tag_ARMOR_NONE));
	return naked;
}
bool Creature::will_do_ranged_attack(bool force_ranged, bool force_melee) const
{
	if (weapon) //Is the creature armed?
	{
		bool reload_allowed = can_reload();
		return weapon->get_attack(force_ranged, force_melee, reload_allowed) //Any attacks possible under circumstances?
			&& weapon->get_attack(force_ranged, force_melee, reload_allowed)->ranged //Is the attacked ranged?
			&& (!weapon->get_attack(force_ranged, force_melee, reload_allowed)->uses_ammo //Does it not use ammo
				|| weapon->get_ammoamount() != 0);                                      //or does it have ammo?
	}
	else return false;
}
bool Creature::can_reload() const
{
	//return len(clips); //Can not be sure creature only has appropriate clips.
	for (int i = 0; i < len(clips); i++)
		if (get_weapon().acceptable_ammo(*clips[i])) return true;
	return false;
}
bool Creature::will_reload(bool force_ranged, bool force_melee) const
{
	return get_weapon().uses_ammo()      //Does it use ammo?
		&& !get_weapon().get_ammoamount() //Is it out of ammo?
		&& can_reload()                  //Is reloading possible?
		&& get_weapon().get_attack(force_ranged, force_melee, false) //Is there an appropriate attack for the situation?
		&& get_weapon().get_attack(force_ranged, force_melee, false)->uses_ammo; //Does the attack need ammo?
}
bool Creature::reload(bool wasteful)
{
	if (get_weapon().uses_ammo() && len(clips)
		&& (wasteful || get_weapon().get_ammoamount() == 0))
	{
		bool r = weapon->reload(*clips.front());
		if (clips.front()->empty())
			delete_and_remove(clips, 0);
		return r;
	}
	else return false;
}
bool Creature::ready_another_throwing_weapon()
{
	bool r = false;
	if (len(extra_throwing_weapons))
	{
		weapon = extra_throwing_weapons.front()->split(1);
		if (extra_throwing_weapons.front()->empty())
			delete_and_remove(extra_throwing_weapons, 0);
		r = true;
	}
	has_thrown_weapon = false;
	return r;
}
int Creature::count_clips() const
{
	int sum = 0;
	for (int i = 0; i < len(clips); i++)
		sum += clips[i]->get_number();
	return sum;
}
bool Creature::take_clips(Item& clip, int number)
{
	if (clip.whatIsThis() == THIS_IS_CLIP)
		return take_clips(static_cast<Clip&>(clip), number); //cast -XML
	else return false;
}
bool Creature::take_clips(Clip& clip, int number)
{
	if (number + count_clips() >= 9) number = 9 - count_clips();
	if (number > clip.get_number()) number = clip.get_number();
	if (number > 0 && get_weapon().acceptable_ammo(clip))
	{
		Clip* c = clip.split(number);
		clips.push_back(c);
		return true;
	}
	else return false;
}
bool Creature::take_clips(const ClipType& ct, int number)
{
	Clip c(ct, number);
	return take_clips(c, number);
}
void Creature::give_weapon(Weapon& w, vector<Item*>* lootpile)
{
	if (weapon && !w.empty())
	{
		if (weapon->is_throwable() && weapon->is_same_type(w))
		{
			int take_number = 10 - count_weapons();
			if (take_number > 0)
				extra_throwing_weapons.push_back(w.split(1));
		}
		else
		{
			if (!lootpile)
			{
				delete weapon;
				delete_and_clear(extra_throwing_weapons);
			}
			else
			{
				lootpile->push_back(weapon);
				while (len(extra_throwing_weapons))
				{
					lootpile->push_back(extra_throwing_weapons.back());
					extra_throwing_weapons.pop_back();
				}
			}
			weapon = w.split(1);
			if (!lootpile)
			{
				for (int i = len(clips) - 1; i >= 0; i--)
				{
					if (!weapon->acceptable_ammo(*clips[i]))
						delete_and_remove(clips, i);
				}
			}
			else
			{
				for (int i = len(clips) - 1; i >= 0; i--)
				{
					if (!weapon->acceptable_ammo(*clips[i]))
					{
						lootpile->push_back(clips[i]);
						clips.erase(clips.begin() + i);
					}
				}
			}
		}
	}
	else if (!w.empty())
	{
		drop_weapons_and_clips(lootpile);
		weapon = w.split(1);
	}
}
void Creature::give_weapon(const WeaponType& wt, vector<Item*>* lootpile)
{
	Weapon w(wt);
	give_weapon(w, lootpile);
}
void Creature::drop_weapons_and_clips(vector<Item*>* lootpile)
{
	has_thrown_weapon = false;
	if (weapon)
	{
		if (lootpile) lootpile->push_back(weapon);
		else delete weapon;
		weapon = NULL;
	}
	while (len(extra_throwing_weapons))
	{
		if (lootpile) lootpile->push_back(extra_throwing_weapons.back());
		else delete extra_throwing_weapons.back();
		extra_throwing_weapons.pop_back();
	}
	while (len(clips))
	{
		if (lootpile) lootpile->push_back(clips.back());
		else delete clips.back();
		clips.pop_back();
	}
}
void Creature::drop_weapon(vector<Item*>* lootpile)
{
	if (len(extra_throwing_weapons))
		has_thrown_weapon = true;
	if (weapon)
	{
		if (lootpile) lootpile->push_back(weapon);
		else delete weapon;
		weapon = NULL;
	}
}
int Creature::count_weapons() const
{
	int sum = 0;
	if (weapon) sum++;
	for (int i = 0; i < len(extra_throwing_weapons); i++)
		sum += extra_throwing_weapons[i]->get_number();
	return sum;
}
void Creature::give_armor(Armor& a, vector<Item*>* lootpile)
{
	if (!a.empty())
	{
		strip(lootpile);
		armor = a.split(1);
	}
}
/*void Creature::give_armor(const ArmorType& at, vector<Item*>* lootpile)
{
Armor a(at);
give_armor(a, lootpile);
}*/
void Creature::give_armor(const int at, vector<Item*>* lootpile)
{
	Armor a(at);
	give_armor(a, lootpile);
}
void Creature::strip(vector<Item*>* lootpile)
{
	if (armor)
	{
		if (!lootpile) delete armor;
		else lootpile->push_back(armor);
		armor = NULL;
	}
}
int Creature::get_weapon_skill() const {
	int wsk = SKILL_HANDTOHAND;
	if (get_weapon().has_musical_attack())
		wsk = SKILL_MUSIC;
	else if (has_thrown_weapon && len(extra_throwing_weapons))
		wsk = extra_throwing_weapons[0]->get_attack(false, false, false)->skill;
	else wsk = get_weapon().get_attack(false, false, false)->skill;
	return get_skill(wsk);
}
string Creature::get_weapon_string(int subtype) const
{
	string r;
	if (is_armed())
	{
		r = weapon->get_name(subtype);
		if (weapon->uses_ammo())
			r += CONST_creature138 + tostring(weapon->get_ammoamount()) + CONST_creatureB162 + tostring(count_clips()) + closeParenthesis;
		else if (weapon->is_throwable())
			r += CONST_creature134 + tostring(count_weapons() - 1) + closeParenthesis; // -1 so not to count weapon in hands.
	}
	else if (len(extra_throwing_weapons))
	{
		r = extra_throwing_weapons[0]->get_name(subtype);
		r += CONST_creature135 + tostring(count_weapons()) + closeParenthesis;
	}
	else r = CONST_creature136;
	return r;
}
int get_XML_value(const std::string& inputXml) {
	int value;
	CMarkup xml;
	xml.SetDoc(inputXml);
	xml.FindElem();
	xml.IntoElem();
	while (xml.FindElem())
	{
		std::string tag = xml.GetTagName();
		if (tag == tag_value)
			value = min(atoi(xml.GetData().data()), MAXATTRIBUTE);
	}
	return value;
}
// Add an age estimate to a person's name
void add_age(Creature& person)
{
	// Who knows how old the purple gorilla/tank/flaming bunny/dog is?
	if (person.animalgloss != ANIMALGLOSS_NONE)
	{
		addstrAlt(CONST_creature137);
		return;
	}
	// For humans, estimate their age and gender
	addstrAlt(CONST_creature138);
	// Almost precise estimates of child and teen ages
	if (person.age < 20)
	{
		// Inaccuracy in estimating age should be the same every
		// time a character is queried. I'm using the day of the
		// month the character was born on to determine this.
		addstrAlt(person.age + person.birthday_day % 3 - 1);
		addstrAlt(CONST_creature151);
	}
	// More rough estimates of everyone else
	else
	{
		if (person.age < 30)
			addstrAlt(CONST_creature140);
		else if (person.age < 40)
			addstrAlt(CONST_creature141);
		else if (person.age < 50)
			addstrAlt(CONST_creature142);
		else if (person.age < 60)
			addstrAlt(CONST_creature143);
		else if (person.age < 70)
			addstrAlt(CONST_creature144);
		else if (person.age < 80)
			addstrAlt(CONST_creature145);
		else if (person.age < 90)
			addstrAlt(CONST_creature146);
		else
			addstrAlt(CONST_creature147);
	}
	// Assess their gender Liberally but allow ambiguity since you don't know them well enough yet
	if (person.gender_liberal == GENDER_MALE)
		addstrAlt(CONST_creature148);
	else if (person.gender_liberal == GENDER_FEMALE)
		addstrAlt(CONST_creature149);
	else
		addstrAlt(CONST_creature150);
	// Note if there's some conflict with Conservative society's perceptions
	if (person.gender_liberal != person.gender_conservative && person.gender_liberal != GENDER_NEUTRAL)
		addstrAlt(CONST_creature151);
	addstrAlt(closeParenthesis);
}
struct fullName {
	string first;
	string middle;
	string last;

};
fullName generate_long_name(char gender) {

	char stra[200];
	char strb[200];
	char strc[200];
	generate_long_name(stra, strb, strc, gender);
	fullName output;
	output.first = stra;
	output.middle = strb;
	output.last = strc;
	return output;
}
fullName generate_long_name(char gender = GENDER_NEUTRAL);
/* rolls up a proper name for a creature */
void Creature::namecreature()
{
	if (!dontname)
	{
		fullName fn = generate_long_name(gender_liberal);
		strcpy(propername, (fn.first + " " + fn.last).data());
		dontname = true;
	}
}


// #include "../includes.h"
const string CONST_creaturenames008 = "archconservative_last_names.txt";
const string CONST_creaturenames007 = "regular_last_names.txt";
const string CONST_creaturenames006 = "great_white_male_patriarch_first_names.txt";
const string CONST_creaturenames005 = "gender_neutral_first_names.txt";
const string CONST_creaturenames004 = "female_first_names.txt";
const string CONST_creaturenames003 = "male_first_names.txt";

vector<string> male_first_names;
vector<string> female_first_names;
vector<string> gender_neutral_first_names;
vector<string> great_white_male_patriarch_first_names;
vector<string> regular_last_names;
vector<string> archconservative_last_names;
const string names = "names\\";
vector<file_and_text_collection> names_text_file_collection = {
	/*creaturenames.cpp*/
	customText(&male_first_names, names + CONST_creaturenames003),
	customText(&female_first_names, names + CONST_creaturenames004),
	customText(&gender_neutral_first_names, names + CONST_creaturenames005),
	customText(&great_white_male_patriarch_first_names, names + CONST_creaturenames006),
	customText(&regular_last_names, names + CONST_creaturenames007),
	customText(&archconservative_last_names, names + CONST_creaturenames008),
};


// #include "../includes.h"
const string CONST_creaturetypeB086 = ": ";
const string CONST_creaturetypeB080 = " lacks idname.";
const string CONST_creaturetypeB078 = ", ";
const string CONST_creaturetypeB075 = " in ";
const string CONST_creaturetype074 = "Fireman";
const string CONST_creaturetype073 = "Car Salesman";
const string CONST_creaturetype072 = "Migrant Worker";
const string CONST_creaturetype071 = "Custodian";
const string CONST_creaturetype070 = "Slave";
const string CONST_creaturetype069 = "type_name not defined for ";
const string CONST_creaturetype068 = "Unknown element for ";
const string CONST_creaturetype067 = "Invalid armor type for ";
const string CONST_creaturetype066 = "Unknown skill for ";
const string CONST_creaturetype065 = "Invalid gender for ";
const string CONST_creaturetype064 = "Unknown attribute in ";
const string CONST_creaturetype063 = "Invalid alignment for ";
const string CONST_creaturetype062 = "Creature type ";
const string CONST_creaturetype061 = "LACKS IDNAME ";
const string CONST_creaturetype060 = "Invalid clip type for ";
const string CONST_creaturetype059 = "can not be used by ";
const string CONST_creaturetype058 = "In ";
const string CONST_creaturetype057 = "Invalid weapon type for ";
const string CONST_creaturetype056 = "Unknown element for weapon in ";
const string CONST_creaturetype055 = "Invalid interval for ";

const string tag_CLIP_45 = "CLIP_45";
const string tag_CLIP = "CLIP";
const string tag_CLIP_9 = "CLIP_9";
const string tag_CLIP_38 = "CLIP_38";
const string tag_CIVILIAN = "CIVILIAN";
const string tag_type_name = "type_name";
const string tag_encounter_name = "encounter_name";
const string tag_skills = "skills";
const string tag_attributes = "attributes";
const string tag_attribute_points = "attribute_points";
const string tag_SENIOR = "SENIOR";
const string tag_MI = "MI";
const string tag_MIDDLEAGED = "MIDDLEAGED";
const string tag_GRADUATE = "GRADUATE";
const string tag_MATURE = "MATURE";
const string tag_YOUNGADULT = "YOUNGADULT";
const string tag_TEENAGER = "TEENAGER";
const string tag_CHILD = "CHILD";
const string tag_CHI = "CHI";
const string tag_DOGYEARS = "DOGYEARS";
const string tag_CONSERVATIVE = "CONSERVATIVE";
const string tag_MODERATE = "MODERATE";
const string tag_LIBERAL = "LIBERAL";
const string tag_PUBLIC_MOOD = "PUBLIC MOOD";
const string tag_alignment = "alignment";
const string tag_APPROPRIATE = "APPROPRIATE";
const string tag_number_clips = "number_clips";
const string tag_cliptype = "cliptype";
const string tag_number_weapons = "number_weapons";
#include "../common/interval.h"
#include "../creature/creaturetype.h"
Weapon& Creature::weapon_none()
{
	extern vector<WeaponType *> weapontype;
	static Weapon unarmed(*weapontype[getweapontype(tag_WEAPON_NONE)]);
	return unarmed;
}
// This would normally be inlined inside the Creature class in creature.h, but the Creature class
// has to be before creaturetype
std::string Creature::get_type_name() const { return getcreaturetype(type_idname)->get_type_name(); }
// Assign a value to an Interval from a string or log error.
void assign_interval(Interval& i, const std::string& value,
	const std::string& owner, const std::string& element)
{
	extern Log xmllog;
	if (!i.set_interval(value))
		xmllog.log(CONST_creaturetype055 + element + CONST_creaturetypeB075 + owner + CONST_creaturetypeB086 + value);
}
int CreatureType::s_number_of_creaturetypes = 0;
CreatureType::WeaponsAndClips::WeaponsAndClips(const std::string& weapon, int weapons, const std::string& clip, int clips)
	: weapon_type_str(weapon), number_weapons(weapons),
	cliptype(clip), number_clips(clips)
{
}
//extern string NONE;
string undefined;
CreatureType::CreatureType(const std::string& xmlstring)
	: age_(18, 57), alignment_public_mood_(true),
	attribute_points_(40),
	gender_liberal_(GENDER_RANDOM), gender_conservative_(GENDER_RANDOM),
	infiltration_(0), juice_(0), money_(20, 40)
{
	extern string NONE;
	extern Log xmllog;
	for (int i = 0; i < ATTNUM; i++)
		attributes_[i].set_interval(1, 10);
	id_ = s_number_of_creaturetypes++;
	CMarkup xml;
	xml.SetDoc(xmlstring);
	xml.FindElem();
	idname_ = xml.GetAttrib(tag_idname);
	if (!len(idname_))
	{
		idname_ = CONST_creaturetype061 + tostring(id_);
		xmllog.log(CONST_creaturetype062 + tostring(id_) + CONST_creaturetypeB080);
	}
	type_ = creaturetype_string_to_enum(idname_);
	xml.IntoElem();
	// Loop over all the elements inside the creaturetype element.
	while (xml.FindElem())
	{
		std::string element = xml.GetTagName();
		if (element == tag_alignment)
		{
			std::string alignment = xml.GetData();
			if (alignment == tag_PUBLIC_MOOD)
				alignment_public_mood_ = true;
			else if (alignment == tag_LIBERAL)
			{
				alignment_ = ALIGN_LIBERAL;
				alignment_public_mood_ = false;
			}
			else if (alignment == tag_MODERATE)
			{
				alignment_ = ALIGN_MODERATE;
				alignment_public_mood_ = false;
			}
			else if (alignment == tag_CONSERVATIVE)
			{
				alignment_ = ALIGN_CONSERVATIVE;
				alignment_public_mood_ = false;
			}
			else
				xmllog.log(CONST_creaturetype063 + idname_ + CONST_creaturetypeB086 + alignment);
		}
		else if (element == tag_age)
		{
			std::string age = xml.GetData();
			if (age == tag_DOGYEARS)
				age_.set_interval(2, 6);
			else if (age == tag_CHILD)
				age_.set_interval(7, 10);
			else if (age == tag_TEENAGER)
				age_.set_interval(14, 17);
			else if (age == tag_YOUNGADULT)
				age_.set_interval(18, 35);
			else if (age == tag_MATURE)
				age_.set_interval(20, 59);
			else if (age == tag_GRADUATE)
				age_.set_interval(26, 59);
			else if (age == tag_MIDDLEAGED)
				age_.set_interval(35, 59);
			else if (age == tag_SENIOR)
				age_.set_interval(65, 94);
			else
				assign_interval(age_, age, idname_, element);
		}
		else if (element == tag_attribute_points)
			assign_interval(attribute_points_, xml.GetData(), idname_, element);
		else if (element == tag_attributes)
		{
			while (xml.FindChildElem())
			{
				int attribute = attribute_string_to_enum(xml.GetChildTagName());
				if (attribute != -1)
					assign_interval(attributes_[attribute], xml.GetChildData(), idname_, element);
				else
					xmllog.log(CONST_creaturetype064 + idname_ + CONST_creaturetypeB086 + xml.GetTagName());
			}
		}
		else if (element == tag_juice)
			assign_interval(juice_, xml.GetData(), idname_, element);
		else if (element == tag_gender)
		{
			int gender = gender_string_to_enum(xml.GetData());
			if (gender != -1 && gender != GENDER_WHITEMALEPATRIARCH)
				gender_liberal_ = gender_conservative_ = gender;
			else
				xmllog.log(CONST_creaturetype065 + idname_ + CONST_creaturetypeB086 + xml.GetData());
		}
		else if (element == tag_infiltration)
			assign_interval(infiltration_, xml.GetData(), idname_, element);
		else if (element == tag_money)
			assign_interval(money_, xml.GetData(), idname_, element);
		else if (element == tag_skills)
		{
			while (xml.FindChildElem())
			{
				int skill = skill_string_to_enum(xml.GetChildTagName());
				if (skill != -1)
					assign_interval(skills_[skill], xml.GetChildData(), idname_, element);
				else
					xmllog.log(CONST_creaturetype066 + idname_ + CONST_creaturetypeB086 + xml.GetChildTagName());
			}
		}
		else if (element == tag_armor)
		{
			if (getarmortype(xml.GetData()) != -1)
				armortypes_.push_back(xml.GetData());
			else
				xmllog.log(CONST_creaturetype067 + idname_ + CONST_creaturetypeB086 + xml.GetData());
		}
		else if (element == tag_weapon)
		{
			//xml.SavePos(tag_creature);
			weapons_and_clips_.push_back(WeaponsAndClips(xml, idname_));
			//xml.RestorePos(tag_creature);
		}
		else if (element == tag_encounter_name)
			encounter_name_ = xml.GetData();
		else if (element == tag_type_name)
			type_name_ = xml.GetData();
		else
			xmllog.log(CONST_creaturetype068 + idname_ + CONST_creaturetypeB086 + element);
	}
	if (!len(type_name_))
	{
		xmllog.log(CONST_creaturetype069 + idname_ + singleDot);
		type_name_ = undefined;
	}
	// If no weapon type has been given then use WEAPON_NONE.
	if (!len(weapons_and_clips_))
		weapons_and_clips_.push_back(WeaponsAndClips(tag_WEAPON_NONE, 1, NONE, 0));
	// If no armor type has been given then use ARMOR_NONE.
	if (!len(armortypes_))
		armortypes_.push_back(tag_ARMOR_NONE);
}
void CreatureType::make_creature(Creature& cr) const
{
	cr.type_idname = idname_;
	cr.align = get_alignment();
	cr.age = age_.roll();
	cr.juice = juice_.roll();
	cr.gender_liberal = cr.gender_conservative = roll_gender();
	cr.infiltration = roll_infiltration();
	cr.money = money_.roll();
	strcpy(cr.name, get_encounter_name());
	for (int i = 0; i < SKILLNUM; i++) cr.set_skill(i, skills_[i].roll());
	give_armor(cr);
	give_weapon(cr);
}
Alignment CreatureType::get_alignment() const
{
	if (alignment_public_mood_)
	{
		int mood = publicmood(-1);
		int a = ALIGN_CONSERVATIVE;
		if (LCSrandom(100) < mood) a++;
		if (LCSrandom(100) < mood) a++;
		return (Alignment)a;
	}
	else return alignment_;
}
int CreatureType::roll_gender() const
{
	extern short lawList[LAWNUM];
	int gender = LCSrandom(2) + 1; // Male or female.
	switch (gender_liberal_)
	{
	case GENDER_NEUTRAL: return GENDER_NEUTRAL;
	case GENDER_MALE:    return GENDER_MALE;
	case GENDER_FEMALE:  return GENDER_FEMALE;
	case GENDER_MALE_BIAS:
		if (lawList[LAW_WOMEN] == -2 ||
			(lawList[LAW_WOMEN] == -1 && LCSrandom(25)) ||
			(lawList[LAW_WOMEN] == 0 && LCSrandom(10)) ||
			(lawList[LAW_WOMEN] == 1 && LCSrandom(4)))
			return GENDER_MALE;
	case GENDER_FEMALE_BIAS:
		if (lawList[LAW_WOMEN] == -2 ||
			(lawList[LAW_WOMEN] == -1 && LCSrandom(25)) ||
			(lawList[LAW_WOMEN] == 0 && LCSrandom(10)) ||
			(lawList[LAW_WOMEN] == 1 && LCSrandom(4)))
			return GENDER_FEMALE;
	}
	return gender;
}
float CreatureType::roll_infiltration() const
{
	return infiltration_.roll() / 100.0f;
}
std::string CreatureType::get_encounter_name() const
{
	if (len(encounter_name_))
		return encounter_name_;
	else return get_type_name();
}
std::string CreatureType::get_type_name() const
{
	extern short lawList[LAWNUM];
	switch (type_) // Hardcoded special cases.
	{
	case CREATURE_WORKER_SERVANT:
		if (lawList[LAW_LABOR] == -2 && lawList[LAW_CORPORATE] == -2) return CONST_creaturetype070;
		break;
	case CREATURE_WORKER_JANITOR:
		if (lawList[LAW_LABOR] == 2) return CONST_creaturetype071;
		break;
	case CREATURE_WORKER_SWEATSHOP:
		if (lawList[LAW_LABOR] == 2 && lawList[LAW_IMMIGRATION] == 2) return CONST_creaturetype072;
		break;
	case CREATURE_CARSALESMAN:
		if (lawList[LAW_WOMEN] == -2) return CONST_creaturetype073;
		break;
	case CREATURE_FIREFIGHTER:
		if (lawList[LAW_FREESPEECH] == -2) return CONST_creaturetype074;
		break;
	}
	return type_name_;
}
void CreatureType::give_weapon(Creature& cr) const
{
	extern string NONE;
	extern vector<WeaponType *> weapontype;
	extern vector<ClipType *> cliptype;
	const WeaponsAndClips& wc = pickrandom(weapons_and_clips_);
	if (wc.weapon_type_str == tag_CIVILIAN)
		give_weapon_civilian(cr);
	else if (wc.weapon_type_str != tag_WEAPON_NONE)
	{
		Weapon w(*weapontype[getweapontype(wc.weapon_type_str)], wc.number_weapons.roll());
		w.set_number(min(w.get_number(), 10L));
		while (!w.empty()) cr.give_weapon(w, NULL);
		if (wc.cliptype != NONE)
		{
			int n = wc.number_clips.roll();
			cr.take_clips(*cliptype[getcliptype(wc.cliptype)], n);
			cr.reload(false);
		}
	}
}
void CreatureType::give_weapon_civilian(Creature& cr) const
{
	extern vector<WeaponType *> weapontype;
	extern short lawList[LAWNUM];
	extern vector<ClipType *> cliptype;
	if (lawList[LAW_GUNCONTROL] == -1 && !LCSrandom(30))
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_REVOLVER_38)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_38)], 4);
		cr.reload(false);
	}
	else if (lawList[LAW_GUNCONTROL] == -2)
	{
		if (!LCSrandom(10))
		{
			cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SEMIPISTOL_9MM)], NULL);
			cr.take_clips(*cliptype[getcliptype(tag_CLIP_9)], 4);
			cr.reload(false);
		}
		else if (!LCSrandom(9))
		{
			cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SEMIPISTOL_45)], NULL);
			cr.take_clips(*cliptype[getcliptype(tag_CLIP_45)], 4);
			cr.reload(false);
		}
	}
}
void CreatureType::give_armor(Creature& cr) const
{
	const std::string str = pickrandom(armortypes_);
	if (str != tag_ARMOR_NONE)
		cr.give_armor(getarmortype(str), NULL);
}

const string tag_CLIP_BUCKSHOT = "CLIP_BUCKSHOT";
const string tag_CLIP_SMG = "CLIP_SMG";
const string tag_CLIP_ASSAULT = "CLIP_ASSAULT";
const string tag_WEAPON_AUTORIFLE_AK47 = "WEAPON_AUTORIFLE_AK47";
const string tag_CLIP_44 = "CLIP_44";
const string tag_WEAPON_AXE = "WEAPON_AXE";
const string tag_CLIP_GASOLINE = "CLIP_GASOLINE";
const string tag_WEAPON_TORCH = "WEAPON_TORCH";
const string tag_WEAPON_PITCHFORK = "WEAPON_PITCHFORK";
const string tag_WEAPON_GAVEL = "WEAPON_GAVEL";

const string CONST_creaturetypes049 = "Giant Mosquito";
const string CONST_creaturetypes048 = "Flaming Rabbit";
const string CONST_creaturetypes047 = "Pet ";
const string CONST_creaturetypes046 = "CCS Team Leader";
const string CONST_creaturetypes045 = "Firefighter";
const string CONST_creaturetypes044 = "Fireman";
const string CONST_creaturetypes043 = "Police Negotiator";
const string CONST_creaturetypes042 = "CEO ";
const string CONST_creaturetypes041 = "Enforcer";
const string CONST_creaturetypes040 = "genetic_monster.txt";
const string CONST_creaturetypes039 = "words_meaning_hick.txt";
const string CONST_creaturetypesX01 = "CCS Lieutenant";
const string CONST_creaturetypesX02 = "CCS Founder";

#define AGE_TEENAGER    14+LCSrandom(4)  /* HS dropout, teenager, some fast food workers */
#define AGE_YOUNGADULT  18+LCSrandom(18) /* young lads and ladies */
vector<string> words_meaning_hick;
vector<string> genetic_monster;
vector<file_and_text_collection> creaturetypes_text_file_collection = {
	/*creaturetypes.cpp*/
	customText(&words_meaning_hick, creature + CONST_creaturetypes039),
	customText(&genetic_monster, creature + CONST_creaturetypes040),
};
char disguisesite(long type);
vector<CreatureTypes> armAsCivilian = {
	// Curiously, CREATURE_CRACKHEAD has a chance to be armed with a shank, regardless of whether they are granted a civilian weapon
	CREATURE_CRACKHEAD, CREATURE_MUTANT, CREATURE_BUM, CREATURE_WORKER_FACTORY_UNION, CREATURE_WORKER_FACTORY_NONUNION, CREATURE_SCIENTIST_EMINENT, CREATURE_SCIENTIST_LABTECH
};

map<short, vector<CreatureTypes> > replaceTheseCreatures = {
	// The original code has a 1/10 chance to replace with CREATURE_THIEF
	// Otherwise, random selection between the other five.
	// This code changes this to a 1/11 chance to replace with CREATURE_THIEF
	// Which is close enough.
	map<CreatureTypes, vector<CreatureTypes> >::value_type(CREATURE_PRISONER,{ CREATURE_THIEF, CREATURE_GANGMEMBER, CREATURE_PROSTITUTE, CREATURE_CRACKHEAD, CREATURE_TEENAGER, CREATURE_HSDROPOUT, CREATURE_GANGMEMBER, CREATURE_PROSTITUTE, CREATURE_CRACKHEAD, CREATURE_TEENAGER, CREATURE_HSDROPOUT })

};
vector<CreatureTypes> doNotArmInThisFunction = {
	CREATURE_JUDGE_LIBERAL,
	CREATURE_POLITICIAN,
	CREATURE_CORPORATE_MANAGER,
	CREATURE_WORKER_SERVANT,
	CREATURE_WORKER_JANITOR,
	CREATURE_WORKER_SECRETARY,
	CREATURE_LANDLORD,
	CREATURE_BANK_TELLER,
	CREATURE_BANK_MANAGER,
	CREATURE_TEENAGER,
	CREATURE_SOLDIER,
	CREATURE_VETERAN,
	CREATURE_HARDENED_VETERAN,
	CREATURE_SWAT,
	CREATURE_DEATHSQUAD,
	CREATURE_GANGUNIT,
	CREATURE_AGENT,
	CREATURE_SECRET_SERVICE,
	CREATURE_RADIOPERSONALITY,
	CREATURE_NEWSANCHOR,
	CREATURE_JUROR,
	CREATURE_WORKER_FACTORY_CHILD,
	CREATURE_SEWERWORKER,
	CREATURE_COLLEGESTUDENT,
	CREATURE_MUSICIAN,
	CREATURE_MATHEMATICIAN,
	CREATURE_TEACHER,
	CREATURE_HSDROPOUT,
	CREATURE_PRIEST,
	CREATURE_ENGINEER,
	CREATURE_TELEMARKETER,
	CREATURE_CARSALESMAN,
	CREATURE_OFFICEWORKER,
	CREATURE_MAILMAN,
	CREATURE_GARBAGEMAN,
	CREATURE_PLUMBER,
	CREATURE_CHEF,
	CREATURE_CONSTRUCTIONWORKER,
	CREATURE_AMATEURMAGICIAN,
	CREATURE_AUTHOR,
	CREATURE_JOURNALIST,
	CREATURE_CRITIC_ART,
	CREATURE_CRITIC_MUSIC,
	CREATURE_BIKER,
	CREATURE_TRUCKER,
	CREATURE_TAXIDRIVER,
	CREATURE_PROGRAMMER,
	CREATURE_NUN,
	CREATURE_RETIREE,
	CREATURE_PAINTER,
	CREATURE_SCULPTOR,
	CREATURE_DANCER,
	CREATURE_PHOTOGRAPHER,
	CREATURE_CAMERAMAN,
	CREATURE_HAIRSTYLIST,
	CREATURE_FASHIONDESIGNER,
	CREATURE_CLERK,
	CREATURE_ACTOR,
	CREATURE_YOGAINSTRUCTOR,
	CREATURE_MARTIALARTIST,
	CREATURE_ATHLETE,
	CREATURE_LOCKSMITH,
	CREATURE_MILITARYPOLICE,
	CREATURE_SEAL,
	// These are not used in the switch statement anymore, but appear in the defaultWeapons collection
	//CREATURE_SECURITY_GUARD
	//CRREATURE_MERC
};
struct weaponLayout {
	string weaponTag;
	string clipTag;
	int ammunition;
	weaponLayout(string whichSkill_, string experience_, int maxLevel_) :weaponTag(whichSkill_), clipTag(experience_), ammunition(maxLevel_) {}
	weaponLayout(string whichSkill_) :weaponTag(whichSkill_), clipTag(""), ammunition(0) {}
	weaponLayout() : weaponLayout(tag_WEAPON_NONE) {}
};
struct fullWeaponLayout {
	weaponLayout cplus;
	weaponLayout c;
	weaponLayout moderate;
	weaponLayout l;
	weaponLayout lplus;
	fullWeaponLayout() : cplus(weaponLayout()), c(weaponLayout()), moderate(weaponLayout()), l(weaponLayout()), lplus(weaponLayout()) {}
	fullWeaponLayout(weaponLayout cplus_, weaponLayout c_, weaponLayout moderate_, weaponLayout l_, weaponLayout lplus_) : cplus(cplus_), c(c_), moderate(moderate_), l(l_), lplus(lplus_) {}

};

map<const short, const fullWeaponLayout> defaultWeapons = {
	map<const short, const fullWeaponLayout>::value_type(CREATURE_BOUNCER, fullWeaponLayout(weaponLayout(tag_WEAPON_SMG_MP5, tag_CLIP_SMG, 4), weaponLayout(tag_WEAPON_REVOLVER_44, tag_CLIP_44, 4), weaponLayout(tag_WEAPON_REVOLVER_38, tag_CLIP_38, 4), weaponLayout(tag_WEAPON_NIGHTSTICK), weaponLayout(tag_WEAPON_NIGHTSTICK))),
	map<const short, const fullWeaponLayout>::value_type(CREATURE_SECURITYGUARD, fullWeaponLayout(weaponLayout(tag_WEAPON_SMG_MP5, tag_CLIP_SMG, 4), weaponLayout(tag_WEAPON_NIGHTSTICK), weaponLayout(tag_WEAPON_NIGHTSTICK), weaponLayout(tag_WEAPON_NIGHTSTICK), weaponLayout(tag_WEAPON_REVOLVER_38, tag_CLIP_38, 4))),
	map<const short, const fullWeaponLayout>::value_type(CREATURE_MERC, fullWeaponLayout(weaponLayout(tag_WEAPON_AUTORIFLE_M16, tag_CLIP_ASSAULT, 7), weaponLayout(tag_WEAPON_AUTORIFLE_M16, tag_CLIP_ASSAULT, 7), weaponLayout(tag_WEAPON_AUTORIFLE_M16, tag_CLIP_ASSAULT, 7), weaponLayout(tag_WEAPON_SEMIRIFLE_AR15, tag_CLIP_ASSAULT, 7), weaponLayout(tag_WEAPON_SEMIRIFLE_AR15, tag_CLIP_ASSAULT, 7))),

};

weaponLayout getWeaponLayout(const short type) {
	extern short lawList[LAWNUM];
	switch (lawList[LAW_GUNCONTROL]) {
	case -2:
		return defaultWeapons[type].cplus;
	case -1:
		return defaultWeapons[type].c;
	case 0:
		return defaultWeapons[type].moderate;
	case 1:
		return defaultWeapons[type].l;
	case 2:
		return defaultWeapons[type].lplus;
	}
	return weaponLayout(tag_WEAPON_NONE);
}

void giveDefaultWeapon(Creature &cr, const short type) {
	extern vector<WeaponType *> weapontype;
	extern vector<ClipType *> cliptype;
	if (defaultWeapons.count(type) >= 1) {
		weaponLayout layout = getWeaponLayout(type);
		cr.give_weapon(*weapontype[getweapontype(layout.weaponTag)], NULL);
		if (layout.ammunition >= 1) {
			cr.take_clips(*cliptype[getcliptype(layout.clipTag)], layout.ammunition);
		}
		cr.reload(false);
	}
}
void armBouncer(Creature &cr) {
	extern short mode;
	extern short sitetype;
	extern short cursite;
	if (mode == GAMEMODE_SITE && LocationsPool::getInstance().isThisPlaceHighSecurity(cursite))
	{
		strcpy(cr.name, CONST_creaturetypes041.c_str());
		cr.set_skill(SKILL_CLUB, LCSrandom(3) + 3);
	}
	if (disguisesite(sitetype))
	{
		cr.align = ALIGN_CONSERVATIVE;
		cr.infiltration = 0.1f*LCSrandom(4);
	}
	else cr.align = ALIGN_MODERATE;
}

void armCREATURE_SCIENTIST_LABTECH(Creature &cr) {
	extern vector<WeaponType *> weapontype;
	if (!cr.is_armed() && !LCSrandom(2))
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SYRINGE)], NULL);
}
void armCREATURE_JUDGE_CONSERVATIVE(Creature &cr) {
	extern vector<WeaponType *> weapontype;
	extern vector<ClipType *> cliptype;
	extern short lawList[LAWNUM];
	if (lawList[LAW_GUNCONTROL] == -2 && !LCSrandom(3))
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_REVOLVER_44)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_44)], 4);
	}
	else if (!LCSrandom(2))
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_GAVEL)], NULL);
	cr.reload(false);
}
void armCREATURE_SCIENTIST_EMINENT(Creature &cr) {
	extern vector<WeaponType *> weapontype;
	if (!cr.is_armed() && !LCSrandom(2))
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SYRINGE)], NULL);
}
void armCREATURE_CORPORATE_CEO(Creature &cr) {
	fullName fn = generate_long_name(GENDER_WHITEMALEPATRIARCH);
	strcpy(cr.propername, (fn.first + " " + fn.last).data());
	strcpy(cr.name, CONST_creaturetypes042.c_str());
	strcat(cr.name, cr.propername);
	cr.dontname = true;
}
void armCREATURE_WORKER_FACTORY_NONUNION(Creature &cr) {
	extern vector<WeaponType *> weapontype;
	if (!cr.is_armed())
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_CHAIN)], NULL);
	if (cr.align == ALIGN_LIBERAL) cr.align = LCSrandom(2) - 1;
}
void armCREATURE_WORKER_SWEATSHOP(Creature &cr) {
	cr.flag |= CREATUREFLAG_ILLEGALALIEN;
}
void armCREATURE_LAWYER(Creature &cr) {
	extern vector<ClipType *> cliptype;
	extern vector<WeaponType *> weapontype;
	extern short lawList[LAWNUM];
	if (lawList[LAW_GUNCONTROL] == -2 && !LCSrandom(3))
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_REVOLVER_38)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_38)], 1);
		cr.reload(false);
	}
}
void armCREATURE_DOCTOR(Creature &cr) {
	extern vector<ClipType *> cliptype;
	extern vector<WeaponType *> weapontype;
	extern short lawList[LAWNUM];
	if (lawList[LAW_GUNCONTROL] == -2 && !LCSrandom(3))
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_REVOLVER_38)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_38)], 1);
		cr.reload(false);
	}
}
void armCREATURE_PSYCHOLOGIST(Creature &cr) {
	extern vector<ClipType *> cliptype;
	extern vector<WeaponType *> weapontype;
	extern short lawList[LAWNUM];
	if (lawList[LAW_GUNCONTROL] == -2 && !LCSrandom(3))
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_REVOLVER_38)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_38)], 1);
		cr.reload(false);
	}
	if (cr.gender_liberal == GENDER_MALE || LCSrandom(2))
		cr.give_armor(getarmortype(tag_ARMOR_CHEAPSUIT), NULL);
	else
		cr.give_armor(getarmortype(tag_ARMOR_CHEAPDRESS), NULL);
}
void armCREATURE_NURSE(Creature &cr) {
	extern vector<ClipType *> cliptype;
	extern vector<WeaponType *> weapontype;
	extern short lawList[LAWNUM];
	if (lawList[LAW_GUNCONTROL] == -2 && !LCSrandom(3))
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_REVOLVER_38)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_38)], 1);
		cr.reload(false);
	}
}
void armCREATURE_WORKER_FACTORY_UNION(Creature &cr) {
	extern vector<WeaponType *> weapontype;
	if (!cr.is_armed())
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_CHAIN)], NULL);
}
void armCREATURE_TANK(Creature &cr) {
	cr.animalgloss = ANIMALGLOSS_TANK;
	cr.specialattack = ATTACK_CANNON;
}
void armCREATURE_HICK(Creature &cr) {
	extern vector<ClipType *> cliptype;
	extern vector<WeaponType *> weapontype;
	extern short lawList[LAWNUM];
	strcpy(cr.name, pickrandom(words_meaning_hick).data());
	if ((lawList[LAW_GUNCONTROL] == -2 && !LCSrandom(2)) || !LCSrandom(10))
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SHOTGUN_PUMP)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_BUCKSHOT)], 4);
	}
	else
		cr.give_weapon(*weapontype[getweapontype(LCSrandom(2) ? tag_WEAPON_TORCH : tag_WEAPON_PITCHFORK)], NULL);
	cr.reload(false);
}
void armCREATURE_COP(Creature &cr) {
	extern vector<ClipType *> cliptype;
	extern short lawList[LAWNUM];
	extern vector<WeaponType *> weapontype;
	if (lawList[LAW_POLICEBEHAVIOR] == 2 && cr.align == ALIGN_LIBERAL && !LCSrandom(3)) // Peace Officer
	{
		cr.align = ALIGN_MODERATE;
		strcpy(cr.name, CONST_creaturetypes043.c_str());
		cr.set_skill(SKILL_PERSUASION, LCSrandom(4) + 1);
		cr.set_skill(SKILL_PISTOL, LCSrandom(3) + 1);
		cr.set_attribute(ATTRIBUTE_HEART, 4);
	}
	else
	{
		if (lawList[LAW_GUNCONTROL] == -2 && !LCSrandom(3))
		{
			cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SMG_MP5)], NULL);
			cr.take_clips(*cliptype[getcliptype(tag_CLIP_SMG)], 4);
		}
		else if (!LCSrandom(3))
		{
			cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SEMIPISTOL_9MM)], NULL);
			cr.take_clips(*cliptype[getcliptype(tag_CLIP_9)], 4);
		}
		else if (!LCSrandom(2))
		{
			cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SHOTGUN_PUMP)], NULL);
			cr.take_clips(*cliptype[getcliptype(tag_CLIP_BUCKSHOT)], 4);
		}
		else
			cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_NIGHTSTICK)], NULL);
		cr.reload(false);
		cr.align = ALIGN_CONSERVATIVE;
		cr.set_skill(SKILL_PISTOL, LCSrandom(4) + 1);
		cr.set_skill(SKILL_SHOTGUN, LCSrandom(3) + 1);
		cr.set_skill(SKILL_CLUB, LCSrandom(2) + 1);
		cr.set_skill(SKILL_HANDTOHAND, LCSrandom(2) + 1);
		cr.set_attribute(ATTRIBUTE_WISDOM, 4);
	}
}
void armCREATURE_FIREFIGHTER(Creature &cr) {
	extern short mode;
	extern short sitetype;
	extern short cursite;
	extern char ccs_kills;
	extern short sitealarm;
	extern char endgamestate;
	extern vector<WeaponType *> weapontype;
	extern vector<ClipType *> cliptype;
	extern short lawList[LAWNUM];
	if (lawList[LAW_FREESPEECH] == -2)
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_FLAMETHROWER)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_GASOLINE)], 4);
		cr.reload(false);
		cr.set_skill(SKILL_HEAVYWEAPONS, LCSrandom(3) + 2);
		strcpy(cr.name, CONST_creaturetypes044.c_str());
		cr.align = ALIGN_CONSERVATIVE;
	}
	else
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_AXE)], NULL);
		cr.set_skill(SKILL_AXE, LCSrandom(3) + 2);
		strcpy(cr.name, CONST_creaturetypes045.c_str());
	}
	if (sitealarm) // Respond to emergencies in bunker gear
		cr.give_armor(getarmortype(tag_ARMOR_BUNKERGEAR), NULL);
}
void armCREATURE_CCS_MOLOTOV(Creature &cr) {
	extern short mode;
	extern short sitetype;
	extern short cursite;
	extern char ccs_kills;
	extern short sitealarm;
	extern char endgamestate;
	if (mode == GAMEMODE_SITE/* && sitealarm>0*/)
		nameCCSMember(cr);
}
void armCREATURE_CCS_SNIPER(Creature &cr) {
	extern short mode;
	extern short sitetype;
	extern short cursite;
	extern char ccs_kills;
	extern short sitealarm;
	extern char endgamestate;
	if (mode == GAMEMODE_SITE/* && sitealarm>0*/)
		nameCCSMember(cr);
}
void armCREATURE_CCS_VIGILANTE(Creature &cr) {
	extern short mode;
	extern short sitetype;
	extern short cursite;
	extern char ccs_kills;
	extern short sitealarm;
	extern char endgamestate;
	extern vector<WeaponType *> weapontype;
	extern vector<ClipType *> cliptype;
	cr.give_armor(getarmortype(tag_ARMOR_CLOTHES), NULL);
	switch (LCSrandom(5) + endgamestate)
	{
	case 0:
	case 1:
		break;
	case 2:
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SEMIPISTOL_9MM)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_9)], 7);
	}
	break;
	case 3:
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_REVOLVER_44)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_44)], 7);
	}
	break;
	case 4:
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SHOTGUN_PUMP)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_BUCKSHOT)], 7);
	}
	break;
	case 5:
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SEMIRIFLE_AR15)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_ASSAULT)], 7);
		cr.give_armor(getarmortype(tag_ARMOR_CIVILLIANARMOR), NULL);
	}
	break;
	case 6:
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SEMIRIFLE_AR15)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_ASSAULT)], 7);
		cr.give_armor(getarmortype(tag_ARMOR_ARMYARMOR), NULL);
	}
	break;
	default:
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_AUTORIFLE_M16)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_ASSAULT)], 7);
		cr.give_armor(getarmortype(tag_ARMOR_ARMYARMOR), NULL);
	}
	break;
	}
	cr.reload(false);
	if (mode == GAMEMODE_SITE/* && sitealarm>0*/)
		nameCCSMember(cr);
}
void armCREATURE_CCS_ARCHCONSERVATIVE(Creature &cr) {
	extern short mode;
	extern short sitetype;
	extern short cursite;
	extern char ccs_kills;
	extern short sitealarm;
	extern char endgamestate;
	strcpy(cr.name, (LocationsPool::getInstance().isThereASiegeHere(cursite) ? CONST_creaturetypes046.c_str() : (ccs_kills < 2 ? CONST_creaturetypesX01.c_str() : CONST_creaturetypesX02.c_str())));
}
void armCREATURE_PRISONGUARD(Creature &cr) {
	extern vector<ClipType *> cliptype;
	extern vector<WeaponType *> weapontype;
	extern short lawList[LAWNUM];
	if (lawList[LAW_GUNCONTROL] == -2 && !LCSrandom(3))
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SMG_MP5)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_SMG)], 4);
	}
	else if (!LCSrandom(3))
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SHOTGUN_PUMP)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_BUCKSHOT)], 4);
	}
	else
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_NIGHTSTICK)], NULL);
	cr.reload(false);
}
void armCREATURE_EDUCATOR(Creature &cr) {
	extern vector<ClipType *> cliptype;
	extern vector<WeaponType *> weapontype;
	extern short lawList[LAWNUM];
	if (lawList[LAW_GUNCONTROL] == -2 && !LCSrandom(3))
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SMG_MP5)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_SMG)], 4);
	}
	else if (!LCSrandom(3))
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SEMIPISTOL_9MM)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_9)], 4);
	}
	else
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SYRINGE)], NULL);
	cr.reload(false);
}
void armCREATURE_GENETIC(Creature &cr, int(&attcap)[ATTNUM]) {
	extern short mode;
	extern short sitetype;
	extern short cursite;
	extern char ccs_kills;
	extern short sitealarm;
	extern char endgamestate;
	extern short lawList[LAWNUM];
	if (LocationsPool::getInstance().getLocationType(cursite) == SITE_CORPORATE_HOUSE)
	{
		strcpy(cr.name, CONST_creaturetypes047.c_str());
		attcap[ATTRIBUTE_CHARISMA] = 10;
	}
	else
		strcpy(cr.name, blankString.c_str());
	switch (LCSrandom(11))
	{
	case 0:strcat(cr.name, CONST_creaturetypes048.c_str());
		cr.specialattack = ATTACK_FLAME;
		break;
	case 1:strcat(cr.name, CONST_creaturetypes049.c_str());
		cr.specialattack = ATTACK_SUCK;
		break;
	default:
		strcat(cr.name, pickrandom(genetic_monster).data());
		break;
	}
	cr.animalgloss = ANIMALGLOSS_ANIMAL;
	if (lawList[LAW_ANIMALRESEARCH] != 2)cr.money = 0;
}
void armCREATURE_GUARDDOG(Creature &cr) {
	extern short lawList[LAWNUM];
	cr.animalgloss = ANIMALGLOSS_ANIMAL;
	if (lawList[LAW_ANIMALRESEARCH] != 2)cr.money = 0;
}
void armCREATURE_PRISONER(Creature &cr, const CreatureType* crtype) {
	cr.drop_weapons_and_clips(NULL);
	crtype->give_weapon(cr);
	cr.strip(NULL);
	crtype->give_armor(cr);
	cr.money = crtype->money_.roll();
	cr.juice = crtype->juice_.roll();
	cr.gender_liberal = cr.gender_conservative = crtype->roll_gender();
	strcpy(cr.name, crtype->get_encounter_name().c_str());
	if (cr.align == ALIGN_CONSERVATIVE)
		cr.align = LCSrandom(2);
}
void armCREATURE_BUM(Creature &cr) {
	extern vector<WeaponType *> weapontype;
	if (!cr.is_armed() && !LCSrandom(5))
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SHANK)], NULL);
	if (cr.align == ALIGN_CONSERVATIVE)cr.align = LCSrandom(2);
}
void armCREATURE_MUTANT(Creature &cr) {
	extern vector<WeaponType *> weapontype;
	if (!cr.is_armed() && !LCSrandom(5))
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SHANK)], NULL);
}
void armCREATURE_GANGMEMBER(Creature &cr) {
	extern vector<WeaponType *> weapontype;
	extern short mode;
	extern short sitetype;
	extern short cursite;
	extern char ccs_kills;
	extern short sitealarm;
	extern char endgamestate;
	extern short lawList[LAWNUM];
	extern vector<ClipType *> cliptype;
	if (!LCSrandom(20) || (lawList[LAW_GUNCONTROL] == -2 && !LCSrandom(5)))
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_AUTORIFLE_AK47)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_ASSAULT)], 3);
	}
	else if (!LCSrandom(16) || (lawList[LAW_GUNCONTROL] == -2 && !LCSrandom(5)))
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SMG_MP5)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_SMG)], 4);
	}
	else if (!LCSrandom(15))
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SEMIPISTOL_45)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_45)], 4);
	}
	else if (!LCSrandom(10))
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SHOTGUN_PUMP)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_BUCKSHOT)], 4);
	}
	else if (!LCSrandom(4))
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SEMIPISTOL_9MM)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_9)], 4);
	}
	else if (!LCSrandom(2))
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_REVOLVER_38)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_38)], 4);
	}
	else
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_COMBATKNIFE)], NULL);
	cr.reload(false);
	// We'll make the crack house a bit dicey
	if (LocationsPool::getInstance().getLocationType(cursite) == SITE_BUSINESS_CRACKHOUSE)cr.align = ALIGN_CONSERVATIVE;
	if (!LCSrandom(2))switch (LCSrandom(3))
	{
	case 0://cr.crimes_committed[LAWFLAG_BROWNIES]++;
		cr.crimes_suspected[LAWFLAG_BROWNIES]++;
		break;
	case 1://cr.crimes_committed[LAWFLAG_ASSAULT]++;
		cr.crimes_suspected[LAWFLAG_ASSAULT]++;
		break;
	case 2://cr.crimes_committed[LAWFLAG_MURDER]++;
		cr.crimes_suspected[LAWFLAG_MURDER]++;
		break;
	}
}
void armCREATURE_CRACKHEAD(Creature &cr, int(&attcap)[ATTNUM]) {
	extern vector<WeaponType *> weapontype;
	if (!LCSrandom(5))
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SHANK)], NULL);
	if (cr.align == ALIGN_CONSERVATIVE)cr.align = LCSrandom(2);
	attcap[ATTRIBUTE_HEALTH] = 1 + LCSrandom(5);
}
void armCREATURE_FASTFOODWORKER(Creature &cr) {
	cr.age = (LCSrandom(2) ? AGE_TEENAGER : AGE_YOUNGADULT);
}
void armCREATURE_FOOTBALLCOACH(Creature &cr) {
	if (LCSrandom(2))
	{
		cr.set_attribute(ATTRIBUTE_HEALTH, 5);
		cr.set_attribute(ATTRIBUTE_AGILITY, 5);
		cr.set_attribute(ATTRIBUTE_STRENGTH, 5);
	}
}
void armCREATURE_PROSTITUTE(Creature &cr) {
	if (LCSrandom(7))cr.gender_conservative = cr.gender_liberal = GENDER_FEMALE;
	else if (!LCSrandom(3))cr.gender_liberal = GENDER_FEMALE;
	if (cr.align == ALIGN_CONSERVATIVE)cr.align = LCSrandom(2);
	if (!LCSrandom(3))cr.crimes_suspected[LAWFLAG_PROSTITUTION]++;
}
void armCREATURE_HIPPIE(Creature &cr) {
	if (!LCSrandom(10))
		cr.crimes_suspected[LAWFLAG_BROWNIES]++;
}
void armCREATURE_SOCIALITE(Creature &cr) {
	cr.give_armor(getarmortype(cr.gender_liberal == GENDER_FEMALE ? tag_ARMOR_EXPENSIVEDRESS : tag_ARMOR_EXPENSIVESUIT), NULL);
}
void armCREATURE_THIEF(Creature &cr) {
	switch (LCSrandom(5))
	{
	case 0:strcpy(cr.name, getcreaturetype(CREATURE_SOCIALITE)->get_encounter_name().c_str());
		break;
	case 1:strcpy(cr.name, getcreaturetype(CREATURE_CLERK)->get_encounter_name().c_str());
		break;
	case 2:strcpy(cr.name, getcreaturetype(CREATURE_OFFICEWORKER)->get_encounter_name().c_str()); break;
	case 3:strcpy(cr.name, getcreaturetype(CREATURE_CRITIC_ART)->get_encounter_name().c_str()); break;
	case 4:strcpy(cr.name, getcreaturetype(CREATURE_CRITIC_MUSIC)->get_encounter_name().c_str()); break;
	}
	if (!LCSrandom(10))cr.crimes_suspected[(LCSrandom(2) ? LAWFLAG_BREAKING : LAWFLAG_THEFT)]++;
}
void armCREATURE_MILITARYOFFICER(Creature &cr) {
	extern vector<WeaponType *> weapontype;
	extern vector<ClipType *> cliptype;
	if (LCSrandom(4))
	{
		cr.give_weapon(*weapontype[getweapontype(tag_WEAPON_SEMIPISTOL_9MM)], NULL);
		cr.take_clips(*cliptype[getcliptype(tag_CLIP_9)], 4);
		cr.reload(false);
	}
}
// IsaacG Very few of the nested functions require anything other than &cr and type.  A rewrite that only uses those two parameters is desirable.
void armSpecificCreature(Creature &cr, const short type, const CreatureType* crtype, int(&attcap)[ATTNUM]) {
	switch (type)
	{
	case CREATURE_BOUNCER:
		armBouncer(cr);
		break;
	case CREATURE_SCIENTIST_LABTECH:
		armCREATURE_SCIENTIST_LABTECH(cr);
		break;
	case CREATURE_JUDGE_CONSERVATIVE:
		armCREATURE_JUDGE_CONSERVATIVE(cr);
		break;
	case CREATURE_SCIENTIST_EMINENT:
		armCREATURE_SCIENTIST_EMINENT(cr);
		break;
	case CREATURE_CORPORATE_CEO:
		armCREATURE_CORPORATE_CEO(cr);
		break;
	case CREATURE_WORKER_FACTORY_NONUNION:
		armCREATURE_WORKER_FACTORY_NONUNION(cr);
		break;
	case CREATURE_WORKER_SWEATSHOP:
		armCREATURE_WORKER_SWEATSHOP(cr);
		break;
	case CREATURE_LAWYER:
		armCREATURE_LAWYER(cr);
		break;
	case CREATURE_DOCTOR:
		armCREATURE_DOCTOR(cr);
		break;
	case CREATURE_PSYCHOLOGIST:
		armCREATURE_PSYCHOLOGIST(cr);
		break;
	case CREATURE_NURSE:
		armCREATURE_NURSE(cr);
		break;
	case CREATURE_WORKER_FACTORY_UNION:
		armCREATURE_WORKER_FACTORY_UNION(cr);
		break;
	case CREATURE_TANK:
		armCREATURE_TANK(cr);
		break;
	case CREATURE_HICK:
		armCREATURE_HICK(cr);
		break;
	case CREATURE_COP:
		armCREATURE_COP(cr);
		break;
	case CREATURE_FIREFIGHTER:
		armCREATURE_FIREFIGHTER(cr);
		break;
	case CREATURE_CCS_MOLOTOV:
		armCREATURE_CCS_MOLOTOV(cr);
		break;
	case CREATURE_CCS_SNIPER:
		armCREATURE_CCS_SNIPER(cr);
		break;
	case CREATURE_CCS_VIGILANTE:
		armCREATURE_CCS_VIGILANTE(cr);
		break;
	case CREATURE_CCS_ARCHCONSERVATIVE:
		armCREATURE_CCS_ARCHCONSERVATIVE(cr);
		break;
	case CREATURE_PRISONGUARD:
		armCREATURE_PRISONGUARD(cr);
		break;
	case CREATURE_EDUCATOR:
		armCREATURE_EDUCATOR(cr);
		break;
	case CREATURE_GENETIC:
		armCREATURE_GENETIC(cr, attcap);
		break;
	case CREATURE_GUARDDOG:
		armCREATURE_GUARDDOG(cr);
		break;
	case CREATURE_PRISONER:
		armCREATURE_PRISONER(cr, crtype);
		break;
	case CREATURE_BUM:
		armCREATURE_BUM(cr);
		break;
	case CREATURE_MUTANT:
		armCREATURE_MUTANT(cr);
		break;
	case CREATURE_GANGMEMBER:
		armCREATURE_GANGMEMBER(cr);
		break;
	case CREATURE_CRACKHEAD:
		armCREATURE_CRACKHEAD(cr, attcap);
		break;
	case CREATURE_FASTFOODWORKER:
		armCREATURE_FASTFOODWORKER(cr);
		break;
	case CREATURE_FOOTBALLCOACH:
		armCREATURE_FOOTBALLCOACH(cr);
		break;
	case CREATURE_PROSTITUTE:
		armCREATURE_PROSTITUTE(cr);
		break;
	case CREATURE_HIPPIE:
		armCREATURE_HIPPIE(cr);
		break;
	case CREATURE_SOCIALITE:
		armCREATURE_SOCIALITE(cr);
		break;
	case CREATURE_THIEF:
		armCREATURE_THIEF(cr);
		break;
	case CREATURE_MILITARYOFFICER:
		armCREATURE_MILITARYOFFICER(cr);
		break;
	}


}
void armCreature(Creature &cr, short type) {

	const CreatureType* crtype = getcreaturetype(type);
	crtype->make_creature(cr);
	int attnum = crtype->attribute_points_.roll();
	int attcap[ATTNUM];
	for (int i = 0; i < ATTNUM; i++)
	{
		cr.set_attribute(i, crtype->attributes_[i].min);
		attcap[i] = crtype->attributes_[i].max;
	}
	bool skipThisCreature = false;
	for (CreatureTypes crt : doNotArmInThisFunction) {
		if (crt == type) {
			skipThisCreature = true;
			break;
		}
	}
	for (CreatureTypes crt : armAsCivilian) {
		if (crt == type) {
			crtype->give_weapon_civilian(cr);
			break;
		}
	}
	if (replaceTheseCreatures.count(type) >= 1) {
		CreatureTypes replacement = pickrandom(replaceTheseCreatures[type]);
		makecreature(cr, replacement);
	}
	giveDefaultWeapon(cr, type);
	if (!skipThisCreature)
		armSpecificCreature(cr, type, crtype, attcap);

	vector<int> possible;
	for (int a = 0; a < ATTNUM; a++)
	{
		attnum -= min(4, cr.get_attribute(a, false));
		possible.push_back(a);
	}
	while (attnum > 0 && len(possible))
	{
		int i = LCSrandom(len(possible));
		int a = possible[i];
		if (a == ATTRIBUTE_WISDOM && cr.align == ALIGN_LIBERAL && LCSrandom(4)) a = ATTRIBUTE_HEART;
		if (a == ATTRIBUTE_HEART && cr.align == ALIGN_CONSERVATIVE && LCSrandom(4)) a = ATTRIBUTE_WISDOM;
		if (cr.get_attribute(a, false) < attcap[a])
		{
			cr.adjust_attribute(a, +1);
			attnum--;
		}
		else possible.erase(possible.begin() + i);
	}

	possible.clear();
}


/* rolls up a creature's stats and equipment */
void makecreature(Creature &cr, short type)
{
	extern short sitealienate;
	extern short cursite;
	cr.drop_weapons_and_clips(NULL); // Get rid of any old equipment from old encounters.
	cr.strip(NULL);                  //
	cr.creatureinit();
	cr.exists = 1;
	cr.squadid = -1;
	cr.type = type;
	cr.infiltration = 0;
	cr.location = cursite;
	cr.worklocation = cursite;
	verifyworklocation(cr);

	armCreature(cr, type);

	if (cr.align == ALIGN_LIBERAL) cr.infiltration = 0.15f + (LCSrandom(10) - 5)*0.01f;
	else if (cr.align == ALIGN_MODERATE) cr.infiltration = 0.25f + (LCSrandom(10) - 5)*0.01f;
	else cr.infiltration += 0.35f*(1 - cr.infiltration) + (LCSrandom(10) - 5)*0.01f;
	if (cr.infiltration < 0) cr.infiltration = 0;
	if (cr.infiltration > 1) cr.infiltration = 1;
	int randomskills = LCSrandom(4) + 4;
	if (cr.age > 20) randomskills += static_cast<int>(randomskills*((cr.age - 20.0) / 20.0));
	else randomskills -= (20 - cr.age) / 2;
	vector<int> possible;
	for (int s = 0; s < SKILLNUM; s++)possible.push_back(s);
	//RANDOM STARTING SKILLS
	while (randomskills > 0 && len(possible))
	{
		int i = LCSrandom(len(possible));
		int randomskill = possible[i];
		// 95% chance of not allowing some skills for anybody...
		if (LCSrandom(20))
		{
			if (randomskill == SKILL_HEAVYWEAPONS) continue;
			if (randomskill == SKILL_SMG) continue;
			if (randomskill == SKILL_SWORD) continue;
			if (randomskill == SKILL_RIFLE) continue;
			if (randomskill == SKILL_AXE) continue;
			if (randomskill == SKILL_CLUB) continue;
			if (randomskill == SKILL_PSYCHOLOGY) continue;
		}
		// 90% chance of not allowing some skills, other than
		//   for conservatives
		if (LCSrandom(10) && cr.align != ALIGN_CONSERVATIVE)
		{
			if (randomskill == SKILL_SHOTGUN) continue;
			if (randomskill == SKILL_PISTOL) continue;
		}
		if (cr.skill_cap(randomskill, true) > cr.get_skill(randomskill))
		{
			cr.set_skill(randomskill, cr.get_skill(randomskill) + 1);
			randomskills--;
			while (randomskills&&LCSrandom(2))
			{
				if (cr.skill_cap(randomskill, true) > cr.get_skill(randomskill) &&
					cr.get_skill(randomskill) < 4)
				{
					cr.set_skill(randomskill, cr.get_skill(randomskill) + 1);
					randomskills--;
				}
				else
				{
					possible.erase(possible.begin() + i);
					break;
				}
			}
		}
		else possible.erase(possible.begin() + i);
	}
	//ALIENATION
	if ((sitealienate >= 1 && cr.align == ALIGN_MODERATE) || (sitealienate == 2 && cr.align == ALIGN_LIBERAL))conservatise(cr);
}
map<int, vector<SiteTypes> > okaySiteList = {
map<int, vector<SiteTypes> >::value_type(CREATURE_BOUNCER,{
SITE_BUSINESS_CIGARBAR,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_POLITICIAN,{
SITE_GOVERNMENT_WHITE_HOUSE,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_CORPORATE_CEO,{
SITE_CORPORATE_HEADQUARTERS,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_SECURITYGUARD,{
SITE_RESIDENTIAL_APARTMENT_UPSCALE,
SITE_LABORATORY_COSMETICS,
SITE_LABORATORY_GENETIC,
SITE_GOVERNMENT_COURTHOUSE,
SITE_GOVERNMENT_INTELLIGENCEHQ,
SITE_INDUSTRY_SWEATSHOP,
SITE_INDUSTRY_POLLUTER,
SITE_INDUSTRY_NUCLEAR,
SITE_CORPORATE_HEADQUARTERS,
SITE_CORPORATE_HOUSE,
SITE_MEDIA_AMRADIO,
SITE_MEDIA_CABLENEWS,
SITE_BUSINESS_CIGARBAR,
SITE_BUSINESS_BANK,
//SITE_GOVERNMENT_FIRESTATION,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_BANK_MANAGER,{
SITE_BUSINESS_BANK,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_BANK_TELLER,{
SITE_BUSINESS_BANK,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_SCIENTIST_LABTECH,{
SITE_LABORATORY_COSMETICS,
SITE_LABORATORY_GENETIC,
SITE_INDUSTRY_NUCLEAR,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_SCIENTIST_EMINENT,{
SITE_LABORATORY_COSMETICS,
SITE_LABORATORY_GENETIC,
SITE_INDUSTRY_NUCLEAR,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_CORPORATE_MANAGER,{
SITE_LABORATORY_COSMETICS,
SITE_LABORATORY_GENETIC,
SITE_INDUSTRY_SWEATSHOP,
SITE_INDUSTRY_POLLUTER,
SITE_INDUSTRY_NUCLEAR,
SITE_CORPORATE_HEADQUARTERS,
SITE_MEDIA_AMRADIO,
SITE_MEDIA_CABLENEWS,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_WORKER_SERVANT,{
SITE_CORPORATE_HOUSE,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_WORKER_JANITOR,{
SITE_RESIDENTIAL_TENEMENT,
SITE_RESIDENTIAL_APARTMENT,
SITE_RESIDENTIAL_APARTMENT_UPSCALE,
SITE_LABORATORY_COSMETICS,
SITE_LABORATORY_GENETIC,
SITE_HOSPITAL_CLINIC,
SITE_HOSPITAL_UNIVERSITY,
SITE_GOVERNMENT_POLICESTATION,
SITE_GOVERNMENT_COURTHOUSE,
SITE_GOVERNMENT_PRISON,
SITE_GOVERNMENT_INTELLIGENCEHQ,
SITE_INDUSTRY_POLLUTER,
SITE_INDUSTRY_NUCLEAR,
SITE_CORPORATE_HEADQUARTERS,
SITE_MEDIA_AMRADIO,
SITE_MEDIA_CABLENEWS,
SITE_BUSINESS_PAWNSHOP,
SITE_BUSINESS_CRACKHOUSE,
SITE_BUSINESS_JUICEBAR,
SITE_BUSINESS_CIGARBAR,
SITE_BUSINESS_LATTESTAND,
SITE_BUSINESS_VEGANCOOP,
SITE_BUSINESS_INTERNETCAFE,
SITE_BUSINESS_DEPTSTORE,
SITE_BUSINESS_HALLOWEEN,
SITE_GOVERNMENT_FIRESTATION,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_WORKER_SWEATSHOP,{
SITE_INDUSTRY_SWEATSHOP,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_WORKER_FACTORY_NONUNION,{
SITE_INDUSTRY_POLLUTER,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_WORKER_FACTORY_CHILD,{
SITE_INDUSTRY_POLLUTER,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_WORKER_SECRETARY,{
SITE_LABORATORY_COSMETICS,
SITE_LABORATORY_GENETIC,
SITE_HOSPITAL_CLINIC,
SITE_HOSPITAL_UNIVERSITY,
SITE_GOVERNMENT_POLICESTATION,
SITE_GOVERNMENT_COURTHOUSE,
SITE_GOVERNMENT_INTELLIGENCEHQ,
SITE_INDUSTRY_POLLUTER,
SITE_INDUSTRY_NUCLEAR,
SITE_CORPORATE_HEADQUARTERS,
SITE_CORPORATE_HOUSE,
SITE_MEDIA_AMRADIO,
SITE_MEDIA_CABLENEWS,
SITE_GOVERNMENT_FIRESTATION,
SITE_GOVERNMENT_WHITE_HOUSE,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_WORKER_FACTORY_UNION,{
SITE_INDUSTRY_POLLUTER,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_LANDLORD,{
SITE_RESIDENTIAL_TENEMENT,
SITE_RESIDENTIAL_APARTMENT,
SITE_RESIDENTIAL_APARTMENT_UPSCALE,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_TEENAGER,{
SITE_RESIDENTIAL_TENEMENT,
SITE_RESIDENTIAL_APARTMENT,
SITE_RESIDENTIAL_APARTMENT_UPSCALE,
SITE_RESIDENTIAL_SHELTER,
SITE_CORPORATE_HOUSE,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_COP,{
SITE_GOVERNMENT_POLICESTATION,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_DEATHSQUAD,{
SITE_GOVERNMENT_POLICESTATION,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_FIREFIGHTER,{
SITE_GOVERNMENT_FIRESTATION,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_GANGUNIT,{
SITE_GOVERNMENT_POLICESTATION,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_SWAT,{
SITE_GOVERNMENT_POLICESTATION,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_JUDGE_LIBERAL,{
SITE_GOVERNMENT_COURTHOUSE,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_JUDGE_CONSERVATIVE,{
SITE_GOVERNMENT_COURTHOUSE,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_SECRET_SERVICE,{
SITE_GOVERNMENT_WHITE_HOUSE,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_AGENT,{
SITE_GOVERNMENT_INTELLIGENCEHQ,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_RADIOPERSONALITY,{
SITE_MEDIA_AMRADIO,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_NEWSANCHOR,{
SITE_MEDIA_CABLENEWS,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_GENETIC,{
SITE_LABORATORY_GENETIC,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_GUARDDOG,{
SITE_GOVERNMENT_PRISON,
SITE_GOVERNMENT_INTELLIGENCEHQ,
SITE_CORPORATE_HOUSE,
SITE_GOVERNMENT_ARMYBASE,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_PRISONER,{
SITE_RESIDENTIAL_TENEMENT,
SITE_RESIDENTIAL_SHELTER,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_JUROR,{
SITE_RESIDENTIAL_APARTMENT,
SITE_RESIDENTIAL_TENEMENT,
SITE_RESIDENTIAL_SHELTER,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_LAWYER,{
SITE_GOVERNMENT_COURTHOUSE,
SITE_GOVERNMENT_WHITE_HOUSE,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_DOCTOR,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_PSYCHOLOGIST,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_NURSE,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_SEWERWORKER,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_COLLEGESTUDENT,{
SITE_UDISTRICT,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_MUSICIAN,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_MATHEMATICIAN,{
SITE_UDISTRICT,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_TEACHER,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_HSDROPOUT,{
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_BUM,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
SITE_RESIDENTIAL_SHELTER,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_GANGMEMBER,{
SITE_BUSINESS_CRACKHOUSE,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_CRACKHEAD,{
SITE_BUSINESS_CRACKHOUSE,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_PRIEST,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_ENGINEER,{
SITE_MEDIA_AMRADIO,
SITE_MEDIA_CABLENEWS,
SITE_INDUSTRY_NUCLEAR,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_FASTFOODWORKER,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_BAKER,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_BARISTA,{
SITE_BUSINESS_LATTESTAND,
SITE_BUSINESS_INTERNETCAFE,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_BARTENDER,{
SITE_BUSINESS_CIGARBAR,
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_TELEMARKETER,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_CARSALESMAN,{
SITE_BUSINESS_CARDEALERSHIP,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_OFFICEWORKER,{
SITE_LABORATORY_COSMETICS,
SITE_LABORATORY_GENETIC,
SITE_HOSPITAL_CLINIC,
SITE_HOSPITAL_UNIVERSITY,
SITE_GOVERNMENT_COURTHOUSE,
SITE_CORPORATE_HEADQUARTERS,
SITE_MEDIA_AMRADIO,
SITE_MEDIA_CABLENEWS,
SITE_BUSINESS_DEPTSTORE,
SITE_GOVERNMENT_WHITE_HOUSE,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_FOOTBALLCOACH,{
SITE_UDISTRICT,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_PROSTITUTE,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_MAILMAN,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_GARBAGEMAN,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_PLUMBER,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_CHEF,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
SITE_BUSINESS_CIGARBAR,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_CONSTRUCTIONWORKER,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_AMATEURMAGICIAN,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_TANK,{
SITE_GOVERNMENT_ARMYBASE,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_MERC,{
SITE_CORPORATE_HEADQUARTERS,
SITE_CORPORATE_HOUSE,
SITE_INDUSTRY_NUCLEAR,
SITE_LABORATORY_GENETIC,
SITE_BUSINESS_BANK,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_HICK,{
SITE_MEDIA_AMRADIO,
SITE_MEDIA_CABLENEWS,
SITE_OUTOFTOWN,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_VETERAN,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_HARDENED_VETERAN,{
SITE_GOVERNMENT_ARMYBASE,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_SOLDIER,{
SITE_GOVERNMENT_ARMYBASE,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_MILITARYPOLICE,{
SITE_GOVERNMENT_ARMYBASE,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_MILITARYOFFICER,{
SITE_GOVERNMENT_ARMYBASE,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_SEAL,{
SITE_GOVERNMENT_ARMYBASE,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_EDUCATOR, {
	SITE_GOVERNMENT_PRISON,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_PRISONGUARD,{
SITE_GOVERNMENT_PRISON,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_HIPPIE,{
SITE_BUSINESS_VEGANCOOP,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_CRITIC_ART,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
SITE_MEDIA_CABLENEWS,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_CRITIC_MUSIC,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
SITE_MEDIA_AMRADIO,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_SOCIALITE,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_PROGRAMMER,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
SITE_GOVERNMENT_INTELLIGENCEHQ,
SITE_CORPORATE_HEADQUARTERS,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_RETIREE,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_PAINTER,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_SCULPTOR,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_AUTHOR,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_JOURNALIST,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_DANCER,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_PHOTOGRAPHER,{
SITE_MEDIA_CABLENEWS,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_CAMERAMAN,{
SITE_MEDIA_CABLENEWS,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_HAIRSTYLIST,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_FASHIONDESIGNER,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_CLERK,{
SITE_BUSINESS_JUICEBAR,
SITE_BUSINESS_LATTESTAND,
SITE_BUSINESS_INTERNETCAFE,
SITE_BUSINESS_DEPTSTORE,
SITE_BUSINESS_HALLOWEEN,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_THIEF,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_ACTOR,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_YOGAINSTRUCTOR,{
SITE_BUSINESS_VEGANCOOP,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_MARTIALARTIST,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_ATHLETE,{
SITE_UDISTRICT,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_BIKER,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_TRUCKER,{
SITE_OUTOFTOWN,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_TAXIDRIVER,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_NUN,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
map<int, vector<SiteTypes> >::value_type(CREATURE_LOCKSMITH,{
SITE_DOWNTOWN,
SITE_UDISTRICT,
SITE_INDUSTRIAL,
}),
};

vector<SiteTypes> defaultSiteList = {
	SITE_RESIDENTIAL_SHELTER
};
/* ensures that the creature's work location is appropriate to its type */
bool verifyworklocation(Creature &cr, char test_location, char test_type)
{
	extern bool multipleCityMode;
	extern char ccs_kills;
	int okaysite[SITENUM];
	memset(okaysite, 0, SITENUM * sizeof(int));
	// If the caller sets test_type, they're just
	// asking if the chosen creature type is appropriate
	// to the location they provided, not actually setting
	// the creature work location -- this is useful
	// for things like stealth
	short type = (test_type != -1 ? test_type : cr.type);
	// TODO this can be extracted to a table
	if (type == CREATURE_CCS_ARCHCONSERVATIVE || type == CREATURE_CCS_MOLOTOV ||
		type == CREATURE_CCS_SNIPER || type == CREATURE_CCS_VIGILANTE) {

		if (ccs_kills == 2)okaysite[SITE_OUTDOOR_BUNKER] = 1;
		if (ccs_kills == 1)okaysite[SITE_RESIDENTIAL_BOMBSHELTER] = 1;
		if (ccs_kills == 0)okaysite[SITE_BUSINESS_BARANDGRILL] = 1;
	}
	else {
		if (okaySiteList.count(type)) {
			for (SiteTypes s : okaySiteList[type]) {
				okaysite[s] = 1;
			}
		}
		else {
			for (SiteTypes s : defaultSiteList) {
				okaysite[s] = 1;
			}
		}
	}

	// Quick exit if only checking if a certain type works
	if (test_type != -1) return okaysite[(int)test_location];
	char swap = 0;
	if (cr.worklocation == -1) swap = 1;
	else if (!okaysite[(int)LocationsPool::getInstance().getLocationType((int)cr.worklocation)]) swap = 1;
	if (swap)
	{
		//int city = location[cr.location]->city;
		//PICK A TYPE OF WORK LOCATION
		//cr.worklocation=choose_one(okaysite,SITENUM,0);
		//FIND ONE OF THESE
		vector<int> goodlist;
		//find_site_index_in_city(cr.worklocation, location[cr.location]->city);
		for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++)
			//if(location[l]->type==cr.worklocation && (!multipleCityMode || location[l]->city == cr.location))
			if (okaysite[(int)LocationsPool::getInstance().getLocationType(l)] && (!multipleCityMode || LocationsPool::getInstance().getLocationCity(l) == LocationsPool::getInstance().getLocationCity(cr.location)))
				goodlist.push_back(l);
		// Sadler - This line sometimes causes a memory fault
		//               Only thing I can think of is if loop above didn't
		//               find any locations of type == to cr.worklocation
		//               My hunch is that some locations, such as the 1st four
		//               are special and cannot be used here..
		//
		//   TODO There was a bug in the makecharacter() code where the
		//   SITE_OUTOFTOWN was not set properly. This was fixed but the bug here
		//   is still occurring, normally at the Latte Bar Downtown ;
		if (!len(goodlist)) cr.worklocation = 0;
		else cr.worklocation = pickrandom(goodlist);
	}
	return false;
}


CreatureType::WeaponsAndClips::WeaponsAndClips(CMarkup& xml, const string& owner)
	: number_weapons(1),
	cliptype(tag_APPROPRIATE), number_clips(4)
{
	extern string NONE;
	extern vector<WeaponType *> weapontype;
	extern Log xmllog;
	weapon_type_str = xml.GetData();
	// Read in values.
	if (!len(weapontype))
	{
		while (xml.FindChildElem())
		{
			std::string element = xml.GetChildTagName();
			if (element == tag_type) weapon_type_str = xml.GetChildData();
			else if (element == tag_number_weapons)
				assign_interval(number_weapons, xml.GetChildData(), owner, element);
			else if (element == tag_cliptype) cliptype = xml.GetChildData();
			else if (element == tag_number_clips)
				assign_interval(number_clips, xml.GetChildData(), owner, element);
			else xmllog.log(CONST_creaturetype056 + owner + CONST_creaturetypeB086 + element);
		}
	}
	// Check values.
	if (weapon_type_str != tag_CIVILIAN)
	{
		if (getweapontype(weapon_type_str) == -1)
		{
			xmllog.log(CONST_creaturetype057 + owner + CONST_creaturetypeB086 + weapon_type_str);
			weapon_type_str = tag_WEAPON_NONE;
			cliptype = NONE;
		}
		else
		{
			const vector<attackst*>& attacks = weapontype[getweapontype(weapon_type_str)]->get_attacks();
			// Find a usable clip type for the weapon.
			if (cliptype == tag_APPROPRIATE)
			{
				cliptype = NONE;
				for (int i = 0; i < len(attacks); i++)
				{
					if (attacks[i]->uses_ammo)
					{
						cliptype = attacks[i]->ammotype;
						break;
					}
				}
			}
			// Check clip is usable by the weapon.
			else if (getcliptype(cliptype) != -1) //Must be a clip type too.
			{
				int i;
				for (i = 0; i < len(attacks) && cliptype != attacks[i]->ammotype; i++);
				if (i == len(attacks))
				{
					xmllog.log(CONST_creaturetype058 + owner + CONST_creaturetypeB078 + cliptype +
						CONST_creaturetype059 + weapon_type_str + singleDot);
					cliptype = NONE;
				}
			}
			// Undefined clip type.
			else
			{
				xmllog.log(CONST_creaturetype060 + owner + CONST_creaturetypeB086 + cliptype);
				cliptype = NONE;
			}
		}
	}
}

// #include "../includes.h"


void majornewspaper(char &clearformess, char canseethings);
//// #include "../sitemode/sitemode.h"
void mode_site(short loc);
/* squad members with no chain of command lose contact */
void dispersalcheck(char &clearformess);

#include "../daily/activities.h"
char recruitment_activity(Creature &cr);
char completerecruitmeeting(recruitst &d, int p);
//// #include "../daily/date.h"
char completevacation(datest &d, int p);
char completedate(datest &d, int p);
#include "../title/titlescreen.h"
const string CONST_shopsnstuff008 = "oubliette.xml";
const string CONST_shopsnstuff007 = "deptstore.xml";
const string CONST_shopsnstuff006 = "P - Repaint car, replace plates and tags ($500)";
const string CONST_shopsnstuff005 = "pawnshop.xml";
const string CONST_shopsnstuff004 = "armsdealer.xml";

#include "../sitemode/shop.h"
string toSpend;
string chooseAColor;
string theseColorsAreCon;
string thisColor;
string notEnoughMoney;
string chooseVehicle;
string thisVehicle;
string weDontNeedCar;
string enterLeave;
string b_chooseBuyer;
string s_sellCar;
string s_sellThe;
string g_getCar;
string f_fixWounds;
/* active squad visits the hospital */
void hospital(int loc)
{
	extern squadst *activesquad;
	extern MusicClass music;
	extern short party_status;
	music.play(MUSIC_SHOPPING);
	locatesquad(activesquad, loc);
	int partysize = squadsize(activesquad);
	while (true)
	{
		eraseAlt();
		locheader();
		printparty();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(10, 1, f_fixWounds);
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(12, 1, enterLeave);
		if (partysize > 0 && (party_status == -1 || partysize > 1)) set_color_easy(WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(13, 1, check_status_of_squad_liberal);
		if (party_status != -1) set_color_easy(WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(14, 1, show_squad_liberal_status);
		int c = getkeyAlt();
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
		if (c == '0') party_status = -1;
		if (c >= '1'&&c <= '6'&&activesquad != NULL)
			if (activesquad->squad[c - '1'] != NULL)
			{
				if (party_status == c - '1')fullstatus(party_status);
				else party_status = c - '1';
			}
		if (c == 'f')
		{
			for (int p = 5; p >= 0; p--)
			{
				if (activesquad->squad[p] == NULL)continue;
				hospitalize(loc, *activesquad->squad[p]);
			}
			break;
		}
	}
}
/* active squad visits the arms dealer */
void armsdealer(int loc)
{
	extern squadst *activesquad;
	extern MusicClass music;
	extern char artdir[MAX_PATH_SIZE];
	music.play(MUSIC_SHOPPING);
	locatesquad(activesquad, loc);
	CMarkup xml; // -XML
	xml.Load(string(artdir) + CONST_shopsnstuff004);
	Shop armsdealer(xml.GetDoc());
	armsdealer.enter(*activesquad);
}
/* active squad visits the pawn shop */
void pawnshop(int loc)
{
	extern squadst *activesquad;
	extern MusicClass music;
	extern char artdir[MAX_PATH_SIZE];
	music.play(MUSIC_SHOPPING);
	locatesquad(activesquad, loc);
	CMarkup xml; // -XML
	xml.Load(string(artdir) + CONST_shopsnstuff005);
	Shop pawnshop(xml.GetDoc());
	pawnshop.enter(*activesquad);
}
/* choose buyer */
void choose_buyer(short &buyer)
{
	extern squadst *activesquad;
	extern short party_status;
	party_status = -1;
	int partysize = squadsize(activesquad);
	if (partysize <= 1) return;
	while (true)
	{
		printparty();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 20, chooseALiberalTo + toSpend);
		int c = getkeyAlt();
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) return;
		if (c >= '1'&&c <= partysize + '1' - 1)
		{
			buyer = c - '1';
			return;
		}
	}
}
int lenVehicleType();
string vehicleTypelongname(const int p);
Vehicle* getVehicleFromTypeYear(const int carchoice, const int colorchoice, const int year);
int getVehicleTypePrice(const int carchoice);
int getVehicleTypeSleeperPrice(const int carchoice);
vector<string> getVehicleTypeColor(const int carchoice);
bool vehicletypeavailableatshop(const int i);
Creature* findSleeperCarSalesman(int loc);
/* active squad visits the car dealership */
void dealership(int loc)
{
	extern string spaceParanthesisDollar;
	extern squadst *activesquad;
	extern MusicClass music;
	extern int year;
	extern short party_status;
	extern class Ledger ledger;
	extern vector<Vehicle *> vehicle;
	music.play(MUSIC_SHOPPING);
	short buyer = 0;
	locatesquad(activesquad, loc);
	int partysize = squadsize(activesquad);
	while (true)
	{
		eraseAlt();
		locheader();
		printparty();
		Creature *sleepercarsalesman = findSleeperCarSalesman(loc);
		Vehicle* car_to_sell = 0;
		int price = 0;
		for (int v = len(vehicle) - 1; v >= 0; v--)
			if (vehicle[v]->id() == activesquad->squad[buyer]->carid)
				car_to_sell = vehicle[v];
		if (!car_to_sell) set_color_easy(WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(10, 1, g_getCar);
		if (car_to_sell)
		{
			price = static_cast<int>(0.8*car_to_sell->price());
			if (car_to_sell->get_heat())
				price /= 10;
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(11, 1, s_sellThe + car_to_sell->fullname() + spaceParanthesisDollar + tostring(price) + closeParenthesis);
		}
		else
		{
			set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(11, 1, s_sellCar);
		}
		/*if(car_to_sell && car_to_sell->heat>1 && ledger.get_funds()>=500)
		set_color_easy(WHITE_ON_BLACK);
		else
		set_color(COLOR_BLACK,COLOR_BLACK,1);
		mvaddstrAlt(12, 1, CONST_shopsnstuff006);*/
		if (partysize >= 2)set_color_easy(WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, b_chooseBuyer);
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(16, 40, enterLeave);
		if (party_status != -1)set_color_easy(WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(15, 1, show_squad_liberal_status);
		if (partysize > 0 && (party_status == -1 || partysize > 1))set_color_easy(WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(15, 40, check_status_of_squad_liberal);
		int c = getkeyAlt();
		// Leave
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR)break;
		//Sell the car
		if (c == 's' && car_to_sell)
		{
			ledger.add_funds(price, INCOME_CARS);
			for (int v = len(vehicle) - 1; v >= 0; v--)
				if (vehicle[v] == car_to_sell)
				{
					delete_and_remove(vehicle, v);
					break;
				}
		}
		// Get a car
		if (c == 'g' && !car_to_sell)
		{
			int carchoice;
			vector<int> availablevehicle;
			vector<string> vehicleoption;
			for (int i = 0; i < lenVehicleType(); i++)
				if (vehicletypeavailableatshop(i))
				{
					availablevehicle.push_back(i);
					vehicleoption.push_back(vehicleTypelongname(i) + spaceParanthesisDollar +
						tostring(sleepercarsalesman ? getVehicleTypeSleeperPrice(i) : getVehicleTypePrice(i)) + closeParenthesis);
				}
			while (true)
			{
				carchoice = choiceprompt(chooseVehicle, blankString, vehicleoption, thisVehicle,
					true, weDontNeedCar);
				if (carchoice != -1 && (sleepercarsalesman ? getVehicleTypeSleeperPrice(availablevehicle[carchoice]) :
					getVehicleTypePrice(availablevehicle[carchoice])) > ledger.get_funds())
				{
					set_color_easy(RED_ON_BLACK);
					mvaddstrAlt(1, 1, notEnoughMoney);
					pressAnyKey();
				}
				else break;
			}
			if (carchoice == -1) continue;
			//Picked a car, pick color
			int colorchoice;
			//if(len(vehicletype[availablevehicle[choice]]->color())>1) //Allow to back out if you don't like single colour? -XML
			//{
			colorchoice = choiceprompt(chooseAColor, blankString, getVehicleTypeColor(availablevehicle[carchoice]),
				thisColor, true, theseColorsAreCon);
			//}
			//else
			//   colorchoice = 0;
			if (colorchoice == -1) continue;
			Vehicle *v = getVehicleFromTypeYear(availablevehicle[carchoice], colorchoice, year);
			activesquad->squad[buyer]->pref_carid = v->id();
			vehicle.push_back(v);
			ledger.subtract_funds((sleepercarsalesman ? v->sleeperprice() : v->price()), EXPENSE_CARS);
		}
		// Reduce heat
		/*if(c=='p' && car_to_sell && car_to_sell->heat>1 && ledger.get_funds()>=500)
		{
		funds-=500;
		moneylost_goods+=500;
		car_to_sell->heat=1;
		}*/
		if (c == 'b')choose_buyer(buyer);
		if (c == '0')party_status = -1;
		if (c >= '1'&&c <= '6'&&activesquad != NULL)
			if (activesquad->squad[c - '1'] != NULL)
			{
				if (party_status == c - '1')fullstatus(party_status);
				else party_status = c - '1';
			}
	}
}
/* active squad visits the department store */
void deptstore(int loc)
{
	extern squadst *activesquad;
	extern MusicClass music;
	extern char artdir[MAX_PATH_SIZE];
	music.play(MUSIC_SHOPPING);
	locatesquad(activesquad, loc);
	CMarkup xml; // -XML
	xml.Load(string(artdir) + CONST_shopsnstuff007);
	Shop deptstore(xml.GetDoc());
	deptstore.enter(*activesquad);
}
/* active squad visits the oubliette */
void halloweenstore(int loc)
{
	extern squadst *activesquad;
	extern MusicClass music;
	extern char artdir[MAX_PATH_SIZE];
	music.play(MUSIC_SHOPPING);
	locatesquad(activesquad, loc);
	CMarkup xml;
	xml.Load(string(artdir) + CONST_shopsnstuff008);
	Shop oubliette(xml.GetDoc());
	oubliette.enter(*activesquad);
}


void determineMedicalSupportAtEachLocation(bool clearformess);

void ageThings(const char clearformess) {
	const string CONST_daily024 = " regains contact with the LCS.";
	const string CONST_daily023 = "CREATURE_POLITICALACTIVIST";
	const string CONST_daily022 = "CREATURE_TEENAGER";
	const string CONST_daily021 = ". The Liberal will be missed.";
	const string CONST_daily020 = " has passed away at the age of ";
	extern int day;
	extern int month;
	extern Log gamelog;
	extern vector<Creature *> pool;
	extern vector<newsstoryst *> newsstory;
	day++;
	int pday = day, pmonth = month; // Find out if it's next month already.
	if (pday > monthday()) // Day counter has increased but end-of-month has not yet been
		pday = 1, pmonth = (pmonth % 12) + 1; // checked so it has to be accounted for here.
	for (int p = 0; p < len(pool); p++)
	{
		pool[p]->stunned = 0; // For lack of a better place, make stunning expire here
							  // Increment number of days since joined/kidnapped
		pool[p]->joindays++;
		// Increment number of days been dead if dead
		if (!pool[p]->alive)
		{
			pool[p]->deathdays++;
			continue;
		}
		// animals, tanks don't have age effects at the moment
		//TODO: Start aging effects for animals at age 12, take into account if they are genetic monsters or not.
		if (!pool[p]->animalgloss)
		{
			if (pool[p]->age > 60)
			{
				int decrement = 0;
				while (pool[p]->age - decrement > 60)
				{
					if (LCSrandom(365 * 10) == 0)
					{
						pool[p]->adjust_attribute(ATTRIBUTE_HEALTH, -1);
						if (pool[p]->get_attribute(ATTRIBUTE_HEALTH, false) <= 0 &&
							pool[p]->get_attribute(ATTRIBUTE_HEALTH, true) <= 1)
						{
							pool[p]->die();
							if (clearformess) eraseAlt();
							else makedelimiter();
							set_color_easy(WHITE_ON_BLACK_BRIGHT);
							mvaddstrAlt(8, 1, pool[p]->name, gamelog);
							addstrAlt(CONST_daily020, gamelog);
							addstrAlt(pool[p]->age, gamelog);
							addstrAlt(CONST_daily021, gamelog);
							gamelog.nextMessage();
							pressAnyKey();
							break;
						}
					}
					decrement += 10;
				}
				if (!pool[p]->alive)continue;
			}
			if (pmonth == pool[p]->birthday_month&&
				pday == pool[p]->birthday_day)
			{
				pool[p]->age++;
				switch (pool[p]->age)
				{
				case 13:
					pool[p]->type = CREATURE_TEENAGER; // aww, all grown up
					pool[p]->type_idname = CONST_daily022;
					break;
				case 18:
					pool[p]->type = CREATURE_POLITICALACTIVIST; // ok seriously this time
					pool[p]->type_idname = CONST_daily023;
					break;
				}
			}
		}
		// Heal over time
		if (pool[p]->blood < 100) pool[p]->blood++;
		// Updating for in hiding
		if (pool[p]->hiding > 0)
		{
			if ((--pool[p]->hiding) == 0)
			{
				if (LocationsPool::getInstance().isThereASiegeHere(pool[p]->base))
					pool[p]->hiding = 1;
				else
				{
					pool[p]->location = pool[p]->base;
					if (clearformess) eraseAlt();
					else makedelimiter();
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(8, 1, pool[p]->name, gamelog);
					addstrAlt(CONST_daily024, gamelog);
					gamelog.nextMessage();
					pressAnyKey();
				}
			}
		}
		// Check if news reports kidnapping
		if ((pool[p]->flag&CREATUREFLAG_MISSING) &&
			!(pool[p]->flag&CREATUREFLAG_KIDNAPPED))
		{
			if (LCSrandom(14) + 5 < pool[p]->joindays)
			{
				pool[p]->flag |= CREATUREFLAG_KIDNAPPED;
				newsstoryst *ns = new newsstoryst;
				ns->type = NEWSSTORY_KIDNAPREPORT;
				ns->loc = pool[p]->location;
				ns->cr = pool[p];
				newsstory.push_back(ns);
			}
		}
		// Gain skill levels for anything where you have enough experience
		pool[p]->skill_up();
	}
}
void meetWithPotentialRecruits(char &clearformess) {
	extern char disbanding;
	extern vector<recruitst *> recruit;
	extern vector<Creature *> pool;
	for (int i = len(pool) - 1; i >= 0; i--)
		pool[i]->meetings = 0;
	if (!disbanding) for (int r = len(recruit) - 1; r >= 0; r--)
	{
		int p = getpoolcreature(recruit[r]->recruiter_id);
		// Stand up recruits if 1) recruiter does not exist, 2) recruiter was not able to return to a safehouse today
		// or 3) recruiter is dead.
		if (p != -1 && ((pool[p]->location != -1 && LocationsPool::getInstance().getRentingType(pool[p]->location) != RENTING_NOCONTROL && pool[p]->alive&&
			LocationsPool::getInstance().getLocationCity(pool[p]->location) == LocationsPool::getInstance().getLocationCity(recruit[r]->recruit->location)) || recruit[r]->timeleft > 0))
		{
			//MEET WITH RECRUIT
			//TERMINATE NULL RECRUIT MEETINGS
			if (LocationsPool::getInstance().isThereASiegeHere(pool[p]->location))
			{
				delete_and_remove(recruit, r);
				continue;
			}
			//DO MEETING
			else {
				clearformess = 1;
				if (completerecruitmeeting(*recruit[r], p))
				{
					delete_and_remove(recruit, r);
					continue;
				}
			}
		}
		else
		{
			delete_and_remove(recruit, r);
			continue;
		}
	}
}
// Determines the number of recruitment meetings a creature has scheduled
int scheduledmeetings(const Creature& cr)
{
	extern vector<recruitst *> recruit;
	int meetings = 0;
	for (int p = len(recruit) - 1; p >= 0; p--)
		// If meeting is with this creature
		if (recruit[p]->recruiter_id == cr.id) meetings++;
	return meetings;
}
void doRent(const char clearformess) {
	extern char disbanding;
	extern int day;
	extern class Ledger ledger;
	if (day == 3 && !disbanding)
		for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++)
			if (LocationsPool::getInstance().getRentingType(l) > 0 &&
				!LocationsPool::getInstance().isNewRental(l))
			{  // if rent >= 1000000 this means you get should kicked out automatically
				if (ledger.get_funds() >= LocationsPool::getInstance().getRentingType(l) && LocationsPool::getInstance().getRentingType(l) < 1000000)
					ledger.subtract_funds(LocationsPool::getInstance().getRentingType(l), EXPENSE_RENT);
				//EVICTED!!!!!!!!!
				else
				{
					if (clearformess) eraseAlt();
					else makedelimiter();
					LocationsPool::getInstance().evictLCSFrom(l);
				}
			}
}
void activitiesForIndividuals(char &clearformess) {
	const string CONST_daily019 = " surfs the Net for recent opinion polls.";
	extern Log gamelog;
	extern vector<Creature *> pool;
	for (int p = 0; p < len(pool); p++)
	{
		pool[p]->income = 0;
		if (!pool[p]->alive) continue;
		if (pool[p]->clinic) continue;
		if (pool[p]->dating) continue;
		if (pool[p]->hiding) continue;
		if (pool[p]->location == -1)
		{
			//Had a crash bug on the siege check. Location was -1, probably set by 'partyrescue' and not reset during to messy violent chase.
			//This may prevent crashes.
			pool[p]->location = pool[p]->base;
		}
		//CLEAR ACTIONS FOR PEOPLE UNDER SIEGE
		if (LocationsPool::getInstance().isThereASiegeHere(pool[p]->location))
		{
			switch (pool[p]->activity.type)
			{
			case ACTIVITY_HOSTAGETENDING:
			case ACTIVITY_TEACH_POLITICS:
			case ACTIVITY_TEACH_FIGHTING:
			case ACTIVITY_TEACH_COVERT:
			case ACTIVITY_HEAL:
			case ACTIVITY_REPAIR_ARMOR:
				break;
			default:
				pool[p]->activity.type = ACTIVITY_NONE;
				break;
			}
		}
		switch (pool[p]->activity.type)
		{
		case ACTIVITY_REPAIR_ARMOR:
			repairarmor(*pool[p], clearformess);
			break;
		case ACTIVITY_MAKE_ARMOR:
			makearmor(*pool[p], clearformess);
			// Uncomment this to have people stop making armor after the first day
			//pool[p]->activity.type=ACTIVITY_NONE;
			break;
		case ACTIVITY_WHEELCHAIR:
			getwheelchair(*pool[p], clearformess);
			if (pool[p]->flag & CREATUREFLAG_WHEELCHAIR)pool[p]->activity.type = ACTIVITY_NONE;
			break;
		case ACTIVITY_RECRUITING:
			clearformess = 1;
			recruitment_activity(*pool[p]);
			break;
		case ACTIVITY_STEALCARS:
			if (stealcar(*pool[p], clearformess))
				pool[p]->activity.type = ACTIVITY_NONE;
			else if (pool[p]->location != -1 && LocationsPool::getInstance().getLocationType(pool[p]->location) == SITE_GOVERNMENT_POLICESTATION)
				criminalize(*pool[p], LAWFLAG_CARTHEFT);
			break;
		case ACTIVITY_POLLS:
			if (clearformess) eraseAlt();
			else makedelimiter();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(8, 1, pool[p]->name, gamelog);
			addstrAlt(CONST_daily019, gamelog);
			gamelog.nextMessage();
			pressAnyKey();
			pool[p]->train(SKILL_COMPUTERS, max(3 - pool[p]->get_skill(SKILL_COMPUTERS), 1));
			survey(pool[p]);
			//pool[p]->activity.type=ACTIVITY_NONE;  No reason for this not to repeat.  -AM-
			clearformess = 1;
			break;
		case ACTIVITY_VISIT:
			pool[p]->activity.type = ACTIVITY_NONE;
			break;
		case ACTIVITY_NONE:
			if (pool[p]->align == 1 && !pool[p]->is_imprisoned() && (pool[p]->get_armor().is_bloody() || pool[p]->get_armor().is_damaged()))
				repairarmor(*pool[p], clearformess);
			break;
		}
	}
}
void tendAllHostages(char &clearformess) {
	extern vector<Creature *> pool;
	for (int p = len(pool) - 1; p >= 0; p--)
	{
		if (!pool[p]->alive) continue;
		if (pool[p]->align != 1)
			tendhostage(pool[p], clearformess);
	}
}
void squadOverrideIndividual(const int sq, const char clearformess) {
	const string CONST_daily005 = " instead of ";
	const string CONST_daily004 = " acted with ";
	extern Log gamelog;
	extern vector<squadst *> squad;


	for (int p = 0; p < 6; p++)
	{
		if (squad[sq]->squad[p])
		{
			if (squad[sq]->squad[p]->activity.type != ACTIVITY_NONE &&
				squad[sq]->squad[p]->activity.type != ACTIVITY_VISIT)
			{
				if (clearformess) eraseAlt();
				else makedelimiter();
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(8, 1, squad[sq]->squad[p]->name, gamelog);
				addstrAlt(CONST_daily004, gamelog);
				addstrAlt(squad[sq]->name, gamelog);
				addstrAlt(CONST_daily005, gamelog);
				addstrAlt(getactivity(squad[sq]->squad[p]->activity), gamelog);
				addstrAlt(singleDot, gamelog);
				gamelog.newline();
				pressAnyKey();
			}
			squad[sq]->squad[p]->activity.type = ACTIVITY_VISIT;
			squad[sq]->squad[p]->activity.arg = squad[sq]->activity.arg;
		}
	}

}
int driveskill(Creature &cr, int v);
string getVehicleFullname(int i);
void carUpSquad(const int sq, vector<long> &caridused, const char clearformess) {
	const string CONST_daily008 = " couldn't use the ";
	extern Log gamelog;
	extern vector<squadst *> squad;
	//CAR UP AS NECESSARY
	vector<long> wantcar;
	for (int p = 0; p < 6; p++) if (squad[sq]->squad[p])
	{
		long wid = squad[sq]->squad[p]->pref_carid;
		if (wid == -1) continue;
		int w;
		for (w = 0; w < len(wantcar); w++)
			if (wantcar[w] == wid) break;
		if (w == len(wantcar)) wantcar.push_back(wid);
	}
	//CULL UNAVAILABLE CARS
	if (len(wantcar))
		for (int c = len(wantcar) - 1; c >= 0; c--)
			for (int c2 = 0; c2 < len(caridused); c2++)
				if (wantcar[c] == caridused[c2])
				{
					long v = id_getcar(caridused[c2]);
					if (v != -1)
					{
						if (clearformess) eraseAlt();
						else makedelimiter();
						set_color_easy(WHITE_ON_BLACK_BRIGHT);
						mvaddstrAlt(8, 1, squad[sq]->name, gamelog);
						addstrAlt(CONST_daily008, gamelog);
						addstrAlt(getVehicleFullname(v), gamelog);
						addstrAlt(singleDot, gamelog);
						gamelog.nextMessage();
						pressAnyKey();
					}
					wantcar.erase(wantcar.begin() + c);
					break;
				}
	//ASSIGN AVAILABLE CARS
	if (len(wantcar))
	{
		for (int w = 0; w < len(wantcar); w++)
		{
			vector<int> driver, passenger;
			long currentPassenger = wantcar[w];
			caridused.push_back(currentPassenger);
			//FILL CAR WITH DESIGNATED DRIVERS AND PASSENGERS
			for (int p = 0; p < 6; p++)
				if (squad[sq]->squad[p])
					if (squad[sq]->squad[p]->pref_carid == currentPassenger)
					{
						squad[sq]->squad[p]->carid = currentPassenger;
						squad[sq]->squad[p]->is_driver = squad[sq]->squad[p]->pref_is_driver&&
							squad[sq]->squad[p]->canwalk();
						if (squad[sq]->squad[p]->is_driver) driver.push_back(p);
						else passenger.push_back(p);
					}
			//NO DRIVER?
			if (!len(driver))
			{
				//MAKE BEST DRIVING PASSENGER INTO A DRIVER
				if (len(passenger))
				{
					int max = 0;
					for (int p = 0; p < len(passenger); p++)
					{
						int v = id_getcar(squad[sq]->squad[passenger[p]]->carid);
						if (v >= 0)
							if (driveskill(*squad[sq]->squad[passenger[p]], v) > max&&
								squad[sq]->squad[passenger[p]]->canwalk())
								max = driveskill(*squad[sq]->squad[passenger[p]], v);
					}
					vector<int> goodp;
					for (int p = 0; p < len(passenger); p++)
					{
						int v = id_getcar(squad[sq]->squad[passenger[p]]->carid);
						if (v >= 0)
							if (driveskill(*squad[sq]->squad[passenger[p]], v) == max &&
								squad[sq]->squad[passenger[p]]->canwalk())
								goodp.push_back(passenger[p]);
					}
					if (len(goodp))
					{
						int p = pickrandom(goodp);
						squad[sq]->squad[p]->is_driver = 1;
					}
				}
			}
			//TOO MANY DRIVERS?
			else if (len(driver) > 1)
			{
				//TOSS ALL BUT THE BEST
				int max = 0;
				for (int p = 0; p < len(driver); p++)
				{
					long v = id_getcar(squad[sq]->squad[driver[p]]->carid);
					if (v >= 0)
						if (driveskill(*squad[sq]->squad[driver[p]], v) > max)
							max = driveskill(*squad[sq]->squad[driver[p]], v);
				}
				vector<int> goodp;
				for (int p = 0; p < len(driver); p++)
				{
					long v = id_getcar(squad[sq]->squad[driver[p]]->carid);
					if (v >= 0)
						if (driveskill(*squad[sq]->squad[driver[p]], v) == max)
							goodp.push_back(p);
				}
				if (len(goodp))
				{
					int p = pickrandom(goodp);
					for (int p2 = 0; p2 < len(driver); p2++)
					{
						if (p2 == p) continue;
						squad[sq]->squad[driver[p2]]->is_driver = 0;
					}
				}
			}
		}
		//PUT PEOPLE WITHOUT CARS INTO RANDOM CARS
		//THESE PEOPLE WILL NOT DRIVE
		for (int p = 0; p < 6; p++)
			if (squad[sq]->squad[p])
				if (squad[sq]->squad[p]->carid == -1)
				{
					squad[sq]->squad[p]->carid = pickrandom(wantcar);
					squad[sq]->squad[p]->is_driver = 0;
				}
	}
}
void turnSquadAway(const int sq) {
	const string CONST_daily007 = " was too hot to risk.";
	const string CONST_daily006 = " decided ";
	extern Log gamelog;
	extern vector<squadst *> squad;
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(8, 1, squad[sq]->name, gamelog);
	addstrAlt(CONST_daily006, gamelog);
	addstrAlt(LocationsPool::getInstance().getLocationName(squad[sq]->activity.arg), gamelog);
	addstrAlt(CONST_daily007, gamelog);
	gamelog.nextMessage();
	pressAnyKey();
	//ON TO THE NEXT SQUAD
	squad[sq]->activity.type = ACTIVITY_NONE;
}
void giveDriverExperience(const int sq) {
	extern short fieldskillrate;
	extern vector<squadst *> squad;

	for (int i = 0; i < 6; i++)
		if (squad[sq]->squad[i] && squad[sq]->squad[i]->carid != -1 && squad[sq]->squad[i]->is_driver)
		{
			switch (fieldskillrate)
			{
			case FIELDSKILLRATE_FAST:
				squad[sq]->squad[i]->train(SKILL_DRIVING, 5); break;
			case FIELDSKILLRATE_CLASSIC:
				squad[sq]->squad[i]->train(SKILL_DRIVING, 5); break;
			case FIELDSKILLRATE_HARD:
				squad[sq]->squad[i]->train(SKILL_DRIVING, max(0, 5 - squad[sq]->squad[i]->get_skill(SKILL_DRIVING))); break;
			}
		}
}
void squadDepart(const int sq, char &clearformess) {
	const string CONST_daily018 = "Why is the squad here?   (S)afe House, to cause (T)rouble, or (B)oth?";
	const string CONST_daily017 = " has arrived at ";
	const string CONST_daily016 = " looks around ";
	const string CONST_daily013 = " arrives in ";
	extern char showcarprefs;
	extern squadst *activesquad;
	extern Log gamelog;
	extern vector<squadst *> squad;
	extern vector<newsstoryst *> newsstory;
	switch (LocationsPool::getInstance().getLocationType(squad[sq]->activity.arg))
	{
	case SITE_CITY_NEW_YORK:
	case SITE_CITY_SEATTLE:
	case SITE_CITY_LOS_ANGELES:
	case SITE_CITY_CHICAGO:
	case SITE_CITY_DETROIT:
	case SITE_CITY_ATLANTA:
	case SITE_CITY_MIAMI:
	case SITE_CITY_WASHINGTON_DC:
		if (clearformess) eraseAlt();
		else makedelimiter();
		mvaddstrAlt(8, 1, squad[sq]->name, gamelog);
		addstrAlt(CONST_daily013, gamelog);
		addstrAlt(LocationsPool::getInstance().getLocationName(squad[sq]->activity.arg), gamelog);
		addstrAlt(singleDot, gamelog);
		gamelog.nextMessage();
		pressAnyKey();
		{
			int l = find_site_index_in_same_city(SITE_RESIDENTIAL_SHELTER, squad[sq]->activity.arg); //int l = find_homeless_shelter(squad[sq]->activity.arg);
																									 // Base at new city's homeless shelter
			basesquad(squad[sq], l);
			locatesquad(squad[sq], l);
		}
		clearformess = 1;
		break;
	case SITE_BUSINESS_DEPTSTORE:
	case SITE_BUSINESS_HALLOWEEN:
	case SITE_BUSINESS_PAWNSHOP:
	case SITE_BUSINESS_CARDEALERSHIP:
	case SITE_BUSINESS_ARMSDEALER:
		if (clearformess) eraseAlt();
		else makedelimiter();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, squad[sq]->name, gamelog);
		addstrAlt(CONST_daily017, gamelog);
		addstrAlt(LocationsPool::getInstance().getLocationName(squad[sq]->activity.arg), gamelog);
		addstrAlt(singleDot, gamelog);
		gamelog.nextMessage();
		pressAnyKey();
		activesquad = squad[sq];
		showcarprefs = -1;
		switch (LocationsPool::getInstance().getLocationType(squad[sq]->activity.arg))
		{
		case SITE_BUSINESS_DEPTSTORE:
			deptstore(squad[sq]->activity.arg);
			break;
		case SITE_BUSINESS_HALLOWEEN:
			halloweenstore(squad[sq]->activity.arg);
			break;
		case SITE_BUSINESS_PAWNSHOP:
			pawnshop(squad[sq]->activity.arg);
			break;
		case SITE_BUSINESS_CARDEALERSHIP:
			dealership(squad[sq]->activity.arg);
			break;
		case SITE_BUSINESS_ARMSDEALER:
			armsdealer(squad[sq]->activity.arg);
			break;
		}
		showcarprefs = 0;
		if (activesquad->squad[0] != NULL)
			locatesquad(activesquad, activesquad->squad[0]->base);
		clearformess = 1;
		break;
	case SITE_HOSPITAL_UNIVERSITY:
	case SITE_HOSPITAL_CLINIC:
		if (clearformess) eraseAlt();
		else makedelimiter();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, squad[sq]->name, gamelog);
		addstrAlt(CONST_daily017, gamelog);
		addstrAlt(LocationsPool::getInstance().getLocationName(squad[sq]->activity.arg), gamelog);
		addstrAlt(singleDot, gamelog);
		gamelog.nextMessage();
		pressAnyKey();
		activesquad = squad[sq];
		hospital(squad[sq]->activity.arg);
		if (activesquad->squad[0] != NULL)
			locatesquad(activesquad, activesquad->squad[0]->base);
		clearformess = 1;
		break;
	default:
		if (clearformess) eraseAlt();
		else makedelimiter();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		if (squad[sq]->squad[0]->base == squad[sq]->activity.arg)
		{
			mvaddstrAlt(8, 1, squad[sq]->name, gamelog);
			addstrAlt(CONST_daily016, gamelog);
			addstrAlt(LocationsPool::getInstance().getLocationName(squad[sq]->activity.arg), gamelog);
			addstrAlt(singleDot, gamelog);
			gamelog.nextMessage();
		}
		else
		{
			mvaddstrAlt(8, 1, squad[sq]->name, gamelog);
			addstrAlt(CONST_daily017, gamelog);
			addstrAlt(LocationsPool::getInstance().getLocationName(squad[sq]->activity.arg), gamelog);
			addstrAlt(singleDot, gamelog);
			gamelog.nextMessage();
		}
		pressAnyKey();
		if (clearformess) eraseAlt();
		else makedelimiter();
		int c = 't';
		if (LocationsPool::getInstance().getRentingType(squad[sq]->activity.arg) >= 0 &&
			LocationsPool::getInstance().getLocationType(squad[sq]->activity.arg) == SITE_INDUSTRY_WAREHOUSE)
			c = 's';
		else if (LocationsPool::getInstance().getRentingType(squad[sq]->activity.arg) >= 0 &&
			squad[sq]->squad[0]->base != squad[sq]->activity.arg)
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(8, 1, CONST_daily018);
			c = pressSpecificKey('s', 'b', 't');
		}
		if (c == 's' || c == 'b') basesquad(squad[sq], squad[sq]->activity.arg);
		if (c == 't' || c == 'b')
		{
			activesquad = squad[sq];
			newsstoryst *ns = new newsstoryst;
			ns->type = NEWSSTORY_SQUAD_SITE;
			ns->positive = 1;
			ns->loc = squad[sq]->activity.arg;
			newsstory.push_back(ns);
			mode_site(squad[sq]->activity.arg);
		}
		if (squad[sq]->squad[0])
			locatesquad(squad[sq], squad[sq]->squad[0]->base);
		clearformess = 1;
		break;
	}
}
void advanceSquads(char &clearformess) {
	const string CONST_daily012 = "%s spent $%d on tickets to go to %s.";
	const string CONST_daily011 = "%s couldn't afford tickets to go to %s.";
	const string CONST_daily010 = "travel location";
	const string CONST_daily009 = " didn't have a car to get to ";
	extern squadst *activesquad;
	extern Log gamelog;
	extern vector<squadst *> squad;
	extern class Ledger ledger;
	vector<long> caridused;
	//ADVANCE SQUADS
	squadst *oactivesquad = activesquad;
	for (int sq = 0; sq < len(squad); sq++)
	{
		//MAKE SURE MEMBERS DON'T ACT IF SQUAD DOES
		if (squad[sq]->activity.type != ACTIVITY_NONE) {
			squadOverrideIndividual(sq, clearformess);
		}
		if (squad[sq]->activity.type == ACTIVITY_VISIT)
		{
			//TURN AWAY SQUADS FROM RECENTLY CLOSED OR SIEGED SITES
			if (LocationsPool::getInstance().isThisSiteClosed(squad[sq]->activity.arg) ||
				LocationsPool::getInstance().isThereASiegeHere(squad[sq]->activity.arg))
			{
				if (clearformess) eraseAlt();
				else makedelimiter();
				turnSquadAway(sq);
				continue;
			}
			carUpSquad(sq, caridused, clearformess);
			//IF NEED CAR AND DON'T HAVE ONE...
			//NOTE: SQUADS DON'T TAKE FREE CARS
			if (LocationsPool::getInstance().doesThisPlaceNeedACar(squad[sq]->activity.arg) && squad[sq]->squad[0])
				if (squad[sq]->squad[0]->carid == -1)
				{
					if (clearformess) eraseAlt();
					else makedelimiter();
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(8, 1, squad[sq]->name, gamelog);
					addstrAlt(CONST_daily009, gamelog);
					addstrAlt(LocationsPool::getInstance().getLocationName(squad[sq]->activity.arg), gamelog);
					addstrAlt(singleDot, gamelog);
					gamelog.nextMessage();
					pressAnyKey();
					//ON TO THE NEXT SQUAD
					squad[sq]->activity.type = ACTIVITY_NONE;
					continue;
				}
			// Give drivers experience if they actually travel
			if (squad[sq]->activity.arg != squad[sq]->squad[0]->base) {
				giveDriverExperience(sq);
			}
			//GO PLACES
			// Identify the CONST_daily010 -- top level in multi-city play,
			// a particular district in one-city play
			int travelLocation = -1;
			for (int i = 0; i < LocationsPool::getInstance().lenpool(); i++)
				if (LocationsPool::getInstance().getLocationType(i) == SITE_TRAVEL)
				{
					travelLocation = i;
					break;
				}
			// Verify travellers can afford the cost, and charge them
			bool canDepart = true;
			if (LocationsPool::getInstance().getLocationParent(squad[sq]->activity.arg) == travelLocation)
			{
				if (clearformess) eraseAlt();
				else makedelimiter();
				int price;
				for (price = 0; price < 6; price++) if (!squad[sq]->squad[price]) break;
				price *= 100;
				if (ledger.get_funds() < price)
				{
					mvaddstr_fl(8, 1, gamelog, CONST_daily011.c_str(), squad[sq]->name, LocationsPool::getInstance().getLocationName(squad[sq]->activity.arg).c_str());
					canDepart = false;
				}
				else
				{
					ledger.subtract_funds(price, EXPENSE_TRAVEL);
					mvaddstr_fl(8, 1, gamelog, CONST_daily012.c_str(), squad[sq]->name, price, LocationsPool::getInstance().getLocationName(squad[sq]->activity.arg).c_str());
				}
				pressAnyKey();
			}
			if (canDepart) {
				squadDepart(sq, clearformess);
			}
			squad[sq]->activity.type = ACTIVITY_NONE;
		}
	}


	activesquad = oactivesquad;
}
void moveSquadlessToBaseIfNotSiege() {
	extern vector<Creature *> pool;
	for (int p = 0; p < len(pool); p++)
	{
		if (!pool[p]->alive || !pool[p]->is_active_liberal() || pool[p]->squadid != -1)
			continue;
		// Prevent moving people to a sieged location,
		// but don't evacuate people already under siege. - wisq
		if (pool[p]->location != pool[p]->base &&
			LocationsPool::getInstance().isThereASiegeHere(pool[p]->base))
		{
			pool[p]->base = find_site_index_in_same_city(SITE_RESIDENTIAL_SHELTER, pool[p]->location); //find_homeless_shelter(*pool[p]);pool[p]->base = find_homeless_shelter(*pool[p]);
		}
		pool[p]->location = pool[p]->base;
	}

}
void doDates(char &clearformess);
void advanceday(char &clearformess, char canseethings)
{
	extern char showcarprefs;
	extern char disbanding;
	extern class Ledger ledger;
	extern vector<Creature *> pool;
	showcarprefs = 0;
	//int w = 0;
	//int l2;
	//*JDS* Save the game to save.dat each day. :)
	if (!disbanding) {
		title_screen::getInstance().autosavegame();
	}
	ledger.resetDailyAmounts();
	//CLEAR CAR STATES
	for (int p = 0; p < len(pool); p++) pool[p]->carid = -1;
	// Move squadless Liberals to their bases if not under siege
	if (!disbanding) {
		moveSquadlessToBaseIfNotSiege();
		advanceSquads(clearformess);
		tendAllHostages(clearformess);
		activitiesForIndividuals(clearformess);
	}
	funds_and_trouble(clearformess);
	determineMedicalSupportAtEachLocation(clearformess);
	//DISPERSAL CHECK
	dispersalcheck(clearformess);
	//DO RENT
	doRent(clearformess);
	//MEET WITH POTENTIAL RECRUITS
	meetWithPotentialRecruits(clearformess);
	//DO DATES
	if (!disbanding) {
		doDates(clearformess);
	}
	//AGE THINGS
	ageThings(clearformess);
	//DO REPORTING BY MAJOR NEWSPAPERS
	majornewspaper(clearformess, canseethings);
	//CLEAN UP GONE SQUADS
	cleangonesquads();
	//SIEGE?
	siegeturn(clearformess);
	siegecheck(canseethings);
	//CLEAN GONE SQUADS AGAIN
	cleangonesquads();
	showcarprefs = 1;
}
/* daily - returns true if the site type supports high security */
char securityable(int type)
{
	switch (type)
	{
	case SITE_BUSINESS_CIGARBAR:
	case SITE_RESIDENTIAL_APARTMENT_UPSCALE:
	case SITE_LABORATORY_COSMETICS:
	case SITE_LABORATORY_GENETIC:
	case SITE_GOVERNMENT_FIRESTATION:
	case SITE_INDUSTRY_SWEATSHOP:
	case SITE_INDUSTRY_POLLUTER:
	case SITE_CORPORATE_HEADQUARTERS:
	case SITE_MEDIA_AMRADIO:
	case SITE_MEDIA_CABLENEWS:
		return 1;
		//These places have better quality locks.
	case SITE_BUSINESS_BANK:
	case SITE_INDUSTRY_NUCLEAR:
	case SITE_GOVERNMENT_POLICESTATION:
	case SITE_GOVERNMENT_COURTHOUSE:
	case SITE_GOVERNMENT_PRISON:
	case SITE_GOVERNMENT_INTELLIGENCEHQ:
	case SITE_GOVERNMENT_ARMYBASE:
	case SITE_CORPORATE_HOUSE:
	case SITE_GOVERNMENT_WHITE_HOUSE:
		return 2;
	}
	return 0;
}



// #include "../includes.h"
const string CONST_dateB104 = "'s ";
const string CONST_dateB103 = " cell phone.";
const string CONST_dateB102 = " pet";
const string CONST_dateB101 = " favourite TV show.";
const string CONST_dateB100 = " hair.";
const string CONST_dateB099 = "'s frozen Conservative heart.";
const string CONST_date103 = "The Liberal wakes up in the police station...";
const string CONST_date102 = " remembers seeing!";
const string CONST_date101 = "'s fist is the last thing ";
const string CONST_date100 = " has failed to kidnap the Conservative.";
const string CONST_date099 = " manages to get away on the way back to the safehouse!";
const string CONST_date098 = "If you do not enter anything, their real name will be used.";
const string CONST_date097 = " in its presence?";
const string CONST_date096 = "What name will you use for this ";
const string CONST_date095 = "The Education of ";
const string CONST_date094 = " kidnaps the Conservative!";
const string CONST_date093 = " struggles and yells for help, but nobody comes.";
const string CONST_date092 = " doesn't resist.";
const string CONST_date091 = "not to [resist]!";
const string CONST_date090 = "not to fuck around!";
const string CONST_date089 = " seizes the Conservative swine from behind and warns it";
const string CONST_date088 = "to the corporate slave's throat!";
const string CONST_date087 = " grabs the Conservative from behind, holding the ";
const string CONST_date086 = "and threatens to blow the Conservative's brains out!";
const string CONST_date085 = " comes back from the bathroom toting the ";
const string CONST_date084 = "E - Just kidnap the Conservative bitch.";
const string CONST_date083 = "D - Break it off.";
const string CONST_date082 = "C - Spend a week on a cheap vacation (must be uninjured).";
const string CONST_date081 = "C - Spend a week on a cheap vacation (stands up any other dates).";
const string CONST_date080 = "B - Try to get through the evening without spending a penny.";
const string CONST_date079 = "A - Spend a hundred bucks tonight to get the ball rolling.";
const string CONST_date078 = " approach the situation?";
const string CONST_date077 = "How should ";
const string CONST_date076 = "Seeing ";
const string CONST_date075 = "Things go downhill fast.";
const string CONST_date074 = " mixes up the names of ";
const string CONST_date073 = " realizes %s has committed to eating %d meals at once.";
const string CONST_date072 = "Ruh roh...";
const string CONST_date071 = "Unfortunately, they turn up at the same time.";
const string CONST_date070 = "Unfortunately, they all turn up at the same time.";
const string CONST_date069 = ".  An ambush was set for the lying dog...";
const string CONST_date068 = "Unfortunately, they know each other and had been discussing";
const string CONST_date067 = "Unfortunately, they all know each other and had been discussing";
const string CONST_date066 = " at ";
const string CONST_date065 = "dates to manage with ";
const string CONST_date064 = "a hot date with ";
const string CONST_date063 = "a \"hot\" date with ";
const string CONST_date062 = " has ";
const string CONST_date061 = " is back from vacation.";
const string CONST_date060 = "This relationship is over.";
const string CONST_date059 = " can sense that things just aren't working out.";
const string CONST_date058 = " from meeting ";
const string CONST_date057 = "schedule for keeping ";
const string CONST_date056 = "mind-bending ";
const string CONST_date055 = "detailed ";
const string CONST_date054 = "complicated ";
const string CONST_date053 = "intricate ";
const string CONST_date052 = "awe-inspiring ";
const string CONST_date051 = "notices ";
const string CONST_date050 = "The date starts well, but goes horribly wrong when ";
const string CONST_date049 = " escapes the police ambush!";
const string CONST_date048 = "But ";
const string CONST_date047 = " has been arrested.";
const string CONST_date046 = " was leaking information to the police the whole time!";
const string CONST_date045 = "'s mind with wisdom!!!";
const string CONST_date044 = " actually curses ";
const string CONST_date043 = "Talking with ";
const string CONST_date042 = "They'll meet again tomorrow.";
const string CONST_date041 = " to recharge ";
const string CONST_date040 = " to go to a birthday party.";
const string CONST_date039 = " six-legged pig.";
const string CONST_date038 = " fish.";
const string CONST_date037 = " dog.";
const string CONST_date036 = " cat.";
const string CONST_date035 = " to take care of ";
const string CONST_date034 = " to catch ";
const string CONST_date033 = " due to an early meeting tomorrow.";
const string CONST_date032 = " due to an allergy attack.";
const string CONST_date031 = " to wash ";
const string CONST_date030 = " seemed to have fun, but left early";
const string CONST_date028 = " knows all about that already.";
const string CONST_date027 = " was able to create a map of the site with this information.";
const string CONST_date026 = " turns the topic of discussion to the ";
const string CONST_date025 = " is slowly warming ";
const string CONST_date021 = "The Self-Nullifying Infatuation of ";
const string CONST_date020 = "'s totally unconditional love-slave!";
const string CONST_date019 = " is ";
const string CONST_date018 = "In fact, ";
const string CONST_date017 = "It was fun though. They agree to part ways amicably.";
const string CONST_date016 = " relationship.";
const string CONST_date015 = "yet another";
const string CONST_date014 = "another";
const string CONST_date013 = " isn't seductive enough to juggle ";
const string CONST_date012 = " people!";
const string CONST_date011 = "someone!";
const string CONST_date010 = " is already dating ";
const string CONST_date008 = "'s unique life philosophy...";
const string CONST_date007 = " is quite taken with ";
const string CONST_date006 = "date_fail.txt";

//// #include "../common/translateid.h"
int getarmortype(const string &idname);
vector<string> date_fail;
const string datey = "date\\";
vector<file_and_text_collection> date_text_file_collection = {
	/*date.cpp*/
	customText(&date_fail, datey + CONST_date006),
};
//extern string commaSpace;
//extern string singleSpace;
vector<datest *> date;
enum DateResults
{
	DATERESULT_MEETTOMORROW,
	DATERESULT_BREAKUP,
	DATERESULT_JOINED,
	DATERESULT_ARRESTED
};
string AND;
//extern string AND;
// Handles the result of a date or vacation
static int dateresult(int aroll, int troll, datest &d, int e, int p, int y)
{
	extern MusicClass music;
	extern int stat_recruits;
	extern Log gamelog;
	extern short lawList[LAWNUM];
	extern vector<Creature *> pool;
	music.play(MUSIC_DATING);
	std::string s = blankString;
	if (aroll > troll)
	{
		set_color_easy(CYAN_ON_BLACK_BRIGHT);
		moveAlt(y, 0); y++;
		addstrAlt(d.date[e]->name, gamelog);
		addstrAlt(CONST_date007, gamelog);
		addstrAlt(pool[p]->name, gamelog);
		addstrAlt(CONST_date008, gamelog);
		gamelog.newline();
		pressAnyKey();
		if (loveslavesleft(*pool[p]) <= 0)
		{
			set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			mvaddstrAlt(y++, 0, CONST_date048, gamelog);
			addstrAlt(pool[p]->name, gamelog);
			addstrAlt(CONST_date010, gamelog);
			int num_relationships = loveslaves(*pool[p]);
			if (pool[p]->flag&CREATUREFLAG_LOVESLAVE) num_relationships++;
			if (num_relationships == 1) addstrAlt(CONST_date011, gamelog);
			else addstrAlt(tostring(num_relationships) + CONST_date012, gamelog);
			gamelog.newline();
			mvaddstrAlt(y++, 0, pool[p]->name, gamelog);
			addstrAlt(CONST_date013, gamelog);
			if (num_relationships == 1) addstrAlt(CONST_date014, gamelog);
			else addstrAlt(CONST_date015, gamelog);
			addstrAlt(CONST_date016, gamelog);
			gamelog.newline();
			pressAnyKey();
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(y++, 0, CONST_date017, gamelog);
			gamelog.nextMessage();
			pressAnyKey();
			delete_and_remove(d.date, e);
			return DATERESULT_BREAKUP;
		}
		if (LCSrandom((aroll - troll) / 2) > d.date[e]->get_attribute(ATTRIBUTE_WISDOM, true))
		{
			set_color_easy(GREEN_ON_BLACK_BRIGHT);
			moveAlt(y, 0); y++;
			addstrAlt(CONST_date018, gamelog);
			addstrAlt(d.date[e]->name, gamelog);
			addstrAlt(CONST_date019, gamelog);
			addstrAlt(pool[p]->name, gamelog);
			addstrAlt(CONST_date020, gamelog);
			gamelog.nextMessage();
			//Get map of their workplace
			LocationsPool::getInstance().setLocationMappedAndUnhidden(d.date[e]->worklocation);
			pressAnyKey();
			d.date[e]->flag |= CREATUREFLAG_LOVESLAVE;
			d.date[e]->hireid = pool[p]->id;
			eraseAlt();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(0, 0, CONST_date021);
			addstrAlt(d.date[e]->propername);
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(2, 0, CONST_date096);
			addstrAlt(d.date[e]->get_type_name());
			addstrAlt(CONST_date097);
			mvaddstrAlt(3, 0, CONST_date098);
			enter_name(4, 0, d.date[e]->name, CREATURE_NAMELEN, d.date[e]->propername);
			sleeperize_prompt(*d.date[e], *pool[p], 8);
			addCreature(d.date[e]);
			stat_recruits++;
			d.date.erase(d.date.begin() + e);
			return DATERESULT_JOINED;
		}
		else
		{
			if (d.date[e]->align == ALIGN_CONSERVATIVE && d.date[e]->get_attribute(ATTRIBUTE_WISDOM, false) > 3)
			{
				set_color_easy(GREEN_ON_BLACK_BRIGHT);
				y++;
				mvaddstrAlt(y++, 0, s + pool[p]->name + CONST_date025 + d.date[e]->name + CONST_dateB099, gamelog);
				gamelog.newline();
				moveAlt(y++, 0);
				d.date[e]->adjust_attribute(ATTRIBUTE_WISDOM, -1);
				d.date[e]->adjust_attribute(ATTRIBUTE_HEART, +1);
			}
			else if (d.date[e]->get_attribute(ATTRIBUTE_WISDOM, false) > 3)
			{
				d.date[e]->adjust_attribute(ATTRIBUTE_WISDOM, -1);
			}
			//Possibly date reveals map of location
			else if (LocationsPool::getInstance().isLocationMapped(d.date[e]->worklocation) == 0 && !LCSrandom(d.date[e]->get_attribute(ATTRIBUTE_WISDOM, false)))
			{
				y++;
				mvaddstrAlt(y++, 0, s + d.date[e]->name + CONST_date026
					+ LocationsPool::getInstance().getLocationName(d.date[e]->worklocation) + singleDot, gamelog);
				gamelog.newline();
				moveAlt(y++, 0);
				if (!(LocationsPool::getInstance().getLocationType(d.date[e]->worklocation) <= SITE_RESIDENTIAL_SHELTER))
				{
					addstrAlt(pool[p]->name, gamelog);
					addstrAlt(CONST_date027, gamelog);
					gamelog.newline();
					y++;
				}
				else
				{
					addstrAlt(pool[p]->name, gamelog);
					addstrAlt(CONST_date028, gamelog);
					gamelog.newline();
					y++;
				}
				LocationsPool::getInstance().setLocationMappedAndUnhidden(d.date[e]->worklocation);
			}
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(y++, 0, CONST_date042, gamelog);
			gamelog.nextMessage();
			pressAnyKey();
			return DATERESULT_MEETTOMORROW;
		}
	}
	else if (aroll == troll)
	{
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(y++, 0, d.date[e]->name, gamelog);
		addstrAlt(CONST_date030, gamelog);
		moveAlt(y++, 0);
		switch (LCSrandom(7))
		{
		case 0: addstrAlt(s + CONST_date031 + d.date[e]->hisher() + CONST_dateB100, gamelog); break;
		case 1: addstrAlt(CONST_date032, gamelog); break;
		case 2: addstrAlt(CONST_date033, gamelog); break;
		case 3: addstrAlt(s + CONST_date034 + d.date[e]->hisher() + CONST_dateB101, gamelog); break;
		case 4:
			addstrAlt(s + CONST_date035 + d.date[e]->hisher() + CONST_dateB102, gamelog);
			switch (LCSrandom(3 + (lawList[LAW_ANIMALRESEARCH] == -2)))
			{
			case 0: addstrAlt(CONST_date036, gamelog); break;
			case 1: addstrAlt(CONST_date037, gamelog); break;
			case 2: addstrAlt(CONST_date038, gamelog); break;
			case 3: addstrAlt(CONST_date039, gamelog); break;
			}
			break;
		case 5: addstrAlt(CONST_date040, gamelog); break;
		case 6: addstrAlt(s + CONST_date041 + d.date[e]->hisher() + CONST_dateB103, gamelog); break;
		}
		mvaddstrAlt(y++, 0, CONST_date042, gamelog);
		gamelog.nextMessage();
		pressAnyKey();
		return DATERESULT_MEETTOMORROW;
	}
	else
	{
		//WISDOM POSSIBLE INCREASE
		if (d.date[e]->align == -1 && aroll < troll / 2)
		{
			set_color_easy(RED_ON_BLACK_BRIGHT);
			mvaddstrAlt(y++, 0, CONST_date043, gamelog);
			addstrAlt(d.date[e]->name, gamelog);
			addstrAlt(CONST_date044, gamelog);
			addstrAlt(pool[p]->name, gamelog);
			addstrAlt(CONST_date045, gamelog);
			gamelog.newline();
			pool[p]->adjust_attribute(ATTRIBUTE_WISDOM, +1);
			if (d.date[e]->get_skill(SKILL_RELIGION) > pool[p]->get_skill(SKILL_RELIGION))
				pool[p]->train(SKILL_RELIGION, 20 * (d.date[e]->get_skill(SKILL_RELIGION) - pool[p]->get_skill(SKILL_RELIGION)));
			if (d.date[e]->get_skill(SKILL_SCIENCE) > pool[p]->get_skill(SKILL_SCIENCE))
				pool[p]->train(SKILL_SCIENCE, 20 * (d.date[e]->get_skill(SKILL_SCIENCE) - pool[p]->get_skill(SKILL_SCIENCE)));
			if (d.date[e]->get_skill(SKILL_BUSINESS) > pool[p]->get_skill(SKILL_BUSINESS))
				pool[p]->train(SKILL_BUSINESS, 20 * (d.date[e]->get_skill(SKILL_BUSINESS) - pool[p]->get_skill(SKILL_BUSINESS)));
			pressAnyKey();
		}
		//BREAK UP
		// If your squad member is wanted by the police, a conservative who breaks up with
		// them has a 1 in 50 chance of ratting them out, unless the person being dated is law
		// enforcement, prison guard, or agent, in which case there is a 1 in 4 chance. -Fox
		if ((iscriminal(*pool[p])) &&
			(!LCSrandom(50) || (LCSrandom(2) && (d.date[e]->kidnap_resistant()))))
		{
			set_color_easy(RED_ON_BLACK_BRIGHT);
			mvaddstrAlt(y++, 0, d.date[e]->name, gamelog);
			addstrAlt(CONST_date046, gamelog);
			pressAnyKey();
			moveAlt(y++, 0);
			// 3/4 chance of being arrested if less than 50 juice,
			// 1/2 chance of being arrested if more than 50 juice
			if ((pool[p]->juice < 50 && LCSrandom(2)) || LCSrandom(2))
			{
				// Find the police station
				long ps = find_site_index_in_same_city(SITE_GOVERNMENT_POLICESTATION, pool[p]->location);
				set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
				addstrAlt(pool[p]->name, gamelog);
				addstrAlt(CONST_date047, gamelog);
				gamelog.nextMessage();
				removesquadinfo(*pool[p]);
				pool[p]->carid = -1;
				pool[p]->location = ps;
				pool[p]->drop_weapons_and_clips(NULL);
				pool[p]->activity.type = ACTIVITY_NONE;
				pressAnyKey();
				delete_and_remove(d.date, e);
				return DATERESULT_ARRESTED;
			}
			else
			{
				set_color_easy(GREEN_ON_BLACK_BRIGHT);
				addstrAlt(CONST_date048, gamelog);
				addstrAlt(pool[p]->name, gamelog);
				addstrAlt(CONST_date049, gamelog);
				gamelog.nextMessage();
			}
		}
		else
		{
			int ls = loveslaves(*pool[p]);
			if (ls > 0 && LCSrandom(2))
			{
				set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
				mvaddstrAlt(y++, 0, s + CONST_date050 + d.date[e]->name, gamelog);
				mvaddstrAlt(y++, 0, s + CONST_date051 + pool[p]->name + CONST_dateB104, gamelog);
				switch (ls)
				{
				case 5:
					addstrAlt(CONST_date052, gamelog);
					break;
				case 4:
					addstrAlt(CONST_date053, gamelog);
					break;
				case 3:
					addstrAlt(CONST_date054, gamelog);
					break;
				case 2:
					addstrAlt(CONST_date055, gamelog);
					break;
				case 1:
					break;
				default:
					addstrAlt(CONST_date056, gamelog);
				}
				addstrAlt(s + CONST_date057 + d.date[e]->himher(), gamelog);
				addstrAlt(s + CONST_date058, gamelog);
				moveAlt(y++, 0);
				int lsfound = 0;
				for (int q = 0; q < (int)pool.size(); q++)
				{
					if (pool[q]->hireid == pool[p]->id && pool[q]->alive && pool[q]->flag & CREATUREFLAG_LOVESLAVE)
					{
						lsfound++;
						if (lsfound == 1)
						{
							addstrAlt(pool[q]->name, gamelog);
						}
						else if (lsfound < ls)
						{
							addstrAlt(s + commaSpace + pool[q]->name, gamelog);
						}
						else
						{
							addstrAlt(s + AND + pool[q]->name, gamelog);
						}
					}
				}
				addstrAlt(singleDot, gamelog);
				gamelog.newline();
				moveAlt(y++, 0);
			}
			else
			{
				set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
				mvaddstrAlt(y++, 0, d.date[e]->name, gamelog);
				addstrAlt(CONST_date059, gamelog);
				gamelog.newline();
				moveAlt(y++, 0);
			}
			addstrAlt(CONST_date060, gamelog);
			gamelog.nextMessage();
		}
		pressAnyKey();
		delete_and_remove(d.date, e);
		return DATERESULT_BREAKUP;
	}
}
/* daily - date - dater p gets back from vacation */
char completevacation(datest &d, int p)
{
	extern MusicClass music;
	extern Log gamelog;
	extern vector<Creature *> pool;
	music.play(MUSIC_DATING);
	int e = 0;
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(0, 0, pool[p]->name, gamelog);
	addstrAlt(CONST_date061, gamelog);
	gamelog.nextMessage();
	// Temporarily make the date Conservative so that high-juice liberals aren't trivial to seduce
	int datealignment = d.date[e]->align;
	d.date[e]->align = -1;
	short aroll = pool[p]->skill_roll(SKILL_SEDUCTION) * 2;
	short troll = d.date[e]->attribute_roll(ATTRIBUTE_WISDOM);
	// Attribute roll over; reset date's alignment to what it should be
	d.date[e]->align = datealignment;
	pool[p]->train(SKILL_SEDUCTION, LCSrandom(11) + 15);
	int thingsincommon = 0;
	for (int s = 0; s < SKILLNUM; s++)
		if (d.date[e]->get_skill(s) >= 1 && pool[p]->get_skill(s) >= 1)
			//Has a skill that is at least half the same skill of the other person on the date.
			if (d.date[e]->get_skill(s) <= pool[p]->get_skill(s) * 2)
				thingsincommon++;
	aroll += thingsincommon * 3;
	pool[p]->train(SKILL_SCIENCE,
		max(d.date[e]->get_skill(SKILL_SCIENCE) - pool[p]->get_skill(SKILL_SCIENCE), 0));
	pool[p]->train(SKILL_RELIGION,
		max(d.date[e]->get_skill(SKILL_RELIGION) - pool[p]->get_skill(SKILL_RELIGION), 0));
	pool[p]->train(SKILL_BUSINESS,
		max(d.date[e]->get_skill(SKILL_BUSINESS) - pool[p]->get_skill(SKILL_BUSINESS), 0));
	if (d.date[e]->skill_roll(SKILL_BUSINESS))
	{
		troll += d.date[e]->skill_roll(SKILL_BUSINESS);
		aroll += pool[p]->skill_roll(SKILL_BUSINESS);
	}
	if (d.date[e]->skill_roll(SKILL_RELIGION))
	{
		troll += d.date[e]->skill_roll(SKILL_RELIGION);
		aroll += pool[p]->skill_roll(SKILL_RELIGION);
	}
	if (d.date[e]->skill_roll(SKILL_SCIENCE))
	{
		troll += d.date[e]->skill_roll(SKILL_SCIENCE);
		aroll += pool[p]->skill_roll(SKILL_SCIENCE);
	}
	switch (dateresult(aroll, troll, d, e, p, 2))
	{
	default:
	case DATERESULT_MEETTOMORROW:return 0;
	case DATERESULT_BREAKUP:     return 1;
	case DATERESULT_JOINED:      return 1;
	case DATERESULT_ARRESTED:    return 1;
	}
}
//extern string pressKeyToReflect;
/* daily - date - dater p goes on some dates */
char completedate(datest &d, int p)
{
	extern MusicClass music;
	extern int stat_kidnappings;
	extern Log gamelog;
	extern class Ledger ledger;
	extern short lawList[LAWNUM];
	extern vector<Creature *> pool;
	music.play(MUSIC_DATING);
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(0, 0, pool[p]->name, gamelog);
	addstrAlt(CONST_date062, gamelog);
	if (len(d.date) == 1)
	{
		if (pool[p]->clinic) addstrAlt(CONST_date063, gamelog);
		else addstrAlt(CONST_date064, gamelog);
	}
	else addstrAlt(CONST_date065, gamelog);
	for (int e = 0; e < len(d.date); e++)
	{
		addstrAlt(d.date[e]->name, gamelog);
		if (e <= len(d.date) - 3) addstrAlt(commaSpace, gamelog);
		else if (e == len(d.date) - 2) addstrAlt(AND, gamelog);
		else
		{
			if (pool[p]->clinic > 0)
			{
				addstrAlt(CONST_date066, gamelog);
				addstrAlt(LocationsPool::getInstance().getLocationName(pool[p]->location), gamelog);
			}
			addstrAlt(singleDot, gamelog);
		}
	}
	gamelog.newline();
	pressAnyKey();
	if (len(d.date) > 1 && !LCSrandom(len(d.date) > 2 ? 4 : 6))
	{
		switch (LCSrandom(3))
		{
		case 0:
			moveAlt(2, 0);
			if (len(d.date) > 2) addstrAlt(CONST_date067, gamelog);
			else addstrAlt(CONST_date068, gamelog);
			mvaddstrAlt(3, 0, pool[p]->name, gamelog);
			addstrAlt(CONST_date069, gamelog);
			gamelog.newline();
			pressAnyKey();
			break;
		case 1:
			moveAlt(2, 0);
			if (len(d.date) > 2) addstrAlt(CONST_date070, gamelog);
			else addstrAlt(CONST_date071, gamelog);
			gamelog.newline();
			mvaddstrAlt(3, 0, CONST_date072, gamelog);
			gamelog.newline();
			pressAnyKey();
			break;
		default:
			mvaddstrAlt(2, 0, pool[p]->name, gamelog);
			if (len(d.date) > 2)
				addstr_fl(gamelog, CONST_date073.c_str(), pool[p]->heshe(), len(d.date));
			else
			{
				addstrAlt(CONST_date074, gamelog);
				addstrAlt(d.date[0]->name, gamelog);
				addstrAlt(AND, gamelog);
				addstrAlt(d.date[1]->name, gamelog);
				gamelog.newline();
			}
			mvaddstrAlt(3, 0, CONST_date075, gamelog);
			gamelog.newline();
			pressAnyKey();
			break;
		}
		mvaddstrAlt(5, 0, pool[p]->name, gamelog);
		addstrAlt(singleSpace, gamelog);
		addstrAlt(pickrandom(date_fail), gamelog);
		addjuice(*pool[p], -5, -50);
		gamelog.nextMessage();
		pressAnyKey();
		return 1;
	}
	for (int e = len(d.date) - 1; e >= 0; e--)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, CONST_date076);
		addstrAlt(d.date[e]->name, gamelog);
		addstrAlt(commaSpace, gamelog);
		addstrAlt(d.date[e]->get_type_name(), gamelog);
		addstrAlt(commaSpace, gamelog);
		addstrAlt(LocationsPool::getInstance().getLocationNameWithGetnameMethod(d.date[e]->worklocation, false, true), gamelog);
		gamelog.newline();
		set_color_easy(WHITE_ON_BLACK);
		printfunds();
		//Others come to dates unarmed and wearing normal
		//clothing
		vector<Item*> temp;
		d.date[e]->drop_weapons_and_clips(&temp);
		Armor atmp(getarmortype(tag_ARMOR_CLOTHES));
		d.date[e]->give_armor(atmp, &temp);
		printcreatureinfo(d.date[e]);
		makedelimiter();
		while (len(temp))
		{
			if (temp.back()->whatIsThis() == THIS_IS_WEAPON)
				d.date[e]->give_weapon(*(static_cast<Weapon*>(temp.back())), NULL); //casts -XML
			else if (temp.back()->whatIsThis() == THIS_IS_ARMOR)
				d.date[e]->give_armor(*(static_cast<Armor*>(temp.back())), NULL);
			else if (temp.back()->whatIsThis() == THIS_IS_CLIP)
				d.date[e]->take_clips(*(static_cast<Clip*>(temp.back())), temp.back()->get_number());
			delete_and_remove(temp, len(temp) - 1);
		}
		mvaddstrAlt(10, 0, CONST_date077);
		addstrAlt(pool[p]->name);
		addstrAlt(CONST_date078);
		if (ledger.get_funds() >= 100 && !pool[p]->clinic)set_color_easy(WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(11, 0, CONST_date079);
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(12, 0, CONST_date080);
		if (!pool[p]->clinic&&pool[p]->blood == 100)set_color_easy(WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		moveAlt(13, 0);
		if (pool[p]->blood == 100) addstrAlt(CONST_date081);
		else addstrAlt(CONST_date082);
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(14, 0, CONST_date083);
		if (d.date[e]->align == -1 && !pool[p]->clinic)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(15, 0, CONST_date084);
		}
		int thingsincommon = 0;
		for (int s = 0; s < SKILLNUM; s++)
			if (d.date[e]->get_skill(s) >= 1 && pool[p]->get_skill(s) >= 1)
				//Has a skill that is at least half the same skill of the other person on the date.
				if (d.date[e]->get_skill(s) <= pool[p]->get_skill(s) * 2)
					thingsincommon++;
		while (true)
		{
			int c = getkeyAlt();
			short aroll = pool[p]->skill_roll(SKILL_SEDUCTION);
			short troll = d.date[e]->attribute_roll(ATTRIBUTE_WISDOM);
			if (d.date[e]->align == ALIGN_CONSERVATIVE)
				troll += troll * (d.date[e]->juice / 100);
			// Even liberals and moderates shouldn't be TOO easy to seduce! -- SlatersQuest
			else if (d.date[e]->align == ALIGN_MODERATE)
				troll += troll * (d.date[e]->juice / 150);
			else troll += troll * (d.date[e]->juice / 200);
			char test = 0;
			aroll += thingsincommon * 3;
			if (c == 'a'&&ledger.get_funds() >= 100 && !pool[p]->clinic)
			{
				ledger.subtract_funds(100, EXPENSE_DATING);
				aroll += LCSrandom(10);
				test = true;
			}
			else if (c == 'b') test = true;
			if (test)
			{
				pool[p]->train(SKILL_SEDUCTION, LCSrandom(4) + 5);
				pool[p]->train(SKILL_SCIENCE,
					max(d.date[e]->get_skill(SKILL_SCIENCE) - pool[p]->get_skill(SKILL_SCIENCE), 0));
				pool[p]->train(SKILL_RELIGION,
					max(d.date[e]->get_skill(SKILL_RELIGION) - pool[p]->get_skill(SKILL_RELIGION), 0));
				pool[p]->train(SKILL_BUSINESS,
					max(d.date[e]->get_skill(SKILL_BUSINESS) - pool[p]->get_skill(SKILL_BUSINESS), 0));
				if (d.date[e]->get_skill(SKILL_BUSINESS))
				{
					troll += d.date[e]->skill_roll(SKILL_BUSINESS);
					aroll += pool[p]->skill_roll(SKILL_BUSINESS);
				}
				if (d.date[e]->get_skill(SKILL_RELIGION))
				{
					troll += d.date[e]->skill_roll(SKILL_RELIGION);
					aroll += pool[p]->skill_roll(SKILL_RELIGION);
				}
				if (d.date[e]->get_skill(SKILL_SCIENCE))
				{
					troll += d.date[e]->skill_roll(SKILL_SCIENCE);
					aroll += pool[p]->skill_roll(SKILL_SCIENCE);
				}
				int y = 17;
				if (dateresult(aroll, troll, d, e, p, y) == DATERESULT_ARRESTED) return 1;
				break;
			}
			if (c == 'c' && !pool[p]->clinic&&pool[p]->blood == 100)
			{
				for (int e2 = len(d.date) - 1; e2 >= 0; e2--)
				{
					if (e2 == e) continue;
					delete_and_remove(d.date, e2);
					e = 0;
				}
				d.timeleft = 7;
				pool[p]->train(SKILL_SEDUCTION, LCSrandom(40) + 15);
				pool[p]->train(SKILL_SCIENCE,
					max((d.date[e]->get_skill(SKILL_SCIENCE) - pool[p]->get_skill(SKILL_SCIENCE)) * 4, 0));
				pool[p]->train(SKILL_RELIGION,
					max((d.date[e]->get_skill(SKILL_RELIGION) - pool[p]->get_skill(SKILL_RELIGION)) * 4, 0));
				pool[p]->train(SKILL_BUSINESS,
					max((d.date[e]->get_skill(SKILL_BUSINESS) - pool[p]->get_skill(SKILL_BUSINESS)) * 4, 0));
				return 0;
			}
			if (c == 'd')
			{
				delete_and_remove(d.date, e);
				break;
			}
			if (c == 'e'&&d.date[e]->align == -1 && !pool[p]->clinic)
			{
				set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				int bonus = 0;
				mvaddstrAlt(17, 0, pool[p]->name, gamelog);
				if (pool[p]->get_weapon().is_ranged())
				{
					addstrAlt(CONST_date085, gamelog);
					addstrAlt(pool[p]->get_weapon().get_name(1), gamelog);
					mvaddstrAlt(18, 0, CONST_date086, gamelog);
					gamelog.newline();
					bonus = 5;
				}
				else if (pool[p]->is_armed())
				{
					addstrAlt(CONST_date087, gamelog);
					addstrAlt(pool[p]->get_weapon().get_name(1), gamelog);
					mvaddstrAlt(18, 0, CONST_date088, gamelog);
					gamelog.newline();
					if (pool[p]->get_weapon().can_take_hostages())
						bonus = 5;
					else bonus = -1; // Conservative emboldened by the fact that you're trying
				}                 // to kidnap them with a gavel or some shit like that
				else
				{
					addstrAlt(CONST_date089, gamelog);
					moveAlt(18, 0);
					if (lawList[LAW_FREESPEECH] != -2)
						addstrAlt(CONST_date090, gamelog);
					else
						addstrAlt(CONST_date091, gamelog);
					gamelog.newline();
					bonus += pool[p]->get_skill(SKILL_HANDTOHAND) - 1;
				}
				pressAnyKey();
				// Kidnap probably succeeds if the conservative isn't very dangerous,
				// but fails 15 times as often if the conservative is tough stuff.
				if ((!d.date[e]->kidnap_resistant() &&
					LCSrandom(15)) ||
					LCSrandom(2 + bonus))
				{
					set_color_easy(GREEN_ON_BLACK_BRIGHT);
					mvaddstrAlt(20, 0, d.date[e]->name, gamelog);
					if (bonus)
					{
						addstrAlt(CONST_date092, gamelog);
						gamelog.newline();
					}
					else
					{
						addstrAlt(CONST_date093, gamelog);
						gamelog.newline();
					}
					pressAnyKey();
					mvaddstrAlt(22, 0, pool[p]->name, gamelog);
					addstrAlt(CONST_date094, gamelog);
					gamelog.nextMessage();
					pressAnyKey();
					d.date[e]->namecreature();
					strcpy(d.date[e]->propername, d.date[e]->name);
					d.date[e]->location = pool[p]->location;
					d.date[e]->base = pool[p]->base;
					d.date[e]->flag |= CREATUREFLAG_MISSING;
					//Kidnapped wearing normal clothes and no weapon
					d.date[e]->drop_weapons_and_clips(NULL);
					Armor clothes(getarmortype(tag_ARMOR_CLOTHES));
					d.date[e]->give_armor(clothes, NULL);
					//Create InterrogationST data
					d.date[e]->activity.intr() = new InterrogationST;
					eraseAlt();
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(0, 0, CONST_date095);
					addstrAlt(d.date[e]->propername);
					set_color_easy(WHITE_ON_BLACK);
					mvaddstrAlt(2, 0, CONST_date096);
					addstrAlt(d.date[e]->get_type_name());
					addstrAlt(CONST_date097);
					mvaddstrAlt(3, 0, CONST_date098);
					enter_name(4, 0, d.date[e]->name, CREATURE_NAMELEN, d.date[e]->propername);
					addCreature(d.date[e]);
					stat_kidnappings++;
					d.date.erase(d.date.begin() + e);
					break;
				}
				else
				{
					int y = 20;
					if (LCSrandom(2))
					{
						set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
						mvaddstrAlt(y++, 0, d.date[e]->name, gamelog);
						addstrAlt(CONST_date099, gamelog);
						gamelog.newline();
						pressAnyKey();
						mvaddstrAlt((++y)++, 0, pool[p]->name, gamelog);
						addstrAlt(CONST_date100, gamelog);
						gamelog.nextMessage();
						// Charge with kidnapping
						criminalize(*pool[p], LAWFLAG_KIDNAPPING);
						pressAnyKey();
						delete_and_remove(d.date, e);
						break;
					}
					else
					{
						set_color_easy(RED_ON_BLACK_BRIGHT);
						mvaddstrAlt(y++, 0, d.date[e]->name, gamelog);
						addstrAlt(CONST_date101, gamelog);
						addstrAlt(pool[p]->name, gamelog);
						addstrAlt(CONST_date102, gamelog);
						gamelog.newline();
						pressAnyKey();
						mvaddstrAlt((++y)++, 0, CONST_date103, gamelog);
						gamelog.nextMessage();
						// Find the police station
						int ps = find_site_index_in_same_city(SITE_GOVERNMENT_POLICESTATION, pool[p]->location);
						// Arrest the Liberal
						removesquadinfo(*pool[p]);
						pool[p]->carid = -1;
						pool[p]->location = ps;
						pool[p]->drop_weapons_and_clips(NULL);
						pool[p]->activity.type = ACTIVITY_NONE;
						// Charge with kidnapping
						criminalize(*pool[p], LAWFLAG_KIDNAPPING);
						pressAnyKey();
						delete_and_remove(d.date, e);
						return 1;
					}
				}
			}
		}
	}
	if (len(d.date))
	{
		d.timeleft = 0;
		return 0;
	}
	else return 1;
}


// Determines the number of dates a creature has scheduled
int scheduleddates(const Creature& cr)
{
	int dates = 0;
	for (int p = len(date) - 1; p >= 0; p--)
		// Does this creature have a list of dates scheduled?
		if (date[p]->mac_id == cr.id)
		{
			dates = len(date[p]->date); break;
		}
	return dates;
}
int getpoolcreature(int id);
char completedate(datest &d, int p);
void removesquadinfo(Creature &cr);
char completevacation(datest &d, int p);
void doDates(char &clearformess) {
	extern vector<Creature *> pool;
	for (int d = len(date) - 1; d >= 0; d--)
	{
		int p = getpoolcreature(date[d]->mac_id);
		// Stand up dates if 1) dater does not exist, or 2) dater was not able to return to a safehouse today (and is not in the hospital)
		if (p != -1 && ((pool[p]->location != -1 &&
			(LocationsPool::getInstance().getRentingType(pool[p]->location) != RENTING_NOCONTROL ||
				LocationsPool::getInstance().getLocationType(pool[p]->location) == SITE_HOSPITAL_CLINIC ||
				LocationsPool::getInstance().getLocationType(pool[p]->location) == SITE_HOSPITAL_UNIVERSITY) &&
			LocationsPool::getInstance().getLocationCity(pool[p]->location) == date[d]->city) ||
			date[d]->timeleft))
		{
			//VACATION
			if (date[d]->timeleft > 0)
			{
				pool[p]->dating = --date[d]->timeleft;
				if (date[d]->timeleft == 0)
				{
					int hs = find_site_index_in_same_city(SITE_RESIDENTIAL_SHELTER, date[d]->city); //int hs = find_homeless_shelter(date[d]->city);
					if (LocationsPool::getInstance().isThereASiegeHere(pool[p]->base))
						pool[p]->base = hs;
					pool[p]->location = pool[p]->base;
					clearformess = 1;
					if (completevacation(*date[d], p))
					{
						delete_and_remove(date, d);
						continue;
					}
				}
			}
			//DO A DATE
			else
			{
				//TERMINATE NULL DATES
				if (LocationsPool::getInstance().isThereASiegeHere(pool[p]->location))
				{
					delete_and_remove(date, d);
					continue;
				}
				//DO DATE
				else {
					clearformess = 1;
					if (completedate(*date[d], p))
					{
						delete_and_remove(date, d);
						continue;
					}
					else
					{
						pool[p]->dating = date[d]->timeleft;
						if (pool[p]->dating > 0)
						{
							//NOW KICK THE DATER OUT OF THE SQUAD AND LOCATION
							removesquadinfo(*pool[p]);
							pool[p]->location = -1;
						}
					}
				}

			}
		}
		else
		{
			delete_and_remove(date, d);
			continue;
		}
	}
}
void delenc(Creature &tk);
int getCity(int l);
void newDate(Creature &a, Creature &tk) {
	datest *newd = NULL;
	for (int d = 0; d < len(date); d++)
	{
		if (date[d]->mac_id == a.id)
		{
			newd = date[d];
			break;
		}
	}
	if (newd == NULL)
	{
		newd = new datest;
		newd->mac_id = a.id;
		newd->city = getCity(a.location);
		date.push_back(newd);
	}
	Creature *newcr = new Creature;
	*newcr = tk;
	newcr->namecreature();
	newcr->location = a.location;
	newcr->base = a.base;
	newd->date.push_back(newcr);
	// TODO this is a pointer subtracting another pointer in order to calculate the index, change it
	delenc(tk);
}

void delete_and_clear_date_pool() {
	delete_and_clear(date);
}

// #include "../includes.h"
const string CONST_endgame047 = "Press any key to breathe a sigh of relief.                   ";
const string CONST_endgame046 = "Press any key to reflect on what has happened ONE LAST TIME.";
const string CONST_endgame045 = "Press 'C' to watch the ratification process unfold.";
const string CONST_endgame044 = "INVALID ALIGNMENT FOR AMENDMENT";
const string CONST_endgame043 = "Press any key to hold new elections!                           ";
const string CONST_endgame041 = "A National Convention has proposed an ELITE LIBERAL AMENDMENT!";
const string CONST_endgame039 = "the Senate.";
const string CONST_endgame038 = "the President's choosing with the advice and consent of";
const string CONST_endgame037 = ", also of";
const string CONST_endgame036 = "a Proper Justice";
const string CONST_endgame035 = "Proper Justices";
const string CONST_endgame034 = "choosing to be replaced by ";
const string CONST_endgame033 = " of the President's";
const string CONST_endgame032 = "a Conservative country";
const string CONST_endgame031 = "Conservative countries";
const string CONST_endgame030 = "be deported to ";
const string CONST_endgame029 = " will";
const string CONST_endgame028 = "s";
const string CONST_endgame027 = "not serve on the Supreme Court.  Said former citizen";
const string CONST_endgame026 = " may";
const string CONST_endgame024 = "In particular, the aforementioned former citizen";
const string CONST_endgame023 = " branded Arch-Conservative:";
const string CONST_endgame022 = " is";
const string CONST_endgame021 = "s are";
const string CONST_endgame020 = "The following former citizen";
const string CONST_endgame019 = "The Elite Liberal Congress is proposing an ELITE LIBERAL AMENDMENT!";
const string CONST_endgame018 = " to the United States Constitution:";
const string CONST_endgame017 = "Proposed Amendment ";
const string CONST_endgame016 = "AMENDMENT REJECTED.";
const string CONST_endgame015 = "AMENDMENT ADOPTED.";
const string CONST_endgame014 = "Nay";
const string CONST_endgame013 = "Yea";
const string CONST_endgame012 = "Press any key to watch the State votes unfold.              ";
const string CONST_endgame011 = "Press any key to watch the Congressional votes unfold.     ";
const string CONST_endgame010 = "Senate";
const string CONST_endgame009 = "House";
const string CONST_endgame008 = "The Ratification Process:";
const string CONST_endgame007 = "stalinizedCabinet.txt";
const string CONST_endgame006 = "reaganifiedCabinet.txt";
const string CONST_endgame005 = "stalinistPrison.txt";
const string CONST_endgame004 = "conservativePrison.txt";
const string CONST_endgame003 = "amendmentPass.txt";
const string CONST_endgame002 = "archConservativeAmendment.txt";
const string CONST_endgame001 = "stalinAmendment.txt";

#include "../common/misc.h"
// for char* statename(int)
#include "../title/highscore.h"
// for void savehighscore(char endtype);
#include <gui_constants.h>
string pressKeyToReflect;
string they_ll_round_you_up;
vector<int> state_biases;
vector<string> reaganifiedCabinet;
vector<string> stalinizedCabinet;
string proposeConservative;
string proposeStalinist;
vector<string> archConservativeAmendment;
vector<string> stalinAmendment;
string YEA;
string NAY;
string youWentOnVacation;
string youWentIntoHiding;
string whileYouWereInPrison;
string youDisappearedSafely;
vector<string> conservativePrison;
vector<string> stalinistPrison;
vector<string> amendmentPass;
// #include "../customMaps.h"
vector<file_and_text_collection> endgame_text_file_collection = {
	customText(&stalinAmendment, mostlyendings + CONST_endgame001),
	customText(&archConservativeAmendment, mostlyendings + CONST_endgame002),
	customText(&amendmentPass, mostlyendings + CONST_endgame003),
	customText(&conservativePrison, mostlyendings + CONST_endgame004),
	customText(&stalinistPrison, mostlyendings + CONST_endgame005),
	customText(&reaganifiedCabinet, mostlyendings + CONST_endgame006),
	customText(&stalinizedCabinet, mostlyendings + CONST_endgame007),
};
/* EndGameStatus - checks if a constitutional amendment is ratified */
char ratify(int level, int lawview, int view, char congress, char canseethings)
{
	extern MusicClass music;
	extern short house[HOUSENUM];
	extern short senate[SENATENUM];
	extern short attitude[VIEWNUM];
	if (canseethings)
	{
		music.play(MUSIC_ELECTIONS);
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, CONST_endgame008);
	}
	//THE STATE VOTE WILL BE BASED ON VIEW OF LAW
	int mood = publicmood(lawview);
	//OR OF A PARTICULAR ISSUE
	if (view >= 0) mood = attitude[view];
	//CONGRESS
	bool ratified = false;
	if (congress)
	{
		ratified = true;
		if (canseethings)
		{
			mvaddstrAlt(0, 62, CONST_endgame009);
			mvaddstrAlt(0, 70, CONST_endgame010);
			mvaddstrAlt(24, 0, CONST_endgame011);
			pressAnyKey();
		}
		bool yeswin_h = false, yeswin_s = false;
		int yesvotes_h = 0, yesvotes_s = 0, s = 0;
		for (int l = 0; l < HOUSENUM; l++)
		{
			int vote = house[l];
			if (vote >= -1 && vote <= 1) vote += LCSrandom(3) - 1;
			if (level == vote) yesvotes_h++;
			if (l == HOUSENUM - 1) if (yesvotes_h >= HOUSESUPERMAJORITY) yeswin_h = true;
			if (canseethings)
			{
				if (l == HOUSENUM - 1 && yeswin_h) set_color_easy(WHITE_ON_BLACK_BRIGHT);
				else if (l == HOUSENUM - 1) set_color_easy(BLACK_ON_BLACK_BRIGHT);
				else set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(2, 62, yesvotes_h);
				addstrAlt(YEA);
				if (l == HOUSENUM - 1 && !yeswin_h) set_color_easy(WHITE_ON_BLACK_BRIGHT);
				else if (l == HOUSENUM - 1) set_color_easy(BLACK_ON_BLACK_BRIGHT);
				else set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(3, 62, l + 1 - yesvotes_h);
				addstrAlt(NAY);
			}
			if (l % 4 == 0 && s < SENATENUM)
			{
				vote = senate[s++];
				if (vote >= -1 && vote <= 1) vote += LCSrandom(3) - 1;
				if (level == vote) yesvotes_s++;
			}
			if (l == HOUSENUM - 1 && yesvotes_s >= SENATESUPERMAJORITY) yeswin_s = true;
			if (canseethings)
			{
				if (l == HOUSENUM - 1 && yeswin_s) set_color_easy(WHITE_ON_BLACK_BRIGHT);
				else if (l == HOUSENUM - 1) set_color_easy(BLACK_ON_BLACK_BRIGHT);
				else set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(2, 70, yesvotes_s);
				addstrAlt(YEA);
				if (l == HOUSENUM - 1 && !yeswin_s) set_color_easy(WHITE_ON_BLACK_BRIGHT);
				else if (l == HOUSENUM - 1) set_color_easy(BLACK_ON_BLACK_BRIGHT);
				else set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(3, 70, s - yesvotes_s);
				addstrAlt(NAY);
				if (l % 5 == 0) pause_ms(10);
			}
		}
		if (!yeswin_h || !yeswin_s) ratified = false;
	}
	else ratified = true;
	if (level == 3) level = -2; // special case for Stalinists: do this after Congress but before the states
								//STATES
	if (ratified)
	{
		ratified = false;
		int yesstate = 0;
		if (canseethings)
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			for (int s = 0; s < 50; s++)
			{
				if (s < 17) moveAlt(5 + s, 0);
				else if (s < 34) moveAlt(5 + s - 17, 27);
				else mvaddstrAlt(5 + s - 34, 54, statename(s));
			}
			mvaddstrAlt(24, 0, CONST_endgame012);
			pressAnyKey();
		}
		for (int s = 0; s < STATENUM; s++)
		{
			int smood = mood;
			// State biases.
			int multiplier = 5 + LCSrandom(3);
			smood += state_biases[s] * multiplier;
			int vote = -2;
			if (LCSrandom(100) < smood)vote++;
			if (LCSrandom(100) < smood)vote++;
			if (LCSrandom(100) < smood)vote++;
			if (LCSrandom(100) < smood)vote++;
			if (vote == 1 && !LCSrandom(2)) vote = 2;
			if (vote == -1 && !LCSrandom(2)) vote = -2;
			if (canseethings)
			{
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				if (s < 17) moveAlt(5 + s, 22);
				else if (s < 34) moveAlt(5 + s - 17, 49);
				else moveAlt(5 + s - 34, 76);
			}
			if (vote == level)
			{
				yesstate++;
				if (canseethings) addstrAlt(CONST_endgame013);
			}
			else if (canseethings) addstrAlt(CONST_endgame014);
			if (canseethings)
			{
				if (s == STATENUM - 1 && yesstate >= STATESUPERMAJORITY) set_color_easy(WHITE_ON_BLACK_BRIGHT);
				else if (s == STATENUM - 1) set_color_easy(BLACK_ON_BLACK_BRIGHT);
				else set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(23, 50, yesstate);
				addstrAlt(YEA);
				if (s == STATENUM - 1 && yesstate < STATESUPERMAJORITY) set_color_easy(WHITE_ON_BLACK_BRIGHT);
				else if (s == STATENUM - 1) set_color_easy(BLACK_ON_BLACK_BRIGHT);
				else set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(23, 60, s + 1 - yesstate);
				addstrAlt(NAY);
				pause_ms(50);
			}
		}
		if (yesstate >= STATESUPERMAJORITY) ratified = true;
	}
	if (canseethings)
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		moveAlt(23, 0);
		if (ratified) addstrAlt(CONST_endgame015);
		else addstrAlt(CONST_endgame016);
	}
	return ratified;
}
/* EndGameStatus - header for announcing constitutional amendments */
void amendmentheading()
{
	extern int amendnum;
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(0, 0, CONST_endgame017);
	addstrAlt(romannumeral(amendnum));
	addstrAlt(CONST_endgame018);
}
/*
TODO: I'm not sure if anything in here should be logged. Perhaps only the notification
that the country has become arch-conservative... --Addictgamer
*/
/* EndGameStatus - attempts to pass a constitutional amendment to help win the game */
void tossjustices(char canseethings)
{
	extern MusicClass music;
	extern int amendnum;
	extern short court[COURTNUM];
	extern char courtname[COURTNUM][POLITICIAN_NAMELEN];
	if (canseethings)
	{
		music.play(MUSIC_ELECTIONS);
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(12, 6, CONST_endgame019);
		pressAnyKey();
	}
	//STATE THE AMENDMENT
	if (canseethings)
	{
		int tossnum = 0;
		for (int j = 0; j < COURTNUM; j++) if (court[j] != ALIGN_ELITELIBERAL) tossnum++;
		amendmentheading();
		mvaddstrAlt(2, 5, CONST_endgame020);
		if (tossnum != 1)addstrAlt(CONST_endgame021);
		else addstrAlt(CONST_endgame022);
		addstrAlt(CONST_endgame023);
		int y = 4;
		for (int j = 0; j < COURTNUM; j++) if (court[j] != ALIGN_ELITELIBERAL)
		{
			mvaddstrAlt(y++, 0, courtname[j]);
		}
		mvaddstrAlt(y + 1, 5, CONST_endgame024);
		if (tossnum != 1)addstrAlt(CONST_endgame028);
		addstrAlt(CONST_endgame026);
		mvaddstrAlt(y + 2, 0, CONST_endgame027);
		if (tossnum != 1)addstrAlt(CONST_endgame028);
		addstrAlt(CONST_endgame029);
		mvaddstrAlt(y + 3, 0, CONST_endgame030);
		if (tossnum != 1)addstrAlt(CONST_endgame031);
		else addstrAlt(CONST_endgame032);
		addstrAlt(CONST_endgame033);
		mvaddstrAlt(y + 4, 0, CONST_endgame034);
		if (tossnum != 1)addstrAlt(CONST_endgame035);
		else addstrAlt(CONST_endgame036);
		addstrAlt(CONST_endgame037);
		mvaddstrAlt(y + 5, 0, CONST_endgame038);
		mvaddstrAlt(y + 6, 0, CONST_endgame039);
		mvaddstrAlt(24, 0, CONST_endgame045);
		while (getkeyAlt() != 'c');
	}
	if (ratify(2, -1, -1, 1, canseethings))
	{
		//BLAST JUSTICES
		for (int j = 0; j < COURTNUM; j++) if (court[j] != ALIGN_ELITELIBERAL)
		{
			do {
				fullName fn = generate_long_name();
				strcpy(courtname[j], (fn.first + " " + fn.last).data());
			} while (len(courtname[j]) > 20);
			court[j] = ALIGN_ELITELIBERAL;
		}
		amendnum++;
	}
	if (canseethings)
	{
		mvaddstrAlt(24, 0, pressKeyToReflect);
		pressAnyKey();
	}
}
/* EndGameStatus - attempts to pass a constitutional amendment to help win the game */
void amendment_termlimits(char canseethings)
{
	extern MusicClass music;
	extern int amendnum;
	extern bool termlimits;
	if (termlimits)return; // Durr~! Don't pass this amendment if it's already passed!
	if (canseethings)
	{
		music.play(MUSIC_ELECTIONS);
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(12, 6, CONST_endgame041);
		pressAnyKey();
	}
	//STATE THE AMENDMENT
	if (canseethings)
	{
		amendmentheading();
		{
			int i = 2;
			for (string s : amendmentPass) {
				mvaddstrAlt(i, 0, s);
				i++;
			}
		}
		mvaddstrAlt(24, 0, CONST_endgame045);
		while (getkeyAlt() != 'c');
	}
	if (ratify(2, -1, -1, 0, canseethings))
	{
		termlimits = true;
		if (canseethings)
		{
			mvaddstrAlt(24, 0, CONST_endgame043);
			pressAnyKey();
		}
		elections_senate(0, canseethings);
		elections_senate(1, canseethings);
		elections_senate(2, canseethings);
		elections_house(canseethings);
		amendnum++;
	}
	else if (canseethings)
	{
		mvaddstrAlt(24, 0, pressKeyToReflect);
		pressAnyKey();
	}
}
string conservativesRemakeWorld;
string stalinistsRemakeWorld;
void badEndRemakeWorld(const string& str, const string& str2, const string& str3, EndTypes end) {
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	eraseAlt();
	mvaddstrAlt(12, 10, str);
	pressAnyKey();
	set_color_easy(WHITE_ON_BLACK);
	eraseAlt();
	mvaddstrAlt(12, 12, str2);
	pressAnyKey();
	set_color_easy(BLACK_ON_BLACK_BRIGHT);
	eraseAlt();
	mvaddstrAlt(12, 14, str3);
	pressAnyKey();
	savehighscore(end);
}
/* EndGameStatus - attempts to pass a constitutional amendment to lose the game */
void attemptAmendmentEnding(char canseethings, Alignment enforcedAlignment)
{
	extern MusicClass music;
	extern int amendnum;
	extern char cantseereason;
	extern char execname[EXECNUM][POLITICIAN_NAMELEN];
	extern short exec[EXECNUM];
	extern short lawList[LAWNUM];
	vector<string> output;
	MusicModes endMusic;
	vector<string> finalCabinet;
	vector<int> ratificationNumbers;
	string proposedAmendment;
	if (enforcedAlignment == ALIGN_ARCHCONSERVATIVE) {
		proposedAmendment = proposeConservative;
		output = archConservativeAmendment;
		endMusic = MUSIC_REAGANIFIED;
		finalCabinet = reaganifiedCabinet;
		ratificationNumbers = {
			-2,-1,-1,1
		};
	}
	else if (enforcedAlignment == ALIGN_STALINIST) {
		proposedAmendment = proposeStalinist;
		output = stalinAmendment;
		endMusic = MUSIC_STALINIZED;
		finalCabinet = stalinizedCabinet;
		ratificationNumbers = {
			3,-2,-2,1
		};
	}
	else {
		addstrAlt(CONST_endgame044);
		return;
	}
	move_center_string(12, proposedAmendment.data());
	if (canseethings)
	{
		music.play(MUSIC_ELECTIONS);
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		eraseAlt();
		pressAnyKey();
		//STATE THE AMENDMENT
		amendmentheading();
		{
			int i = 2;
			for (string s : output) {
				mvaddstrAlt(i, 0, s);
				i++;
			}
		}
		mvaddstrAlt(24, 0, CONST_endgame045);
		while (getkeyAlt() != 'c');
	}
	if (ratify(ratificationNumbers[0], ratificationNumbers[1], ratificationNumbers[2], ratificationNumbers[3], canseethings))
	{
		music.play(endMusic);
		if (canseethings)
		{
			mvaddstrAlt(24, 0, CONST_endgame046);
			pressAnyKey();
		}
		amendnum = 1; // Constitution repealed...
		if (canseethings)
		{
			strcpy(execname[EXEC_PRESIDENT], finalCabinet[0].data());
			strcpy(execname[EXEC_VP], finalCabinet[1].data());
			strcpy(execname[EXEC_STATE], finalCabinet[2].data());
			strcpy(execname[EXEC_ATTORNEY], finalCabinet[3].data());
			for (int e = 0; e < EXECNUM; e++) exec[e] = enforcedAlignment;
			if (enforcedAlignment == ALIGN_ARCHCONSERVATIVE) {
				for (int l = 0; l < LAWNUM; l++) lawList[l] = enforcedAlignment;
				liberalagenda(-1);
				savehighscore(END_REAGAN);
			}
			else if (enforcedAlignment == ALIGN_STALINIST) {
				for (int l = 0; l < LAWNUM; l++) lawList[l] = stalinview(l, true) ? ALIGN_ELITELIBERAL : ALIGN_ARCHCONSERVATIVE;
				liberalagenda(-2);
				savehighscore(END_STALIN);
			}
		}
		else
		{
			string endingOne;
			string endingTwo;
			string endingThree;
			EndTypes ending;
			vector<string> inPrison;
			switch (cantseereason)
			{
			case 1:
				//DATING AND 
				endingOne = youWentOnVacation;
				if (enforcedAlignment == ALIGN_ARCHCONSERVATIVE) {
					endingTwo = conservativesRemakeWorld;
				}
				else if (enforcedAlignment == ALIGN_STALINIST) {
					endingTwo = stalinistsRemakeWorld;
				}
				endingThree = they_ll_round_you_up;
				ending = END_DATING;
				break;
			case 2:
				//HIDING AND 
				endingOne = youWentIntoHiding;
				if (enforcedAlignment == ALIGN_ARCHCONSERVATIVE) {
					endingTwo = conservativesRemakeWorld;
				}
				else if (enforcedAlignment == ALIGN_STALINIST) {
					endingTwo = stalinistsRemakeWorld;
				}
				endingThree = they_ll_round_you_up;
				ending = END_HIDING;
				break;
			case 3:
				//IF YOU ARE ALL IN PRISON, 
				endingOne = whileYouWereInPrison;
				if (enforcedAlignment == ALIGN_ARCHCONSERVATIVE) {
					vector<string> inPrison = conservativePrison;
				}
				else if (enforcedAlignment == ALIGN_STALINIST) {
					vector<string> inPrison = stalinistPrison;
				}
				endingTwo = inPrison[0];
				endingThree = inPrison[1];
				ending = END_PRISON;
				break;
			case 4:
				//DISBANDED AND 
				endingOne = youDisappearedSafely;
				if (enforcedAlignment == ALIGN_ARCHCONSERVATIVE) {
					endingTwo = conservativesRemakeWorld;
				}
				else if (enforcedAlignment == ALIGN_STALINIST) {
					endingTwo = stalinistsRemakeWorld;
				}
				endingThree = they_ll_round_you_up;
				ending = END_DISBANDLOSS;
				break;
			}
			badEndRemakeWorld(endingOne, endingTwo, endingThree, ending);
		}
		viewhighscores(endMusic);
		end_game();
	}
	else
	{
		if (canseethings)
		{
			mvaddstrAlt(24, 0, CONST_endgame047);
			pressAnyKey();
		}
	}
}

// #include "../includes.h"
const string CONST_fight239 = "'s neck is broken!";
const string CONST_fight238 = "'s neck bones are shattered!";
const string CONST_fight237 = "'s nose is removed!";
const string CONST_fight236 = "'s nose is cut off!";
const string CONST_fight235 = "'s nose is torn off!";
const string CONST_fight234 = "'s nose is burned away!";
const string CONST_fight233 = "'s nose is blasted off!";
const string CONST_fight232 = "'s tongue is removed!";
const string CONST_fight231 = "'s tongue is cut off!";
const string CONST_fight230 = "'s tongue is torn out!";
const string CONST_fight229 = "'s tongue is burned away!";
const string CONST_fight228 = "'s tongue is blasted off!";
const string CONST_fight227 = "'s left eye is removed!";
const string CONST_fight226 = "'s left eye is poked out!";
const string CONST_fight225 = "'s left eye is torn out!";
const string CONST_fight224 = "'s left eye is burned away!";
const string CONST_fight223 = "'s left eye is blasted out!";
const string CONST_fight222 = "'s right eye is removed!";
const string CONST_fight221 = "'s right eye is poked out!";
const string CONST_fight220 = "'s right eye is torn out!";
const string CONST_fight219 = "'s right eye is burned away!";
const string CONST_fight218 = "'s right eye is blasted out!";
const string CONST_fight217 = "knocked out!";
const string CONST_fight216 = "cut out!";
const string CONST_fight215 = "gouged out!";
const string CONST_fight214 = "burned away!";
const string CONST_fight213 = "shot out!";
const string CONST_fight212 = "'s last tooth is ";
const string CONST_fight211 = "'s teeth is ";
const string CONST_fight210 = "One of ";
const string CONST_fight209 = "'s teeth are ";
const string CONST_fight208 = " of ";
const string CONST_fight207 = "All ";
const string CONST_fight206 = "'s face is removed!";
const string CONST_fight205 = "'s face is cut away!";
const string CONST_fight204 = "'s face is torn off!";
const string CONST_fight203 = "'s face is burned away!";
const string CONST_fight202 = "'s face is blasted off!";
const string CONST_fight201 = "broken!";
const string CONST_fight200 = "shot apart!";
const string CONST_fight199 = "'s last unbroken rib is ";
const string CONST_fight198 = "'s rib is ";
const string CONST_fight196 = "'s ribs are ";
const string CONST_fight193 = "'s spleen is punctured!";
const string CONST_fight192 = "'s spleen is torn!";
const string CONST_fight191 = "'s spleen is blasted!";
const string CONST_fight190 = "'s left kidney is punctured!";
const string CONST_fight189 = "'s left kidney is torn!";
const string CONST_fight188 = "'s left kidney is blasted!";
const string CONST_fight187 = "'s right kidney is punctured!";
const string CONST_fight186 = "'s right kidney is torn!";
const string CONST_fight185 = "'s right kidney is blasted!";
const string CONST_fight184 = "'s stomach is punctured!";
const string CONST_fight183 = "'s stomach is torn!";
const string CONST_fight182 = "'s stomach is blasted!";
const string CONST_fight181 = "'s liver is punctured!";
const string CONST_fight180 = "'s liver is torn!";
const string CONST_fight179 = "'s liver is blasted!";
const string CONST_fight178 = "'s heart is punctured!";
const string CONST_fight177 = "'s heart is torn!";
const string CONST_fight176 = "'s heart is blasted!";
const string CONST_fight175 = "'s left lung is punctured!";
const string CONST_fight174 = "'s left lung is torn!";
const string CONST_fight173 = "'s left lung is blasted!";
const string CONST_fight172 = "'s right lung is punctured!";
const string CONST_fight171 = "'s right lung is torn!";
const string CONST_fight170 = "'s right lung is blasted!";
const string CONST_fight169 = "'s lower spine is broken!";
const string CONST_fight168 = "'s lower spine is shattered!";
const string CONST_fight167 = "'s upper spine is broken!";
const string CONST_fight166 = "'s upper spine is shattered!";
const string CONST_fight165 = "'s body.";
const string CONST_fight164 = " drops ";
const string CONST_fight163 = "super enemy";
const string CONST_fight162 = "dangerous enemies";
const string CONST_fight161 = "super enemies";
const string CONST_fight160 = " misses completely!";
const string CONST_fight159 = " just barely missed!";
const string CONST_fight158 = " missed!";
const string CONST_fight154 = " knocks the blow aside and counters!";
const string CONST_fight153 = " to no effect.";
const string CONST_fight146 = "!";
const string CONST_fight145 = "'s corpse";
const string CONST_fight144 = " shields ";
const string CONST_fight143 = " heroically";
const string CONST_fight142 = " misguidedly";
const string CONST_fight141 = "(ATK %d, DEF %d, DAMMOD %d, DAMAGE %d, AP %d)";
const string CONST_fight140 = "the ";
const string CONST_fight139 = "The attack bounces off ";
const string CONST_fight138 = " through ";
const string CONST_fight137 = "striking";
const string CONST_fight136 = "'s ";
const string CONST_fight135 = " hits ";
const string CONST_fight134 = " stabs ";
const string CONST_fight132 = " with a ";
const string CONST_fight131 = "sneaks up on";
const string CONST_fight130 = "bites";
const string CONST_fight129 = "stabs";
const string CONST_fight128 = "breathes fire at";
const string CONST_fight127 = "fires a 120mm shell at";
const string CONST_fight119 = "MISTAKENLY ";
const string CONST_fight118 = " readies another ";
const string CONST_fight117 = " reloads.";
const string CONST_fight116 = "actual";
const string CONST_fight114 = "\"A plague on both your houses...\"";
const string CONST_fight113 = " speaks these final words: ";
const string CONST_fight112 = "soils the floor.";
const string CONST_fight111 = "[makes a mess].";
const string CONST_fight110 = " gasps a last breath and ";
const string CONST_fight109 = "something about Jesus, and dies.";
const string CONST_fight108 = "something [good] about Jesus, and dies.";
const string CONST_fight107 = " sweats profusely, murmurs ";
const string CONST_fight106 = "the neck hole, then is quiet.";
const string CONST_fight105 = " sucks a last breath through ";
const string CONST_fight104 = "neck and falls to the side.";
const string CONST_fight103 = "neck and runs down the hall.";
const string CONST_fight102 = " out of the ";
const string CONST_fight101 = "[red water]";
const string CONST_fight100 = " squirts ";
const string CONST_fight099 = "moment then crumples over.";
const string CONST_fight098 = " sits headless for a ";
const string CONST_fight097 = " stands headless for a ";
const string CONST_fight096 = "is no head, and slumps over.";
const string CONST_fight095 = "is no head, and falls.";
const string CONST_fight094 = " reaches once where there ";
const string CONST_fight093 = " has been destroyed.";
const string CONST_fight091 = "'s grasp.";
const string CONST_fight090 = " slips from";
const string CONST_fight089 = "NULL BODYPART";
const string CONST_fight088 = " remains strong.";
const string CONST_fight087 = " has turned Liberal!";
const string CONST_fight086 = "'s Heart swells!";
const string CONST_fight085 = " seems less badass!";
const string CONST_fight083 = " doesn't want to fight anymore";
const string CONST_fight081 = " is turned Conservative";
const string CONST_fight080 = " can't bear to leave!";
const string CONST_fight079 = " is tainted with Wisdom!";
const string CONST_fight078 = " loses juice!";
const string CONST_fight077 = " already agrees with ";
const string CONST_fight076 = " is immune to the attack!";
const string CONST_fight074 = "rocks out at";
const string CONST_fight073 = "plays country songs at";
const string CONST_fight072 = "plays protest songs at";
const string CONST_fight071 = " at";
const string CONST_fight070 = "blows a harmonica";
const string CONST_fight069 = "strums the ";
const string CONST_fight068 = "sings to";
const string CONST_fight067 = "plays a song for";
const string CONST_fight060 = "explains ethical research to";
const string CONST_fight059 = "explains the benefits of research to";
const string CONST_fight057 = " spits up a cluster of bloody bubbles.";
const string CONST_fight056 = " [makes a mess].";
const string CONST_fight055 = " vomits up a clot of blood.";
const string CONST_fight049 = "'s gums start chattering.";
const string CONST_fight048 = "'s tooth starts chattering.";
const string CONST_fight047 = "'s teeth start chattering.";
const string CONST_fight046 = " pisses on the floor, moaning.";
const string CONST_fight045 = " [makes a mess], moaning.";
const string CONST_fight044 = " stares out with hollow sockets.";
const string CONST_fight043 = " stares into space with one empty eye.";
const string CONST_fight042 = " stares off into space.";
const string CONST_fight041 = " leans against the door.";
const string CONST_fight040 = " stumbles against a wall.";
const string CONST_fight039 = " soils the floor.";
const string CONST_fight038 = " [makes a stinky].";
const string CONST_fight030 = "evasionStringsAlt.txt";
const string CONST_fight029 = "evasionStrings.txt";
const string CONST_fight028 = "body_falls_apart.txt";
const string CONST_fight027 = "double_line_death.txt";
const string CONST_fight026 = "bleeding_animal.txt";
const string CONST_fight025 = "paralyzed_tank.txt";
const string CONST_fight024 = "paralyzed_text.txt";
const string CONST_fight023 = "stunned_text.txt";
const string CONST_fight022 = "bleeding_to_death.txt";
const string CONST_fight021 = "cry_alarm.txt";
const string CONST_fight020 = "scientist_debate.txt";
const string CONST_fight019 = "police_debate.txt";
const string CONST_fight018 = "military_debate.txt";
const string CONST_fight017 = "media_debate.txt";
const string CONST_fight016 = "other_politician_debate.txt";
const string CONST_fight015 = "conservative_politician_debate.txt";
const string CONST_fight014 = "other_ceo_debate.txt";
const string CONST_fight013 = "conservative_ceo_debate.txt";
const string CONST_fight012 = "judge_debate.txt";
const string CONST_fight011 = "escape_crawling.txt";
const string CONST_fight010 = "escape_running.txt";
const string CONST_fightX01 = " cries \"Mommy!\"";
const string CONST_fightX02 = " murmurs \"What about my offspring?\"";
const string CONST_fightX03 = " murmurs \"What about my puppies?\"";
const string CONST_fightX04 = " murmurs \"What about my children?\"";
const string CONST_fightX05 = "\"Better dead than liberal...\"";

#include "../items/money.h"
// #include "../log/log.h"
// for gamelog
//// #include "../common/translateid.h"
int getarmortype(const string &idname);
//// #include "../common/commondisplay.h"
void printparty();
//// #include "../combat/chaseCreature.h"
Vehicle* getChaseVehicle(const Creature &c);
Creature* getChaseDriver(const Creature &c);
//// #include "../combat/haulkidnapCreature.h"
void freehostage(Creature &cr, char situation);
bool goodguyattack = false;
vector<string> escape_running;
vector<string> escape_crawling;
vector<string> judge_debate;
vector<string> conservative_ceo_debate;
vector<string> other_ceo_debate;
vector<string> conservative_politician_debate;
vector<string> other_politician_debate;
vector<string> media_debate;
vector<string> military_debate;
vector<string> police_debate;
vector<string> scientist_debate;
vector<string> cry_alarm;
vector<string> bleeding_to_death;
vector<string> stunned_text;
vector<string> paralyzed_text;
vector<string> paralyzed_tank;
vector<string> bleeding_animal;
vector<vector<string> > double_line_death;
vector<string> body_falls_apart;
vector<string> evasionStringsAlt;
vector<string> evasionStrings;
const string fighty = "fight\\";
const int DOUBLE_LINE = 2;
vector<file_and_text_collection> fighty_text_file_collection = {
	/*fight.cpp*/
	customText(&escape_running, fighty + CONST_fight010),
	customText(&escape_crawling, fighty + CONST_fight011),
	customText(&judge_debate, fighty + CONST_fight012),
	customText(&conservative_ceo_debate, fighty + CONST_fight013),
	customText(&other_ceo_debate, fighty + CONST_fight014),
	customText(&conservative_politician_debate, fighty + CONST_fight015),
	customText(&other_politician_debate, fighty + CONST_fight016),
	customText(&media_debate, fighty + CONST_fight017),
	customText(&military_debate, fighty + CONST_fight018),
	customText(&police_debate, fighty + CONST_fight019),
	customText(&scientist_debate, fighty + CONST_fight020),
	customText(&cry_alarm, fighty + CONST_fight021),
	customText(&bleeding_to_death, fighty + CONST_fight022),
	customText(&stunned_text, fighty + CONST_fight023),
	customText(&paralyzed_text, fighty + CONST_fight024),
	customText(&paralyzed_tank, fighty + CONST_fight025),
	customText(&bleeding_animal, fighty + CONST_fight026),
	customText(&double_line_death, fighty + CONST_fight027, DOUBLE_LINE),
	customText(&body_falls_apart, fighty + CONST_fight028),
	customText(&evasionStrings, mostlyendings + CONST_fight029),
	customText(&evasionStringsAlt, mostlyendings + CONST_fight030),
};
//extern string singleSpace;
//extern string singleDot;
//extern string commaSpace;
vector<Item *> groundloot;

/* generates the loot dropped by a creature when it dies */
void makeloot(Creature &cr, vector<Item *> &loot)
{
	extern short mode;
	cr.drop_weapons_and_clips(&loot);
	cr.strip(&loot);
	if (cr.money > 0 && mode == GAMEMODE_SITE)
	{
		loot.push_back(new Money(cr.money));
		cr.money = 0;
	}
}
void makeloot(Creature &cr)
{
	makeloot(cr, groundloot);
}
bool isThereGroundLoot() {
	return len(groundloot) > 0;
}
void delete_and_clear_groundloot() {
	delete_and_clear(groundloot);
}
// TODO convert this to Linked List?
/* kills the specified creature from the encounter, dropping loot */
void delenc(const short e, const char loot)
{
	extern short mode;
	extern Creature encounter[ENCMAX];
	//MAKE GROUND LOOT
	if ((mode == GAMEMODE_SITE) && loot) makeloot(encounter[e]);
	//BURY IT
	for (int en = e; en < ENCMAX; en++)
	{
		if (!encounter[en].exists) break;
		if (en < ENCMAX - 1) encounter[en] = encounter[en + 1];
	}
	encounter[ENCMAX - 1].exists = 0;
}
void delenc(Creature &tk) {
	extern Creature encounter[ENCMAX];
	delenc(&tk - encounter, 0);
}
string specialWoundPossibilityBody(
	Creature &target,
	const char breakdam,
	const char pokedam,
	const char damtype
);
string specialWoundPossibilityHead(
	Creature &target,
	const char breakdam,
	const char heavydam,
	const char damtype
);
/* checks if the creature can fight and prints flavor text if they can't */
char incapacitated(Creature &a, const char noncombat, char &printed)
{
	extern short mode;
	extern Log gamelog;
	extern short lawList[LAWNUM];
	printed = 0;
	switch (a.animalgloss) {
	case ANIMALGLOSS_TANK:
	{
		if (a.blood <= 20 || (a.blood <= 50 && (LCSrandom(2) || a.forceinc)))
		{
			a.forceinc = 0;
			if (noncombat)
			{
				clearmessagearea();
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(16, 1, tag_The, gamelog);
				addstrAlt(a.name, gamelog);
				addstrAlt(singleSpace + pickrandom(paralyzed_tank));
				gamelog.newline();
				printed = 1;
			}
			return 1;
		}
		return 0;
	}
	case ANIMALGLOSS_ANIMAL:
	{
		if (a.blood <= 20 || (a.blood <= 50 && (LCSrandom(2) || a.forceinc)))
		{
			a.forceinc = 0;
			if (noncombat)
			{
				clearmessagearea();
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(16, 1, tag_The, gamelog);
				addstrAlt(a.name);
				switch (LCSrandom(3))
				{
				case 0: if (lawList[LAW_FREESPEECH] == -2) addstrAlt(CONST_fight038, gamelog);
						else addstrAlt(CONST_fight039, gamelog); break;
				default:
					addstrAlt(singleSpace + pickrandom(bleeding_animal), gamelog); break;
				}
				gamelog.newline();
				printed = 1;
			}
			return 1;
		}
		return 0;
	}
	default:
		if (a.blood <= 20 || (a.blood <= 50 && (LCSrandom(2) || a.forceinc)))
		{
			a.forceinc = 0;
			if (noncombat)
			{
				clearmessagearea();
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(16, 1, a.name);
				switch (LCSrandom(54))
				{
					//TODO IsaacG Complete Migration of Strings
				case 0: if (lawList[LAW_FREESPEECH] == -2) addstrAlt(CONST_fight038);
						else addstrAlt(CONST_fight039); break;
				case 1: if (mode != GAMEMODE_CHASECAR) addstrAlt(CONST_fight040);
						else addstrAlt(CONST_fight041); break;
				case 2: if (a.special[SPECIALWOUND_RIGHTEYE] && a.special[SPECIALWOUND_LEFTEYE])
					addstrAlt(CONST_fight042);
						else if (a.special[SPECIALWOUND_RIGHTEYE] || a.special[SPECIALWOUND_LEFTEYE])
							addstrAlt(CONST_fight043);
						else addstrAlt(CONST_fight044); break;
				case 3: if (lawList[LAW_FREESPEECH] == -2) addstrAlt(CONST_fight045);
						else addstrAlt(CONST_fight046); break;
				case 4: if (a.special[SPECIALWOUND_TEETH] > 1) addstrAlt(CONST_fight047);
						else if (a.special[SPECIALWOUND_TEETH] == 1) addstrAlt(CONST_fight048);
						else addstrAlt(CONST_fight049); break;
				case 5: if (a.age < 20 && !a.animalgloss) addstrAlt(CONST_fightX01);
						else switch (a.type) {
						case CREATURE_GENETIC:
							addstrAlt(CONST_fightX02); break;
						case CREATURE_GUARDDOG:
							addstrAlt(CONST_fightX03); break;
						default:
							addstrAlt(CONST_fightX04); break;
						} break;
				case 6: if (lawList[LAW_FREESPEECH] == -2)addstrAlt(CONST_fight056);
						else addstrAlt(CONST_fight055); break;
				case 7: if (lawList[LAW_FREESPEECH] == -2)addstrAlt(CONST_fight056);
						else addstrAlt(CONST_fight057); break;
				default: addstrAlt(pickrandom(bleeding_to_death));
				}
				printed = 1;
			}
			return 1;
		}
		if (a.stunned)
		{
			if (noncombat)
			{
				a.stunned--;
				clearmessagearea();
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(16, 1, a.name, gamelog);
				addstrAlt(singleSpace + pickrandom(stunned_text));
				gamelog.newline();
				printed = 1;
			}
			return 1;
		}
		if (a.special[SPECIALWOUND_NECK] == 2 || a.special[SPECIALWOUND_UPPERSPINE] == 2)
		{
			if (!noncombat)
			{
				clearmessagearea();
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(16, 1, a.name, gamelog);
				addstrAlt(singleSpace + pickrandom(paralyzed_text));
				gamelog.newline();
				printed = 1;
			}
			return 1;
		}
		return 0;
	}
}
void specialattack(Creature &a, Creature &t)
{
	extern short mode;
	extern Log gamelog;
	extern squadst *activesquad;
	extern short lawList[LAWNUM];
	extern Creature encounter[ENCMAX];
	int resist = 0;
	char str[200];
	clearmessagearea();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	strcpy(str, a.name);
	strcat(str, singleSpace.c_str());
	int attack = 0;
	if (a.align != 1)
		attack = a.attribute_roll(ATTRIBUTE_WISDOM) + t.get_attribute(ATTRIBUTE_WISDOM, false);
	else //if (a.align == 1)
		attack = a.attribute_roll(ATTRIBUTE_HEART) + t.get_attribute(ATTRIBUTE_HEART, false);
	switch (a.type)
	{
	case CREATURE_JUDGE_CONSERVATIVE:
	case CREATURE_JUDGE_LIBERAL:
		strcat(str, pickrandom(judge_debate).c_str());
		strcat(str, singleSpace.c_str());
		strcat(str, t.name);
		strcat(str, CONST_fight146.c_str());
		if (t.align == 1)
			resist = t.skill_roll(SKILL_LAW) +
			t.attribute_roll(ATTRIBUTE_HEART);
		else
			resist = t.skill_roll(SKILL_LAW) +
			t.attribute_roll(ATTRIBUTE_WISDOM);
		attack += a.skill_roll(SKILL_LAW);
		break;
	case CREATURE_SCIENTIST_EMINENT:
		switch (LCSrandom(scientist_debate.size() + 1))
		{
		case 0:if (a.align == ALIGN_CONSERVATIVE)strcat(str, CONST_fight059.c_str());
			   else strcat(str, CONST_fight060.c_str()); break;
		default:
			strcat(str, pickrandom(scientist_debate).c_str()); break;
		}
		strcat(str, singleSpace.c_str());
		strcat(str, t.name);
		strcat(str, CONST_fight146.c_str());
		if (t.align == 1)
			resist = t.skill_roll(SKILL_SCIENCE) +
			t.attribute_roll(ATTRIBUTE_HEART);
		else
			resist = t.skill_roll(SKILL_SCIENCE) +
			t.attribute_roll(ATTRIBUTE_WISDOM);
		attack += a.skill_roll(SKILL_SCIENCE);
		break;
	case CREATURE_POLITICIAN:
		if (a.align == -1)
			strcat(str, pickrandom(conservative_politician_debate).c_str());
		else
			strcat(str, pickrandom(other_politician_debate).c_str());
		strcat(str, singleSpace.c_str());
		strcat(str, t.name);
		strcat(str, CONST_fight146.c_str());
		if (t.align == 1)
			resist = t.skill_roll(SKILL_LAW) +
			t.attribute_roll(ATTRIBUTE_HEART);
		else
			resist = t.skill_roll(SKILL_LAW) +
			t.attribute_roll(ATTRIBUTE_WISDOM);
		attack += a.skill_roll(SKILL_LAW);
		break;
	case CREATURE_CORPORATE_CEO:
		if (a.align == -1)
			strcat(str, pickrandom(conservative_ceo_debate).c_str());
		else
			strcat(str, pickrandom(other_ceo_debate).c_str());
		strcat(str, singleSpace.c_str());
		strcat(str, t.name);
		strcat(str, CONST_fight146.c_str());
		if (t.align == 1)
			resist = t.skill_roll(SKILL_BUSINESS) +
			t.attribute_roll(ATTRIBUTE_HEART);
		else
			resist = t.skill_roll(SKILL_BUSINESS) +
			t.attribute_roll(ATTRIBUTE_WISDOM);
		attack += a.skill_roll(SKILL_BUSINESS);
		break;
	case CREATURE_RADIOPERSONALITY:
	case CREATURE_NEWSANCHOR:
		strcat(str, pickrandom(media_debate).c_str());
		strcat(str, singleSpace.c_str());
		strcat(str, t.name);
		strcat(str, CONST_fight146.c_str());
		if (t.align == 1)
			resist = t.attribute_roll(ATTRIBUTE_HEART);
		else
			resist = t.attribute_roll(ATTRIBUTE_WISDOM);
		attack += a.attribute_roll(ATTRIBUTE_CHARISMA);
		break;
	case CREATURE_MILITARYOFFICER:
		strcat(str, pickrandom(military_debate).c_str());
		strcat(str, singleSpace.c_str());
		strcat(str, t.name);
		strcat(str, CONST_fight146.c_str());
		if (t.align == 1)
			resist = t.attribute_roll(ATTRIBUTE_HEART);
		else
			resist = t.attribute_roll(ATTRIBUTE_WISDOM);
		attack += a.attribute_roll(ATTRIBUTE_CHARISMA);
		break;
	case CREATURE_COP:
		if (a.enemy())
		{
			strcat(str, pickrandom(police_debate).c_str());
			strcat(str, singleSpace.c_str());
			strcat(str, t.name);
			strcat(str, CONST_fight146.c_str());
			resist = t.attribute_roll(ATTRIBUTE_HEART);
			attack += a.skill_roll(SKILL_PERSUASION);
			break;
		}
		//No break. If the cop is a liberal it will do a musical attack instead.
	default:
		if (a.get_weapon().has_musical_attack() || a.type == CREATURE_COP)
		{
			switch (LCSrandom(5))
			{
				//TODO IsaacG Migrate Strings
			case 0:strcat(str, CONST_fight067.c_str()); break;
			case 1:strcat(str, CONST_fight068.c_str()); break;
			case 2:if (a.get_weapon().has_musical_attack())
			{
				strcat(str, CONST_fight069.c_str());
				strcat(str, a.get_weapon().get_name().c_str());
			}
				   else // let's use a small enough instrument for anyone to carry in their pocket
					   strcat(str, CONST_fight070.c_str());
				strcat(str, CONST_fight071.c_str()); break;
			case 3:if (a.align == 1)strcat(str, CONST_fight072.c_str());
				   else strcat(str, CONST_fight073.c_str());
				   break;
			case 4:strcat(str, CONST_fight074.c_str()); break;
			}
			strcat(str, singleSpace.c_str());
			strcat(str, t.name);
			strcat(str, CONST_fight146.c_str());
			attack = a.skill_roll(SKILL_MUSIC);
			if (t.align == 1)
				resist = t.attribute_roll(ATTRIBUTE_HEART);
			else resist = t.attribute_roll(ATTRIBUTE_WISDOM);
			if (resist > 0)
				a.train(SKILL_MUSIC, LCSrandom(resist) + 1);
			else a.train(SKILL_MUSIC, 1);
		}
		break;
	}
	mvaddstrAlt(16, 1, str, gamelog);
	gamelog.newline();
	if ((t.animalgloss == ANIMALGLOSS_TANK || (t.animalgloss == ANIMALGLOSS_ANIMAL && lawList[LAW_ANIMALRESEARCH] != 2))
		|| (a.enemy() && t.flag & CREATUREFLAG_BRAINWASHED))
	{
		mvaddstrAlt(17, 1, t.name + (string)CONST_fight076, gamelog);
	}
	else if (a.align == t.align)
	{
		mvaddstrAlt(17, 1, t.name + (string)CONST_fight077 + a.name + singleDot);
	}
	else if (attack > resist)
	{
		t.stunned += (attack - resist) / 4;
		if (a.enemy())
		{
			if (t.juice > 100)
			{
				mvaddstrAlt(17, 1, t.name + (string)CONST_fight078, gamelog);
				addjuice(t, -50, 100);
			}
			else if (LCSrandom(15) > t.get_attribute(ATTRIBUTE_WISDOM, true) || t.get_attribute(ATTRIBUTE_WISDOM, true) < t.get_attribute(ATTRIBUTE_HEART, true))
			{
				mvaddstrAlt(17, 1, t.name + (string)CONST_fight079, gamelog);
				t.adjust_attribute(ATTRIBUTE_WISDOM, +1);
			}
			else if (t.align == ALIGN_LIBERAL && t.flag & CREATUREFLAG_LOVESLAVE)
			{
				mvaddstrAlt(17, 1, t.name + (string)CONST_fight080, gamelog);
			}
			else
			{
				if (a.align == -1)
				{
					mvaddstrAlt(17, 1, t.name + (string)CONST_fight081, gamelog);
					t.stunned = 0;
					if (t.prisoner != NULL)
						freehostage(t, 0);
					addstrAlt(CONST_fight146, gamelog);
				}
				else
				{
					mvaddstrAlt(17, 1, t.name + (string)CONST_fight083, gamelog);
					t.stunned = 0;
					if (t.prisoner != NULL)
						freehostage(t, 0);
					addstrAlt(CONST_fight146, gamelog);
				}
				for (int e = 0; e < ENCMAX; e++)
				{
					if (encounter[e].exists == 0)
					{
						encounter[e] = t;
						encounter[e].exists = 1;
						if (a.align == -1)conservatise(encounter[e]);
						encounter[e].cantbluff = 2;
						encounter[e].squadid = -1;
						break;
					}
				}
				bool flipstart = 0;
				for (int p = 0; p < 6; p++)
				{
					if (activesquad->squad[p] == &t)
					{
						activesquad->squad[p]->die();
						activesquad->squad[p]->location = -1;
						activesquad->squad[p] = NULL;
						flipstart = 1;
					}
					if (flipstart&&p < 5) activesquad->squad[p] = activesquad->squad[p + 1];
				}
				if (flipstart) activesquad->squad[5] = NULL;
			}
		}
		else
		{
			if (t.juice >= 100)
			{
				mvaddstrAlt(17, 1, t.name + (string)CONST_fight085, gamelog);
				addjuice(t, -50, 99);
			}
			else if (!t.attribute_check(ATTRIBUTE_HEART, DIFFICULTY_AVERAGE) ||
				t.get_attribute(ATTRIBUTE_HEART, true) < t.get_attribute(ATTRIBUTE_WISDOM, true))
			{
				mvaddstrAlt(17, 1, t.name + (string)CONST_fight086, gamelog);
				t.adjust_attribute(ATTRIBUTE_HEART, +1);
			}
			else
			{
				mvaddstrAlt(17, 1, t.name + (string)CONST_fight087, gamelog);
				t.stunned = 0;
				liberalize(t);
				t.infiltration /= 2;
				t.flag |= CREATUREFLAG_CONVERTED;
				t.cantbluff = 0;
			}
		}
	}
	else
	{
		mvaddstrAlt(17, 1, t.name + (string)CONST_fight088, gamelog);
	}
	gamelog.newline();
	printparty();
	if (mode == GAMEMODE_CHASECAR ||
		mode == GAMEMODE_CHASEFOOT) printchaseencounter();
	else printencounter();
	pressAnyKey();
	return;
}
/* modifies a combat roll based on the creature's critical injuries */
void healthmodroll(int &aroll, Creature &a)
{
	if (a.special[SPECIALWOUND_RIGHTEYE] != 1) aroll -= LCSrandom(2);
	if (a.special[SPECIALWOUND_LEFTEYE] != 1) aroll -= LCSrandom(2);
	if (a.special[SPECIALWOUND_RIGHTEYE] != 1 &&
		a.special[SPECIALWOUND_LEFTEYE] != 1) aroll -= LCSrandom(20);
	if (a.special[SPECIALWOUND_RIGHTLUNG] != 1) aroll -= LCSrandom(8);
	if (a.special[SPECIALWOUND_LEFTLUNG] != 1) aroll -= LCSrandom(8);
	if (a.special[SPECIALWOUND_HEART] != 1) aroll -= LCSrandom(10);
	if (a.special[SPECIALWOUND_LIVER] != 1) aroll -= LCSrandom(5);
	if (a.special[SPECIALWOUND_STOMACH] != 1) aroll -= LCSrandom(5);
	if (a.special[SPECIALWOUND_RIGHTKIDNEY] != 1) aroll -= LCSrandom(5);
	if (a.special[SPECIALWOUND_LEFTKIDNEY] != 1) aroll -= LCSrandom(5);
	if (a.special[SPECIALWOUND_SPLEEN] != 1) aroll -= LCSrandom(4);
	if (a.special[SPECIALWOUND_LOWERSPINE] != 1) aroll -= LCSrandom(100);
	if (a.special[SPECIALWOUND_UPPERSPINE] != 1) aroll -= LCSrandom(200);
	if (a.special[SPECIALWOUND_NECK] != 1) aroll -= LCSrandom(300);
	if (a.special[SPECIALWOUND_RIBS] < RIBNUM) aroll -= LCSrandom(5);
	if (a.special[SPECIALWOUND_RIBS] < RIBNUM / 2) aroll -= LCSrandom(5);
	if (a.special[SPECIALWOUND_RIBS] == 0) aroll -= LCSrandom(5);
}
/* adjusts attack damage based on armor, other factors */
void damagemod(Creature &t, const char &damtype, int &damamount, int mod)
{

	if (mod > 10) mod = 10; // Cap damage multiplier (every 5 points adds 1x damage)
	if (mod <= -20) damamount >>= 8;  //Cars plus heavy armor can be really tough.
	else if (mod <= -14) damamount >>= 7;
	else if (mod <= -8) damamount >>= 6;
	else if (mod <= -6) damamount >>= 5;
	else if (mod <= -4) damamount >>= 4;
	else if (mod <= -3) damamount >>= 3;
	else if (mod <= -2) damamount >>= 2;
	else if (mod <= -1) damamount >>= 1;
	else if (mod >= 0) damamount = (int)((float)damamount * (1.0f + 0.2f*mod));
	// Firefighter's bunker gear reduces fire damage by 3/4
	if ((damtype & WOUND_BURNED) && t.get_armor().has_fireprotection())
	{
		// Damaged gear isn't as effective as undamaged gear
		if (t.get_armor().is_damaged())
			damamount >>= 1; // Only half as much damage reduction
		else
			damamount >>= 2; // Full damage reduction
	}
	if (damamount < 0)damamount = 0;
}
map<short, string> tankBodyParts;
map<short, string> animalBodyParts;
map<short, string> humanBodyParts;
std::string bodypartName(Bodyparts w, AnimalGlosses t) {
	if (t == ANIMALGLOSS_TANK) {
		if (tankBodyParts.count(w) > 0)
			return tankBodyParts[w];
	}
	else if (t == ANIMALGLOSS_ANIMAL) {// FIXME: What about Six-legged Pigs?
		if (animalBodyParts.count(w) > 0)
			return animalBodyParts[w];
	}
	else {
		if (humanBodyParts.count(w) > 0)
			return humanBodyParts[w];
	}
	return CONST_fight089;
}
/* damages the selected armor if it covers the body part specified */
void armordamage(Armor &armor, const int bp, const int damamount)
{
	if (armor.covers(bp) && LCSrandom(armor.get_durability()) < damamount)
	{
		if (armor.is_damaged())
		{
			armor.decrease_quality(LCSrandom(armor.get_durability()) < LCSrandom(damamount) / armor.get_quality() ? 1 : 0);
		}
		else
		{
			armor.set_damaged(true);
		}
	}
}
std::string burstHitString(int bursthits);
/* blood explosions */
void bloodblast(Armor* armor)
{
	extern short mode;
	extern squadst *activesquad;
	extern int locx;
	extern int locy;
	extern int locz;
	extern Creature encounter[ENCMAX];
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	//GENERAL
	if (armor != NULL)
		armor->set_bloody(true);
	if (mode != GAMEMODE_SITE)
		return;
	levelmap[locx][locy][locz].flag |= SITEBLOCK_BLOODY2;
	//HIT EVERYTHING
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] == NULL) continue;
		if (!LCSrandom(2))
			activesquad->squad[p]->get_armor().set_bloody(true);
	}
	for (int e = 0; e < ENCMAX; e++)
	{
		if (!encounter[e].exists) continue;
		if (!LCSrandom(2))
			encounter[e].get_armor().set_bloody(true);
	}
	//REFRESH THE SCREEN
	printsitemap(locx, locy, locz);
	refreshAlt();
}
/* destroys armor, masks, drops weapons based on severe damage */
void severloot(Creature &cr)
{
	extern short mode;
	extern Log gamelog;
	int armok = 2;
	if ((cr.wound[BODYPART_ARM_RIGHT] & WOUND_NASTYOFF) ||
		(cr.wound[BODYPART_ARM_RIGHT] & WOUND_CLEANOFF)) armok--;
	if ((cr.wound[BODYPART_ARM_LEFT] & WOUND_NASTYOFF) ||
		(cr.wound[BODYPART_ARM_LEFT] & WOUND_CLEANOFF)) armok--;
	if (cr.special[SPECIALWOUND_NECK] != 1) armok = 0;
	if (cr.special[SPECIALWOUND_UPPERSPINE] != 1) armok = 0;
	if (cr.is_armed() && armok == 0)
	{
		clearmessagearea();
		set_color_easy(YELLOW_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, tag_The, gamelog);
		addstrAlt(cr.get_weapon().get_name(1), gamelog);
		addstrAlt(CONST_fight090, gamelog);
		mvaddstrAlt(17, 1, cr.name, gamelog);
		addstrAlt(CONST_fight091, gamelog);
		gamelog.newline();
		pressAnyKey();
		if (mode == GAMEMODE_SITE) cr.drop_weapons_and_clips(&groundloot);
		else cr.drop_weapons_and_clips(NULL);
	}
	if ((((cr.wound[BODYPART_BODY] & WOUND_CLEANOFF) ||
		(cr.wound[BODYPART_BODY] & WOUND_NASTYOFF)) &&
		cr.get_armor().covers(BODYPART_BODY)) ||
		((cr.wound[BODYPART_HEAD] & WOUND_NASTYOFF) &&
			cr.get_armor().is_mask()))
	{
		clearmessagearea();
		set_color_easy(YELLOW_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, cr.name, gamelog);
		addstrAlt(CONST_fight136, gamelog);
		addstrAlt(cr.get_armor().get_name(), gamelog);
		addstrAlt(CONST_fight093, gamelog);
		gamelog.newline();
		pressAnyKey();
		cr.strip(NULL);
	}
}
/* describes a character's death */
void adddeathmessage(Creature &cr)
{
	extern short mode;
	extern Log gamelog;
	extern short lawList[LAWNUM];
	extern string slogan_str;
	set_color_easy(YELLOW_ON_BLACK_BRIGHT);
	char str[200];
	char secondLine[200];
	bool hasSecondLine = false;
	strcpy(str, cr.name);
	if ((cr.wound[BODYPART_HEAD] & WOUND_CLEANOFF) ||
		(cr.wound[BODYPART_HEAD] & WOUND_NASTYOFF))
	{
		hasSecondLine = true;
		switch (LCSrandom(4))
		{
			//TODO IsaacG Complete Migration of Strings
		case 0:
			strcat(str, CONST_fight094.c_str());
			if (mode != GAMEMODE_CHASECAR)
				strcpy(secondLine, CONST_fight095.c_str());
			else strcpy(secondLine, CONST_fight096.c_str());
			break;
		case 1:
			if (mode != GAMEMODE_CHASECAR)
				strcat(str, CONST_fight097.c_str());
			else strcat(str, CONST_fight098.c_str());
			strcpy(secondLine, CONST_fight099.c_str());
			break;
		case 2:
			strcat(str, CONST_fight100.c_str());
			if (lawList[LAW_FREESPEECH] == -2)strcat(str, CONST_fight101.c_str());
			else strcat(str, tag_blood.c_str());
			strcat(str, CONST_fight102.c_str());
			if (mode != GAMEMODE_CHASECAR)
				strcpy(secondLine, CONST_fight103.c_str());
			else strcpy(secondLine, CONST_fight104.c_str());
			break;
		case 3:
			strcat(str, CONST_fight105.c_str());
			strcpy(secondLine, CONST_fight106.c_str());
			break;
		}
	}
	else if ((cr.wound[BODYPART_BODY] & WOUND_CLEANOFF) ||
		(cr.wound[BODYPART_BODY] & WOUND_NASTYOFF))
	{
		strcat(str, (singleSpace + pickrandom(body_falls_apart)).c_str());
	}
	else
	{
		hasSecondLine = true;
		switch (LCSrandom(11))
		{
		case 0:
			strcat(str, CONST_fight107.c_str());
			if (lawList[LAW_FREESPEECH] == -2)strcpy(secondLine, CONST_fight108.c_str());
			else strcpy(secondLine, CONST_fight109.c_str());
			break;
		case 1:
			strcat(str, CONST_fight110.c_str());
			if (lawList[LAW_FREESPEECH] == -2) strcpy(secondLine, CONST_fight111.c_str());
			else strcpy(secondLine, CONST_fight112.c_str());
			break;
		case 2:
			strcat(str, CONST_fight113.c_str());
			switch (cr.align)
			{
			case ALIGN_LIBERAL:
			case ALIGN_ELITELIBERAL:
				strcpy(secondLine, slogan_str.c_str()); break;
			case ALIGN_MODERATE:
				strcpy(secondLine, CONST_fight114.c_str()); break;
			default:
				strcpy(secondLine, CONST_fightX05.c_str()); break;
			}
			break;
		default:
			vector<string> death = pickrandom(double_line_death);
			strcat(str, (singleSpace + death[0]).c_str());
			strcpy(secondLine, death[1].c_str());
			break;
		}
	}
	mvaddstrAlt(16, 1, str, gamelog);
	if (hasSecondLine) {
		mvaddstrAlt(17, 1, secondLine, gamelog);
	}
	gamelog.newline();
}
/* attack handling for an individual creature and its target */
// returns a boolean representing whether it was the intended target or CONST_fight116
// so bool actual does not need to be passed by reference
bool attack(Creature &a, Creature &t, const char mistake, const bool force_melee = false);

bool attemptSpecialAttack(Creature &a, Creature &t, const bool force_melee) {
	extern Creature encounter[ENCMAX];
	//SPECIAL ATTACK!
	int encnum = 0;
	for (int e = 0; e < ENCMAX; e++) if (encounter[e].exists) encnum++;
	bool specialAttackIsPossible = (!force_melee &&
		(((a.type == CREATURE_COP && a.align == ALIGN_MODERATE && a.enemy()) ||
			a.type == CREATURE_SCIENTIST_EMINENT ||
			a.type == CREATURE_JUDGE_LIBERAL ||
			a.type == CREATURE_JUDGE_CONSERVATIVE ||
			(a.type == CREATURE_CORPORATE_CEO && LCSrandom(2)) ||
			a.type == CREATURE_POLITICIAN ||
			a.type == CREATURE_RADIOPERSONALITY ||
			a.type == CREATURE_NEWSANCHOR ||
			a.type == CREATURE_MILITARYOFFICER ||
			a.get_weapon().has_musical_attack()) &&
			(a.get_weapon().has_musical_attack() || !a.is_armed() || a.align != 1)));
	if (specialAttackIsPossible)
	{
		if (a.align == 1 || encnum < ENCMAX)
		{
			specialattack(a, t);
			return true;
		}
	}
	return false;
}
bool attemptReload(Creature &a, const bool force_melee) {
	extern short mode;
	extern Log gamelog;
	//RELOAD
	if ((a.will_reload(mode == GAMEMODE_CHASECAR, force_melee)
		|| (a.has_thrown_weapon && len(a.extra_throwing_weapons)))
		&& !force_melee)
	{
		char str[200];
		if (a.will_reload(mode == GAMEMODE_CHASECAR, force_melee))
		{
			a.reload(false);
			strcpy(str, a.name);
			strcat(str, CONST_fight117.c_str());
		}
		else if (a.has_thrown_weapon && len(a.extra_throwing_weapons))
		{
			a.ready_another_throwing_weapon();
			strcpy(str, a.name);
			strcat(str, CONST_fight118.c_str());
			strcat(str, a.get_weapon().get_name().c_str());
			strcat(str, singleDot.c_str());
		}
		mvaddstrAlt(16, 1, str, gamelog);
		gamelog.newline();
		printparty();
		if (mode == GAMEMODE_CHASECAR
			|| mode == GAMEMODE_CHASEFOOT) printchaseencounter();
		else printencounter();
		pressAnyKey();
		return true;
	}
	else if (a.has_thrown_weapon) a.has_thrown_weapon = false;
	return false;
}
bool attemptIncapacitated(Creature &a) {
	extern short mode;
	//INCAPACITATED
	char incaprint;
	a.forceinc = 0;
	if (incapacitated(a, 0, incaprint))
	{
		if (incaprint)
		{
			printparty();
			if (mode == GAMEMODE_CHASECAR ||
				mode == GAMEMODE_CHASEFOOT) printchaseencounter();
			else printencounter();
			pressAnyKey();
		}
		a.forceinc = 1;
		return true;
	}
	return false;
}

string showMultipleHits(Creature &a, const int bursthits, const attackst* attack_used) {
	string str;
	// show multiple hits
	if (bursthits > 1 && a.is_armed()) // Only show if not melee
	{
		str = commaSpace;
		if (!a.is_armed()) //Move into WEAPON_NONE? -XML
		{
			str += CONST_fight137;
		}
		else {
			str += attack_used->hit_description;
		}
		str += burstHitString(bursthits);
	}
	else if (attack_used->always_describe_hit)
	{
		str += commaSpace;
		str += attack_used->hit_description;
	}
	return str;
}
Creature* takeBulletForLeader(Creature &t, const int damamount, const int w) {
	extern Log gamelog;
	extern squadst *activesquad;
	Creature* target = 0;
	if (t.squadid != -1 && t.hireid == -1 && //if the founder is hit...
		(damamount > t.blood || damamount >= 10) && //and lethal or potentially crippling damage is done...
		(w == BODYPART_HEAD || w == BODYPART_BODY)) //to a critical bodypart...
	{
		//Oh Noes!!!! Find a liberal to jump in front of the bullet!!!
		for (int i = 0; i < 6; i++)
		{
			if (activesquad->squad[i] == NULL) break;
			if (activesquad->squad[i] == &t) break;
			if (activesquad->squad[i]->get_attribute(ATTRIBUTE_HEART, true) > 8 &&
				activesquad->squad[i]->get_attribute(ATTRIBUTE_AGILITY, true) > 4)
			{
				target = activesquad->squad[i];
				clearmessagearea();
				set_color_easy(GREEN_ON_BLACK_BRIGHT);
				mvaddstrAlt(16, 1, target->name, gamelog);
				if (!t.alive) addstrAlt(CONST_fight142, gamelog);
				else addstrAlt(CONST_fight143, gamelog);
				addstrAlt(CONST_fight144, gamelog);
				addstrAlt(t.name, gamelog);
				if (!t.alive) addstrAlt(CONST_fight145, gamelog);
				addstrAlt(CONST_fight146, gamelog);
				gamelog.newline();
				addjuice(*target, 10, 1000);//Instant juice!! Way to take the bullet!!
				pressAnyKey();
				break;
			}
		}
	}
	return target;
}

int determineBodypartHit(Creature &t, const int aroll, const int droll, const bool sneak_attack) {

	bool canhit = false;
	for (int w = 0; w < BODYPARTNUM && !canhit; w++)
	{
		if (!(t.wound[w] & WOUND_CLEANOFF) && !(t.wound[w] & WOUND_NASTYOFF))
		{
			canhit = true;
		}
	}
	int w;
	do
	{
		int offset = 0;
		if (aroll > droll + 5)
			offset = 4;  // NICE SHOT; MORE LIKELY TO HIT BODY/HEAD
		if (aroll > droll + 10 &&
			(!(t.wound[BODYPART_HEAD] & (WOUND_CLEANOFF | WOUND_NASTYOFF)) ||
				!(t.wound[BODYPART_BODY] & (WOUND_CLEANOFF | WOUND_NASTYOFF))))
			offset = 8;  // NO LIMB HITS HERE YOU AWESOME PERSON
		if (sneak_attack)
			offset = 10; // Backstab! 2/3 body, 1/3 head
		if (aroll > droll + 15 &&
			!(t.wound[BODYPART_HEAD] & (WOUND_CLEANOFF | WOUND_NASTYOFF)))
			offset = 12; // BOOM AUTOMATIC HEADSHOT MOTHA******
						 //Weighted location roll:
						 //200% chance to hit body
						 //50% chance to hit head
		w = offset + LCSrandom(13 - offset);
		switch (w)
		{
		case 12:w = BODYPART_HEAD; break;
		case 11:
		case 10:
		case 9:
		case 8:w = BODYPART_BODY; break;
		case 7:
		case 3:w = BODYPART_ARM_RIGHT; break;
		case 6:
		case 2:w = BODYPART_ARM_LEFT; break;
		case 5:
		case 1:w = BODYPART_LEG_RIGHT; break;
		case 4:
		case 0:w = BODYPART_LEG_LEFT; break;
		}
	} while (((t.wound[w] & WOUND_CLEANOFF) || (t.wound[w] & WOUND_NASTYOFF)) && canhit == true);
	return w;
}
string printSpecialWounds(Creature* target, const int w, const int damamount, const int damtype) {

	char heavydam = 0, breakdam = 0, pokedam = 0;
	if (damamount >= 12) //JDS -- 2x damage needed
	{
		if (damtype & WOUND_SHOT || damtype & WOUND_BURNED || damtype & WOUND_TORN || damtype & WOUND_CUT) heavydam = 1;
	}
	if (damamount >= 10) //JDS -- 2x damage needed
	{
		if (damtype & WOUND_SHOT || damtype & WOUND_TORN || damtype & WOUND_CUT) pokedam = 1;
	}
	if ((damtype & WOUND_BRUISED || damtype & WOUND_SHOT || damtype & WOUND_TORN || damtype & WOUND_CUT) && damamount >= 50) {
		breakdam = 1;
	}
	string damageDescription;
	switch (w) {
	case BODYPART_HEAD:
		damageDescription = specialWoundPossibilityHead(
			*target,
			breakdam,
			heavydam,
			damtype
		);
		break;
	case BODYPART_BODY:
		string damageDescription = specialWoundPossibilityBody(
			*target,
			breakdam,
			pokedam,
			damtype
		);
		break;
	}
	return damageDescription;

}


char consolidateDamageTypesNotCutOrBruised(const attackst* attack_used) {
	char damtype = 0;
	if (attack_used->burns) damtype |= WOUND_BURNED;
	if (attack_used->tears) damtype |= WOUND_TORN;
	if (attack_used->shoots) damtype |= WOUND_SHOT;
	if (attack_used->bleeding) damtype |= WOUND_BLEEDING;
	return damtype;
}

char consolidateDamageTypes(const attackst* attack_used) {
	char damtype = 0;
	if (attack_used->bruises) damtype |= WOUND_BRUISED;
	if (attack_used->cuts) damtype |= WOUND_CUT;
	damtype |= consolidateDamageTypesNotCutOrBruised(attack_used);
	return damtype;
}

string howGracefulAttack(int handToHand);
string initiateCombat(const Creature a, const bool sneak_attack, const attackst* attack_used) {
	extern short sitealarm;

	string str;

	if (!a.is_armed())
	{
		if (!a.animalgloss) //Move into WEAPON_NONE -XML
		{
			str += howGracefulAttack(a.get_skill(SKILL_HANDTOHAND));
		}
		else
		{
			if (a.specialattack == ATTACK_CANNON)
			{
				str += CONST_fight127;
			}
			else if (a.specialattack == ATTACK_FLAME) str += CONST_fight128;
			else if (a.specialattack == ATTACK_SUCK) str += CONST_fight129;
			else str += CONST_fight130;
		}
	}
	else
	{

		if (sneak_attack)
		{
			str += CONST_fight131;
		}
		else {
			str += attack_used->attack_description;
			sitealarm = 1;
		}
	}
	return str;
}

string unsuccessfulHit(Creature &a, Creature &t, const int droll) {

	extern short mode;

	string str;

	if (mode == GAMEMODE_CHASECAR)
	{
		Creature* driver = getChaseDriver(t);
		str = driver->name;
		if (droll == 1) {
			str = a.name;
			str += CONST_fight158;
		}
		else if (droll == 2) {
			str = a.name;
			str += CONST_fight159;
		}
		else if (droll > 18 || droll < 1) {
			str = a.name;
			str += CONST_fight160;  // You failed to hit someone who probably rolled a zero.  You should feel bad.
		}
		else {
			str += evasionStringsAlt[droll - 3];
		}
	}
	else {
		str = t.name;
		if (droll == 1) {
			str = a.name;
			str += CONST_fight158;
		}
		else if (droll == 2) {
			str = a.name;
			str += CONST_fight159;
		}
		else if (droll > 18 || droll < 1) {
			str = a.name;
			str += CONST_fight160;  // You failed to hit someone who probably rolled a zero.  You should feel bad.
		}
		else {
			str += evasionStrings[droll - 3];
		}
	}
	return str;

}


string dismemberingWound(const int w, const int wound);
void addLocationChange(int cursite, sitechangest change);
int bodypartSeverAmount(const int w);
/* attack handling for an individual creature and its target */
bool attack(Creature &a, Creature &t, const char mistake, const bool force_melee)
{
	extern short mode;
	extern int stat_dead;
	extern int stat_kills;
	extern int ccs_siege_kills;
	extern int ccs_boss_kills;
	extern Log gamelog;
	extern newsstoryst *sitestory;
	extern short sitealarm;
	extern int sitecrime;
	extern short cursite;
	extern int locx;
	extern int locy;
	extern int locz;
	extern short sitealarmtimer;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	extern short lawList[LAWNUM];
	//char newActual = 0;
	clearmessagearea(true);  // erase the whole length and redraw map if applicable, since previous combat messages can be wider than 53 chars.
	if (goodguyattack) set_color_easy(GREEN_ON_BLACK_BRIGHT);
	else set_color_easy(RED_ON_BLACK_BRIGHT);

	const attackst* attack_used = a.get_weapon().get_attack(mode == GAMEMODE_CHASECAR,          //Force ranged if in a car.
		force_melee,
		(force_melee || !a.can_reload())); //No reload if force melee or unable to reload.
	if (attemptIncapacitated(a) || attemptSpecialAttack(a, t, force_melee) || attemptReload(a, force_melee) || attack_used == NULL) {
		// All exit points consolidated here, except the final one.
		// These four conditions, in order, determine the attacker is not capable of attacking using the standard attack()
		// It relies on lazy conditional OR, since each condition has side effects.
		return false;
	}

	// for tanks, attack_used->ranged returns false, so we need to check if it's a tank
	bool melee = !attack_used->ranged && !(!a.is_armed() && a.animalgloss && a.specialattack == ATTACK_CANNON);
	
	bool sneak_attack = a.is_armed() && (attack_used->can_backstab && a.align == ALIGN_LIBERAL && !mistake) && (t.cantbluff < 1 && sitealarm < 1);

	if (sneak_attack)
	{
		if (sitealarmtimer > 10 || sitealarmtimer < 0) { 
			sitealarmtimer = 10;
		}
		t.cantbluff = 2;
	}

	{
		string str = a.name;

		str += singleSpace;
		if (mistake) { str += CONST_fight119; }
		str += initiateCombat(a, sneak_attack, attack_used);
		str += singleSpace;
		str += t.name;

		if (a.is_armed() && !attack_used->thrown)
		{
			str += CONST_fight132;
			str += a.get_weapon().get_name(1);
		}

		str += CONST_fight146;

		mvaddstrAlt(16, 1, str, gamelog);
	}
	gamelog.newline();
	pressAnyKey();
	if (goodguyattack) set_color_easy(GREEN_ON_BLACK_BRIGHT);
	else set_color_easy(RED_ON_BLACK_BRIGHT);
	
	int bonus = 0; // Accuracy bonus or penalty that does NOT affect damage or counterattack chance
				   //SKILL EFFECTS
	const int wsk = attack_used->skill;
	Creature* driver = getChaseDriver(t);
	Creature* adriver = getChaseDriver(a);
	Vehicle* avehicle = getChaseVehicle(a);
	Vehicle* vehicle = getChaseVehicle(t);
	// Basic roll
	int aroll = a.skill_roll(wsk);
	// In a car chase, the driver provides the defence roll instead of the victim.
	int droll = 0;
	if (mode != GAMEMODE_CHASECAR)
	{
		droll = t.skill_roll(SKILL_DODGE) / 2;
	}
	else
	{
		if (driver != NULL && vehicle != NULL)
		{  // without a vehicle or driver, you get a zero roll.
			droll = driver->skill_roll(PSEUDOSKILL_DODGEDRIVE);
		}
		if (adriver != NULL && avehicle != NULL)
		{
			bonus += avehicle->attackbonus(adriver->id == a.id);  // Attack bonus depends on attacker's car and whether attacker is distracted by driving.
		}
		else // shouldn't happen
		{
			bonus -= 10; // You're on the wrong side of a drive-by shooting?!
		}
	}
	if (sneak_attack)
	{
		droll = t.attribute_roll(ATTRIBUTE_WISDOM) / 2;
		aroll += a.skill_roll(SKILL_STEALTH);
		a.train(wsk, 10);
	}
	else
	{
		if (driver != NULL)
			driver->train(SKILL_DRIVING, aroll / 2);
		else
			t.train(SKILL_DODGE, aroll * 2);
		a.train(wsk, droll * 2 + 5);
	}
	// Hostages interfere with attack
	if (t.prisoner != NULL) bonus -= LCSrandom(10);
	if (a.prisoner != NULL) aroll -= LCSrandom(10);
	//Injured people suck at attacking, are like fish in a barrel to attackers
	if (mode == GAMEMODE_CHASEFOOT)
	{
		// If in a foot chase, double the debilitating effect of injuries
		healthmodroll(aroll, a);
		healthmodroll(droll, t);
		healthmodroll(droll, t);
	}
	else if (mode == GAMEMODE_CHASECAR)
	{
		// In a car chase, the driver is applying dodge rolls even for crippled people.
		healthmodroll(aroll, a);
		if (driver != NULL)
		{// if there is no driver, we already rolled a zero, so don't worry about further penalties.
			healthmodroll(droll, *driver);
		}
	}
	else
	{
		// Any other case (site fight) normal penalties.
		healthmodroll(aroll, a);
		healthmodroll(droll, t);
	}
	// Prevent negative rolls
	if (aroll < 0) aroll = 0;
	if (droll < 0) droll = 0;
	// Weapon accuracy bonuses and penalties
	bonus += attack_used->accuracy_bonus;
	//USE BULLETS
	int bursthits = 0; // Tracks number of hits.
	int thrownweapons = 0; // Used by thrown weapons to remove the weapons at the end of the turn if needed
	if (!a.is_armed()) //Move into WEAPON_NONE -XML
	{
		// Martial arts multi-strikes
		bursthits = 1 + LCSrandom(a.get_skill(SKILL_HANDTOHAND) / 3 + 1);
		if (bursthits > 5) bursthits = 5;
		if (a.animalgloss) bursthits = 1; // Whoops, must be human to use martial arts fanciness
	}
	else
	{
		if (mode == GAMEMODE_SITE && LCSrandom(100) < attack_used->fire.chance_causes_debris)
		{// TODO - In a car chase, debris should make driving harder for one round, or require a drive skill check to avoid damage
			sitechangest change(locx, locy, locz, SITEBLOCK_DEBRIS);
			addLocationChange(cursite, change);//  location[cursite]->changes.push_back(change);
		}
		if (mode == GAMEMODE_SITE && LCSrandom(100) < attack_used->fire.chance)
		{// TODO - In a car chase, apply vehicle damage, with drive skill check to partially mitigate
		 // Fire!
			if (!(levelmap[locx][locy][locz].flag & SITEBLOCK_FIRE_END) ||
				!(levelmap[locx][locy][locz].flag & SITEBLOCK_FIRE_PEAK) ||
				!(levelmap[locx][locy][locz].flag & SITEBLOCK_FIRE_START) ||
				!(levelmap[locx][locy][locz].flag & SITEBLOCK_DEBRIS))
			{
				levelmap[locx][locy][locz].flag |= SITEBLOCK_FIRE_START;
				sitecrime += 3;
				addjuice(a, 5, 500);
				criminalizeparty(LAWFLAG_ARSON);
				sitestory->crime.push_back(CRIME_ARSON);
			}
		}
		int num_attacks = attack_used->number_attacks;
		if (sneak_attack) {
			num_attacks = 1;
			bursthits = 1;
		}
		if (attack_used->thrown)
		{
			thrownweapons = num_attacks;
			if (thrownweapons > a.count_weapons()) {
				thrownweapons = a.count_weapons();
				num_attacks = thrownweapons;
			}
		}
		else
			if (attack_used->uses_ammo) {
				if (a.get_weapon().get_ammoamount() < num_attacks) {
					num_attacks = a.get_weapon().get_ammoamount();
				}
				a.get_weapon().decrease_ammo(num_attacks);
			}
		if (!sneak_attack) {
			for (int i = 0; i < num_attacks; i++)
			{
				// Each shot in a burst is increasingly less likely to hit
				if (aroll + bonus - i * attack_used->successive_attacks_difficulty > droll)
					bursthits++;
			}
		}
	}
	//HIT!
	if (aroll + bonus > droll)
	{
		int w = determineBodypartHit(t, aroll, droll, sneak_attack);


		char damtype = 0;
		int damamount = 0;
		char strengthmin = 1;
		char strengthmax = 1;
		int severtype = -1;
		char damagearmor = 0;
		char armorpiercing = 0;
		int extraarmor = 0;
		if (!a.is_armed())
		{
			strengthmin = 5;
			strengthmax = 10;
			for ( ; bursthits > 0; bursthits--) //Put into WEAPON_NONE -XML
			{
				damamount += LCSrandom(5 + a.get_skill(SKILL_HANDTOHAND)) + 1 + a.get_skill(SKILL_HANDTOHAND);
			}
			if (!a.animalgloss) damtype |= WOUND_BRUISED;
			else
			{
				if (a.specialattack == ATTACK_CANNON)
				{
					damamount = LCSrandom(5000) + 5000;
					armorpiercing = 20;

					damamount |= consolidateDamageTypesNotCutOrBruised(attack_used);

					strengthmin = 0;
					strengthmax = 0;
				}
				else if (a.specialattack == ATTACK_FLAME) damtype |= WOUND_BURNED;
				else if (a.specialattack == ATTACK_SUCK) damtype |= WOUND_CUT;
				else damtype |= WOUND_TORN;
				severtype = WOUND_NASTYOFF;
			}
		}
		else
		{
			damtype |= consolidateDamageTypes(attack_used);
			strengthmin = attack_used->strength_min;
			strengthmax = attack_used->strength_max;
			severtype = attack_used->severtype;
			int random = attack_used->random_damage;
			int fixed = attack_used->fixed_damage;
			if (sneak_attack) fixed += 100;
			if (bursthits >= attack_used->critical.hits_required
				&& LCSrandom(100) < attack_used->critical.chance)
			{
				if (attack_used->critical.random_damage_defined)
					random = attack_used->critical.random_damage;
				if (attack_used->critical.fixed_damage_defined)
					fixed = attack_used->critical.fixed_damage;
				if (attack_used->critical.severtype_defined)
					severtype = attack_used->critical.severtype;
			}
			for (; bursthits > 0; bursthits--)
			{
				damamount += LCSrandom(random) + fixed;
			}
			damagearmor = attack_used->damages_armor;
			armorpiercing = attack_used->armorpiercing;
		}
		// Coarse combat lethality reduction.
		//damamount/=2;
		if (t.squadid != -1 && t.hireid == -1) // Plot Armor: if the founder is hit, inflict
			damamount /= 2;                // 1/2 damage, because founders are cool
		int mod = 0;
		if (strengthmax > strengthmin)
		{
			// Melee attacks: Maximum strength bonus, minimum
			// strength to deliver full damage
			int strength = a.attribute_roll(ATTRIBUTE_STRENGTH);
			if (strength > strengthmax) strength = (strengthmax + strength) / 2;
			mod += strength - strengthmin;
			armorpiercing += (strength - strengthmin) / 4;
		}
		//SKILL BONUS FOR GOOD ROLL
		mod += aroll - droll;
		//DO THE HEALTH MOD ON THE WOUND
		mod -= t.attribute_roll(ATTRIBUTE_HEALTH);
		//Health and poor accuracy will only avoid critical hits, not stop low-damage attacks
		if (mod < 0) mod = 0;
		// In a car chase, the vehicle itself provides bonus armor
		int vehicleHitLocation = 0;
		Vehicle* vehicle = getChaseVehicle(t);
		if (mode == GAMEMODE_CHASECAR && vehicle != NULL)
		{
			vehicleHitLocation = vehicle->gethitlocation(w);
			extraarmor = vehicle->armorbonus(vehicleHitLocation);
			// TODO damage vehicle itself
		}
		int cardmg = damamount;
		{
			int mod3 = mod;
			int armor = t.get_armor().get_armor(w);
			if (t.animalgloss == ANIMALGLOSS_TANK)
			{
				if (damtype != WOUND_BURNED) armor = 15;
				else armor = 10;
			}
			//if(t.get_armor().get_quality()>1)
			armor -= t.get_armor().get_quality() - 1;
			if (t.get_armor().is_damaged())
				armor -= 1;
			if (armor < 0) armor = 0; // Possible from second-rate clothes
			armor += extraarmor; // Add vehicle armor 
			const int mod2 = armor + LCSrandom(armor + 1) - armorpiercing;
			if (mod2 > 0) mod3 -= mod2 * 2;
			damagemod(t, damtype, damamount, mod3);
		}

			string str;
		

			// Could the vehicle have bounced that round on its own?
			if ((damamount == 0) && (mode == GAMEMODE_CHASECAR && vehicle != NULL && extraarmor > 0))
			{
				Creature testDummy; // Spawn nude test dummy to see if body armor was needed to prevent damage
				int mod3 = mod;
				int armor = t.get_armor().get_armor(w);
				if (t.animalgloss == ANIMALGLOSS_TANK)
				{
					if (damtype != WOUND_BURNED) armor = 15;
					else armor = 10;
				}
				//if(t.get_armor().get_quality()>1)
				armor -= t.get_armor().get_quality() - 1;
				if (t.get_armor().is_damaged())
					armor -= 1;
				if (armor < 0) armor = 0; // Possible from second-rate clothes
				armor += extraarmor; // Add vehicle armor 
				const int mod2 = armor + LCSrandom(armor + 1) - armorpiercing;
				if (mod2 > 0) mod3 -= mod2 * 2;
				damagemod(testDummy, damtype, cardmg, mod3);

				if (cardmg < 2) //fudge factor of 1 armor level due to randomness
				{
					str = CONST_fight139;

					str += (CONST_fight140 + vehicle->shortname() + CONST_fight136);
					str += vehicle->getpartname(vehicleHitLocation);
				}

			}
			if (len(str) < 1) {
				str = a.heshe(true); // capitalize=true. Shorten the string so it doesn't spill over as much; we already said attacker's name on the previous line anyways.
				if (sneak_attack) str += CONST_fight134;
				else str += CONST_fight135;
				str += t.name;
				str += CONST_fight136;
				str += bodypartName((Bodyparts)w, (AnimalGlosses)t.animalgloss);
				str += showMultipleHits(a, bursthits, attack_used);
				// Report vehicle protection effect
				if (mode == GAMEMODE_CHASECAR && vehicle != NULL && extraarmor > 0)
				{
					str += CONST_fight138;

					str += (CONST_fight140 + vehicle->shortname() + CONST_fight136);
					str += vehicle->getpartname(vehicleHitLocation);
				}
			}

		

		// Bullets caught by armor should bruise instead of poke holes.
		if (damamount < 4 && damtype & WOUND_SHOT)
		{
			damtype &= ~(WOUND_SHOT | WOUND_BLEEDING);
			damtype |= WOUND_BRUISED;
		}
		if (damamount > 0)
		{
				
			Creature *target = takeBulletForLeader(t, damamount, w);
			if (!target) target = &t;//If nobody jumps in front of the attack,
			target->wound[w] |= damtype;
			int severamount = bodypartSeverAmount(w);
			if (severtype != -1 && damamount >= severamount)
				target->wound[w] |= (char)severtype;
			if (w != BODYPART_HEAD && w != BODYPART_BODY && target->blood - damamount <= 0 &&
				target->blood > 0)
			{
				do
				{
					if (LCSrandom(100) < attack_used->no_damage_reduction_for_limbs_chance)
						break;
					else damamount >>= 1;
				} while (target->blood - damamount <= 0);
			}
			if (damagearmor) armordamage(target->get_armor(), w, damamount); {
				target->blood -= damamount; 
			}
			levelmap[locx][locy][locz].flag |= SITEBLOCK_BLOODY; 

			string hit_punctuation = attack_used->hit_punctuation;
			string dismembered = dismemberingWound(w, target->wound[w]);
			if (len(dismembered)) {
				hit_punctuation = dismembered;
			}
			str += hit_punctuation;

			if ((target->wound[BODYPART_HEAD] & (WOUND_CLEANOFF | WOUND_NASTYOFF)) ||
				(target->wound[BODYPART_BODY] & (WOUND_CLEANOFF | WOUND_NASTYOFF)) ||
				target->blood <= 0)
			{
				if ((w == BODYPART_HEAD && target->wound[BODYPART_HEAD] & WOUND_NASTYOFF) ||
					(w == BODYPART_BODY && target->wound[BODYPART_BODY] & WOUND_NASTYOFF)) {
					bloodblast(&target->get_armor());
				}
				const char alreadydead = !target->alive; // This tests whether the person being fatally wounded was a corpse
				if (!alreadydead)
				{
					target->die();
					if (t.align == -a.align)
						addjuice(a, 5 + t.juice / 20, 1000); // Instant juice
					else addjuice(a, -(5 + t.juice / 20), -50);
					if (target->squadid != -1)
					{
						if (target->align == 1) stat_dead++;
					}
					else if (target->enemy() && (t.animalgloss != ANIMALGLOSS_ANIMAL || lawList[LAW_ANIMALRESEARCH] == 2))
					{
						stat_kills++;
						if (LocationsPool::getInstance().isThereASiegeHere(cursite)) LocationsPool::getInstance().addSiegeKill(cursite);
						if (LocationsPool::getInstance().isThereASiegeHere(cursite) && t.animalgloss == ANIMALGLOSS_TANK) LocationsPool::getInstance().removeTank(cursite);
						if (LocationsPool::getInstance().getRentingType(cursite) == RENTING_CCS)
						{
							if (target->type == CREATURE_CCS_ARCHCONSERVATIVE) ccs_boss_kills++;
							ccs_siege_kills++;
						}
					}
					if (target->squadid == -1 &&
						(target->animalgloss != ANIMALGLOSS_ANIMAL || lawList[LAW_ANIMALRESEARCH] == 2) &&
						!sneak_attack)
					{
						sitecrime += 10;
						sitestory->crime.push_back(CRIME_KILLEDSOMEBODY);
						if (a.squadid != -1) criminalizeparty(LAWFLAG_MURDER);
					}
				}			
				//set_color_easy(WHITE_ON_BLACK_BRIGHT);
				if (goodguyattack) { set_color_easy(GREEN_ON_BLACK_BRIGHT); }
				else { set_color_easy(RED_ON_BLACK_BRIGHT); }

				mvaddstrAlt(17, 1, str, gamelog);
				gamelog.newline();
				pressAnyKey();
				if (!alreadydead)
				{
					severloot(t);
					clearmessagearea();
					adddeathmessage(*target);
					pressAnyKey();
					if (target->prisoner != NULL) freehostage(t, 1);
				}
			}
			else
			{
				if (target->wound[w] & WOUND_NASTYOFF) bloodblast(&target->get_armor());
				if (goodguyattack) set_color_easy(GREEN_ON_BLACK_BRIGHT);
				else set_color_easy(RED_ON_BLACK_BRIGHT);
				//set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(17, 1, str, gamelog);
				gamelog.newline();
				printparty();
				if (mode == GAMEMODE_CHASECAR ||
					mode == GAMEMODE_CHASEFOOT) printchaseencounter();
				else printencounter();
				pressAnyKey();
				//SPECIAL WOUNDS
				string damageDescription;
				if (!(target->wound[w] & (WOUND_CLEANOFF | WOUND_NASTYOFF)) &&
					!target->animalgloss)
				{
					damageDescription = printSpecialWounds(target, w, damamount, damtype);
					severloot(*target);
				}
				if (len(damageDescription) > 0) {
					clearmessagearea();
					if (goodguyattack) set_color_easy(GREEN_ON_BLACK_BRIGHT);
					else set_color_easy(RED_ON_BLACK_BRIGHT);
					mvaddstrAlt(16, 1, damageDescription, gamelog);
					gamelog.newline();
					pressAnyKey();
				}
				//set_color_easy(WHITE_ON_BLACK_BRIGHT);
			}
		}
		else
		{
			set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			str += CONST_fight153;
			mvaddstrAlt(17, 1, str, gamelog);
			gamelog.newline();
			printparty();
			if (mode == GAMEMODE_CHASECAR ||
				mode == GAMEMODE_CHASEFOOT) printchaseencounter();
			else printencounter();
			pressAnyKey();
		}
	}
	else
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		if (melee && aroll < droll - 10 && t.blood>70 && t.animalgloss == ANIMALGLOSS_NONE
			&& t.is_armed() && t.get_weapon().get_attack(false, true, true) != NULL)
		{
			string str2 = t.name;
			str2 += CONST_fight154;
			mvaddstrAlt(17, 1, str2, gamelog);
			gamelog.newline();
			pressAnyKey();
			goodguyattack = !goodguyattack;
			attack(t, a, 0, true);
			goodguyattack = !goodguyattack;
		}//TODO if missed person, but vehicle is large, it might damage the car. 
		else {
			string str2;
			if (sneak_attack)
			{
				str2 = t.name;
				str2 += singleSpace + pickrandom(cry_alarm);
				sitealarm = 1;
			}
			else {
				str2 += unsuccessfulHit(a, t, droll);

			}
			mvaddstrAlt(17, 1, str2, gamelog);

			gamelog.newline();
			printparty();
			if (mode == GAMEMODE_CHASECAR ||
				mode == GAMEMODE_CHASEFOOT) printchaseencounter();
			else printencounter();
			pressAnyKey();



		}
	}
	for (; thrownweapons > 0; thrownweapons--)
	{
		if (a.has_thrown_weapon)
			a.ready_another_throwing_weapon();
		a.drop_weapon(NULL);
	}
	// This is the only point in the function that returns true
	return true;
}
/* attack handling for each side as a whole */
void youattack()
{
	extern char foughtthisround;
	extern squadst *activesquad;
	extern newsstoryst *sitestory;
	extern short sitealarm;
	extern int sitecrime;
	extern short cursite;
	extern Creature encounter[ENCMAX];
	extern vector<Creature *> pool;
	foughtthisround = 1;
	const short wasalarm = sitealarm;
	goodguyattack = true;
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] == NULL) continue;
		if (!activesquad->squad[p]->alive) continue;
		vector<int> super_enemies;
		vector<int> dangerous_enemies;
		vector<int> enemies;
		vector<int> non_enemies;
		for (int e = 0; e < ENCMAX; e++)
		{
			if (encounter[e].alive&&encounter[e].exists)
			{
				if (encounter[e].enemy())
				{
					if (encounter[e].animalgloss == ANIMALGLOSS_TANK &&
						encounter[e].stunned == 0)
						super_enemies.push_back(e);
					else if ((encounter[e].is_armed() ||
						(encounter[e].type == CREATURE_COP && encounter[e].align == ALIGN_MODERATE) ||
						encounter[e].type == CREATURE_SCIENTIST_EMINENT ||
						encounter[e].type == CREATURE_JUDGE_LIBERAL ||
						encounter[e].type == CREATURE_JUDGE_CONSERVATIVE ||
						encounter[e].type == CREATURE_CORPORATE_CEO ||
						encounter[e].type == CREATURE_POLITICIAN ||
						encounter[e].type == CREATURE_RADIOPERSONALITY ||
						encounter[e].type == CREATURE_NEWSANCHOR ||
						encounter[e].type == CREATURE_MILITARYOFFICER ||
						encounter[e].specialattack != -1) &&
						encounter[e].blood >= 40 &&
						encounter[e].stunned == 0)
						dangerous_enemies.push_back(e);
					else enemies.push_back(e);
				}
				else non_enemies.push_back(e);
			}
		}
		if (!(len(super_enemies) + len(dangerous_enemies) + len(enemies))) return;
		int target;
		// If there are CONST_fight161, shoot at one of them unless we're using a persuasion-based attack
		if (len(super_enemies) &&
			((activesquad->squad[p]->type != CREATURE_SCIENTIST_EMINENT &&
				activesquad->squad[p]->type != CREATURE_JUDGE_LIBERAL &&
				activesquad->squad[p]->type != CREATURE_JUDGE_CONSERVATIVE &&
				activesquad->squad[p]->type != CREATURE_CORPORATE_CEO &&
				activesquad->squad[p]->type != CREATURE_POLITICIAN &&
				activesquad->squad[p]->type != CREATURE_RADIOPERSONALITY &&
				activesquad->squad[p]->type != CREATURE_NEWSANCHOR &&
				activesquad->squad[p]->type != CREATURE_MILITARYOFFICER &&
				!activesquad->squad[p]->get_weapon().has_musical_attack()) ||
				(!activesquad->squad[p]->get_weapon().has_musical_attack() &&
					activesquad->squad[p]->is_armed())))
			target = pickrandom(super_enemies);
		// Else, if there are CONST_fight162, shoot at one of them
		else if (len(dangerous_enemies))
			target = pickrandom(dangerous_enemies);
		// Else, if there are regular enemies, shoot at one of them
		else if (len(enemies)) target = pickrandom(enemies);
		// Else, we skipped a CONST_fight163 because it we're using a persuasion-based attack but it's the only enemy left so we have to pick it
		else target = pickrandom(super_enemies);
		char mistake = 0;
		// Mistaken attack
		/*
		Mistakenly attacking innocents: if skill is 8 or higher, there is no chance of mistakenly hitting innocents (except when used as a human shield).
		If skill is 7 or lower, the odds are based on skill, with a maximum of 10% chance at skill = 0;
		Melee weapons only require a skill of 4.
		If skill is 3 or lower, the odds are based on skill, with a maximum of 5% chance at skill = 0;
		*/
		if (len(non_enemies) && activesquad->squad[p]->get_weapon_skill() < (4 + (activesquad->squad[p]->get_weapon().is_ranged() * 4)) &&
			!LCSrandom(10 + 2 * (5 + 5 * activesquad->squad[p]->get_weapon().is_ranged()) * activesquad->squad[p]->get_weapon_skill()))
			// Mistaken attack
		{
			target = pickrandom(non_enemies);
			mistake = 1;
		}
		bool actual;
		const short beforeblood = encounter[target].blood;
		if (encounter[target].align == 1) mistake = 1;
		actual = attack(*activesquad->squad[p], encounter[target], mistake);
		if (actual)
		{
			if (mistake)
			{
				alienationcheck(mistake);
				sitestory->crime.push_back(CRIME_ATTACKED_MISTAKE);
				sitecrime += 10;
			}
			else
			{
				sitecrime += 3;
				addjuice(*(activesquad->squad[p]), 1, 200);
			}
			sitestory->crime.push_back(CRIME_ATTACKED);
			// Charge with assault if first strike
			if (sitealarm && (!wasalarm || (beforeblood > encounter[target].blood && beforeblood == 100)))
			{
				if (!activesquad->squad[p]->is_armed())
					criminalize(*activesquad->squad[p], LAWFLAG_ASSAULT);
				else criminalize(*activesquad->squad[p], LAWFLAG_ARMEDASSAULT);
			}
		}
		if (!encounter[target].alive)
		{
			delenc(target, 1);
			if (!mistake)
			{
				for (int p = 0; p < 6; p++)
				{
					if (activesquad->squad[p] == NULL) continue;
					if (!activesquad->squad[p]->alive) continue;
					addjuice(*(activesquad->squad[p]), 5, 500);
				}
			}
		}
	}
	for (int e = 0; e < ENCMAX; e++)
	{
		if (encounter[e].exists && encounter[e].alive && encounter[e].enemy())
		{
			sitealarm = 1;
			break;
		}
	}
	//COVER FIRE
	if (LocationsPool::getInstance().isThereASiegeHere(cursite))
	{
		for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
		{
			if (!pool[p]->alive) continue;
			if (pool[p]->align != 1) continue;
			if (pool[p]->squadid != -1) continue;
			if (pool[p]->location != cursite) continue;
			// Juice check to engage in cover fire
			// 10% chance for every 10 juice, starting at
			// 10% chance for 0 juice -- caps out at 100%
			// chance to fire at 90 juice
			//if(LCSrandom(10)-pool[p]->juice/10>0)continue;
			if (pool[p]->get_weapon().get_attack(true, false, false))
			{
				char conf = 0;
				if (pool[p]->get_weapon().get_ammoamount() > 0) conf = 1;
				if (pool[p]->get_weapon().get_attack(true, false, false)->uses_ammo)
					if (pool[p]->can_reload()) conf = 1;
				if (conf)
				{
					vector<int> goodtarg, badtarg;
					for (int e = 0; e < ENCMAX; e++)
					{
						if (encounter[e].alive&&encounter[e].exists)
						{
							if (encounter[e].enemy())goodtarg.push_back(e);
							else badtarg.push_back(e);
						}
					}
					if (!len(goodtarg)) return;
					int target = pickrandom(goodtarg);
					char mistake = 0;
					// Mistaken attack
					/*
					Mistakenly attacking innocents: if skill is 8 or higher, there is no chance of mistakenly hitting innocents (except when used as a human shield).
					If skill is 7 or lower, the odds are based on skill, with a maximum of 10% chance at skill = 0;
					Melee weapons only require a skill of 4.
					If skill is 3 or lower, the odds are based on skill, with a maximum of 5% chance at skill = 0;
					*/
					if (len(badtarg) && pool[p]->get_weapon_skill() < (4 + (pool[p]->get_weapon().is_ranged() * 4)) &&
						!LCSrandom(10 + 2 * (5 + 5 * pool[p]->get_weapon().is_ranged()) * pool[p]->get_weapon_skill()))
					{
						target = pickrandom(badtarg);
						mistake = 1;
					}
					bool actual;
					actual = attack(*pool[p], encounter[target], mistake);
					if (actual)
					{
						if (mistake)
						{
							alienationcheck(mistake);
							sitestory->crime.push_back(CRIME_ATTACKED_MISTAKE);
							sitecrime += 10;
						}
						if (!pool[p]->is_armed())
							criminalize(*pool[p], LAWFLAG_ASSAULT);
						else criminalize(*pool[p], LAWFLAG_ARMEDASSAULT);
					}
					if (!encounter[target].alive) delenc(target, 1);
				}
			}
		}
	}
}

void enemyattack()
{
	extern short mode;
	extern char foughtthisround;
	extern Log gamelog;
	extern squadst *activesquad;
	extern short sitealarm;
	extern int sitecrime;
	// Enemies don't attack
	extern bool NOENEMYATTACK;
	extern Creature encounter[ENCMAX];
	extern int locx;
	extern int locy;
	extern int locz;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	foughtthisround = 1;
	goodguyattack = false;
	bool armed = false;
	for (int i = 0; i < 6; i++)
	{
		if (activesquad->squad[i] == NULL) break;
		if (activesquad->squad[i]->is_armed()) armed = true;
	}
	if (NOENEMYATTACK) {
		return;
	}
	char printed;
	for (int e = 0; e < ENCMAX; e++)
	{
		if (!encounter[e].exists) continue;
		if (!encounter[e].alive) continue;
		if (sitealarm == 1 && encounter[e].type == CREATURE_BOUNCER && encounter[e].align != ALIGN_LIBERAL)
			conservatise(encounter[e]);
		if (encounter[e].enemy()) encounter[e].cantbluff = 2;

		if (mode != GAMEMODE_CHASECAR)
		{
			// Encountered creature will flee if:
			// (a) Non-Conservative, and not recently converted via music or some other mechanism
			// (b) Conservative, no juice, unarmed, non-tank/animal, enemy is armed, and fails a morale check based in part on injury level
			// (c) Conservative, and lost more than 55% blood
			// (d) There's a fire, they are not firefighters, and they fail a random check
			// Encountered creatures will never flee if they are tanks, animals, or so hurt they can't move
			char fire = 0;
			if (mode == GAMEMODE_SITE)
			{
				if (levelmap[locx][locy][locz].flag & SITEBLOCK_FIRE_START ||
					levelmap[locx][locy][locz].flag & SITEBLOCK_FIRE_END)
					fire = 1;
				else if (levelmap[locx][locy][locz].flag & SITEBLOCK_FIRE_PEAK)
					fire = 2;
			}
			if (((!encounter[e].enemy() ||
				(encounter[e].juice == 0 && !encounter[e].is_armed() && armed&&encounter[e].blood<signed(70 + LCSrandom(61))))
				&& !(encounter[e].flag & CREATUREFLAG_CONVERTED)) || (encounter[e].blood < 45 && encounter[e].juice < 200)
				|| ((fire*LCSrandom(5) >= 3) && !(encounter[e].type == CREATURE_FIREFIGHTER)))
			{
				if (encounter[e].animalgloss == ANIMALGLOSS_NONE)
				{
					if (!incapacitated(encounter[e], 0, printed))
					{
						if (printed)
						{
							printparty();
							if (mode == GAMEMODE_CHASECAR ||
								mode == GAMEMODE_CHASEFOOT) printchaseencounter();
							else printencounter();
							pressAnyKey();
						}
						clearmessagearea();
						mvaddstrAlt(16, 1, encounter[e].name, gamelog);
						if ((encounter[e].wound[BODYPART_LEG_RIGHT] & WOUND_NASTYOFF) ||
							(encounter[e].wound[BODYPART_LEG_RIGHT] & WOUND_CLEANOFF) ||
							(encounter[e].wound[BODYPART_LEG_LEFT] & WOUND_NASTYOFF) ||
							(encounter[e].wound[BODYPART_LEG_LEFT] & WOUND_CLEANOFF) ||
							(encounter[e].blood < 45))
							addstrAlt(pickrandom(escape_crawling), gamelog);
						else addstrAlt(pickrandom(escape_running), gamelog);
						gamelog.newline();
						delenc(e, 0);
						e--;
						printparty();
						if (mode == GAMEMODE_CHASECAR ||
							mode == GAMEMODE_CHASEFOOT) printchaseencounter();
						else printencounter();
						pressAnyKey();
					}
					continue;
				}
			}
		}

		vector<int> goodtarg, badtarg;
		if (encounter[e].enemy())
		{
			for (int p = 0; p < 6; p++) {
				if (activesquad->squad[p] != NULL) {
					if (activesquad->squad[p]->alive) { goodtarg.push_back(p); }
				}
			}
		}
		else
		{
			for (int e2 = 0; e2 < ENCMAX; e2++)
			{
				if (!encounter[e2].exists) continue;
				if (!encounter[e2].alive) continue;
				if (encounter[e2].align != -1) continue;
				goodtarg.push_back(e2);
			}
		}
		for (int e2 = 0; e2 < ENCMAX; e2++)
		{
			if (!encounter[e2].exists) continue;
			if (!encounter[e2].alive) continue;
			if (encounter[e2].enemy()) continue;
			badtarg.push_back(e2);
		}
		if (!len(goodtarg)) return;
		int target = pickrandom(goodtarg);
		char canmistake = 1;
		int encnum = 0;
		for (int e2 = 0; e2 < ENCMAX; e2++) if (encounter[e2].exists) encnum++;
		if ((encounter[e].type == CREATURE_SCIENTIST_EMINENT ||
			encounter[e].type == CREATURE_JUDGE_LIBERAL ||
			encounter[e].type == CREATURE_JUDGE_CONSERVATIVE ||
			encounter[e].type == CREATURE_CORPORATE_CEO ||
			encounter[e].type == CREATURE_POLITICIAN ||
			encounter[e].type == CREATURE_RADIOPERSONALITY ||
			encounter[e].type == CREATURE_NEWSANCHOR ||
			encounter[e].type == CREATURE_MILITARYOFFICER) && encnum < ENCMAX) canmistake = 0;
		bool actual;
		if (canmistake)
		{
			if (encounter[e].enemy())
			{
				if (activesquad->squad[target]->prisoner != NULL && !LCSrandom(2))
				{
					// Mistaken attack
					actual = attack(encounter[e], *activesquad->squad[target]->prisoner, 1);
					if (!activesquad->squad[target]->prisoner->alive)
					{
						if (activesquad->squad[target]->prisoner->squadid == -1)
						{
							clearmessagearea();
							set_color_easy(WHITE_ON_BLACK_BRIGHT);
							mvaddstrAlt(16, 1, activesquad->squad[target]->name, gamelog);
							addstrAlt(CONST_fight164, gamelog);
							addstrAlt(activesquad->squad[target]->prisoner->name, gamelog);
							addstrAlt(CONST_fight165, gamelog);
							gamelog.newline();
							const int prisonerType = activesquad->squad[target]->prisoner->type;
							if (prisonerType == CREATURE_CORPORATE_CEO ||
								prisonerType == CREATURE_POLITICIAN ||
								prisonerType == CREATURE_RADIOPERSONALITY ||
								prisonerType == CREATURE_NEWSANCHOR ||
								prisonerType == CREATURE_SCIENTIST_EMINENT ||
								prisonerType == CREATURE_JUDGE_CONSERVATIVE ||
								prisonerType == CREATURE_MILITARYOFFICER) sitecrime += 30;
							makeloot(*activesquad->squad[target]->prisoner);
							pressAnyKey();
							delete_and_nullify(activesquad->squad[target]->prisoner);
						}
					}
					continue;
				}
			}
			// Mistaken attack
			/*
			Mistakenly attacking innocents: if skill is 8 or higher, there is no chance of mistakenly hitting innocents (except when used as a human shield).
			If skill is 7 or lower, the odds are based on skill, with a maximum of 20% chance at skill = 0;
			Melee weapons only require a skill of 4.
			If skill is 3 or lower, the odds are based on skill, with a maximum of 10% chance at skill = 0;
			*/
			if (len(badtarg) && encounter[e].get_weapon_skill() < (4 + (encounter[e].get_weapon().is_ranged() * 4)) &&
				!LCSrandom(10 + 2 * (5 + 5 * encounter[e].get_weapon().is_ranged()) * encounter[e].get_weapon_skill()))
			{
				target = pickrandom(badtarg);
				if (encounter[target].flag & CREATUREFLAG_CONVERTED)
					actual = attack(encounter[e], encounter[target], 0);
				// Mistaken Attack
				else actual = attack(encounter[e], encounter[target], 1);
				if (!encounter[target].alive) delenc(target, 1);
				continue;
			}
		}
		if (encounter[e].enemy())
			actual = attack(encounter[e], *activesquad->squad[target], 0);
		else actual = attack(encounter[e], encounter[target], 0);
	}
}
//std::string bodypartName(Bodyparts w, AnimalGlosses t);
string specialWoundPossibilityBody(
	Creature &t,
	const char breakdam,
	const char pokedam,
	const char damtype)
{
	Creature* target = &t;
	string damageDescription = blankString;
	switch (LCSrandom(11))
	{
	case 0:
		if (target->special[SPECIALWOUND_UPPERSPINE] && breakdam)
		{
			damageDescription += (target->name);
			if (damtype & WOUND_SHOT) damageDescription += (CONST_fight166);
			else (damageDescription += CONST_fight167);
			target->special[SPECIALWOUND_UPPERSPINE] = 0;
			if (target->blood > 20) target->blood = 20;
		}
		break;
	case 1:
		if (target->special[SPECIALWOUND_LOWERSPINE] && breakdam)
		{
			damageDescription += (target->name);
			if (damtype & WOUND_SHOT)damageDescription += CONST_fight168;
			else damageDescription += (CONST_fight169);
			target->special[SPECIALWOUND_LOWERSPINE] = 0;
			if (target->blood > 20) target->blood = 20;
		}
		break;
	case 2:
		if (target->special[SPECIALWOUND_RIGHTLUNG] && pokedam)
		{
			damageDescription += (target->name);
			if (damtype & WOUND_SHOT)damageDescription += (CONST_fight170);
			else if (damtype & WOUND_TORN)damageDescription += (CONST_fight171);
			else damageDescription += (CONST_fight172);
			target->special[SPECIALWOUND_RIGHTLUNG] = 0;
			if (target->blood > 20) target->blood = 20;
		}
		break;
	case 3:
		if (target->special[SPECIALWOUND_LEFTLUNG] && pokedam)
		{
			damageDescription += (target->name);
			if (damtype & WOUND_SHOT)damageDescription += (CONST_fight173);
			else if (damtype & WOUND_TORN)damageDescription += (CONST_fight174);
			else damageDescription += (CONST_fight175);
			target->special[SPECIALWOUND_LEFTLUNG] = 0;
			if (target->blood > 20) target->blood = 20;
		}
		break;
	case 4:
		if (target->special[SPECIALWOUND_HEART] && pokedam)
		{
			damageDescription += (target->name);
			if (damtype & WOUND_SHOT)damageDescription += (CONST_fight176);
			else if (damtype & WOUND_TORN)damageDescription += (CONST_fight177);
			else damageDescription += (CONST_fight178);
			target->special[SPECIALWOUND_HEART] = 0;
			if (target->blood > 3) target->blood = 3;
		}
		break;
	case 5:
		if (target->special[SPECIALWOUND_LIVER] && pokedam)
		{
			damageDescription += (target->name);
			if (damtype & WOUND_SHOT)damageDescription += (CONST_fight179);
			else if (damtype & WOUND_TORN)damageDescription += (CONST_fight180);
			else damageDescription += (CONST_fight181);
			target->special[SPECIALWOUND_LIVER] = 0;
			if (target->blood > 50) target->blood = 50;
		}
		break;
	case 6:
		if (target->special[SPECIALWOUND_STOMACH] && pokedam)
		{
			damageDescription += (target->name);
			if (damtype & WOUND_SHOT)damageDescription += (CONST_fight182);
			else if (damtype & WOUND_TORN)damageDescription += (CONST_fight183);
			else damageDescription += (CONST_fight184);
			target->special[SPECIALWOUND_STOMACH] = 0;
			if (target->blood > 50) target->blood = 50;
		}
		break;
	case 7:
		if (target->special[SPECIALWOUND_RIGHTKIDNEY] && pokedam)
		{
			damageDescription += (target->name);
			if (damtype & WOUND_SHOT)damageDescription += (CONST_fight185);
			else if (damtype & WOUND_TORN)damageDescription += (CONST_fight186);
			else damageDescription += (CONST_fight187);
			target->special[SPECIALWOUND_RIGHTKIDNEY] = 0;
			if (target->blood > 50) target->blood = 50;
		}
		break;
	case 8:
		if (target->special[SPECIALWOUND_LEFTKIDNEY] && pokedam)
		{
			damageDescription += (target->name);
			if (damtype & WOUND_SHOT)damageDescription += (CONST_fight188);
			else if (damtype & WOUND_TORN)damageDescription += (CONST_fight189);
			else damageDescription += (CONST_fight190);
			target->special[SPECIALWOUND_LEFTKIDNEY] = 0;
			if (target->blood > 50) target->blood = 50;
		}
		break;
	case 9:
		if (target->special[SPECIALWOUND_SPLEEN] && pokedam)
		{
			damageDescription += (target->name);
			if (damtype & WOUND_SHOT)damageDescription += (CONST_fight191);
			else if (damtype & WOUND_TORN)damageDescription += (CONST_fight192);
			else damageDescription += (CONST_fight193);
			target->special[SPECIALWOUND_SPLEEN] = 0;
			if (target->blood > 50) target->blood = 50;
		}
		break;
	case 10:
		if (target->special[SPECIALWOUND_RIBS] > 0 && breakdam)
		{
			int ribminus = LCSrandom(RIBNUM) + 1;
			if (ribminus > target->special[SPECIALWOUND_RIBS]) ribminus = target->special[SPECIALWOUND_RIBS];
			if (ribminus > 1)
			{
				if (ribminus == target->special[SPECIALWOUND_RIBS])
					damageDescription += (CONST_fight207);
				damageDescription += (target->name);
				damageDescription += (CONST_fight208);
				damageDescription += (target->name);
				damageDescription += (CONST_fight196);
			}
			else if (target->special[SPECIALWOUND_RIBS] > 1)
			{
				damageDescription += (CONST_fight210);
				damageDescription += (target->name);
				damageDescription += (CONST_fight198);
			}
			else
			{
				damageDescription += (target->name);
				damageDescription += (CONST_fight199);
			}
			if (damtype & WOUND_SHOT)damageDescription += (CONST_fight200);
			else damageDescription += (CONST_fight201);
			target->special[SPECIALWOUND_RIBS] -= ribminus;
		}
		break;
	}
	return damageDescription;
}
string specialWoundPossibilityHead(
	Creature &t,
	const char breakdam,
	//char pokedam,
	const char heavydam,
	const char damtype
) {
	Creature* target = &t;
	string damageDescription = blankString;
	switch (LCSrandom(7))
	{
	case 0:
		if ((target->special[SPECIALWOUND_RIGHTEYE] ||
			target->special[SPECIALWOUND_LEFTEYE] ||
			target->special[SPECIALWOUND_NOSE]) && heavydam)
		{
			damageDescription += (target->name);
			if (damtype & WOUND_SHOT)damageDescription += (CONST_fight202);
			else if (damtype & WOUND_BURNED)damageDescription += (CONST_fight203);
			else if (damtype & WOUND_TORN)damageDescription += (CONST_fight204);
			else if (damtype & WOUND_CUT)damageDescription += (CONST_fight205);
			else damageDescription += (CONST_fight206);
			target->special[SPECIALWOUND_RIGHTEYE] = 0;
			target->special[SPECIALWOUND_LEFTEYE] = 0;
			target->special[SPECIALWOUND_NOSE] = 0;
			if (target->blood > 20)target->blood = 20;
		}
		break;
	case 1:
		if (target->special[SPECIALWOUND_TEETH] > 0)
		{
			int teethminus = LCSrandom(TOOTHNUM) + 1;
			if (teethminus > target->special[SPECIALWOUND_TEETH])
				teethminus = target->special[SPECIALWOUND_TEETH];
			if (teethminus > 1)
			{
				if (teethminus == target->special[SPECIALWOUND_TEETH])
				{
					damageDescription += (CONST_fight207);
				}
				damageDescription += tostring(teethminus);
				damageDescription += CONST_fight208;
				damageDescription += target->name;
				damageDescription += CONST_fight209;
			}
			else if (target->special[SPECIALWOUND_TEETH] > 1)
			{
				damageDescription += (CONST_fight210);
				damageDescription += (target->name);
				damageDescription += (CONST_fight211);
			}
			else
			{
				damageDescription += (target->name);
				damageDescription += (CONST_fight212);
			}
			if (damtype & WOUND_SHOT)damageDescription += (CONST_fight213);
			else if (damtype & WOUND_BURNED)damageDescription += (CONST_fight214);
			else if (damtype & WOUND_TORN)damageDescription += (CONST_fight215);
			else if (damtype & WOUND_CUT)damageDescription += (CONST_fight216);
			else damageDescription += (CONST_fight217);
			target->special[SPECIALWOUND_TEETH] -= teethminus;
		}
		break;
	case 2:
		if (target->special[SPECIALWOUND_RIGHTEYE] && heavydam)
		{
			damageDescription += (target->name);
			if (damtype & WOUND_SHOT)damageDescription += (CONST_fight218);
			else if (damtype & WOUND_BURNED)damageDescription += (CONST_fight219);
			else if (damtype & WOUND_TORN)damageDescription += (CONST_fight220);
			else if (damtype & WOUND_CUT)damageDescription += (CONST_fight221);
			else damageDescription += (CONST_fight222);
			target->special[SPECIALWOUND_RIGHTEYE] = 0;
			if (target->blood > 50)target->blood = 50;
		}
		break;
	case 3:
		if (target->special[SPECIALWOUND_LEFTEYE] && heavydam)
		{
			damageDescription += (target->name);
			if (damtype & WOUND_SHOT)damageDescription += (CONST_fight223);
			else if (damtype & WOUND_BURNED)damageDescription += (CONST_fight224);
			else if (damtype & WOUND_TORN)damageDescription += (CONST_fight225);
			else if (damtype & WOUND_CUT)damageDescription += (CONST_fight226);
			else damageDescription += (CONST_fight227);
			target->special[SPECIALWOUND_LEFTEYE] = 0;
			if (target->blood > 50)target->blood = 50;
		}
		break;
	case 4:
		if (target->special[SPECIALWOUND_TONGUE] && heavydam)
		{
			damageDescription += (target->name);
			if (damtype & WOUND_SHOT)damageDescription += (CONST_fight228);
			else if (damtype & WOUND_BURNED)damageDescription += (CONST_fight229);
			else if (damtype & WOUND_TORN)damageDescription += (CONST_fight230);
			else if (damtype & WOUND_CUT)damageDescription += (CONST_fight231);
			else damageDescription += (CONST_fight232);
			target->special[SPECIALWOUND_TONGUE] = 0;
			if (target->blood > 50)target->blood = 50;
		}
		break;
	case 5:
		if (target->special[SPECIALWOUND_NOSE] && heavydam)
		{
			damageDescription += (target->name);
			if (damtype & WOUND_SHOT)damageDescription += (CONST_fight233);
			else if (damtype & WOUND_BURNED)damageDescription += (CONST_fight234);
			else if (damtype & WOUND_TORN)damageDescription += (CONST_fight235);
			else if (damtype & WOUND_CUT)damageDescription += (CONST_fight236);
			else damageDescription += (CONST_fight237);
			target->special[SPECIALWOUND_NOSE] = 0;
			if (target->blood > 50)target->blood = 50;
		}
		break;
	case 6:
		if (target->special[SPECIALWOUND_NECK] && breakdam)
		{
			damageDescription += (target->name);
			if (damtype & WOUND_SHOT)damageDescription += (CONST_fight238);
			else damageDescription += (CONST_fight239);
			target->special[SPECIALWOUND_NECK] = 0;
			if (target->blood > 20)target->blood = 20;
		}
		break;
	}
	return damageDescription;
}
/* abandoned liberal is captured by conservatives */
void capturecreature(Creature &t)
{
	extern short sitetype;
	extern short cursite;
	t.activity.type = ACTIVITY_NONE;
	t.drop_weapons_and_clips(NULL);
	//t.strip(NULL);
	Armor clothes = Armor(getarmortype(tag_ARMOR_CLOTHES));
	t.give_armor(clothes, NULL);
	freehostage(t, 2); // situation 2 = no message; this may want to be changed to 0 or 1
	if (t.prisoner)
	{
		if (t.prisoner->squadid == -1)
			delete t.prisoner;
		t.prisoner = NULL; // Stop hauling people
	}
	if (t.flag & CREATUREFLAG_JUSTESCAPED)
	{
		t.location = cursite;
		if (sitetype == SITE_GOVERNMENT_PRISON ||
			sitetype == SITE_GOVERNMENT_COURTHOUSE)
		{
			Armor prisoner = Armor(getarmortype(tag_ARMOR_PRISONER));
			t.give_armor(prisoner, NULL);
		}
		if (sitetype == SITE_GOVERNMENT_PRISON)
		{
			// Clear criminal record?
			t.heat = 0;
			for (int i = 0; i < LAWFLAGNUM; i++)
				t.crimes_suspected[i] = 0;
		}
	}
	else
		t.location = find_site_index_in_same_city(SITE_GOVERNMENT_POLICESTATION, cursite);
	t.squadid = -1;
}
/* pushes people into the current squad (used in a siege) */
void autopromote(const int loc)
{
	extern squadst *activesquad;
	extern vector<Creature *> pool;
	if (!activesquad) return;
	const int partysize = squadsize(activesquad), partyalive = squadalive(activesquad);
	int libnum = 0;
	if (partyalive == 6) return;
	for (int pl = 0; pl < CreaturePool::getInstance().lenpool(); pl++)
	{
		if (pool[pl]->location != loc) continue;
		if (pool[pl]->alive&&pool[pl]->align == 1) libnum++;
	}
	if (partysize == libnum) return;
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] == NULL || !activesquad->squad[p]->alive)
		{
			for (int pl = 0; pl < CreaturePool::getInstance().lenpool(); pl++)
			{
				if (pool[pl]->location != loc) continue;
				if (pool[pl]->alive&&pool[pl]->squadid == -1 &&
					pool[pl]->align == 1)
				{
					if (activesquad->squad[p] != NULL) activesquad->squad[p]->squadid = -1;
					activesquad->squad[p] = pool[pl];
					activesquad->squad[p]->squadid = activesquad->id;
					break;
				}
			}
		}
	}
}


// #include "includes.h"
const string CONST_game015 = "masktype";
const string CONST_game014 = "default";
const string CONST_game013 = "Unspecified error with custom text";
const string CONST_game011 = "debug_defines.txt";
const string CONST_game010 = "File Error: InitiateMoreIncompleteText";
const string CONST_game009 = "File Error: InitiateIncompleteText";
const string CONST_game008 = "File Error: ";
const string CONST_game006 = "Comment Found";
const string CONST_game005 = "sitemaps.txt";
const string CONST_game004 = "Liberal Crime Squad ";


void loadgraphics();
// Reads in an entire configuration file
// Returns 0 for read successful, returns -1 if failed read
int readConfigFile(const std::string& filename);
//// #include "common/getnames.h"
std::string cityname();
#include "../title/initfile.h"
struct highscorest
{
	char valid, endtype, slogan[SLOGAN_LEN];
	int month, year, stat_recruits, stat_kidnappings, stat_dead, stat_kills, stat_funds, stat_spent, stat_buys, stat_burns;
};
highscorest score[SCORENUM];
#ifdef WIN32
bool fixcleartype = false;
#endif
struct pointerAndString {
	bool *super_collection;
	string fileName;
	pointerAndString(bool *super_, const string& file_) : fileName(file_), super_collection(super_) {}
};
//int mainSeven(bool xml_loaded_ok);
void init_console();
void initialize_debug_defines();
void mainOne() {
	extern Log gamelog; //The gamelog.
	init_console(); // do this FIRST
					//start curses
	initscrAlt();
	gamelog.initialize(GAMELOG_FILEPATH, OVERWRITE_GAMELOG, NEWLINEMODE_GAMELOG); //Initialize the gamelog (and also initialize artdir and homedir)
	title_screen::getInstance();
	CreaturePool::getInstance();
	LocationsPool::getInstance();
}
void mainTwo() {
	extern Log gamelog; //The gamelog.
	time_t t = time(0);
	struct tm *now = localtime(&t); //Do not need to deallocate this. Statically allocated by system
	char datetime[41];
	sprintf(datetime, "---------%i-%02i-%02i %02i:%02i:%02i---------\n\n\n",
		now->tm_year + 1900, now->tm_mon + 1, now->tm_mday, now->tm_hour, now->tm_min, now->tm_sec); //YYYY-MM-DD HH:MM:SS format
	gamelog.log(string("\n\n\n---------- PROGRAM STARTED ----------\n") + datetime);
}
// #include "common/musicClass.h"
void mainThree() {
	extern string PACKAGE_VERSION_STR;
	extern MusicClass music;
	music.play(MUSIC_TITLEMODE); // initialize music and play title mode song (do this BEFORE displaying anything on the screen, but AFTER initializing artdir and homedir)
								 // set window title
	char wtitle[50];
	strcpy(wtitle, CONST_game004);
	strcat(wtitle, PACKAGE_VERSION_STR.c_str());
	set_title(wtitle);
}
string failedToLoadSitemaps;
string debugCode;
string activated;
string failedToLoad;
string exclamationPoint;
string defaultMissingForMask;
string defaultUnknownForMask;
int oldMapMode = 0; // -1 if we're using the old map generation functions.
void mainFour() {
	extern Log gamelog; //The gamelog.
	noechoAlt();
	//initialize curses color
	start_colorAlt();
	initMainRNG();
	//initialize the array of color pairs
	for (int i = 0; i < 8; i++)
		for (int j = 0; j < 8; j++)
		{
			if (i == 0 && j == 0)
			{
				init_pairAlt(7 * 8, 0, 0);
				continue;
			}
			if (i == 7 && j == 0) continue;
			init_pairAlt(i * 8 + j, i, j);
		}
	//turns off cursor
	curs_setAlt(0);
	//begin the game loop
	keypadAlt(TRUE);
	raw_outputAlt(TRUE);
	//Loading Graphics...
	loadgraphics();
	//Loading Init File Options...
	loadinitfile();
	//Loading sitemaps.txt...
	oldMapMode = !readConfigFile(CONST_game005); // load site map data
	if (oldMapMode)
	{
		addstrAlt(failedToLoadSitemaps, gamelog);
		gamelog.nextMessage();
		pressAnyKey();
	}
	//Setting initial game data...
}
void mainFive() {
	// Laws start archconservative
	extern bool SHITLAWS;
	// Laws start elite liberal
	extern bool PERFECTLAWS;
	// Public opinion starts at 100% Liberal
	extern bool REVOLUTIONNOW;
	extern short activesortingchoice[];
	extern short attitude[];
	extern short public_interest[];
	extern short background_liberal_influence[];
	extern short lawList[];
	//Initialize sorting choices.
	for (int s = 0; s < SORTINGCHOICENUM; s++)
		activesortingchoice[s] = SORTING_NONE;
	for (int v = 0; v < VIEWNUM; v++)
	{
		attitude[v] = 30 + LCSrandom(25);
		public_interest[v] = 0;
		background_liberal_influence[v] = 0;
	}
	attitude[VIEW_LIBERALCRIMESQUAD] = 0;
	attitude[VIEW_LIBERALCRIMESQUADPOS] = 5;
	//attitude[VIEW_POLITICALVIOLENCE]=5;
	if (REVOLUTIONNOW) {
		for (int v = 0; v < VIEWNUM; v++)
			attitude[v] = 100;
	}
	if (SHITLAWS) {
		for (int l = 0; l < LAWNUM; l++) { lawList[l] = -2; }
	}
	else
		if (PERFECTLAWS) {
			for (int l = 0; l < LAWNUM; l++) { lawList[l] = 2; }
		}
		else {
			lawList[LAW_ABORTION] = 1;
			lawList[LAW_ANIMALRESEARCH] = -1;
			lawList[LAW_POLICEBEHAVIOR] = -1;
			lawList[LAW_PRIVACY] = -1;
			lawList[LAW_DEATHPENALTY] = -1;
			lawList[LAW_NUCLEARPOWER] = -1;
			lawList[LAW_POLLUTION] = -1;
			lawList[LAW_LABOR] = 0;
			lawList[LAW_GAY] = 1;
			lawList[LAW_CORPORATE] = 0;
			lawList[LAW_FREESPEECH] = 0;
			lawList[LAW_FLAGBURNING] = 1;
			lawList[LAW_GUNCONTROL] = -1;
			lawList[LAW_TAX] = 0;
			lawList[LAW_WOMEN] = 1;
			lawList[LAW_CIVILRIGHTS] = 1;
			lawList[LAW_DRUGS] = -1;
			lawList[LAW_IMMIGRATION] = 0;
			lawList[LAW_ELECTIONS] = 0;
			lawList[LAW_MILITARY] = -1;
			lawList[LAW_PRISONS] = 0;
			lawList[LAW_TORTURE] = -1;
		}
}
string fixLineSpecialCharacter(char * toFix) {
	string str = blankString;
	for (int i = 0; i < len(toFix); i++) {
		bool special = (static_cast<int> (toFix[i])) == -61;
		if (special) {
			i++;
			char c;
			switch (toFix[i]) {
			case -87: // 'é'
				c = (char)0x82;
				break;
			case -74: // 'ö'
				c = (char)0x94;
				break;
			case -95: // 'á'
				c = (char)0xa0;
				break;
			case -83: // 'í'
				c = (char)0xa1;
				break;
			case -77: // 'ó'
				c = (char)0xa2;
				break;
			case -70: // 'ú'
				c = (char)0xa3;
				break;
			case (int) '¼':
				// 'ü'
				c = (char)0x81;
				break;
			case (int) '«':
				// 'ë'
				c = (char)0x89;
				break;
			case (int) '²':
				// 'ò'
				c = (char)0x95;
				break;
			case (int) '¢':
				// 'â'
				c = (char)0x83;
				break;
			case (int) '´':
				// 'ô'
				c = (char)0x93;
				break;
				/*
				case (int) 'Â':
				// '¢'
				// This letter does not use the escape character '-61'
				// meaning it would need its own switch statement
				// in addition to the hassle of determining what escape character is used
				c = (char) 0x9b;
				break;
				*/
			default:
				c = toFix[i];
				break;
			}
			str += c;
		}
		else {
			str += toFix[i];
		}
	}
	return str;
}
bool isThisNotComment(char* currentLine) {
	return currentLine[0] != '#' && currentLine[1] != '#';
}
// populate_from_text extracts plaintext and puts it in a two dimensional vector of strings.
// returns true if file loads, false if not.
bool populate_from_txt(vector< vector<string> >& types, const string& fileName, const int dimension)
{
	extern char artdir[];
	types.clear();
	const int line_length = 2048;
	bool success = false;
	ifstream txtFile;
	txtFile.open(string(artdir) + fileName);
	if (txtFile.fail()) {
		cout << failedToLoad + fileName + exclamationPoint << endl;
		pressAnyKey();
	}
	else {
		while (!txtFile.eof()) {
			char currentLine[line_length];
			txtFile.getline(currentLine, line_length);
			const bool notComment = isThisNotComment(currentLine);
			if (notComment) {
				vector<string> line;
				line.push_back(currentLine);
				for (int i = 0; i < dimension - 1 && !txtFile.eof(); i++) {
					// whether the line is not a comment, and is also the line whose contents are optional
					// Testing until obtain proper data from file
					txtFile.getline(currentLine, line_length);
					strcpy(currentLine, fixLineSpecialCharacter(currentLine));
					line.push_back(currentLine);
					if (!isThisNotComment(currentLine)) {
						cout << CONST_game006 << endl << currentLine << endl;
						pressAnyKey();
					}
				}
				types.push_back(line);
			}
		}
	}
	success = types.size() > 0;
	if (!success) {
		addstrAlt(CONST_game008 + fileName);
		pressAnyKey();
	}
	return success;
}
bool populate_from_txt(vector<string> & types, const string& fileName)
{
	extern char artdir[];
	types.clear();
	const int line_length = 2048;
	bool success = false;
	ifstream txtFile;
	txtFile.open(string(artdir) + fileName);
	if (txtFile.fail()) {
		cout << failedToLoad + fileName + exclamationPoint << endl;
		pressAnyKey();
	}
	else {
		cout << endl;
		while (!txtFile.eof()) {
			char currentLine[line_length];
			txtFile.getline(currentLine, line_length);
			const bool notComment = (currentLine[0] && currentLine[0] != '#');
			if (notComment) {
				strcpy(currentLine, fixLineSpecialCharacter(currentLine));
				types.push_back(currentLine);
			}
		}
	}
	success = types.size() > 0;
	if (!success) {
		addstrAlt(CONST_game008 + fileName);
		pressAnyKey();
	}
	return success;
}
bool initialize_incomplete_txt();
bool initialize_more_incomplete_txt();
bool initialize_txt();
bool initialize_txt() {
	extern vector<file_and_text_collection> activate_text_file_collection;
	extern vector<file_and_text_collection> activities_text_file_collection;
	extern vector<file_and_text_collection> baseactions_text_file_collection;
	extern vector<file_and_text_collection> chase_text_file_collection;
	extern vector<file_and_text_collection> common_text_file_collection;
	extern vector<file_and_text_collection> creature_text_file_collection;
	extern vector<file_and_text_collection> creaturetypes_text_file_collection;
	extern vector<file_and_text_collection> date_text_file_collection;
	extern vector<file_and_text_collection> endgame_text_file_collection;
	extern vector<file_and_text_collection> externally_stored_data_text_file_collection;
	extern vector<file_and_text_collection> fighty_text_file_collection;
	extern vector<file_and_text_collection> get_names_text_file_collection;
	extern vector<file_and_text_collection> globals_text_file_collection;
	extern vector<file_and_text_collection> interrogate_text_file_collection;
	extern vector<file_and_text_collection> justice_text_file_collection;
	extern vector<file_and_text_collection> liberl_agenda_text_file_collection;
	extern vector<file_and_text_collection> locations_text_file_collection;
	extern vector<file_and_text_collection> locationspool_text_file_collection;
	extern vector<file_and_text_collection> majorevent_text_file_collection;
	extern vector<file_and_text_collection> map_specials_text_file_collection;
	extern vector<file_and_text_collection> misc_activities_text_file_collection;
	extern vector<file_and_text_collection> misc_text_file_collection;
	extern vector<file_and_text_collection> names_text_file_collection;
	extern vector<file_and_text_collection> newgame_file_collection;
	extern vector<file_and_text_collection> politics_text_file_collection;
	extern vector<file_and_text_collection> talk_file_collection;
	extern vector<file_and_text_collection> text_file_collection;
	extern vector<file_and_text_collection> title_screen_text_files;
	extern vector<file_and_text_collection> reviewmode_text_file_collection;
	extern vector<file_and_text_collection> siege_text_file_collection;
	extern vector<file_and_text_collection> stealth_text_file_collection;
	vector<vector<file_and_text_collection> > vast_text_collection = {
		activate_text_file_collection,
		activities_text_file_collection,
		baseactions_text_file_collection,
		chase_text_file_collection,
		common_text_file_collection,
		creature_text_file_collection,
		creaturetypes_text_file_collection,
		date_text_file_collection,
		endgame_text_file_collection,
		externally_stored_data_text_file_collection,
		fighty_text_file_collection,
		get_names_text_file_collection,
		globals_text_file_collection,
		interrogate_text_file_collection,
		justice_text_file_collection,
		liberl_agenda_text_file_collection,
		locations_text_file_collection,
		locationspool_text_file_collection,
		majorevent_text_file_collection,
		map_specials_text_file_collection,
		misc_activities_text_file_collection,
		misc_text_file_collection,
		names_text_file_collection,
		newgame_file_collection,
		politics_text_file_collection,
		talk_file_collection,
		text_file_collection,
		title_screen_text_files,
		reviewmode_text_file_collection,
		siege_text_file_collection,
		stealth_text_file_collection,
	};
	bool loaded = true;

	for (vector<file_and_text_collection> file : vast_text_collection) {
		for (file_and_text_collection f : file) {
			if (f.superCollection) {
				loaded &= populate_from_txt(*f.super_collection, f.fileName, f.dimensions);
			}
			else {
				loaded &= populate_from_txt(*f.collection, f.fileName);
			}
		}
	}
	loaded &= initialize_incomplete_txt();
	if (!loaded) {
		addstrAlt(CONST_game009);
		pressAnyKey();
	}
	else {
		loaded &= initialize_more_incomplete_txt();
		if (!loaded) {
			addstrAlt(CONST_game010);
			pressAnyKey();
		}
	}
	return loaded;
}
void initialize_debug_defines() {
	// inform player of activated debug codes
	extern bool DISPLAYDEBUG;
	extern char artdir[];
	extern vector<pointerAndString> debug_defines;
	string fileName = CONST_game011;
	ifstream txtFile;
	txtFile.open(string(artdir) + fileName);
	//int debug_codes = 0;
	if (txtFile.fail()) {
		// debug file not found, don't do anything
	}
	else {
		clearAlt();
		int y = 0;
		while (!txtFile.eof()) {
			char currentLine[800];
			txtFile.getline(currentLine, 800);
			const bool notComment = isThisNotComment(currentLine);
			if (notComment) {
				for (pointerAndString p : debug_defines) {
					if (currentLine == p.fileName) {
						*(p.super_collection) = true;
						mvaddstrAlt(y++, 0, debugCode + p.fileName + activated);
					}
				}
			}
		}
		if (DISPLAYDEBUG) {
			pressAnyKey();
		}
	}
}
void mainSix() {
	extern short senate[];
	extern short house[];
	extern short court[];
	extern char courtname[COURTNUM][POLITICIAN_NAMELEN];
	extern short  exec[];
	extern char execname[EXECNUM][POLITICIAN_NAMELEN];
	for (int s = 0; s < SENATENUM; s++)
	{
		if (s < 25) senate[s] = -2;
		else if (s < 60) senate[s] = -1;
		else if (s < 80) senate[s] = 0;
		else if (s < 95) senate[s] = 1;
		else senate[s] = 2;
	}
	for (int h = 0; h < HOUSENUM; h++)
	{
		if (h < 50) house[h] = -2;
		else if (h < 250) house[h] = -1;
		else if (h < 350) house[h] = 0;
		else if (h < 400) house[h] = 1;
		else house[h] = 2;
	}
	for (int c = 0; c < COURTNUM; c++)
	{
		if (c < 3) court[c] = -2;
		else if (c < 5) court[c] = -1;
		else if (c < 5) court[c] = 0;
		else if (c < 8) court[c] = 1;
		else court[c] = 2;
		do
		{
			fullName fn;
			if (court[c] == -2) {
				fn = generate_long_name(GENDER_WHITEMALEPATRIARCH);
			}
			else {
				fn = generate_long_name();
			}
			strcpy(courtname[c], (fn.first + " " + fn.last).data());
		} while (len(courtname[c]) > 20);
	}
	for (int e = 0; e < EXECNUM; e++)
	{
		exec[e] = -2;
		fullName fn = generate_long_name(GENDER_WHITEMALEPATRIARCH);
		strcpy(execname[e], (fn.first + " " + fn.last).data());
	}
	extern unsigned long attorneyseed[4];
	initOtherRNG(attorneyseed);
	extern char lcityname[];
	strcpy(lcityname, cityname());
}
bool mainSeven(bool xml_loaded_ok);
int main(int argc, char* argv[])
{
	mainOne();
	mainTwo();
	initialize_debug_defines();
	bool xml_loaded_ok = initialize_txt();
	if (!xml_loaded_ok) {
		mvaddstrAlt(0, 0, CONST_game013);
		pressAnyKey();
	}
	mainThree();
	mainFour();
	mainFive();
	mainSix();
	// Main Loop
	if (!mainSeven(xml_loaded_ok)) {
		// This function closes the entire program, and can be called anywhere
		end_game(EXIT_FAILURE);
	}
	else {
		clearAlt();
		title_screen::getInstance().mode_title();
	}
}
bool populate_masks_from_xml(vector<ArmorType*>& masks, const string& file, Log& log)
{
	extern char artdir[];
	CMarkup xml;
	if (!xml.Load(string(artdir) + file))
	{ //File is missing or not valid XML.
		addstrAlt(failedToLoad + file + exclamationPoint, log);
		pressAnyKey();
		return false; //Abort.
	}
	xml.FindElem();
	xml.IntoElem();
	int defaultindex;
	if (xml.FindElem(CONST_game014)) defaultindex = getarmortype(xml.GetData());
	else
	{
		addstrAlt(defaultMissingForMask, log);
		pressAnyKey();
		return false; //Abort.
	}
	if (defaultindex == -1)
	{
		addstrAlt(defaultUnknownForMask, log);
		pressAnyKey();
		return false; //Abort.
	}
	xml.ResetMainPos();
	while (xml.FindElem(CONST_game015)) masks.push_back(new ArmorType(*masks[defaultindex], xml.GetSubDoc()));
	return true;
}


// #include "../includes.h"
const string CONST_getnames045 = "getMonth.txt";
const string CONST_getnames044 = "city_names.txt";
const string CONST_getnames042 = "Buggy Software";
const string CONST_getnames041 = "bugs";
const string CONST_getnames040 = "Elite Liberal";
const string CONST_getnames039 = "Liberal Guardian";
const string CONST_getnames038 = "Urban Commando";
const string CONST_getnames037 = "Revolutionary";
const string CONST_getnames036 = "Socialist Threat";
const string CONST_getnames035 = "Activist";
const string CONST_getnames034 = "Civilian";
const string CONST_getnames033 = "Punk";
const string CONST_getnames032 = "Society's Dregs";
const string CONST_getnames031 = "Damn Worthless";
const string CONST_getnames030 = "[Darn] Worthless";
const string CONST_getnames029 = "Peace Prize Winner";
const string CONST_getnames028 = "Peacemaker";
const string CONST_getnames027 = "Great Person";
const string CONST_getnames026 = "Upstanding Citizen";
const string CONST_getnames025 = "Respected";
const string CONST_getnames024 = "Hard Working";
const string CONST_getnames023 = "Non-Liberal";
const string CONST_getnames022 = "Non-Liberal Punk";
const string CONST_getnames018 = "Evil Incarnate";
const string CONST_getnames017 = "Arch-Conservative";
const string CONST_getnames016 = "Insane Vigilante";
const string CONST_getnames015 = "Heartless Bastard";
const string CONST_getnames014 = "Heartless [Jerk]";
const string CONST_getnames013 = "Stubborn as Hell";
const string CONST_getnames012 = "Stubborn as [Heck]";
const string CONST_getnames011 = "Wrong-Thinker";
const string CONST_getnames010 = "Mindless Conservative";
const string CONST_getnames009 = "Conservative Punk";
const string CONST_getnames008 = "Conservative Dregs";

vector<string> city_names;
std::string gettitle(Creature &cr)
{
	extern short lawList[LAWNUM];
	if (cr.align == -1)
	{
		if (cr.juice <= -50)
		{
			if (lawList[LAW_FREESPEECH] == -2) return CONST_getnames030;
			else return CONST_getnames031;
		}
		else if (cr.juice <= -10) return CONST_getnames008;
		else if (cr.juice < 0) return CONST_getnames009;
		else if (cr.juice < 10) return CONST_getnames010;
		else if (cr.juice < 50) return CONST_getnames011;
		else if (cr.juice < 100)
		{
			if (lawList[LAW_FREESPEECH] == -2) return CONST_getnames012;
			else return CONST_getnames013;
		}
		else if (cr.juice < 200)
		{
			if (lawList[LAW_FREESPEECH] == -2) return CONST_getnames014;
			else return CONST_getnames015;
		}
		else if (cr.juice < 500) return CONST_getnames016;
		else if (cr.juice < 1000) return CONST_getnames017;
		else return CONST_getnames018;
	}
	else if (cr.align == 0)
	{
		if (cr.juice <= -50)
		{
			if (lawList[LAW_FREESPEECH] == -2) return CONST_getnames030;
			else return CONST_getnames031;
		}
		else if (cr.juice <= -10) return CONST_getnames032;
		else if (cr.juice < 0) return CONST_getnames022;
		else if (cr.juice < 10) return CONST_getnames023;
		else if (cr.juice < 50) return CONST_getnames024;
		else if (cr.juice < 100) return CONST_getnames025;
		else if (cr.juice < 200) return CONST_getnames026;
		else if (cr.juice < 500) return CONST_getnames027;
		else if (cr.juice < 1000) return CONST_getnames028;
		else return CONST_getnames029;
	}
	else
	{
		if (cr.juice <= -50)
		{
			if (lawList[LAW_FREESPEECH] == -2) return CONST_getnames030;
			else return CONST_getnames031;
		}
		else if (cr.juice <= -10) return CONST_getnames032;
		else if (cr.juice < 0) return CONST_getnames033;
		else if (cr.juice < 10) return CONST_getnames034;
		else if (cr.juice < 50) return CONST_getnames035;
		else if (cr.juice < 100) return CONST_getnames036;
		else if (cr.juice < 200) return CONST_getnames037;
		else if (cr.juice < 500) return CONST_getnames038;
		else if (cr.juice < 1000) return CONST_getnames039;
		else return CONST_getnames040;
	}
}
map<short, vector<string> > getViewString;
std::string getview(short view, bool shortname)
{
	if (shortname)
	{
		if (getViewString.count(view)) {
			return getViewString[view][0];
		}
		else
			return CONST_getnames041;
	}
	else
	{
		if (getViewString.count(view)) {
			return getViewString[view][1];
		}
		else
			return CONST_getnames042;
	}
}
map<short, string> getLawString;

map<short, string> getLawFlagString;
map<short, map<short, string> > getLawFlagStringFull;
string findingBugs;

// shortname defaults to false
vector<string> getMonth;
std::string getmonth(int month, bool shortname)
{
	int monthIndex = (month - 1) * 2 + (shortname ? 0 : 1);
	if (monthIndex < len(getMonth)) {
		return getMonth[monthIndex];
	}
	else {
		return getMonth[22 + (shortname ? 0 : 1)];
	}
}
vector<file_and_text_collection> get_names_text_file_collection = {
	/*getnames.cpp*/
	customText(&city_names, names + CONST_getnames044),
	customText(&getMonth, mostlyendings + CONST_getnames045),
};
map<short, string> getAlignString;
string moderateLC;
string buggyString;
std::string getalign(short alignment, bool capitalize)
{
	if (capitalize == false && alignment == ALIGN_MODERATE) {
		return moderateLC;
	}
	else if (getAlignString.count(alignment) > 0) {
		return getAlignString[alignment];
	}
	else {
		return buggyString;
	}
}


// #include "../includes.h"
const string CONST_haulkidnap035 = " hauls ";
const string CONST_haulkidnap034 = " is left to be captured.";
const string CONST_haulkidnap033 = "Nobody can carry Martyr ";
const string CONST_haulkidnap032 = " can no longer handle ";
const string CONST_haulkidnap031 = "                                  ";
const string CONST_haulkidnap030 = "The hostage shouts for help!      ";
const string CONST_haulkidnap029 = "release their hostage.";
const string CONST_haulkidnap027 = "No hostages are being held.       ";
const string CONST_haulkidnap026 = "                                                     ";
const string CONST_haulkidnap025 = "All of the targets are too dangerous.                ";
const string CONST_haulkidnap024 = "Kidnap whom?";
const string CONST_haulkidnap023 = "do the job.";
const string CONST_haulkidnap021 = "No one can do the job.            ";
const string CONST_haulkidnap020 = " is captured.";
const string CONST_haulkidnap019 = " is recaptured.";
const string CONST_haulkidnap018 = "A hostage escapes!";
const string CONST_haulkidnap017 = " is captured";
const string CONST_haulkidnap016 = " is recaptured";
const string CONST_haulkidnap015 = " and a hostage is freed";
const string CONST_haulkidnap012 = "and says, ";
const string CONST_haulkidnap011 = " the ";
const string CONST_haulkidnap010 = " shows ";
const string CONST_haulkidnap009 = " writhes away!";
const string CONST_haulkidnap008 = "but ";
const string CONST_haulkidnap007 = " grabs at ";
const string CONST_haulkidnap006 = " is struggling and screaming!";
const string CONST_haulkidnap005 = "!";
const string CONST_haulkidnap004 = " snatches ";
const string CONST_haulkidnapX01 = "\"[Please], be cool.\"";
const string CONST_haulkidnapX02 = "\"Bitch, be cool.\"";

//// #include "../common/commonactions.h"
void criminalizeparty(short crime);
//// #include "../common/commonactionsCreature.h"
void removesquadinfo(Creature &cr);
/* roll on the kidnap attempt and show the results */
bool kidnap(Creature &a, Creature &t, bool &amateur)
{
	extern Log gamelog;
	extern short lawList[LAWNUM];
	if (!a.get_weapon().can_take_hostages())
	{
		amateur = 1;
		//BASIC ROLL
		int aroll = a.skill_roll(SKILL_HANDTOHAND);
		int droll = t.attribute_check(ATTRIBUTE_AGILITY, true);
		a.train(SKILL_HANDTOHAND, droll);
		clearmessagearea();
		//HIT!
		if (aroll > droll)
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, a.name, gamelog);
			addstrAlt(CONST_haulkidnap004, gamelog);
			addstrAlt(t.name, gamelog);
			addstrAlt(CONST_haulkidnap005, gamelog);
			gamelog.newline(); //New line.
			a.prisoner = new Creature;
			*a.prisoner = t;
			pressAnyKey();
			set_color_easy(RED_ON_BLACK_BRIGHT);
			mvaddstrAlt(17, 1, t.name, gamelog);
			addstrAlt(CONST_haulkidnap006, gamelog);
			gamelog.newline(); //New line.
			pressAnyKey();
			gamelog.newline();
			return 1;
		}
		else
		{
			set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, a.name, gamelog);
			addstrAlt(CONST_haulkidnap007, gamelog);
			addstrAlt(t.name, gamelog);
			gamelog.newline(); //New line.
			mvaddstrAlt(17, 1, CONST_haulkidnap008, gamelog);
			addstrAlt(t.name, gamelog);
			addstrAlt(CONST_haulkidnap009, gamelog);
			gamelog.newline(); //New line.
			pressAnyKey();
			gamelog.newline();
			return 0;
		}
	}
	else
	{
		clearmessagearea();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, a.name, gamelog);
		addstrAlt(CONST_haulkidnap010, gamelog);
		addstrAlt(t.name, gamelog);
		addstrAlt(CONST_haulkidnap011, gamelog);
		addstrAlt(a.get_weapon().get_name(2), gamelog);
		addstrAlt(singleSpace, gamelog);
		mvaddstrAlt(17, 1, CONST_haulkidnap012, gamelog);
		set_color_easy(GREEN_ON_BLACK_BRIGHT);
		if (lawList[LAW_FREESPEECH] == -2)addstrAlt(CONST_haulkidnapX01, gamelog);
		else addstrAlt(CONST_haulkidnapX02, gamelog);
		a.prisoner = new Creature;
		*a.prisoner = t;
		pressAnyKey();
		gamelog.newline();
		return 1;
	}
}
/* hostage freed due to host unable to haul */
void freehostage(Creature &cr, char situation)
{
	extern short mode;
	extern Log gamelog;
	extern Creature encounter[ENCMAX];
	if (cr.prisoner == NULL)return;
	if (cr.prisoner->alive)
	{
		if (situation == 0)
		{
			if (cr.prisoner->squadid == -1)addstrAlt(CONST_haulkidnap015, gamelog);
			else
			{
				addstrAlt(AND, gamelog);
				addstrAlt(cr.prisoner->name, gamelog);
				if (cr.prisoner->flag & CREATUREFLAG_JUSTESCAPED)addstrAlt(CONST_haulkidnap016, gamelog);
				else addstrAlt(CONST_haulkidnap017, gamelog);
			}
			gamelog.newline(); //New line.
		}
		else if (situation == 1)
		{
			clearmessagearea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			if (cr.prisoner->squadid == -1)mvaddstrAlt(16, 1, CONST_haulkidnap018, gamelog);
			else
			{
				mvaddstrAlt(16, 1, cr.prisoner->name, gamelog);
				if (cr.prisoner->flag & CREATUREFLAG_JUSTESCAPED)addstrAlt(CONST_haulkidnap019, gamelog);
				else addstrAlt(CONST_haulkidnap020, gamelog);
			}
			gamelog.newline(); //New line.
		}
		else if (situation == 2)
		{
			//Don't print anything.
		}
		if (cr.prisoner->squadid == -1)
		{
			for (int e = 0; e < ENCMAX; e++)
			{
				if (encounter[e].exists == 0)
				{
					encounter[e] = *cr.prisoner;
					encounter[e].exists = 1;
					conservatise(encounter[e]);
					break;
				}
			}
			delete cr.prisoner;
		}
		else capturecreature(*cr.prisoner);
	}
	else
	{
		if (cr.prisoner->squadid != -1)
		{
			removesquadinfo(*cr.prisoner);
			cr.prisoner->die();
			cr.prisoner->location = -1;
		}
	}
	cr.prisoner = NULL;
	if (situation == 1)
	{
		printparty();
		if (mode == GAMEMODE_CHASECAR ||
			mode == GAMEMODE_CHASEFOOT) printchaseencounter();
		else printencounter();
		pressAnyKey();
	}
}
/* prompt after you've said you want to kidnap someone */
void kidnapattempt()
{
	extern int sitecrime;
	extern short party_status;
	extern short sitealarm;
	extern short sitealarmtimer;
	extern short offended_amradio;
	extern short offended_cablenews;
	extern squadst *activesquad;
	extern Creature encounter[ENCMAX];
	extern short lawList[LAWNUM];
	short kidnapper = -1;
	party_status = -1;
	int available = 0;
	char availslot[6] = { 0,0,0,0,0,0 };
	for (int p = 0; p < 6; p++)
		if (activesquad->squad[p] != NULL)
			if (activesquad->squad[p]->alive&&activesquad->squad[p]->prisoner == NULL)
			{
				available++;
				availslot[p] = 1;
			}
	if (!available)
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, CONST_haulkidnap021);
		mvaddstrAlt(17, 1, CONST_haulkidnap031);
		pressAnyKey();
		return;
	}
	do
	{
		printparty();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 20, chooseALiberalTo + CONST_haulkidnap023);
		int c = getkeyAlt();
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) return;
		if (c >= '1'&&c <= '6')
			if (availslot[c - '1'])
				kidnapper = c - '1';
	} while (kidnapper < 0);
	vector<int> target;
	for (int e = 0; e < ENCMAX; e++)
		if (encounter[e].exists&&encounter[e].alive&&encounter[e].align == -1 &&
			(encounter[e].animalgloss == ANIMALGLOSS_NONE || lawList[LAW_ANIMALRESEARCH] == 2) &&
			(!encounter[e].get_weapon().protects_against_kidnapping() ||
				encounter[e].blood <= 20) && encounter[e].animalgloss != ANIMALGLOSS_TANK)
			target.push_back(e);
	if (len(target))
	{
		int t = target[0];
		if (len(target) > 1)
		{
			clearcommandarea();
			clearmessagearea();
			clearmaparea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(9, 1, CONST_haulkidnap024);
			int x = 1, y = 11;
			for (int t2 = 0; t2 < len(target); t2++)
			{
				mvaddcharAlt(y++, x, t2 + 'A');
				addstrAlt(spaceDashSpace);
				addstrAlt(encounter[target[t2]].name);
				if (y == 17) y = 11, x += 30;
			}
			do
			{
				int c = getkeyAlt();
				if (c >= 'a'&&c < ('a' + ENCMAX))
				{
					t = c - 'a';
					if (t >= len(target)) t = -1;
					else t = target[t];
				}
				if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) return;
			} while (t < 0);
		}
		bool amateur = 0;
		if (kidnap(*activesquad->squad[kidnapper], encounter[t], amateur))
		{
			delenc(t, 0);
			int time = 20 + LCSrandom(10);
			if (time < 1) time = 1;
			if (sitealarmtimer > time || sitealarmtimer == -1) sitealarmtimer = time;
		}
		else sitealarm = 1;
		if (amateur)
		{
			bool present = 0;
			for (int e = 0; e < ENCMAX; e++)
				if (encounter[e].exists&&encounter[e].alive) { present = 1; break; }
			if (present)
			{
				alienationcheck(1);
				if (!sitealarm)sitealarm = 1;
				sitecrime += 5;
				criminalizeparty(LAWFLAG_KIDNAPPING);
				if (activesquad->squad[kidnapper]->prisoner != NULL)
				{
					if (activesquad->squad[kidnapper]->prisoner->type == CREATURE_RADIOPERSONALITY) offended_amradio = 1;
					if (activesquad->squad[kidnapper]->prisoner->type == CREATURE_NEWSANCHOR) offended_cablenews = 1;
				}
				else
				{
					if (encounter[t].type == CREATURE_RADIOPERSONALITY) offended_amradio = 1;
					if (encounter[t].type == CREATURE_NEWSANCHOR) offended_cablenews = 1;
				}
			}
		}
		if (sitealarm) enemyattack();
		creatureadvance();
	}
	else
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, CONST_haulkidnap025);
		mvaddstrAlt(17, 1, CONST_haulkidnap026);
		pressAnyKey();
	}
}
/* prompt after you've said you want to release someone */
void releasehostage()
{
	extern short party_status;
	extern short sitealarm;
	extern squadst *activesquad;
	extern Log gamelog;
	short kidnapper = -1;
	party_status = -1;
	int available = 0;
	char availslot[6] = { 0,0,0,0,0,0 };
	for (int p = 0; p < 6; p++)
		if (activesquad->squad[p] != NULL)
			if (activesquad->squad[p]->alive&&activesquad->squad[p]->prisoner != NULL && activesquad->squad[p]->prisoner->align != ALIGN_LIBERAL)
				available++, availslot[p] = 1;
	if (!available)
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, CONST_haulkidnap027);
		mvaddstrAlt(17, 1, CONST_haulkidnap031);
		pressAnyKey();
		return;
	}
	do
	{
		printparty();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 20, chooseALiberalTo + CONST_haulkidnap029);
		int c = getkeyAlt();
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) return;
		if (c >= '1'&&c <= '6')
			if (availslot[c - '1'])
				kidnapper = c - '1';
	} while (kidnapper < 0);
	activesquad->squad[kidnapper]->prisoner->cantbluff = 2;
	freehostage(*(activesquad->squad[kidnapper]), 2);
	if (!sitealarm)
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, CONST_haulkidnap030, gamelog);
		gamelog.nextMessage(); //Next message.
		mvaddstrAlt(17, 1, CONST_haulkidnap031);
		pressAnyKey();
		sitealarm = 1;
		alienationcheck(1);
	}
}
/* haul dead/paralyzed */
void squadgrab_immobile(char dead)
{
	extern squadst *activesquad;
	extern Log gamelog;
	int hostslots = 0; //DRAGGING PEOPLE OUT IF POSSIBLE
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] != NULL)
		{
			if (activesquad->squad[p]->alive &&
				(activesquad->squad[p]->canwalk() ||
				(activesquad->squad[p]->flag & CREATUREFLAG_WHEELCHAIR)) &&
				activesquad->squad[p]->prisoner == NULL)
				hostslots++;
			else if ((!activesquad->squad[p]->alive ||
				(!activesquad->squad[p]->canwalk() &&
					!(activesquad->squad[p]->flag & CREATUREFLAG_WHEELCHAIR))) &&
				activesquad->squad[p]->prisoner != NULL)
			{
				clearmessagearea();
				set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				mvaddstrAlt(16, 1, activesquad->squad[p]->name, gamelog);
				addstrAlt(CONST_haulkidnap032, gamelog);
				addstrAlt(activesquad->squad[p]->prisoner->name, gamelog);
				addstrAlt(singleDot, gamelog);
				gamelog.newline(); //New line.
				pressAnyKey();
				freehostage(*activesquad->squad[p]->prisoner, 1);
			}
		}
	}
	for (int p = 5; p >= 0; p--)
	{
		if (activesquad->squad[p] != NULL)
		{
			if ((!activesquad->squad[p]->alive&&dead) ||
				(activesquad->squad[p]->alive &&
					!(activesquad->squad[p]->flag & CREATUREFLAG_WHEELCHAIR) &&
					!activesquad->squad[p]->canwalk() && !dead))
			{
				if (hostslots == 0)
				{
					if (!activesquad->squad[p]->alive)
					{
						clearmessagearea();
						set_color_easy(YELLOW_ON_BLACK_BRIGHT);
						mvaddstrAlt(16, 1, CONST_haulkidnap033, gamelog);
						addstrAlt(activesquad->squad[p]->name, gamelog);
						addstrAlt(singleDot, gamelog);
						gamelog.newline();
						//DROP LOOT
						makeloot(*activesquad->squad[p]);
						activesquad->squad[p]->die();
						activesquad->squad[p]->location = -1;
					}
					else
					{
						clearmessagearea();
						set_color_easy(YELLOW_ON_BLACK_BRIGHT);
						mvaddstrAlt(16, 1, activesquad->squad[p]->name, gamelog);
						addstrAlt(CONST_haulkidnap034, gamelog);
						gamelog.newline(); //New line.
						capturecreature(*activesquad->squad[p]);
					}
				}
				else
				{
					for (int p2 = 0; p2 < 6; p2++)
					{
						if (p2 == p) continue;
						if (activesquad->squad[p2] != NULL)
						{
							if (activesquad->squad[p2]->alive &&
								(activesquad->squad[p2]->canwalk() ||
								(activesquad->squad[p2]->flag & CREATUREFLAG_WHEELCHAIR)) &&
								activesquad->squad[p2]->prisoner == NULL)
							{
								activesquad->squad[p2]->prisoner = activesquad->squad[p];
								clearmessagearea();
								set_color_easy(YELLOW_ON_BLACK_BRIGHT);
								mvaddstrAlt(16, 1, activesquad->squad[p2]->name, gamelog);
								addstrAlt(CONST_haulkidnap035, gamelog);
								addstrAlt(activesquad->squad[p]->name, gamelog);
								addstrAlt(singleDot, gamelog);
								gamelog.newline(); //New line.
								break;
							}
						}
					}
					hostslots--;
				}
				//SHUFFLE SQUAD
				bool flipstart = 0;
				for (int pt = 0; pt < 6; pt++)
				{
					if (pt == p - 1) continue;
					if (pt == p) flipstart = 1;
					if (flipstart&&pt < 5) activesquad->squad[pt] = activesquad->squad[pt + 1];
				}
				if (flipstart) activesquad->squad[5] = NULL;
				printparty();
				pressAnyKey();
			}
		}
	}
}


map<short, vector<string> > helpTopics;
string liberalHelpOn;
string pressAnyKeyToReturn;
void help(const char* string)
{
	eraseAlt();
}
// Generates help page on activities.
// Just supply Activity type.
void HelpActivities(int activityType)
{
	//
	if (activityType == ACTIVITY_NONE)
	{
		return;
	}
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(0, 0, liberalHelpOn);
	vector<string> helpTopic;
	if (helpTopics.count(activityType)) {
		helpTopic = helpTopics[activityType];
	}
	else {
		helpTopic = helpTopics[-1];
	}
	mvaddstrAlt(2, 0, helpTopic[0]);
	for (int i = 0; i < len(helpTopic) - 1; i++) {
		mvaddstrAlt(4 + i, 0, helpTopic[i + 1]);
	}
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(23, 0, pressAnyKeyToReturn);
	pressAnyKey();
}



// #include "../includes.h"
const string CONST_highscoreB003 = "wb";
const string CONST_highscoreB002 = "rb";
const string CONST_highscore002 = "score.dat";

string univer;
string numRecruit;
string numMartyr;
string numKills;
string numKidnap;
string cashTaxed;
string cashSpent;
string flagsBought;
string flagsBurned;
string noValid;
string heLiElite;
string heLiLiber;
string heLiBrought;
string heLiBlot;
string heLiMob;
string heLiDownsized;
string heLiKIA;
string hecoReag;
string heLiDie;
string heLiExec;
string heLiVaca;
string heLiHide;
string heLiHunted;
string heLiScattered;
string heLiOutCrime;
string heLiBurned;
string hecoStalinized;
string dotSpace;

//extern highscorest score[SCORENUM];
//extern string singleSpace;
MusicModes getEndingMusic(EndTypes e);
string getEndingString(EndTypes e);
struct  saveLoadChunk {
	void * Buffer;
	size_t      ElementSize;
	size_t      ElementCount;
	saveLoadChunk(void * _Buffer, int _ElementSize, int _ElementCount) :Buffer(_Buffer), ElementSize(_ElementSize), ElementCount(_ElementCount) {}
};

/* displays the high score board */
void viewhighscores(int musicoverride)
{
	extern int ustat_recruits;
	extern int ustat_kidnappings;
	extern int ustat_dead;
	extern int ustat_kills;
	extern int ustat_funds;
	extern int ustat_spent;
	extern int ustat_buys;
	extern int ustat_burns;
	extern int stat_buys;
	extern int stat_burns;
	extern int stat_kidnappings;
	extern int year;
	extern int stat_dead;
	extern int stat_kills;
	extern int stat_recruits;
	extern MusicClass music;
	extern int yourscore;
	if (musicoverride != MUSIC_OFF) music.play(musicoverride);
	loadhighscores();
	short validsum = 0;
	for (int s = 0; s < SCORENUM; s++)
	{
		if (score[s].valid)validsum++;
	}
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(0, 0, validsum ? heLiElite : noValid);
	if (!validsum)
	{
		return;
	}
	for (int s = 0, y = 2; s < SCORENUM; s++)
	{
		if (score[s].valid)
		{
			if (yourscore == s && score[s].endtype == END_WON)set_color_easy(GREEN_ON_BLACK_BRIGHT);
			else if (yourscore == s)set_color_easy(RED_ON_BLACK_BRIGHT);
			else set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(y, 0, score[s].slogan);
			if (yourscore == s && score[s].endtype == END_WON)set_color_easy(GREEN_ON_BLACK);
			else if (yourscore == s)set_color_easy(RED_ON_BLACK);
			else set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(y + 1, 0, getEndingString((EndTypes)score[s].endtype));
			if (yourscore == s && musicoverride == MUSIC_OFF) { music.play(getEndingMusic((EndTypes)score[s].endtype)); }
			addstrAlt(getmonth(score[s].month));
			addstrAlt(singleSpace);
			addstrAlt(score[s].year);
			addstrAlt(dotSpace);
			mvaddstrAlt(y + 2, 0, numRecruit);
			addstrAlt(score[s].stat_recruits);
			mvaddstrAlt(y + 3, 0, numMartyr);
			addstrAlt(score[s].stat_dead);
			mvaddstrAlt(y + 2, 20, numKills);
			addstrAlt(score[s].stat_kills);
			mvaddstrAlt(y + 3, 20, numKidnap);
			addstrAlt(score[s].stat_kidnappings);
			mvaddstrAlt(y + 2, 40, cashTaxed);
			addstrAlt(score[s].stat_funds);
			mvaddstrAlt(y + 3, 40, cashSpent);
			addstrAlt(score[s].stat_spent);
			mvaddstrAlt(y + 2, 60, flagsBought);
			addstrAlt(score[s].stat_buys);
			mvaddstrAlt(y + 3, 60, flagsBurned);
			addstrAlt(score[s].stat_burns);
			y += 4;
		}
	}
	set_color_easy(GREEN_ON_BLACK_BRIGHT);
	//UNIVERSAL STATS
	mvaddstrAlt(22, 0, univer);
	mvaddstrAlt(23, 0, numRecruit);
	addstrAlt(ustat_recruits);
	mvaddstrAlt(24, 0, numMartyr);
	addstrAlt(ustat_dead);
	mvaddstrAlt(23, 20, numKills);
	addstrAlt(ustat_kills);
	mvaddstrAlt(24, 20, numKidnap);
	addstrAlt(ustat_kidnappings);
	mvaddstrAlt(23, 40, cashTaxed);
	addstrAlt(ustat_funds);
	mvaddstrAlt(24, 40, cashSpent);
	addstrAlt(ustat_spent);
	mvaddstrAlt(23, 60, flagsBought);
	addstrAlt(ustat_buys);
	mvaddstrAlt(24, 60, flagsBurned);
	addstrAlt(ustat_burns);
	pressAnyKey();
}
MusicModes getEndingMusic(EndTypes e) {
	switch (e)
	{
	case END_WON:
		return (MUSIC_VICTORY);
	case END_POLICE:
		return (MUSIC_DEFEAT);
	case END_CIA:
		return (MUSIC_DEFEAT);
	case END_HICKS:
		return (MUSIC_DEFEAT);
	case END_CORP:
		return (MUSIC_DEFEAT);
	case END_DEAD:
		return (MUSIC_DEFEAT);
	case END_REAGAN:
		return (MUSIC_REAGANIFIED);
	case END_PRISON:
		return (MUSIC_DEFEAT);
	case END_EXECUTED:
		return (MUSIC_DEFEAT);
	case END_DATING:
		return (MUSIC_DEFEAT);
	case END_HIDING:
		return (MUSIC_DEFEAT);
	case END_DISBANDLOSS:
		return (MUSIC_DEFEAT);
	case END_DISPERSED:
		return (MUSIC_DEFEAT);
	case END_CCS:
		return (MUSIC_DEFEAT);
	case END_FIREMEN:
		return (MUSIC_DEFEAT);
	case END_STALIN:
		return (MUSIC_STALINIZED);
	default:
		return MUSIC_RANDOM;
	}
}
string getEndingString(EndTypes e) {
	switch (e)
	{
	case END_WON:
		return(heLiLiber);
		break;
	case END_POLICE:
		return(heLiBrought);
		break;
	case END_CIA:
		return(heLiBlot);
		break;
	case END_HICKS:
		return(heLiMob);
		break;
	case END_CORP:
		return(heLiDownsized);
		break;
	case END_DEAD:
		return(heLiKIA);
		break;
	case END_REAGAN:
		return(hecoReag);
		break;
	case END_PRISON:
		return(heLiDie);
		break;
	case END_EXECUTED:
		return(heLiExec);
		break;
	case END_DATING:
		return(heLiVaca);
		break;
	case END_HIDING:
		return(heLiHide);
		break;
	case END_DISBANDLOSS:
		return(heLiHunted);
		break;
	case END_DISPERSED:
		return(heLiScattered);
		break;
	case END_CCS:
		return(heLiOutCrime);
		break;
	case END_FIREMEN:
		return(heLiBurned);
		break;
	case END_STALIN:
		return(hecoStalinized);
		break;
	default:
		return blankString;
		break;
	}
}



// #include "../includes.h"
const string CONST_interrogation167 = "Press any key to reflect on this.";
const string CONST_interrogation166 = "'s disappearance has not yet been reported.";
const string CONST_interrogation165 = " was able to create a map of the site with this information.";
const string CONST_interrogation164 = "Unfortunately, none of it is useful to the LCS.";
const string CONST_interrogation163 = " reveals details about the ";
const string CONST_interrogation162 = "The conversion is convincing enough that the police no longer consider it a kidnapping.";
const string CONST_interrogation161 = "The Automaton has been Enlightened!   Your Liberal ranks are swelling!";
const string CONST_interrogation160 = " grows colder.";
const string CONST_interrogation159 = "'s interrogation.";
const string CONST_interrogation158 = " under ";
const string CONST_interrogation157 = " is dead";
const string CONST_interrogation156 = " has committed suicide.";
const string CONST_interrogation155 = " has been tainted with wisdom!";
const string CONST_interrogation154 = "!";
const string CONST_interrogation153 = " turns the tables on ";
const string CONST_interrogation152 = " holds firm.";

const string CONST_interrogation140 = " takes it well.";
const string CONST_interrogation139 = "'s weakened body crumbles under the brutal assault.";
const string CONST_interrogation138 = " is badly hurt.";
const string CONST_interrogation137 = " seems to be getting the message.";
const string CONST_interrogation136 = "A detailed map has been created of ";
const string CONST_interrogation134 = " beats information out of the pathetic thing.";

const string CONST_interrogation123 = "!\" in its face.";
const string CONST_interrogation122 = "! ";
const string CONST_interrogation121 = " the Automaton";
const string CONST_interrogation120 = "'s guards beat";
const string CONST_interrogation119 = " beat";
const string CONST_interrogation118 = " beats";
const string CONST_interrogation115 = "screaming \"";
const string CONST_interrogation114 = " had a near-death experience and met John Lennon.";
const string CONST_interrogation113 = " had a near-death experience and met God in heaven.";
const string CONST_interrogation112 = " clumsily rescues it from cardiac arrest with a defibrillator.";
const string CONST_interrogation111 = " from any health damage.";
const string CONST_interrogation110 = " skillfully saves ";
const string CONST_interrogation109 = " deftly rescues it from cardiac arrest with a defibrillator.";
const string CONST_interrogation108 = "'s incompetence at first aid.";
const string CONST_interrogation107 = " dies due to ";
const string CONST_interrogation106 = "'s weakened state.";
const string CONST_interrogation105 = "It is a lethal overdose in ";
const string CONST_interrogation104 = " pants.";
const string CONST_interrogation103 = " has a panic attack and shits ";
const string CONST_interrogation102 = " has a panic attack and [makes a stinky].";
const string CONST_interrogation101 = " flatlines.";
const string CONST_interrogation100 = " uses a defibrillator repeatedly but ";
const string CONST_interrogation099 = " foams at the mouth and its eyes roll back in its skull.";
const string CONST_interrogation098 = "It is subjected to dangerous hallucinogens.";
const string CONST_interrogation097 = "converted into a makeshift cell.";
const string CONST_interrogation096 = " is locked in a back room ";
const string CONST_interrogation095 = "in the middle of a back room.";
const string CONST_interrogation094 = " is tied hands and feet to a metal chair";
const string CONST_interrogation093 = "The Automaton";
const string CONST_interrogation092 = ": Day ";
const string CONST_interrogation091 = "The Education of ";
const string CONST_interrogation089 = " in cold blood.";
const string CONST_interrogation088 = "execute ";
const string CONST_interrogation087 = "There is no one able to get up the nerve to ";
const string CONST_interrogation085 = " by ";
const string CONST_interrogation084 = " executes ";
const string CONST_interrogation082 = "The Final Education of ";
const string CONST_interrogation081 = "Press Enter to Confirm the Plan";
const string CONST_interrogation080 = "K - Kill the Hostage";
const string CONST_interrogation079 = "($50)";
const string CONST_interrogation078 = "Hallucinogenic Drugs    ";
const string CONST_interrogation077 = "No ";
const string CONST_interrogation076 = "E - ";
const string CONST_interrogation075 = "($250)";
const string CONST_interrogation074 = "Expensive Props     ";
const string CONST_interrogation072 = "D - ";
const string CONST_interrogation071 = "Violently Beaten    ";
const string CONST_interrogation070 = "Not ";
const string CONST_interrogation069 = "C - ";
const string CONST_interrogation068 = "Physical Restraints   ";
const string CONST_interrogation066 = "B - ";
const string CONST_interrogation065 = "Attempt to Convert";
const string CONST_interrogation064 = "No Verbal Contact     ";
const string CONST_interrogation063 = "A - ";
const string CONST_interrogation062 = "Selecting a Liberal Interrogation Plan";
const string CONST_interrogation061 = "The Execution of an Automaton         ";
const string CONST_interrogation058 = "murder ";
const string CONST_interrogation057 = "The Conservative would like to ";
const string CONST_interrogation056 = "The Conservative hates ";
const string CONST_interrogation055 = "toward ";
const string CONST_interrogation054 = "The Conservative is uncooperative ";
const string CONST_interrogation053 = "The Conservative likes ";
const string CONST_interrogation052 = " as its only friend.";
const string CONST_interrogation051 = "to ";
const string CONST_interrogation050 = "The Conservative clings helplessly ";
const string CONST_interrogation049 = "Outfit: ";
const string CONST_interrogation048 = "Wisdom: ";
const string CONST_interrogation047 = "Heart: ";
const string CONST_interrogation046 = "Psychology Skill: ";
const string CONST_interrogation045 = "Health: ";
const string CONST_interrogation044 = "Lead Interrogator: ";
const string CONST_interrogation039 = "Prisoner: ";
const string CONST_interrogation038 = "                                  ";
const string CONST_interrogation037 = "cling_to_science.txt";
const string CONST_interrogation036 = "cling_to_business.txt";
const string CONST_interrogation035 = "cling_to_science_one_line.txt";
const string CONST_interrogation034 = "cling_to_business_one_line.txt";
const string CONST_interrogation033 = "vanilla_recruit.txt";
const string CONST_interrogation032 = "discuss.txt";
const string CONST_interrogation031 = "cling_to_religion_one_line.txt";
const string CONST_interrogation030 = "cling_to_religion.txt";
const string CONST_interrogation029 = "clinging_one_line.txt";
const string CONST_interrogation028 = "cling_to_interrogater.txt";
const string CONST_interrogation027 = "interrogater_shows_compassion.txt";
const string CONST_interrogation026 = "interrogater_shows_compassion_one_line.txt";
const string CONST_interrogation025 = "develops_hatred.txt";
const string CONST_interrogation024 = "develops_hatred_one_line.txt";
const string CONST_interrogation023 = "smarter_than_you.txt";
const string CONST_interrogation022 = "smarter_than_you_one_line.txt";
const string CONST_interrogation021 = "good_trip_companion.txt";
const string CONST_interrogation020 = "bad_trip.txt";
const string CONST_interrogation019 = "fall_in_love.txt";
const string CONST_interrogation018 = "good_trip.txt";
const string CONST_interrogation017 = "self_wounding.txt";
const string CONST_interrogation016 = "broods_over_death.txt";
const string CONST_interrogation015 = "partial_conversion.txt";
const string CONST_interrogation014 = "resist_drugs.txt";
const string CONST_interrogation013 = "use_props.txt";
const string CONST_interrogation012 = "prays_on_drugs.txt";
const string CONST_interrogation011 = "prays.txt";
const string CONST_interrogation010 = "words_to_scream.txt";
const string CONST_interrogation009 = "words_meaning_screaming.txt";
const string CONST_interrogation008 = "beat_with_props.txt";
const string CONST_interrogation007 = "screaming.txt";
const string CONST_interrogation006 = "low_heart_torture_props.txt";
const string CONST_interrogation005 = "feels_sick.txt";
const string CONST_interrogation004 = "execution.txt";

// #include "../common/musicClass.h"
vector<string> execution;
vector<string> feels_sick;
vector<string> low_heart_torture_props;
vector<string> screaming;
vector<string> beat_with_props;
vector<string> words_meaning_screaming;
vector<string> words_to_scream;
vector<string> use_props;
vector<string> resist_drugs;
vector<string> partial_conversion;
vector<string> broods_over_death;
vector<string> self_wounding;
vector<string> good_trip;
vector<vector<string> > good_trip_companion;
vector<vector<string> > discuss;
vector<string> vanilla_recruit;

string feels_sick_and;
enum InterrogationTechnqiues
{
	TECHNIQUE_TALK,
	TECHNIQUE_RESTRAIN,
	TECHNIQUE_BEAT,
	TECHNIQUE_PROPS,
	TECHNIQUE_DRUGS,
	TECHNIQUE_KILL
};
// Clear sidebar
void clear_interrogation_sidebar()
{
	for (int i = 4; i < 23; i++)
		mvaddstrAlt(i, 40, CONST_interrogation038); // 34 spaces
}
// Shows the InterrogationST data at the right side of the screen
void show_interrogation_sidebar(Creature * cr, Creature * a)
{
	clear_interrogation_sidebar();
	map<long, struct Float_Zero>& rapport = cr->activity.intr()->rapport;
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(4, 40, CONST_interrogation039);
	set_color_easy(RED_ON_BLACK_BRIGHT);
	addstrAlt(cr->name);
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(6, 40, CONST_interrogation045);
	printhealthstat(*cr, 6, 48, 0);
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(7, 40, CONST_interrogation047);
	addstrAlt(cr->get_attribute(ATTRIBUTE_HEART, true));
	mvaddstrAlt(8, 40, CONST_interrogation048);
	addstrAlt(cr->get_attribute(ATTRIBUTE_WISDOM, true));
	mvaddstrAlt(9, 40, CONST_interrogation045);
	addstrAlt(cr->get_attribute(ATTRIBUTE_HEALTH, true));
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(13, 40, CONST_interrogation044);
	set_color_easy(GREEN_ON_BLACK_BRIGHT);
	addstrAlt(a->name);
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(15, 40, CONST_interrogation045);
	printhealthstat(*a, 16, 48, 0);
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(17, 40, CONST_interrogation046);
	addstrAlt(a->get_skill(SKILL_PSYCHOLOGY));
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(18, 40, CONST_interrogation047);
	addstrAlt(a->get_attribute(ATTRIBUTE_HEART, true));
	mvaddstrAlt(19, 40, CONST_interrogation048);
	addstrAlt(a->get_attribute(ATTRIBUTE_WISDOM, true));
	mvaddstrAlt(20, 40, CONST_interrogation049);
	addstrAlt(a->get_armor().get_name());
	// What would 4, 2, 0, -2, -3, and/or -5 mean? (Some of these may not exist) -- LK
	// These are greater than and less than comparisons, so they are testing ranges -Fox
	string line_one;
	string line_two = blankString;
	if (rapport[a->id] > 3)
	{
		line_one = CONST_interrogation050;
		line_two = CONST_interrogation051;
		line_two += string(a->name);
		line_two += CONST_interrogation052;
	}
	else if (rapport[a->id] > 1)
	{
		line_one = CONST_interrogation053;
		line_two += string(a->name);
		line_one += singleDot;
	}
	else if (rapport[a->id] > -1)
	{
		line_one = CONST_interrogation054;
		line_two = CONST_interrogation055;
		line_two += string(a->name);
		line_two += singleDot;
	}
	else if (rapport[a->id] > -4)
	{
		line_one = CONST_interrogation056;
		line_two += string(a->name);
		line_one += singleDot;
	}
	else
	{
		line_one = CONST_interrogation057;
		line_two, CONST_interrogation058;
		line_two += string(a->name);
		line_two += singleDot;
	}
	mvaddstrAlt(22, 40, line_one);
	if (len(line_two)) {
		mvaddstrAlt(23, 40, line_two);
	}
}
void printInterrogationMenu(bool techniques[6], Creature * cr, Creature * a) {
	int c = -1;
	do
	{

		if (techniques[TECHNIQUE_KILL])
		{
			set_color_easy(RED_ON_BLACK_BRIGHT);
			mvaddstrAlt(2, 0, CONST_interrogation061);
		}
		else
		{
			set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			mvaddstrAlt(2, 0, CONST_interrogation062);
		}
		if (techniques[TECHNIQUE_KILL])set_color_easy(BLACK_ON_BLACK_BRIGHT);
		else set_color_easy(techniques[TECHNIQUE_TALK] ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);

		mvaddstrAlt(4, 0, CONST_interrogation063);

		if (!techniques[TECHNIQUE_TALK]) addstrAlt(CONST_interrogation064);
		else addstrAlt(CONST_interrogation065);

		if (!techniques[TECHNIQUE_KILL])set_color_easy(techniques[TECHNIQUE_RESTRAIN] ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);

		mvaddstrAlt(5, 0, CONST_interrogation066);
		if (!techniques[TECHNIQUE_RESTRAIN]) addstrAlt(CONST_interrogation077);

		addstrAlt(CONST_interrogation068);
		if (!techniques[TECHNIQUE_KILL])set_color_easy(techniques[TECHNIQUE_BEAT] ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);

		mvaddstrAlt(6, 0, CONST_interrogation069);

		if (!techniques[TECHNIQUE_BEAT]) addstrAlt(CONST_interrogation070);

		addstrAlt(CONST_interrogation071);

		if (!techniques[TECHNIQUE_KILL])set_color_easy(techniques[TECHNIQUE_PROPS] ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);

		mvaddstrAlt(7, 0, CONST_interrogation072);

		if (!techniques[TECHNIQUE_PROPS])addstrAlt(CONST_interrogation077);

		addstrAlt(CONST_interrogation074);
		mvaddstrAlt(7, 27, CONST_interrogation075);

		if (!techniques[TECHNIQUE_KILL])set_color_easy(techniques[TECHNIQUE_DRUGS] ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);

		mvaddstrAlt(8, 0, CONST_interrogation076);

		if (!techniques[TECHNIQUE_DRUGS])addstrAlt(CONST_interrogation077);

		addstrAlt(CONST_interrogation078);
		mvaddstrAlt(8, 28, CONST_interrogation079);

		if (techniques[TECHNIQUE_KILL])set_color_easy(RED_ON_BLACK_BRIGHT);
		else set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(10, 0, CONST_interrogation080);
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(12, 0, CONST_interrogation081);
		show_interrogation_sidebar(cr, a);
		c = getkeyAlt();
		if (c >= 'a'&&c <= 'e') { techniques[c - 'a'] = !techniques[c - 'a']; }
		if (c == 'k') { techniques[TECHNIQUE_KILL] = !techniques[TECHNIQUE_KILL]; }
	} while (c != 'x' && c != ENTER && c != ESC && c != SPACEBAR);
}
void attemptExecution(Creature * cr) {

	extern Log gamelog;
	vector<Creature *> temppool;
	findAllTendersToThisHostage(cr, temppool);
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(0, 0, CONST_interrogation082, gamelog);
	addstrAlt(cr->name, gamelog);
	addstrAlt(CONST_interrogation092, gamelog);
	addstrAlt(cr->joindays, gamelog);
	gamelog.newline();
	Creature *a = NULL;
	for (int i = 0; i < len(temppool); i++)
		if (LCSrandom(50) < temppool[i]->juice ||
			LCSrandom(9) + 1 >= temppool[i]->get_attribute(ATTRIBUTE_HEART, 0))
		{
			a = temppool[i]; break;
		}
	if (a)
	{
		set_color_easy(MAGENTA_ON_BLACK);
		cr->die();
		mvaddstrAlt(13, 0, a->name, gamelog);
		addstrAlt(CONST_interrogation084, gamelog);
		addstrAlt(cr->name, gamelog);
		addstrAlt(CONST_interrogation085, gamelog);
		addstrAlt(pickrandom(execution), gamelog);
		//show_interrogation_sidebar(cr,a);
		pressAnyKey();
		if (LCSrandom(a->get_attribute(ATTRIBUTE_HEART, false)) > LCSrandom(3))
		{
			gamelog.newline();
			set_color_easy(GREEN_ON_BLACK_BRIGHT);
			mvaddstrAlt(14, 0, a->name, gamelog);
			addstrAlt(feels_sick_and, gamelog);
			a->adjust_attribute(ATTRIBUTE_HEART, -1);
			mvaddstrAlt(15, 0, pickrandom(feels_sick), gamelog);
		}
		else if (!LCSrandom(3))
		{
			gamelog.newline();
			set_color_easy(CYAN_ON_BLACK_BRIGHT);
			mvaddstrAlt(14, 0, a->name, gamelog);
			addstrAlt(CONST_interrogation160, gamelog);
			a->adjust_attribute(ATTRIBUTE_WISDOM, +1);
		}
		gamelog.nextMessage();
	}
	else
	{
		set_color_easy(YELLOW_ON_BLACK);
		mvaddstrAlt(13, 0, CONST_interrogation087, gamelog);
		mvaddstrAlt(14, 0, CONST_interrogation088, gamelog);
		addstrAlt(cr->name, gamelog);
		addstrAlt(CONST_interrogation089, gamelog);
		gamelog.nextMessage();
	}
	pressAnyKey();
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(24, 0, CONST_interrogation167);
	pressAnyKey();
}
char feelTheDrugUse(Creature *cr, Creature *doctor) {
	extern short lawList[LAWNUM];
	extern Log gamelog;
	char emptyDrugs = 0;
	cr->adjust_attribute(ATTRIBUTE_HEALTH, -1);
	pressAnyKey();
	mvaddstrAlt(7, 0, cr->name, gamelog);
	addstrAlt(CONST_interrogation099, gamelog);
	gamelog.newline();
	pressAnyKey();
	mvaddstrAlt(8, 0, doctor->name, gamelog);
	int y = 8;
	if (cr->get_attribute(ATTRIBUTE_HEALTH, false) <= 0 || !doctor->get_skill(SKILL_FIRSTAID)) // he's dead, Jim
	{
		if (doctor->get_skill(SKILL_FIRSTAID))
		{ // we have a real doctor but the patient is still dead anyway
			addstrAlt(CONST_interrogation100, gamelog);
			addstrAlt(cr->name, gamelog);
			addstrAlt(CONST_interrogation101, gamelog);
		}
		else
		{
			if (lawList[LAW_FREESPEECH] == -2)
				addstrAlt(CONST_interrogation102, gamelog);
			else
			{
				addstrAlt(CONST_interrogation103, gamelog);
				addstrAlt(doctor->hisher(), gamelog);
				addstrAlt(CONST_interrogation104, gamelog);
			}
		}
		gamelog.newline();
		pressAnyKey();
		set_color_easy(YELLOW_ON_BLACK_BRIGHT);
		if (doctor->get_skill(SKILL_FIRSTAID))
		{
			mvaddstrAlt(9, 0, CONST_interrogation105, gamelog);
			addstrAlt(cr->name, gamelog);
			addstrAlt(CONST_interrogation106, gamelog);
		}
		else
		{
			mvaddstrAlt(9, 0, cr->name, gamelog);
			addstrAlt(CONST_interrogation107, gamelog);
			addstrAlt(doctor->name, gamelog);
			addstrAlt(CONST_interrogation108, gamelog);
		}
		gamelog.newline();
		cr->die();
	}
	else
	{
		if (doctor->skill_check(SKILL_FIRSTAID, DIFFICULTY_CHALLENGING)) // is the doctor AWESOME?
		{
			doctor->train(SKILL_FIRSTAID, 5 * max(10 - doctor->get_skill(SKILL_FIRSTAID), 0), 10); // can train up to 10
			addstrAlt(CONST_interrogation109, gamelog); // not long enough for near-death experience
			gamelog.newline();
			pressAnyKey();
			mvaddstrAlt(9, 0, doctor->name, gamelog);
			addstrAlt(CONST_interrogation110, gamelog);
			addstrAlt(cr->name, gamelog);
			addstrAlt(CONST_interrogation111, gamelog);
			cr->adjust_attribute(ATTRIBUTE_HEALTH, +1); // no permanent health damage from a skilled doctor
			emptyDrugs = 1;
		}
		else
		{
			doctor->train(SKILL_FIRSTAID, 5 * max(5 - doctor->get_skill(SKILL_FIRSTAID), 0), 5); // can train up to 5
			addstrAlt(CONST_interrogation112, gamelog);
			gamelog.newline();
			pressAnyKey();
			mvaddstrAlt(9, 0, cr->name, gamelog);
			if (cr->get_skill(SKILL_RELIGION)) // the patient was out long enough to have a near-death experience
				addstrAlt(CONST_interrogation113, gamelog);
			else addstrAlt(CONST_interrogation114, gamelog);
			emptyDrugs = 2;
		}
		gamelog.newline();
	}
	return emptyDrugs;
}
string getDespairString(const bool drugs, const bool restrain, const bool religion);

string acquireMapFromWork(const int worklocation) {

	if (LocationsPool::getInstance().getLocationType(worklocation) <= SITE_RESIDENTIAL_SHELTER)
		return CONST_interrogation164;
	else
	{
		return CONST_interrogation136 + LocationsPool::getInstance().getLocationName(worklocation) + singleDot;
	}
}

string victimPrays(const bool onDrugs);
string getFallsInLove(const string name, const bool restrain);
string getBadTrip(const string name, const bool restrain, const bool rapport);
string outPsychologyCaptor(const string name);
string triedConvertingTheAbused(const string name);
string feelsBadForAbused(const string name);
string stockholmSyndrome(const string name);
string failToBreakReligion(const string a, const string cr);
string failedToBreakBusiness(const string a, const string cr);
string failedToBreakScience(const string a, const string cr);

bool attemptToOutsmartCaptor(Creature *cr, Creature *a, const bool drugs, int& y) {
	extern Log gamelog;
	//Failure to break religious convictions
	 if (cr->get_skill(SKILL_RELIGION) > a->get_skill(SKILL_RELIGION) + a->get_skill(SKILL_PSYCHOLOGY) && !drugs)
	{
		moveAlt(y++, 0);
		addstrAlt(failToBreakReligion(a->name, cr->name), gamelog);
		gamelog.newline();
		a->train(SKILL_RELIGION, cr->get_skill(SKILL_RELIGION) * 4);
	}
	//Failure to persuade entrenched capitalists
	else if (cr->get_skill(SKILL_BUSINESS) > a->get_skill(SKILL_BUSINESS) + a->get_skill(SKILL_PSYCHOLOGY) && !drugs)
	{
		moveAlt(y++, 0);
		addstrAlt(failedToBreakBusiness(a->name, cr->name), gamelog);
		gamelog.newline();
		a->train(SKILL_BUSINESS, cr->get_skill(SKILL_BUSINESS) * 4);
	}
	//Failure to persuade scientific minds
	else if (cr->get_skill(SKILL_SCIENCE) > a->get_skill(SKILL_SCIENCE) + a->get_skill(SKILL_PSYCHOLOGY) && !drugs)
	{
		moveAlt(y++, 0);
		addstrAlt(failedToBreakScience(a->name, cr->name), gamelog);
		
		gamelog.newline();
		a->train(SKILL_SCIENCE, cr->get_skill(SKILL_SCIENCE) * 4);
	}
	else {
		return false;
	}
	return true;


}

bool attemptSway(Creature *cr, Creature *a, const int attack, map<long, struct Float_Zero>(&rapport), char& turned, int& y) {
	extern Log gamelog;

	//Target is swayed by Liberal Reason -- skilled interrogators, time held,
	//and rapport contribute to the likelihood of this
	if (!(cr->attribute_check(ATTRIBUTE_WISDOM, attack / 6)))
	{
		if (cr->juice > 0)
		{
			cr->juice -= attack;
			if (cr->juice < 0) cr->juice = 0;
		}
		if (cr->get_attribute(ATTRIBUTE_HEART, false) < 10)
			cr->adjust_attribute(ATTRIBUTE_HEART, +1);
		//Improve rapport with interrogator
		rapport[a->id] += 1.5;
		//Join LCS??
		//1) They were liberalized
		if (cr->get_attribute(ATTRIBUTE_HEART, true) > cr->get_attribute(ATTRIBUTE_WISDOM, true) + 4) turned = 1;
		//2) They were befriended
		if (rapport[a->id] > 4) turned = 1;
		mvaddstrAlt(y++, 0, cr->name, gamelog);
		addstrAlt(pickrandom(partial_conversion), gamelog);
		gamelog.newline();
		if (LocationsPool::getInstance().isLocationMapped(cr->worklocation) == 0 && !LCSrandom(5))
		{
			mvaddstrAlt((++y)++, 0, cr->name, gamelog);
			addstrAlt(CONST_interrogation163, gamelog);
			addstrAlt(LocationsPool::getInstance().getLocationName(cr->worklocation), gamelog);
			addstrAlt(singleDot, gamelog);
			gamelog.newline();
			moveAlt(y++, 0);
			if (LocationsPool::getInstance().getLocationType(cr->worklocation) <= SITE_RESIDENTIAL_SHELTER)
			{
				addstrAlt(CONST_interrogation164, gamelog);
			}
			else
			{
				addstrAlt(a->name, gamelog);
				addstrAlt(CONST_interrogation165, gamelog);
			}
			gamelog.newline();
			LocationsPool::getInstance().setLocationMappedAndUnhidden(cr->worklocation);
		}
	}
	else {
		return false;
	}
	return true;
}

void interrogaterNotOutsmarted(Creature *cr, Creature *a, const bool props, map<long, struct Float_Zero>(&rapport), int& y) {
	extern Log gamelog;

	//Target is not sold on the LCS arguments and holds firm
	//This is the worst possible outcome if you use props
	if (!(cr->skill_check(SKILL_PERSUASION, a->get_attribute(ATTRIBUTE_HEART, true))) || props)
	{
		//Not completely unproductive; builds rapport
		rapport[a->id] += 0.2f;
		mvaddstrAlt(y++, 0, cr->name, gamelog);
		addstrAlt(CONST_interrogation152, gamelog);
		gamelog.newline();
	}
	//Target actually wins the argument so successfully that the Liberal
	//interrogator's convictions are the ones that are shaken
	else
	{
		//Consolation prize is that they end up liking the
		//liberal more
		rapport[a->id] += 0.5f;
		a->adjust_attribute(ATTRIBUTE_WISDOM, +1);
		mvaddstrAlt(y++, 0, cr->name, gamelog);
		addstrAlt(CONST_interrogation153, gamelog);
		addstrAlt(a->name, gamelog);
		addstrAlt(CONST_interrogation154, gamelog);
		gamelog.newline();
		//show_interrogation_sidebar(cr,a);
		pressAnyKey();
		mvaddstrAlt(y++, 0, a->name, gamelog);
		addstrAlt(CONST_interrogation155, gamelog);
		gamelog.newline();
	}
}
/* hostage tending */
void tendhostage(Creature *cr, char &clearformess)
{
	// Interrogation always enlightens
	extern bool AUTOENLIGHTEN;
	extern Log gamelog;
	extern MusicClass music;
	extern int stat_recruits;
	extern int stat_kills;
	extern class Ledger ledger;
	extern short lawList[LAWNUM];
	if (cr->location == -1)
	{
		delete cr;
		return;
	}
	music.play(MUSIC_INTERROGATION);
	vector<Creature *> temppool;
	Creature *a = NULL;
	InterrogationST* &intr = cr->activity.intr();
	bool(&techniques)[6] = intr->techniques;
	map<long, struct Float_Zero>& rapport = intr->rapport;
	findAllTendersToThisHostage(cr, temppool);
	//possible hostage escape attempt if unattended or unrestrained
	if (!len(temppool) || !techniques[TECHNIQUE_RESTRAIN])
	{
		//CHECK FOR HOSTAGE ESCAPE
		if (LCSrandom(200) + 25 * len(temppool) <
			cr->get_attribute(ATTRIBUTE_INTELLIGENCE, true) +
			cr->get_attribute(ATTRIBUTE_AGILITY, true) +
			cr->get_attribute(ATTRIBUTE_STRENGTH, true) &&
			cr->joindays >= 5)
		{
			hostageEscapes(cr, clearformess);
			//delete InterrogationST data
			delete intr;
			return;
		}
	}
	if (!len(temppool)) return;
	clearformess = 1;
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(0, 0, CONST_interrogation091);
	addstrAlt(cr->name);
	addstrAlt(CONST_interrogation092);
	addstrAlt(cr->joindays);
	pressAnyKey();
	set_color_easy(WHITE_ON_BLACK);

	{
		//each day, the attack roll is initialized to the number of days of the stay with
		//the LCS -- they will eventually break, but also eventually become too traumatized
		//to continue
		int business = 0, religion = 0, science = 0, attack = 0;
		int* _attack = new int[len(temppool)];
		for (int p = 0; p < len(temppool); p++)
		{
			_attack[p] = 0;
			if (temppool[p])
				if (temppool[p]->alive)
				{
					if (temppool[p]->get_skill(SKILL_BUSINESS) > business)
						business = temppool[p]->get_skill(SKILL_BUSINESS);
					if (temppool[p]->get_skill(SKILL_RELIGION) > religion)
						religion = temppool[p]->get_skill(SKILL_RELIGION);
					if (temppool[p]->get_skill(SKILL_SCIENCE) > science)
						science = temppool[p]->get_skill(SKILL_SCIENCE);
					_attack[p] = (temppool[p]->get_attribute(ATTRIBUTE_HEART, true) -
						temppool[p]->get_attribute(ATTRIBUTE_WISDOM, true) +
						temppool[p]->get_skill(SKILL_PSYCHOLOGY) * 2);
					_attack[p] += temppool[p]->get_armor().get_interrogation_basepower();
					if (_attack[p] < 0) _attack[p] = 0;
					if (_attack[p] > attack) attack = _attack[p];
				}
		}
		vector<int> goodp;
		for (int p = 0; p < len(temppool); p++)
			if (temppool[p])
				if (temppool[p]->alive&&_attack[p] == attack)
					goodp.push_back(p);
		a = temppool[pickrandom(goodp)];
		attack += len(temppool);
		attack += cr->joindays;
		attack += business - cr->get_skill(SKILL_BUSINESS);
		attack += religion - cr->get_skill(SKILL_RELIGION);
		attack += science - cr->get_skill(SKILL_SCIENCE);
		attack += a->skill_roll(SKILL_PSYCHOLOGY) - cr->skill_roll(SKILL_PSYCHOLOGY);
		attack += cr->attribute_roll(ATTRIBUTE_HEART);
		attack -= cr->attribute_roll(ATTRIBUTE_WISDOM) * 2;
		char turned = 0;
		{
			printInterrogationMenu(techniques, cr, a);
			if (techniques[TECHNIQUE_PROPS] && ledger.get_funds() >= 250)
				ledger.subtract_funds(250, EXPENSE_HOSTAGE);
			else techniques[TECHNIQUE_PROPS] = 0;
			if (techniques[TECHNIQUE_DRUGS] && ledger.get_funds() >= 50)
				ledger.subtract_funds(50, EXPENSE_HOSTAGE);

			else techniques[TECHNIQUE_DRUGS] = 0;

			if (techniques[TECHNIQUE_KILL]) // Kill the Hostage
			{
				attemptExecution(cr);
				if (cr->alive) {
					//Interrogation will continue as planned, with
					//these restrictions:
					techniques[TECHNIQUE_TALK] = 0; //don't talk to them today
					techniques[TECHNIQUE_BEAT] = 0; //don't beat them today
					techniques[TECHNIQUE_DRUGS] = 0; //don't administer drugs
													 //Food and restraint settings will be applied as normal
				}
				else {

					//delete InterrogationST information
					delete intr;
					stat_kills++;

					setAllCreatureActivities(ACTIVITY_NONE, temppool);
					delete[] _attack;

					return;
				}
			}
			eraseAlt();
		}
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, CONST_interrogation091, gamelog);
		addstrAlt(cr->name, gamelog);
		addstrAlt(CONST_interrogation092, gamelog);
		addstrAlt(cr->joindays, gamelog);
		gamelog.newline();

		mvaddstrAlt(2, 0, CONST_interrogation093, gamelog);
		if (techniques[TECHNIQUE_RESTRAIN]) // Restraint
		{
			addstrAlt(CONST_interrogation094, gamelog);
			mvaddstrAlt(3, 0, CONST_interrogation095, gamelog);
			gamelog.newline();
			attack += 5;
		}
		else
		{
			addstrAlt(CONST_interrogation096, gamelog);
			mvaddstrAlt(3, 0, CONST_interrogation097, gamelog);
			gamelog.newline();
		}
		//show_interrogation_sidebar(cr,a);
		pressAnyKey();
		int y = 4;
		if (techniques[TECHNIQUE_DRUGS]) // Hallucinogenic drugs
		{

			mvaddstrAlt(5, 0, CONST_interrogation098, gamelog);
			gamelog.newline();
			int drugbonus = 10 + a->get_armor().get_interrogation_drugbonus(); // we won't apply this JUST yet
																			   //Possible permanent health damage
			if (LCSrandom(50) < ++intr->druguse)
			{
				y = 9;

				Creature* doctor = a; // the lead interrogator is doctor by default
				int maxskill = doctor->get_skill(SKILL_FIRSTAID);
				for (int i = 0; i < len(temppool); i++) // search for the best doctor
					if (temppool[i]->get_skill(SKILL_FIRSTAID) > maxskill)
						maxskill = (doctor = temppool[i])->get_skill(SKILL_FIRSTAID); // we found a doctor


				int drugeffect = feelTheDrugUse(cr, doctor);
				if (drugeffect == 0) {
				
				}
				else if (drugeffect == 1) {

					techniques[TECHNIQUE_DRUGS] = (intr->druguse = drugbonus = 0); // drugs eliminated from the system (zeroing out 3 variables with 1 line of code)
					rapport[doctor->id] += 0.5f; // rapport bonus for having life saved by doctor
				}
				else if (drugeffect == 2) {

					drugbonus *= 2; // the near-death experience doubles the drug bonus, since the hostage is spaced out afterwards
					rapport[doctor->id] += 0.5f; // rapport bonus for having life saved by doctor
				}


			}
			attack += drugbonus; // now we finally apply the drug bonus
			moveAlt(++y, 0);
			//show_interrogation_sidebar(cr,a);
			pressAnyKey();
		}
		if (techniques[TECHNIQUE_BEAT] && !turned&&cr->alive) // Beating
		{
			y++;
			int forceroll = 0;
			bool tortured = 0;
			for (int i = 0; i < len(temppool); i++)
			{
				//add interrogator's strength to beating strength
				forceroll += temppool[i]->attribute_roll(ATTRIBUTE_STRENGTH);
				//reduce rapport with each interrogator
				rapport[temppool[i]->id] -= 0.4f;
			}
			//Torture captive if lead interrogator has low heart
			//and you funded using extra supplies
			//
			//Yeah, you kinda don't want this to happen
			if (!(a->attribute_check(ATTRIBUTE_HEART, DIFFICULTY_EASY)) && techniques[TECHNIQUE_PROPS])
			{
				tortured = true;
				//Torture more devastating than normal beating
				forceroll *= 5;
				//Extremely bad for rapport with lead interrogator
				rapport[a->id] -= 3;
				mvaddstrAlt(y, 0, a->name, gamelog);
				addstrAlt(singleSpace, gamelog);
				addstrAlt(pickrandom(low_heart_torture_props), gamelog);
				addstrAlt(commaSpace, gamelog);
				mvaddstrAlt(++y, 0, CONST_interrogation115, gamelog);
				addstrAlt(pickrandom(screaming), gamelog);
				addstrAlt(CONST_interrogation122, gamelog);
				addstrAlt(pickrandom(screaming), gamelog);
				addstrAlt(CONST_interrogation123, gamelog);
				gamelog.newline();
				if (cr->get_attribute(ATTRIBUTE_HEART, true) > 1) cr->adjust_attribute(ATTRIBUTE_HEART, -1);
				if (cr->get_attribute(ATTRIBUTE_WISDOM, true) > 1) cr->adjust_attribute(ATTRIBUTE_WISDOM, -1);
			}
			else
			{
				string guardsAdministerBeating;
				switch (len(temppool)) {
				case 1: // X beats the automaton
					guardsAdministerBeating = temppool[0]->name + CONST_interrogation118;
					break;

				case 2: // X and Y beat the automaton
					guardsAdministerBeating = temppool[0]->name + AND + temppool[1]->name + CONST_interrogation119;
					break;

				default: // cr->name's guards beat the automaton
					guardsAdministerBeating = cr->name + CONST_interrogation120;
					break;
				}
				mvaddstrAlt(y, 0, guardsAdministerBeating + CONST_interrogation121, gamelog);
				if (techniques[TECHNIQUE_PROPS])
				{
					addstrAlt(singleSpace, gamelog);
					addstrAlt(pickrandom(beat_with_props), gamelog);
				}
				addstrAlt(commaSpace, gamelog);
				mvaddstrAlt(++y, 0, pickrandom(words_meaning_screaming), gamelog);
				for (int i = 0; i < 3; i++)
				{
					addstrAlt(pickrandom(words_to_scream), gamelog);
					if (i < 2) addstrAlt(CONST_interrogation122, gamelog);
				}
				addstrAlt(CONST_interrogation123, gamelog);
				gamelog.newline();
			}
			y++;
			cr->blood -= (5 + LCSrandom(5)) * (1 + techniques[TECHNIQUE_PROPS]);
			//show_interrogation_sidebar(cr,a);
			pressAnyKey();
			if (!(cr->attribute_check(ATTRIBUTE_HEALTH, forceroll)))
			{
				if (cr->skill_check(SKILL_RELIGION, forceroll))
				{
					mvaddstrAlt(y++, 0, cr->name, gamelog);
					addstrAlt(singleSpace + victimPrays(techniques[TECHNIQUE_DRUGS]), gamelog);
					gamelog.newline();
					
				}
				else if (forceroll >
					cr->get_attribute(ATTRIBUTE_WISDOM, true) * 3 +
					cr->get_attribute(ATTRIBUTE_HEART, true) * 3 +
					cr->get_attribute(ATTRIBUTE_HEALTH, true) * 3)
				{
					
					mvaddstrAlt(y++, 0, cr->name, gamelog);
					addstrAlt(getDespairString(techniques[TECHNIQUE_DRUGS], techniques[TECHNIQUE_RESTRAIN], cr->get_skill(SKILL_RELIGION)), gamelog);
					
					gamelog.newline();
					if (cr->get_attribute(ATTRIBUTE_HEART, false) > 1) cr->adjust_attribute(ATTRIBUTE_HEART, -1);
					if (LCSrandom(2) && cr->juice > 0) { if ((cr->juice -= forceroll) < 0) cr->juice = 0; }
					else if (cr->get_attribute(ATTRIBUTE_WISDOM, false) > 1)
					{
						cr->set_attribute(ATTRIBUTE_WISDOM, cr->get_attribute(ATTRIBUTE_WISDOM, false) - (forceroll / 10));
						if (cr->get_attribute(ATTRIBUTE_WISDOM, false) < 1) cr->set_attribute(ATTRIBUTE_WISDOM, 1);
					}
					if (LocationsPool::getInstance().isLocationMapped(cr->worklocation) == 0 && !LCSrandom(5))
					{
						//show_interrogation_sidebar(cr,a);
						pressAnyKey();
						mvaddstrAlt(y++, 0, a->name, gamelog);
						addstrAlt(CONST_interrogation134, gamelog);
						gamelog.newline();
						moveAlt(y++, 0);
						pressAnyKey();
						addstrAlt(acquireMapFromWork(cr->worklocation), gamelog);
						gamelog.newline();
						LocationsPool::getInstance().setLocationMappedAndUnhidden(cr->worklocation);
					}
				}
				else
				{
					mvaddstrAlt(y++, 0, cr->name, gamelog);
					addstrAlt(CONST_interrogation137, gamelog);
					gamelog.newline();
					if (cr->juice > 0) if ((cr->juice -= forceroll) < 0) cr->juice = 0;
					if (cr->get_attribute(ATTRIBUTE_WISDOM, false) > 1)
					{
						cr->set_attribute(ATTRIBUTE_WISDOM, cr->get_attribute(ATTRIBUTE_WISDOM, false) - (forceroll / 10 + 1));
						if (cr->get_attribute(ATTRIBUTE_WISDOM, false) < 1) cr->set_attribute(ATTRIBUTE_WISDOM, 1);
					}
				}
				if (!(cr->attribute_check(ATTRIBUTE_HEALTH, forceroll / 3)))
				{
					//show_interrogation_sidebar(cr,a);
					pressAnyKey();
					moveAlt(y++, 0);
					if (cr->get_attribute(ATTRIBUTE_HEALTH, false) > 1)
					{
						cr->adjust_attribute(ATTRIBUTE_HEALTH, -1);
						addstrAlt(cr->name, gamelog);
						addstrAlt(CONST_interrogation138, gamelog);
						gamelog.newline();
					}
					else
					{
						cr->set_attribute(ATTRIBUTE_HEALTH, 0);
						addstrAlt(cr->name, gamelog);
						addstrAlt(CONST_interrogation139, gamelog);
						gamelog.newline();
						cr->die();
					}
				}
			}
			else
			{
				mvaddstrAlt(y++, 0, cr->name, gamelog);
				addstrAlt(CONST_interrogation140, gamelog);
				gamelog.newline();
			}
			//show_interrogation_sidebar(cr,a);
			pressAnyKey();
			if (tortured && cr->alive)
			{
				if (LCSrandom(a->get_attribute(ATTRIBUTE_HEART, false)) > LCSrandom(3))
				{
					set_color_easy(GREEN_ON_BLACK_BRIGHT);
					mvaddstrAlt(y++, 0, a->name, gamelog);
					addstrAlt(feels_sick_and, gamelog);
					a->adjust_attribute(ATTRIBUTE_HEART, -1);
					mvaddstrAlt(y++, 0, pickrandom(feels_sick), gamelog);
					gamelog.newline();
				}
				else if (!LCSrandom(3))
				{
					set_color_easy(CYAN_ON_BLACK_BRIGHT);
					mvaddstrAlt(y++, 0, a->name, gamelog);
					addstrAlt(CONST_interrogation160, gamelog);
					gamelog.newline();
					a->adjust_attribute(ATTRIBUTE_WISDOM, +1);
				}
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
			}
		}
		// Verbal Interrogation
		if (techniques[TECHNIQUE_TALK] && cr->alive)
		{
			float rapport_temp = rapport[a->id];
			if (!techniques[TECHNIQUE_RESTRAIN])attack += 5;
			attack += int(rapport[a->id] * 3);
			mvaddstrAlt((++y)++, 0, a->name, gamelog);
			if (techniques[TECHNIQUE_PROPS])//props
			{
				attack += 10;
				addstrAlt(singleSpace, gamelog);
				addstrAlt(pickrandom(use_props), gamelog);
				gamelog.newline();
			}
			else
			{
				int which_discuss = LCSrandom(discuss.size() + vanilla_recruit.size());
				if (which_discuss < discuss.size()) {
					addstrAlt(discuss[which_discuss][0], gamelog);
					addstrAlt(getview(LCSrandom(VIEWNUM - 3), true), gamelog);
					addstrAlt(discuss[which_discuss][1], gamelog);
				}
				else {
					addstrAlt(pickrandom(vanilla_recruit), gamelog);
				}
			}
			addstrAlt(cr->name, gamelog);
			addstrAlt(singleDot, gamelog);
			gamelog.newline();
			//Hallucinogenic drugs:
			//Re-interprets lead interrogator
			if (techniques[TECHNIQUE_DRUGS])
			{
				//show_interrogation_sidebar(cr,a);
				pressAnyKey();
				moveAlt(y++, 0);
				if (cr->skill_check(SKILL_PSYCHOLOGY, DIFFICULTY_CHALLENGING))
				{
					addstrAlt(cr->name);
					addstrAlt(singleSpace, gamelog);
					addstrAlt(pickrandom(resist_drugs), gamelog);
					gamelog.newline();
				}
				else if ((rapport[a->id] > 1 && !LCSrandom(3)) || !LCSrandom(10))
				{
					rapport_temp = 10;
					addstrAlt(cr->name + getFallsInLove(a->name, techniques[TECHNIQUE_RESTRAIN]), gamelog);
					gamelog.newline();
				}
				else if ((rapport[a->id] < -1 && LCSrandom(3)) || !LCSrandom(5))
				{
					attack = 0;
					addstrAlt(cr->name + getBadTrip(a->name, techniques[TECHNIQUE_RESTRAIN], rapport[a->id] < -3), gamelog);					
					gamelog.newline();
				}
				else
				{
					int which_good_trip = LCSrandom(good_trip.size() + good_trip_companion.size());
					addstrAlt(cr->name, gamelog);
					if (which_good_trip < good_trip_companion.size()) {
						addstrAlt(good_trip_companion[which_good_trip][0], gamelog);
						addstrAlt(a->name, gamelog);
						addstrAlt(good_trip_companion[which_good_trip][1], gamelog);
					}
					else {
						addstrAlt(pickrandom(good_trip), gamelog);
					}
					gamelog.newline();
				}
			}
			//show_interrogation_sidebar(cr,a);
			pressAnyKey();
			if (cr->get_skill(SKILL_PSYCHOLOGY) > a->get_skill(SKILL_PSYCHOLOGY))
			{
				mvaddstrAlt(y++, 0, cr->name, gamelog);
				addstrAlt(outPsychologyCaptor(a->name), gamelog);

			}
			//Attempt to convert when the target is brutally treated will
			//just alienate them and make them cynical
			else if (techniques[TECHNIQUE_BEAT] || rapport_temp < -2)
			{
				mvaddstrAlt(y++, 0, cr->name, gamelog);
				addstrAlt(triedConvertingTheAbused(a->name), gamelog);

				gamelog.newline();
				if (a->skill_check(SKILL_SEDUCTION, DIFFICULTY_CHALLENGING))
				{
					//show_interrogation_sidebar(cr,a);
					pressAnyKey();
					mvaddstrAlt(y++, 0, a->name, gamelog);
					addstrAlt(feelsBadForAbused(cr->name), gamelog);
					gamelog.newline();
					rapport[a->id] += 0.7f;
					if (rapport[a->id] > 3)
					{
						//show_interrogation_sidebar(cr,a);
						pressAnyKey();
						mvaddstrAlt(y++, 0, cr->name, gamelog);
						addstrAlt(stockholmSyndrome(a->name), gamelog);
						gamelog.newline();
						if (rapport[a->id] > 5) turned = 1;
					}
				}
				if (cr->get_attribute(ATTRIBUTE_HEART, false) > 1) cr->adjust_attribute(ATTRIBUTE_HEART, -1);
			}
			else
			if (!attemptToOutsmartCaptor(cr, a, techniques[TECHNIQUE_DRUGS], y)) {
				if (!attemptSway(cr, a, attack, rapport, turned, y)) {
					interrogaterNotOutsmarted(cr, a, techniques[TECHNIQUE_PROPS], rapport, y);
				}
			}
			//show_interrogation_sidebar(cr,a);
			pressAnyKey();
		}
		//Lead interrogator gets bonus experience
		if (!techniques[TECHNIQUE_KILL])
		{
			a->train(SKILL_PSYCHOLOGY, attack / 2 + 1);
			//Others also get experience
			for (int i = 0; i < len(temppool); i++) temppool[i]->train(SKILL_PSYCHOLOGY, attack / 4 + 1);
		}
		//Possibly suicidal when heart is down to 1 and prisoner has already been
		//captive for a week without rescue
		if (!turned&&cr->alive&&cr->get_attribute(ATTRIBUTE_HEART, false) <= 1 && LCSrandom(3) && cr->joindays > 6)
		{
			//can't commit suicide if restrained
			if (LCSrandom(6) || techniques[TECHNIQUE_RESTRAIN])
			{
				set_color_easy(MAGENTA_ON_BLACK);
				mvaddstrAlt(++y, 0, cr->name, gamelog);
				//can't cut self if restrained
				if (!techniques[TECHNIQUE_RESTRAIN] && !LCSrandom(5)) {
					addstrAlt(singleSpace + pickrandom(self_wounding), gamelog); cr->blood -= LCSrandom(15) + 10;
				}
				else {
					addstrAlt(singleSpace + pickrandom(broods_over_death), gamelog);
				}
				gamelog.newline();
			}
			else
			{
				set_color_easy(RED_ON_BLACK_BRIGHT);
				mvaddstrAlt(++y, 0, cr->name, gamelog);
				addstrAlt(CONST_interrogation156, gamelog);
				gamelog.newline(); //TODO: Next message?
				cr->die();
			}
			y++;
			//show_interrogation_sidebar(cr,a);
			pressAnyKey();
		}
		//Death
		if (cr->alive == 0 || cr->blood < 1)
		{
			//delete InterrogationST information
			delete intr;
			cr->die();
			stat_kills++;
			set_color_easy(RED_ON_BLACK_BRIGHT);
			mvaddstrAlt(++y, 0, cr->name, gamelog);
			addstrAlt(CONST_interrogation157, gamelog);
			if (a)
			{
				addstrAlt(CONST_interrogation158, gamelog);
				addstrAlt(a->name, gamelog);
				addstrAlt(CONST_interrogation159, gamelog);
			}
			else addstrAlt(singleDot, gamelog);
			set_color_easy(WHITE_ON_BLACK);
			y++;
			//show_interrogation_sidebar(cr,a);
			pressAnyKey();
			if (a)
			{
				if (LCSrandom(a->get_attribute(ATTRIBUTE_HEART, false)))
				{
					gamelog.newline();
					set_color_easy(GREEN_ON_BLACK_BRIGHT);
					mvaddstrAlt(++y, 0, a->name, gamelog);
					addstrAlt(feels_sick_and, gamelog);
					a->adjust_attribute(ATTRIBUTE_HEART, -1);
					mvaddstrAlt(++y, 0, pickrandom(feels_sick), gamelog);
				}
				else if (!LCSrandom(3))
				{
					gamelog.newline();
					set_color_easy(CYAN_ON_BLACK_BRIGHT);
					mvaddstrAlt(++y, 0, a->name, gamelog);
					addstrAlt(CONST_interrogation160, gamelog);
					a->adjust_attribute(ATTRIBUTE_WISDOM, +1);
				}
			}
		}
		gamelog.nextMessage();
		delete[] _attack;

		if (AUTOENLIGHTEN) {
			turned = 1;// Lucky!
		}
		if (turned&&cr->alive)
		{
			//clear_interrogation_sidebar();
			//delete InterrogationST information
			delete intr;
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(++y, 0, CONST_interrogation161, gamelog);
			if (cr->get_attribute(ATTRIBUTE_HEART, true) > 7 &&
				cr->get_attribute(ATTRIBUTE_WISDOM, true) > 2 &&
				!LCSrandom(4) && (cr->flag & CREATUREFLAG_KIDNAPPED))
			{
				gamelog.newline();
				mvaddstrAlt(++y, 0, CONST_interrogation162, gamelog);
				//Actually liberalized -- they'll clean up the kidnapping story
				cr->flag &= ~CREATUREFLAG_MISSING;
				cr->flag &= ~CREATUREFLAG_KIDNAPPED;
			}
			cr->flag |= CREATUREFLAG_BRAINWASHED;
			setAllCreatureActivities(ACTIVITY_NONE, temppool);
			y += 2;
			liberalize(*cr, false);
			cr->hireid = a->id;
			stat_recruits++;
			if (LocationsPool::getInstance().isLocationMapped(cr->worklocation) == 0 || LocationsPool::getInstance().isLocationHidden(cr->worklocation) == 1)
			{
				gamelog.newline();
				mvaddstrAlt(y, 0, cr->name, gamelog);
				addstrAlt(CONST_interrogation163, gamelog);
				addstrAlt(LocationsPool::getInstance().getLocationName(cr->worklocation), gamelog);
				addstrAlt(singleDot, gamelog);
				gamelog.newline();
				if (LocationsPool::getInstance().getLocationType(cr->worklocation) <= SITE_RESIDENTIAL_SHELTER)
					mvaddstrAlt(++y, 0, CONST_interrogation164, gamelog);
				else
				{
					mvaddstrAlt(++y, 0, a->name, gamelog);
					addstrAlt(CONST_interrogation165, gamelog);
				}
				LocationsPool::getInstance().setLocationMappedAndUnhidden(cr->worklocation);
			}
			if (cr->flag & CREATUREFLAG_MISSING && !(cr->flag & CREATUREFLAG_KIDNAPPED))
			{
				pressAnyKey();
				eraseAlt();
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				gamelog.newline();
				mvaddstrAlt(1, 0, cr->name, gamelog);
				addstrAlt(CONST_interrogation166, gamelog);
				sleeperize_prompt(*cr, *a, 3);
				cr->flag &= ~CREATUREFLAG_MISSING;
				gamelog.nextMessage();
				return;
			}
		}
		if (cr->align == 1 || !cr->alive) {
			setAllCreatureActivities(ACTIVITY_NONE, temppool);
		}
	}
	gamelog.nextMessage();
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(24, 0, CONST_interrogation167);
	pressAnyKey();
}

// #include "../includes.h"
const string CONST_item007 = "a";
const string CONST_item006 = "an";
const string CONST_item005 = "number";
const string CONST_item004 = "itemtypeid";
const string CONST_item003 = "itemtypename";

Item::Item(const ItemType& seed, int number) : number_(number)
{
	itemtypename_ = seed.get_idname();
	itemtypeid_ = seed.get_id();
}
Item::Item(const std::string& inputXml)
{
	CMarkup xml;
	xml.SetDoc(inputXml);
	xml.FindElem();
	xml.IntoElem();
	while (xml.FindElem())
	{
		std::string tag = xml.GetTagName();
		if (tag == CONST_item003) itemtypename_ = xml.GetData();
		else if (tag == CONST_item004) itemtypeid_ = atoi(xml.GetData().c_str());
		else if (tag == CONST_item005) number_ = atoi(xml.GetData().c_str());
	}
}
void Item::addBaseValues(CMarkup& xml) const
{
	xml.AddElem(CONST_item003, itemtypename_);
	xml.AddElem(CONST_item004, itemtypeid_);
	xml.AddElem(CONST_item005, tostring(number_));
}
bool Item::sort_compare(Item *b, Item *a)
{
	if (a->whatIsThis() == THIS_IS_WEAPON && !(b->whatIsThis() == THIS_IS_WEAPON)) return false;
	else if (!(a->whatIsThis() == THIS_IS_WEAPON) && b->whatIsThis() == THIS_IS_WEAPON) return true;
	else if (a->whatIsThis() == THIS_IS_ARMOR && !(b->whatIsThis() == THIS_IS_ARMOR)) return false;
	else if (!(a->whatIsThis() == THIS_IS_ARMOR) && b->whatIsThis() == THIS_IS_ARMOR) return true;
	else if (a->whatIsThis() == THIS_IS_CLIP && !(b->whatIsThis() == THIS_IS_CLIP)) return false;
	else if (!(a->whatIsThis() == THIS_IS_CLIP) && b->whatIsThis() == THIS_IS_CLIP) return true;
	else if (a->whatIsThis() == THIS_IS_LOOT && !(b->whatIsThis() == THIS_IS_LOOT)) return false;
	else if (!(a->whatIsThis() == THIS_IS_LOOT) && b->whatIsThis() == THIS_IS_LOOT) return true;
	else return a->sort_compare_special(b);
}
const char* Item::aan() const
{
	switch (get_name()[0])
	{
	case 'a': case 'A':
	case 'e': case 'E':
	case 'i': case 'I':
	case 'o': case 'O':
	case 'u': case 'U':
		return CONST_item006.c_str();
	default:
		return CONST_item007.c_str();
	}
}

// #include "../includes.h"
const string CONST_itemtype007 = "Unknown element for item type << idname_ << ";
const string CONST_itemtype006 = "LACKS IDNAME ";
const string CONST_itemtype005 = "UNDEFINED";

const string tag_fencevalue = "fencevalue";
// #include "../items/itemtype.h"
int ItemType::number_of_itemtypes = 0;
ItemType::ItemType(MCD_STR xmlstring)
	: name_(CONST_itemtype005), name_future_defined_(false), fencevalue_(0)
{
	init(xmlstring);
}
ItemType::ItemType(const ItemType& base, MCD_STR xmlstring)
{
	idname_ = base.idname_;
	id_ = base.id_;
	name_ = base.name_;
	name_future_ = base.name_future_;
	name_future_defined_ = base.name_future_defined_;
	fencevalue_ = base.fencevalue_;
	init(xmlstring);
}
void ItemType::init(const MCD_STR& xmlstring)
{
	id_ = number_of_itemtypes++;
	CMarkup xml;
	xml.SetDoc(xmlstring);
	xml.FindElem();
	idname_ = xml.GetAttrib(tag_idname);
	if (!len(idname_))
		idname_ = CONST_itemtype006 + tostring(id_);
	xml.IntoElem();
	while (xml.FindElem()) //Loop over all the elements inside the element.
	{
		std::string element = xml.GetTagName();
		if (element == tag_name)
			name_ = xml.GetData();
		else if (element == tag_name_future)
		{
			name_future_ = xml.GetData();
			name_future_defined_ = true;
		}
		else if (element == tag_fencevalue)
			fencevalue_ = atoi(xml.GetData().c_str());
		/*else
		errorlog << CONST_itemtype007: " << element << endl;*/
	}
}
const string& ItemType::get_name() const
{
	extern int year;
	if (name_future_defined_ && year >= 2100)
		return name_future_;
	else
		return name_;
}


// #include "../includes.h"
const string CONST_justiceB174 = "hiring an undocumented worker";
const string CONST_justiceB173 = "hiring undocumented workers";
const string CONST_justice182 = " months.";
const string CONST_justice181 = " is due to be executed in ";
const string CONST_justice180 = " is due to be released next month.";
const string CONST_justice179 = " is due to be executed next month.";
const string CONST_justice178 = "No doubt there are some mental scars, but the Liberal is back.";
const string CONST_justice177 = " has been released from prison.";
const string CONST_justice176 = "If you can't protect your own people, who can you protect?";
const string CONST_justice175 = " has failed the Liberal Crime Squad.";
const string CONST_justice174 = "by ";
const string CONST_justice173 = "Today, the Conservative Machine executed ";
const string CONST_justice172 = "FOR SHAME:";
const string CONST_justice171 = "due to the abolition of the death penalty.";
const string CONST_justice170 = "'s death sentence has been commuted to life, ";
const string CONST_justice169 = " seems to be mostly fine, though.";
const string CONST_justice168 = " is kinda losing it in here. Juice, that is.";
const string CONST_justice167 = " has become a more hardened, Juicier criminal.";
const string CONST_justice166 = "The LCS will rise again! Multiple LCS members escape!";
const string CONST_justice165 = "Another imprisoned LCS member also gets out!";
const string CONST_justice164 = " escaped from prison!";
const string CONST_justice163 = " intentionally ODs on smuggled drugs, then breaks out of the medical ward!";
const string CONST_justice162 = " jimmies the cell door and cuts the outer fence in the dead of night!";
const string CONST_justice161 = " puts on smuggled street clothes and calmly walks out of prison.";
const string CONST_justice160 = " codes a virus on a smuggled phone that opens all the prison doors!";
const string CONST_justice159 = " leads a riot with dozens of prisoners chanting the LCS slogan!";
const string CONST_justice158 = " managed to avoid lasting injury.";
const string CONST_justice157 = " is found dead.";
const string CONST_justice156 = " is badly hurt in the process.";
const string CONST_justice152 = " consumes drugs that simulate death, and is thrown out with the trash!";
const string CONST_justice151 = " picks the lock on their leg chains and then sneaks away!";
const string CONST_justice150 = " wears an electrician's outfit and rides away with some contractors.";
const string CONST_justice149 = " leads the oppressed prisoners and overwhelms the prison guards!";
const string CONST_justice148 = " remains strong.";
const string CONST_justice147 = " abandons the Liberal Crime Squad!";
const string CONST_justice146 = " only stays loyal to the LCS for ";
const string CONST_justice145 = " silently grows Wiser...";
const string CONST_justice144 = " feels bad about LCS actions, and loses juice!";
const string CONST_justice143 = "The court accepts the plea.";
const string CONST_justice142 = "nolo";
const string CONST_justice141 = ", less a month for time already served.";
const string CONST_justice140 = " will be returned to prison to resume an earlier sentence";
const string CONST_justice139 = " is free!";
const string CONST_justice138 = "NOT GUILTY!";
const string CONST_justice134 = "The prosecution declines to re-try the case.";
const string CONST_justice133 = "The case will be re-tried next month.";
const string CONST_justice132 = "But they can't reach a verdict!";
const string CONST_justice131 = "The jury has returned from deliberations.";
const string CONST_justice130 = "The jury leaves to consider the case.";
const string CONST_justice129 = " to acquit)";
const string CONST_justice128 = ", need ";
const string CONST_justice127 = " (";
const string CONST_justice126 = " had the jury, judge, and prosecution crying for freedom.";
const string CONST_justice125 = " made a very powerful case.";
const string CONST_justice124 = " worked the jury very well.";
const string CONST_justice123 = "'s arguments were pretty good.";
const string CONST_justice122 = " did all right, but made some mistakes.";
const string CONST_justice121 = "'s case really sucked.";
const string CONST_justice120 = " makes one horrible mistake after another.";
const string CONST_justice119 = " conducts an incredible defense.";
const string CONST_justice118 = "and shout \"NOT GUILTY!\" before deliberations even began.";
const string CONST_justice117 = "'s arguments made several of the jurors stand up ";
const string CONST_justice116 = "The defense is extremely compelling.";
const string CONST_justice115 = "The defense makes the prosecution look like amateurs.";
const string CONST_justice114 = "The defense was really slick.";
const string CONST_justice113 = "Defense arguments were pretty good.";
const string CONST_justice112 = "The defense was lackluster.";
const string CONST_justice111 = "The defense is totally lame.";
const string CONST_justice110 = "The defense attorney accidentally said \"My client is GUILTY!\" during closing.";
const string CONST_justice109 = "The defense attorney rarely showed up.";
const string CONST_justice108 = " to convict)";
const string CONST_justice107 = " to +";
const string CONST_justice106 = " (+";
const string CONST_justice105 = "The prosecution is incredibly strong.";
const string CONST_justice104 = "The prosecution makes an airtight case.";
const string CONST_justice103 = "The prosecution's case is solid.";
const string CONST_justice102 = "The prosecution gives a standard presentation.";
const string CONST_justice101 = "The prosecution's presentation is terrible.";
const string CONST_justice098 = "The jury is a bit Conservative.";
const string CONST_justice097 = "The jury is quite moderate.";
const string CONST_justice096 = "The jury is fairly Liberal.";
const string CONST_justice095 = "'s best friend from childhood is a juror.";
const string CONST_justice094 = "'s CONSERVATIVE ARCH-NEMESIS will represent the prosecution!!!";
const string CONST_justice093 = "'s favor!";
const string CONST_justice092 = " ensures the jury is stacked in ";
const string CONST_justice091 = "The trial proceeds.  Jury selection is first.";
const string CONST_justice090 = " is standing trial.";
const string CONST_justice089 = "Intelligence: ";
const string CONST_justice088 = "Law: ";
const string CONST_justice087 = "Charisma: ";
const string CONST_justice086 = "Persuasion: ";
const string CONST_justice085 = "Heart: ";
const string CONST_justice084 = "'s offer to assist pro bono.";
const string CONST_justice083 = "E - Accept sleeper ";
const string CONST_justice082 = "D - Pay $5000 to hire ace Liberal attorney ";
const string CONST_justice081 = "C - Plead guilty.";
const string CONST_justice080 = "B - Defend self!";
const string CONST_justice079 = "A - Use a court-appointed attorney.";
const string CONST_justice078 = "How will you conduct the defense?";
const string CONST_justice077 = "A former LCS member will testify against ";
const string CONST_justice076 = " former LCS members will testify against ";
const string CONST_justice075 = "loitering";
const string CONST_justice074 = "indecent exposure";
const string CONST_justice073 = "disturbing the peace";
const string CONST_justice072 = "resisting arrest";
const string CONST_justice071 = "vandalism";
const string CONST_justice070 = "breaking and entering";
const string CONST_justice069 = "unlawful burial";
const string CONST_justice068 = "unlawful access of an information system";
const string CONST_justice067 = "interference with interstate commerce";
const string CONST_justice066 = "possession of an illegal weapon";
const string CONST_justice065 = "firing an illegal weapon";
const string CONST_justice064 = "hiring an illegal alien";
const string CONST_justice063 = "hiring illegal aliens";
const string CONST_justice062 = "prostitution";
const string CONST_justice061 = "petty larceny";
const string CONST_justice060 = "credit card fraud";
const string CONST_justice059 = "grand theft auto";
const string CONST_justice058 = "misdemeanor assault";
const string CONST_justice057 = "felony assault";
const string CONST_justice056 = "extortion";
const string CONST_justice055 = "racketeering";
const string CONST_justice054 = "jury tampering";
const string CONST_justice053 = "aiding a prison escape";
const string CONST_justice052 = "escaping prison";
const string CONST_justice051 = "drug dealing";
const string CONST_justice050 = "sedition";
const string CONST_justice049 = "flag burning";
const string CONST_justice048 = "felony flag burning";
const string CONST_justice047 = "Flag Murder";
const string CONST_justice046 = "arson";
const string CONST_justice045 = "bank robbery";
const string CONST_justice044 = "kidnapping";
const string CONST_justice043 = "murder";
const string CONST_justice042 = "terrorism";
const string CONST_justice041 = "treason";
const string CONST_justice040 = ", is charged with ";
const string CONST_justice039 = "The defendant, ";
const string CONST_justice038 = "The judge reads the charges:";
const string CONST_justice037 = " reads the charges, trying to hide a smile:";
const string CONST_justice035 = "to be served consecutively";
const string CONST_justice034 = "to be served concurrently";
const string CONST_justice033 = ",";
const string CONST_justice032 = " in prison";
const string CONST_justice031 = "s";
const string CONST_justice030 = " month";
const string CONST_justice029 = " years in prison";
const string CONST_justice028 = "life in prison";
const string CONST_justice027 = "Have a nice day, ";
const string CONST_justice026 = " consecutive life terms in prison";
const string CONST_justice025 = ", you are sentenced to ";
const string CONST_justice024 = ", consider this a warning.  You are free to go.";
const string CONST_justice022 = "You will be returned to prison to resume it";
const string CONST_justice021 = ", the court sees no need to add to your existing sentence.";
const string CONST_justice020 = ", you are sentenced to DEATH!";
const string CONST_justice019 = ", you will be returned to prison to carry out your death sentence.";
const string CONST_justice018 = "During sentencing, the judge grants some leniency.";
const string CONST_justice017 = "GUILTY!";
const string CONST_justice016 = "general_experiences.txt";
const string CONST_justice015 = "bad_experiences.txt";
const string CONST_justice014 = "good_experiences.txt";
const string CONST_justice013 = "labor_camp_experiences.txt";
const string CONST_justice012 = "reeducation_experiences.txt";
const string CONST_justice011 = "supposedly_painless_execution_method.txt";
const string CONST_justice010 = "standard_execution_methods.txt";
const string CONST_justice009 = "cruel_and_unusual_execution_methods.txt";
const string CONST_justice008 = "conservative_jury.txt";
const string CONST_justice007 = "liberal_jury.txt";

//// #include "../common/commonactions.h"
int scare_factor(int lawflag, int crimenumber);
vector<string> liberal_jury;
vector<string> conservative_jury;
vector<string> cruel_and_unusual_execution_methods;
vector<string> standard_execution_methods;
vector<string> supposedly_painless_execution_method;
vector<string> reeducation_experiences;
vector<string> labor_camp_experiences;
vector<string> good_experiences;
vector<string> bad_experiences;
vector<string> general_experiences;
// #include "../customMaps.h"
const string justice = "justice\\";
vector<file_and_text_collection> justice_text_file_collection = {
	/*justice.cpp*/
	customText(&liberal_jury, justice + CONST_justice007),
	customText(&conservative_jury, justice + CONST_justice008),
	customText(&cruel_and_unusual_execution_methods, justice + CONST_justice009),
	customText(&standard_execution_methods, justice + CONST_justice010),
	customText(&supposedly_painless_execution_method, justice + CONST_justice011),
	customText(&reeducation_experiences, justice + CONST_justice012),
	customText(&labor_camp_experiences, justice + CONST_justice013),
	customText(&good_experiences, justice + CONST_justice014),
	customText(&bad_experiences, justice + CONST_justice015),
	customText(&general_experiences, justice + CONST_justice016),
};
string counts_of;
string execution_in_three_months;
/* monthly - sentence a liberal */
void penalize(Creature &g, char lenient)
{
	extern Log gamelog;
	extern short lawList[LAWNUM];
	set_color_easy(RED_ON_BLACK_BRIGHT);
	mvaddstrAlt(3, 1, CONST_justice017, gamelog);
	gamelog.newline();
	pressAnyKey();
	short oldsentence = g.sentence;
	char olddeathpenalty = g.deathpenalty;
	g.sentence = 0, g.deathpenalty = 0;
	if (!lenient && ((g.crimes_suspected[LAWFLAG_MURDER]) || (g.crimes_suspected[LAWFLAG_TREASON]) ||
		((g.crimes_suspected[LAWFLAG_BURNFLAG]) && lawList[LAW_FLAGBURNING] == -2) ||
		lawList[LAW_DEATHPENALTY] == -2))
	{
		if (lawList[LAW_DEATHPENALTY] == -2) g.deathpenalty = 1;
		if (lawList[LAW_DEATHPENALTY] == -1) g.deathpenalty = LCSrandom(3);
		if (lawList[LAW_DEATHPENALTY] == 0) g.deathpenalty = LCSrandom(2);
		if (lawList[LAW_DEATHPENALTY] == 1) g.deathpenalty = !LCSrandom(5);
		if (lawList[LAW_DEATHPENALTY] == 2) g.deathpenalty = 0;
	}
	for (int l = 0; l < LAWFLAGNUM; l++) if (g.crimes_suspected[l] > 10) g.crimes_suspected[l] = 10;
	//CALC TIME
	if (!g.deathpenalty)
	{
		if (!(g.sentence < 0))
		{
			g.sentence += (36 + LCSrandom(18))*g.crimes_suspected[LAWFLAG_KIDNAPPING];
			g.sentence += (1 + LCSrandom(4))*g.crimes_suspected[LAWFLAG_THEFT];
			//g.sentence+=(4+LCSrandom(12))*(!!g.crimes_suspected[LAWFLAG_GUNUSE])+ // Extra for first incident only
			//            (2+LCSrandom(4)*g.crimes_suspected[LAWFLAG_GUNUSE]);      // Generally
			//g.sentence+=(1+LCSrandom(4))*(!!g.crimes_suspected[LAWFLAG_GUNCARRY]);
			g.sentence += (6 + LCSrandom(7))*g.crimes_suspected[LAWFLAG_CARTHEFT];
			g.sentence += (1 + LCSrandom(13))*g.crimes_suspected[LAWFLAG_INFORMATION];
			g.sentence += (1 + LCSrandom(13))*g.crimes_suspected[LAWFLAG_COMMERCE];
			g.sentence += (6 + LCSrandom(25))*g.crimes_suspected[LAWFLAG_CCFRAUD];
			g.sentence += (3 + LCSrandom(12))*g.crimes_suspected[LAWFLAG_BURIAL];
			g.sentence += (1 + LCSrandom(6))*g.crimes_suspected[LAWFLAG_PROSTITUTION];
			g.sentence += 1 * g.crimes_suspected[LAWFLAG_DISTURBANCE];
			g.sentence += 1 * g.crimes_suspected[LAWFLAG_PUBLICNUDITY];
			//g.sentence+=1*g.crimes_suspected[LAWFLAG_LOITERING];
			g.sentence += 1 * g.crimes_suspected[LAWFLAG_HIREILLEGAL];
			g.sentence += (12 + LCSrandom(100))*g.crimes_suspected[LAWFLAG_RACKETEERING];
			// How illegal is marijuana?
			if (lawList[LAW_DRUGS] == -2) g.sentence += (3 + LCSrandom(360))*g.crimes_suspected[LAWFLAG_BROWNIES]; //insanely illegal
			else if (lawList[LAW_DRUGS] == -1) g.sentence += (3 + LCSrandom(120))*g.crimes_suspected[LAWFLAG_BROWNIES]; //very illegal
			else if (lawList[LAW_DRUGS] == 0) g.sentence += (3 + LCSrandom(12))*g.crimes_suspected[LAWFLAG_BROWNIES]; //moderately illegal
																													  // else not illegal
			g.sentence += 1 * g.crimes_suspected[LAWFLAG_BREAKING];
			g.sentence += (60 + LCSrandom(181))*g.crimes_suspected[LAWFLAG_TERRORISM];
			g.sentence += (30 + LCSrandom(61))*g.crimes_suspected[LAWFLAG_BANKROBBERY];
			g.sentence += (30 + LCSrandom(61))*g.crimes_suspected[LAWFLAG_JURY];
			g.sentence += (30 + LCSrandom(61))*g.crimes_suspected[LAWFLAG_HELPESCAPE];
			g.sentence += (3 + LCSrandom(16))*g.crimes_suspected[LAWFLAG_ESCAPED];
			g.sentence += (1 + LCSrandom(1))*g.crimes_suspected[LAWFLAG_RESIST];
			g.sentence += (6 + LCSrandom(1))*g.crimes_suspected[LAWFLAG_EXTORTION];
			g.sentence += (4 + LCSrandom(3))*g.crimes_suspected[LAWFLAG_SPEECH];
			g.sentence += 1 * g.crimes_suspected[LAWFLAG_VANDALISM];
			g.sentence += (12 + LCSrandom(12))*g.crimes_suspected[LAWFLAG_ARSON];
			g.sentence += (12 + LCSrandom(1))*g.crimes_suspected[LAWFLAG_ARMEDASSAULT];
			g.sentence += (3 + LCSrandom(1))*g.crimes_suspected[LAWFLAG_ASSAULT];
		}
		if (lawList[LAW_FLAGBURNING] == -2)
		{
			if (!LCSrandom(2)) g.sentence += (120 + LCSrandom(241))*g.crimes_suspected[LAWFLAG_BURNFLAG];
			else if (g.crimes_suspected[LAWFLAG_BURNFLAG])g.sentence = -1 * g.crimes_suspected[LAWFLAG_BURNFLAG];
		}
		else if (lawList[LAW_FLAGBURNING] == -1) g.sentence += 36 * g.crimes_suspected[LAWFLAG_BURNFLAG];
		else if (lawList[LAW_FLAGBURNING] == 0) g.sentence += 1 * g.crimes_suspected[LAWFLAG_BURNFLAG];
		if ((LCSrandom(4) - g.crimes_suspected[LAWFLAG_MURDER]) > 0)
		{
			if (!(g.sentence < 0)) g.sentence += (120 + LCSrandom(241))*g.crimes_suspected[LAWFLAG_MURDER];
		}
		else
		{
			if (g.sentence < 0) g.sentence -= -1 * g.crimes_suspected[LAWFLAG_MURDER];
			else if (g.crimes_suspected[LAWFLAG_MURDER])
				g.sentence = -1 * g.crimes_suspected[LAWFLAG_MURDER];
		}
		if (g.sentence < 0) g.sentence -= 1 * g.crimes_suspected[LAWFLAG_TREASON];
		else if (g.crimes_suspected[LAWFLAG_TREASON]) g.sentence = -1 * g.crimes_suspected[LAWFLAG_TREASON];
		if (lenient&&g.sentence != -1) g.sentence /= 2;
		if (lenient&&g.sentence == -1) g.sentence = 240 + LCSrandom(120);
	}
	//LENIENCY AND CAPITAL PUNISHMENT DON'T MIX
	else if (g.deathpenalty&&lenient) g.deathpenalty = 0, g.sentence = -1;
	//MENTION LENIENCY
	if (lenient)
	{
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(5, 1, CONST_justice018, gamelog);
		gamelog.newline();
		pressAnyKey();
	}
	//MENTION SENTENCE
	if (olddeathpenalty)
	{
		g.deathpenalty = 1;
		g.sentence = 3;
		set_color_easy(RED_ON_BLACK_BRIGHT);
		mvaddstrAlt(7, 1, g.propername, gamelog);
		addstrAlt(CONST_justice019, gamelog);
		gamelog.newline();
		pressAnyKey();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(9, 1, execution_in_three_months, gamelog);
		pressAnyKey();
	}
	else if (g.deathpenalty)
	{
		g.sentence = 3;
		set_color_easy(YELLOW_ON_RED_BRIGHT);
		mvaddstrAlt(7, 1, g.propername, gamelog);
		addstrAlt(CONST_justice020, gamelog);
		gamelog.newline();
		pressAnyKey();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(9, 1, execution_in_three_months, gamelog);
		pressAnyKey();
	}
	// Don't give a time-limited sentence if they already have a life sentence.
	else if ((g.sentence >= 0 && oldsentence < 0) ||
		(g.sentence == 0 && oldsentence > 0))
	{
		g.sentence = oldsentence;
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(7, 1, g.propername, gamelog);
		addstrAlt(CONST_justice021, gamelog);
		mvaddstrAlt(8, 1, CONST_justice022, gamelog);
		if (g.sentence > 1 && lenient)
		{
			g.sentence--;
			addstrAlt(CONST_justice141, gamelog);
		}
		else addstrAlt(singleDot, gamelog);
		pressAnyKey();
	}
	else if (g.sentence == 0)
	{
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(7, 1, g.propername, gamelog);
		addstrAlt(CONST_justice024, gamelog);
		pressAnyKey();
	}
	else
	{
		if (g.sentence >= 36)g.sentence -= g.sentence % 12;
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(7, 1, g.propername, gamelog);
		addstrAlt(CONST_justice025, gamelog);
		if (g.sentence > 1200) g.sentence /= -1200;
		if (g.sentence <= -1)
		{
			if (g.sentence < -1)
			{
				addstrAlt(-(g.sentence), gamelog);
				addstrAlt(CONST_justice026, gamelog);
				gamelog.newline();
				// Don't bother saying this if the convicted already has one or
				// more life sentences. Makes the 'consecutively' and 'concurrently'
				// statements later easier to tack on.
				if (oldsentence >= 0)
				{
					addstrAlt(singleDot, gamelog);
					pressAnyKey();
					mvaddstrAlt(9, 1, CONST_justice027, gamelog);
					addstrAlt(g.propername, gamelog);
				}
			}
			else addstrAlt(CONST_justice028, gamelog);
		}
		else if (g.sentence >= 36)
		{
			addstrAlt(g.sentence / 12, gamelog);
			addstrAlt(CONST_justice029, gamelog);
		}
		else
		{
			addstrAlt(g.sentence, gamelog);
			addstrAlt(CONST_justice030, gamelog);
			if (g.sentence > 1)addstrAlt(CONST_justice031, gamelog);
			addstrAlt(CONST_justice032, gamelog);
		}
		// Mash together compatible sentences.
		if ((g.sentence > 0 && oldsentence > 0) ||
			(g.sentence < 0 && oldsentence < 0))
		{
			addstrAlt(CONST_justice033, gamelog);
			moveAlt(8, 1);
			if (lenient)
			{
				if (abs(oldsentence) > abs(g.sentence))
					g.sentence = oldsentence;
				addstrAlt(CONST_justice034, gamelog);
			}
			else
			{
				g.sentence += oldsentence;
				addstrAlt(CONST_justice035, gamelog);
			}
		}
		addstrAlt(singleDot, gamelog);
		//dejuice boss
		dejuiceBoss(g);
		pressAnyKey();
	}
	gamelog.nextMessage();
}
/* monthly - move a liberal to jail */
void imprison(Creature &g)
{
	g.location = find_site_index_in_city(SITE_GOVERNMENT_PRISON, LocationsPool::getInstance().getLocationCity(g.location));
}
int listAllCrimes(Creature &g) {

	extern Log gamelog;
	extern short lawList[LAWNUM];
	int y = 5;
	bool breaker[LAWFLAGNUM] = { 0 };
	int typenum = 0;
	// *JDS* Scarefactor is the severity of the case against you; if you're a really
	// nasty person with a wide variety of major charges against you, then scarefactor
	// can get up there
	for (int i = 0; i < LAWFLAGNUM; i++) if (g.crimes_suspected[i])
	{
		typenum++;
		breaker[i] = 1;
	}
	int x = 2;
	while ((typenum--) > 0)
	{
		if ((x++) >= 2) { x = 0; moveAlt(++y, 1); }
		//////////////////////////////////////////////////////////////////////////
		//                                Treason                               //
		//////////////////////////////////////////////////////////////////////////
		// Technically, treason is exposing state secrets, or somesuch.         //
		// Illegal Immigrants cannot commit treason, because treason can only   //
		// be committed by `those owing allegiance to the United States`.       //
		//////////////////////////////////////////////////////////////////////////
		// The above is already respected by LCS; treason occurs from exposing
		// intelligence secrets, and illegal immigrants are not taken to trial.
		//    - Jonathan S. Fox
		// Oh, right. Forgot about that. Even if the law is L+?
		if (breaker[LAWFLAG_TREASON])
		{
			if (g.crimes_suspected[LAWFLAG_TREASON] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_TREASON], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice041, gamelog);
			breaker[LAWFLAG_TREASON] = 0;
		}
		else if (breaker[LAWFLAG_TERRORISM])
		{
			if (g.crimes_suspected[LAWFLAG_TERRORISM] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_TERRORISM], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice042, gamelog);
			breaker[LAWFLAG_TERRORISM] = 0;
		}
		else if (breaker[LAWFLAG_MURDER])//XXX: How about the addition of a `manslaughter` charge? -- LK
		{                               //     Manslaughter is murder without forethought or malice, IIRC. -- LK
										// Well, I can't think of an instance of this in LCS besides fruit stand employees. -Fox
										// Possibly people you accidentally kill when shooting at conservatives. -- LK
			if (g.crimes_suspected[LAWFLAG_MURDER] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_MURDER], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice043, gamelog);
			breaker[LAWFLAG_MURDER] = 0;
		}
		else if (breaker[LAWFLAG_KIDNAPPING])
		{
			if (g.crimes_suspected[LAWFLAG_KIDNAPPING] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_KIDNAPPING], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice044, gamelog);
			breaker[LAWFLAG_KIDNAPPING] = 0;
		}
		else if (breaker[LAWFLAG_BANKROBBERY])
		{
			if (g.crimes_suspected[LAWFLAG_BANKROBBERY] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_BANKROBBERY], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice045, gamelog);
			breaker[LAWFLAG_BANKROBBERY] = 0;
		}
		else if (breaker[LAWFLAG_ARSON])
		{
			if (g.crimes_suspected[LAWFLAG_ARSON] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_ARSON], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice046, gamelog);
			breaker[LAWFLAG_ARSON] = 0;
		}
		else if (breaker[LAWFLAG_BURNFLAG] && lawList[LAW_FLAGBURNING] <= 0)
		{
			if (g.crimes_suspected[LAWFLAG_BURNFLAG] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_BURNFLAG]);
				addstrAlt(counts_of, gamelog);
			}
			if (lawList[LAW_FLAGBURNING] == -2)
				addstrAlt(CONST_justice047, gamelog);
			else if (lawList[LAW_FLAGBURNING] == -1)
				addstrAlt(CONST_justice048, gamelog);
			else if (lawList[LAW_FLAGBURNING] == 0)
				addstrAlt(CONST_justice049, gamelog);
			breaker[LAWFLAG_BURNFLAG] = 0;
		}
		else if (breaker[LAWFLAG_SPEECH])
		{
			if (g.crimes_suspected[LAWFLAG_SPEECH] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_SPEECH], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice050, gamelog);
			breaker[LAWFLAG_SPEECH] = 0;
		}
		else if (breaker[LAWFLAG_BROWNIES])
		{
			if (g.crimes_suspected[LAWFLAG_BROWNIES] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_BROWNIES], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice051, gamelog);
			breaker[LAWFLAG_BROWNIES] = 0;
			//x=2;
		}
		else if (breaker[LAWFLAG_ESCAPED])
		{
			if (g.crimes_suspected[LAWFLAG_ESCAPED] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_ESCAPED], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice052, gamelog);
			breaker[LAWFLAG_ESCAPED] = 0;
		}
		else if (breaker[LAWFLAG_HELPESCAPE])
		{
			if (g.crimes_suspected[LAWFLAG_HELPESCAPE] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_HELPESCAPE], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice053, gamelog);
			breaker[LAWFLAG_HELPESCAPE] = 0;
			x = 2;
		}
		else if (breaker[LAWFLAG_JURY])
		{
			if (g.crimes_suspected[LAWFLAG_JURY] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_JURY], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice054, gamelog);
			breaker[LAWFLAG_JURY] = 0;
		}
		else if (breaker[LAWFLAG_RACKETEERING])
		{
			addstrAlt(CONST_justice055, gamelog);
			breaker[LAWFLAG_RACKETEERING] = 0;
		}
		else if (breaker[LAWFLAG_EXTORTION])
		{
			if (g.crimes_suspected[LAWFLAG_EXTORTION] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_EXTORTION], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice056, gamelog);
			breaker[LAWFLAG_EXTORTION] = 0;
		}
		else if (breaker[LAWFLAG_ARMEDASSAULT])
		{
			if (g.crimes_suspected[LAWFLAG_ARMEDASSAULT] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_ARMEDASSAULT], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice057, gamelog);
			breaker[LAWFLAG_ARMEDASSAULT] = 0;
		}
		else if (breaker[LAWFLAG_ASSAULT])
		{
			if (g.crimes_suspected[LAWFLAG_ASSAULT] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_ASSAULT], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice058, gamelog);
			breaker[LAWFLAG_ASSAULT] = 0;
		}
		else if (breaker[LAWFLAG_CARTHEFT])
		{
			if (g.crimes_suspected[LAWFLAG_CARTHEFT] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_CARTHEFT], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice059, gamelog);// If chase lasts more than 20 `turns` then
			breaker[LAWFLAG_CARTHEFT] = 0;// this should be `Grand Theft Auto` -- LK
		}                              // We'll just make it grand theft auto anyway :) -Fox
		else if (breaker[LAWFLAG_CCFRAUD])
		{
			if (g.crimes_suspected[LAWFLAG_CCFRAUD] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_CCFRAUD], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice060, gamelog);
			breaker[LAWFLAG_CCFRAUD] = 0;
		}
		else if (breaker[LAWFLAG_THEFT])
		{
			if (g.crimes_suspected[LAWFLAG_THEFT] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_THEFT], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice061, gamelog);
			breaker[LAWFLAG_THEFT] = 0;
		}
		else if (breaker[LAWFLAG_PROSTITUTION])
		{
			if (g.crimes_suspected[LAWFLAG_PROSTITUTION] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_PROSTITUTION], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice062, gamelog);
			breaker[LAWFLAG_PROSTITUTION] = 0;
		}
		else if (breaker[LAWFLAG_HIREILLEGAL])
		{
			if (g.crimes_suspected[LAWFLAG_HIREILLEGAL] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_HIREILLEGAL], gamelog);
				addstrAlt(counts_of, gamelog);
				addstrAlt((lawList[LAW_IMMIGRATION] < 1 ? CONST_justice063 : CONST_justiceB173), gamelog);
			}
			else addstrAlt((lawList[LAW_IMMIGRATION] < 1 ? CONST_justice064 : CONST_justiceB174), gamelog);
			breaker[LAWFLAG_HIREILLEGAL] = 0;
			x = 2;
		}
		/*else if(breaker[LAWFLAG_GUNUSE])
		{
		if(g.crimes_suspected[LAWFLAG_GUNUSE]>1)
		{
		addstrAlt(g.crimes_suspected[LAWFLAG_GUNUSE]);
		addstrAlt(counts_of);
		}
		addstrAlt(CONST_justice065);
		breaker[LAWFLAG_GUNUSE]=0;
		x=2;
		}
		else if(breaker[LAWFLAG_GUNCARRY])
		{
		if(g.crimes_suspected[LAWFLAG_GUNCARRY]>1)
		{
		addstrAlt(g.crimes_suspected[LAWFLAG_GUNCARRY]);
		addstrAlt(counts_of);
		}
		addstrAlt(CONST_justice066);
		breaker[LAWFLAG_GUNCARRY]=0;
		x=2;
		}*/
		else if (breaker[LAWFLAG_COMMERCE])
		{
			if (g.crimes_suspected[LAWFLAG_COMMERCE] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_COMMERCE], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice067, gamelog);
			breaker[LAWFLAG_COMMERCE] = 0;
			x = 2;
		}
		else if (breaker[LAWFLAG_INFORMATION])
		{
			if (g.crimes_suspected[LAWFLAG_INFORMATION] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_INFORMATION], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice068, gamelog);
			breaker[LAWFLAG_INFORMATION] = 0;
			x = 2;
		}
		else if (breaker[LAWFLAG_BURIAL])
		{
			if (g.crimes_suspected[LAWFLAG_BURIAL] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_BURIAL], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice069, gamelog);
			breaker[LAWFLAG_BURIAL] = 0;
		}
		else if (breaker[LAWFLAG_BREAKING])
		{
			if (g.crimes_suspected[LAWFLAG_BREAKING] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_BREAKING], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice070, gamelog);
			breaker[LAWFLAG_BREAKING] = 0;
		}
		else if (breaker[LAWFLAG_VANDALISM])
		{
			if (g.crimes_suspected[LAWFLAG_VANDALISM] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_VANDALISM], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice071, gamelog);
			breaker[LAWFLAG_VANDALISM] = 0;
		}
		else if (breaker[LAWFLAG_RESIST])
		{
			addstrAlt(CONST_justice072, gamelog);
			breaker[LAWFLAG_RESIST] = 0;
		}
		else if (breaker[LAWFLAG_DISTURBANCE])
		{
			if (g.crimes_suspected[LAWFLAG_DISTURBANCE] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_DISTURBANCE], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice073, gamelog);
			breaker[LAWFLAG_DISTURBANCE] = 0;
		}
		else if (breaker[LAWFLAG_PUBLICNUDITY])
		{
			if (g.crimes_suspected[LAWFLAG_PUBLICNUDITY] > 1)
			{
				addstrAlt(g.crimes_suspected[LAWFLAG_PUBLICNUDITY], gamelog);
				addstrAlt(counts_of, gamelog);
			}
			addstrAlt(CONST_justice074, gamelog);
			breaker[LAWFLAG_PUBLICNUDITY] = 0;
		}
		else if (breaker[LAWFLAG_LOITERING])
		{
			addstrAlt(CONST_justice075, gamelog);
			breaker[LAWFLAG_LOITERING] = 0;
		}
		if (typenum > 1) addstrAlt(commaSpace, gamelog);
		if (typenum == 1) addstrAlt(AND, gamelog);
		if (typenum == 0) addstrAlt(singleDot, gamelog);
		pressAnyKey();
	}
	return y;

}
void pleadInnocent(Creature &g, Creature &sleeperLawyer, const char attorneyname[200], const int defense, const bool sleeperjudge, const int scarefactor) {

	// Show die rolls, 100% accurate poll numbers
	extern bool SHOWMECHANICS;
	extern Log gamelog;
	Creature *sleeperlawyer = &sleeperLawyer;
	int prosecution = 0;
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(1, 1, g.name, gamelog);
	addstrAlt(CONST_justice090);
	//TRIAL MESSAGE
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(3, 1, CONST_justice091, gamelog);
	gamelog.newline();
	pressAnyKey();
	//JURY MAKEUP MESSAGE
	set_color_easy(WHITE_ON_BLACK);
	moveAlt(5, 1);
	int jury = LCSrandom(61) - (60 * publicmood(-1)) / 100; // Political leanings of the population determine your jury
	if (sleeperjudge) jury -= 20;
	if (defense == 3) // Hired $5000 ace attorney
	{
		if (LCSrandom(10))
		{
			addstrAlt(attorneyname, gamelog);
			addstrAlt(CONST_justice092, gamelog);
			addstrAlt(g.name, gamelog);
			addstrAlt(CONST_justice093, gamelog);
			gamelog.newline();
			if (jury > 0) jury = 0;
			jury -= 30;
		}
		else
		{
			set_color_easy(RED_ON_BLACK_BRIGHT);
			addstrAlt(attorneyname, gamelog);
			addstrAlt(CONST_justice094, gamelog);
			gamelog.newline();
			jury = 0;
			prosecution += 100; // DUN DUN DUN!!
		}
	}
	else if (jury <= -29)
	{
		set_color_easy(GREEN_ON_BLACK_BRIGHT);
		switch (LCSrandom(liberal_jury.size() + 1))
		{
		case 0:addstrAlt(g.name); addstrAlt(CONST_justice095, gamelog); break;
		default:addstrAlt(pickrandom(liberal_jury), gamelog); break;
		}
		gamelog.newline();
	}
	else if (jury <= -15) addstrAlt(CONST_justice096, gamelog);
	else if (jury < 15) addstrAlt(CONST_justice097, gamelog);
	else if (jury < 29) addstrAlt(CONST_justice098, gamelog);
	else
	{
		set_color_easy(YELLOW_ON_BLACK_BRIGHT);
		addstrAlt(pickrandom(conservative_jury), gamelog);
	}
	gamelog.newline();
	// Debug jury bias
	if (SHOWMECHANICS)
	{
		addstrAlt(CONST_justice127);
		if (jury >= 0) addcharAlt('+');
		addstrAlt(jury);
		addstrAlt(CONST_justice108);
	}
	pressAnyKey();
	//PROSECUTION MESSAGE
	// *JDS* The bigger your record, the stronger the evidence
	prosecution += 40 + LCSrandom(101) + scarefactor + (20 * g.confessions);
	if (sleeperjudge) prosecution >>= 1;
	if (defense == 3) prosecution -= 60;
	set_color_easy(WHITE_ON_BLACK);
	moveAlt(7, 1);

	{
		if (prosecution <= 50) addstrAlt(CONST_justice101, gamelog);
		else if (prosecution <= 75) addstrAlt(CONST_justice102, gamelog);
		else if (prosecution <= 125) addstrAlt(CONST_justice103, gamelog);
		else if (prosecution <= 175) addstrAlt(CONST_justice104, gamelog);
		else addstrAlt(CONST_justice105, gamelog);
		gamelog.newline();
	}
	// Debug prosecution power
	if (SHOWMECHANICS)
	{
		addstrAlt(CONST_justice106);
		addstrAlt(prosecution / 2);
		addstrAlt(CONST_justice107);
		addstrAlt(prosecution);
		addstrAlt(CONST_justice108);
	}
	pressAnyKey();
	jury += LCSrandom(prosecution / 2 + 1) + prosecution / 2;
	//DEFENSE MESSAGE
	set_color_easy(WHITE_ON_BLACK);
	moveAlt(9, 1);
	int defensepower = 0;
	if (defense == 0 || defense == 3 || defense == 4)
	{

		{
			if (defense == 0) defensepower = LCSrandom(71);    // Court-appointed attorney
			else if (defense == 3) defensepower = LCSrandom(71) + 80; // Ace Liberal attorney
			else if (defense == 4)
			{
				// Sleeper attorney
				defensepower = LCSrandom(71) + sleeperlawyer->get_skill(SKILL_LAW) * 2
					+ sleeperlawyer->get_skill(SKILL_PERSUASION) * 2;
				sleeperlawyer->train(SKILL_LAW, prosecution / 4);
				sleeperlawyer->train(SKILL_PERSUASION, prosecution / 4);
			}
			if (defensepower <= 5) addstrAlt(CONST_justice109, gamelog);
			else if (defensepower <= 15) addstrAlt(CONST_justice110, gamelog);
			else if (defensepower <= 25) addstrAlt(CONST_justice111, gamelog);
			else if (defensepower <= 50) addstrAlt(CONST_justice112, gamelog);
			else if (defensepower <= 75) addstrAlt(CONST_justice113, gamelog);
			else if (defensepower <= 100) addstrAlt(CONST_justice114, gamelog);
			else if (defensepower <= 145)
			{
				if (prosecution < 100) addstrAlt(CONST_justice115, gamelog);
				else addstrAlt(CONST_justice116, gamelog);
			}
			else
			{
				if (prosecution < 100)
				{
					addstrAlt(attorneyname, gamelog);
					addstrAlt(CONST_justice117, gamelog);
					mvaddstrAlt(10, 1, CONST_justice118, gamelog);
					if (defense == 4) addjuice(*sleeperlawyer, 10, 500); // Bow please
				}
				else
				{
					addstrAlt(attorneyname, gamelog);
					addstrAlt(CONST_justice119, gamelog);
				}
			}
			gamelog.newline();
		}
	}
	if (defense == 1)
	{
		// *JDS* LEGAL SELF-REPRESENTATION: To succeed here, you really need to have two skills be
		// high: persuasion and law, with law being 1.5 times as influential. You can't have
		// just one or just the other. Even if you're a very persuasive person, the court will eat
		// you alive if you can't sound intelligent when talking about the relevant charges, and you
		// won't be able to fool the jury into letting you go if you aren't persuasive, as no
		// matter how encyclopedic your legal knowledge is, it's all in the pitch.
		//
		// If either your persuasion or your law roll is too low, you'll end up getting a negative
		// result that will drag down your defense. So try not to suck in either area.
		defensepower = 5 * (g.skill_roll(SKILL_PERSUASION) - 3) +
			10 * (g.skill_roll(SKILL_LAW) - 3);
		g.train(SKILL_PERSUASION, 50);
		g.train(SKILL_LAW, 50);
		addstrAlt(g.name, gamelog);
		if (defensepower <= 0)
		{
			addstrAlt(CONST_justice120, gamelog);
			gamelog.newline();
			addjuice(g, -10, -50); // You should be ashamed
		}
		else if (defensepower <= 25) addstrAlt(CONST_justice121, gamelog);
		else if (defensepower <= 50) addstrAlt(CONST_justice122, gamelog);
		else if (defensepower <= 75) addstrAlt(CONST_justice123, gamelog);
		else if (defensepower <= 100) addstrAlt(CONST_justice124, gamelog);
		else if (defensepower <= 150) addstrAlt(CONST_justice125, gamelog);
		else
		{
			addstrAlt(CONST_justice126, gamelog);
			addjuice(g, 50, 1000); // That shit is legend
		}
		gamelog.newline();
	}
	// Debug defense power
	if (SHOWMECHANICS)
	{
		addstrAlt(CONST_justice127);
		addstrAlt(defensepower);
		addstrAlt(CONST_justice128);
		addstrAlt(jury + 1);
		addstrAlt(CONST_justice129);
	}
	pressAnyKey();
	//DELIBERATION MESSAGE
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(12, 1, CONST_justice130, gamelog);
	gamelog.newline();
	pressAnyKey();
	//JURY RETURN MESSAGE
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(1, 1, CONST_justice131, gamelog);
	gamelog.newline();
	pressAnyKey();
	bool keeplawflags = false;
	//HUNG JURY
	if (defensepower == jury)
	{
		set_color_easy(YELLOW_ON_BLACK_BRIGHT);
		mvaddstrAlt(3, 1, CONST_justice132, gamelog);
		gamelog.newline();
		pressAnyKey();
		//RE-TRY
		if (LCSrandom(2) || scarefactor >= 10 || g.confessions)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(5, 1, CONST_justice133, gamelog);
			gamelog.newline();
			pressAnyKey();
			g.location = find_site_index_in_same_city(SITE_GOVERNMENT_COURTHOUSE, g.location);
			keeplawflags = true;
		}
		//NO RE-TRY
		else
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(5, 1, CONST_justice134, gamelog);
			gamelog.newline();
			if (g.sentence == 0)
			{
				set_color_easy(GREEN_ON_BLACK_BRIGHT);
				mvaddstrAlt(7, 1, g.name, gamelog);
				addstrAlt(CONST_justice139, gamelog);
			}
			else
			{
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(7, 1, g.name, gamelog);
				addstrAlt(CONST_justice140, gamelog);
				if (!g.deathpenalty && g.sentence > 1 && (LCSrandom(2) || sleeperjudge))
				{
					g.sentence--;
					addstrAlt(CONST_justice141, gamelog);
				}
				else addstrAlt(singleDot, gamelog);
				if (g.deathpenalty)
				{
					g.sentence = 3;
					mvaddstrAlt(9, 1, execution_in_three_months, gamelog);
				}
			}
			gamelog.nextMessage();
			pressAnyKey();
		}
	}
	//ACQUITTAL!
	else if (defensepower > jury)
	{
		set_color_easy(GREEN_ON_BLACK_BRIGHT);
		mvaddstrAlt(3, 1, CONST_justice138, gamelog);
		gamelog.newline();
		pressAnyKey();
		if (g.sentence == 0)
		{
			set_color_easy(GREEN_ON_BLACK_BRIGHT);
			mvaddstrAlt(5, 1, g.name, gamelog);
			addstrAlt(CONST_justice139, gamelog);
		}
		else
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(5, 1, g.name, gamelog);
			addstrAlt(CONST_justice140, gamelog);
			if (!g.deathpenalty && g.sentence > 1 && (LCSrandom(2) || sleeperjudge))
			{
				g.sentence--;
				addstrAlt(CONST_justice141, gamelog);
			}
			else addstrAlt(singleDot, gamelog);
			if (g.deathpenalty)
			{
				g.sentence = 3;
				mvaddstrAlt(7, 1, execution_in_three_months, gamelog);
			}
		}
		gamelog.nextMessage();
		// Juice sleeper
		if (defense == 4) addjuice(*sleeperlawyer, 10, 100);
		// Juice for self-defense
		if (defense == 1) addjuice(g, 10, 100);
		pressAnyKey();
	}
	//LENIENCE
	else
	{
		// De-Juice sleeper
		if (defense == 4) addjuice(*sleeperlawyer, -5, 0);
		// Juice for getting convicted of something :)
		addjuice(g, 25, 200);
		// Check for lenience; sleeper judge will always be merciful
		if (defensepower / 3 >= jury / 4 || sleeperjudge) penalize(g, 1);
		else penalize(g, 0);
	}
	//CLEAN UP LAW FLAGS
	if (!keeplawflags) for (int i = 0; i < LAWFLAGNUM; i++) g.crimes_suspected[i] = 0;
	//Clean up heat, confessions
	g.heat = 0, g.confessions = 0;
	//PLACE PRISONER
	if (g.sentence != 0) imprison(g);
	else
	{
		Armor clothes(getarmortype(tag_ARMOR_CLOTHES));
		g.give_armor(clothes, NULL);
	}

}
void pleadGuilty(Creature &g, const bool sleeperjudge) {

	extern Log gamelog;

	eraseAlt();
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(1, 1, CONST_justice143, gamelog);
	gamelog.nextMessage();
	pressAnyKey();
	// Check for lenience; sleeper judge will always be merciful
	if (sleeperjudge || LCSrandom(2)) penalize(g, 1);
	else penalize(g, 0);
	//CLEAN UP LAW FLAGS
	for (int i = 0; i < LAWFLAGNUM; i++) g.crimes_suspected[i] = 0;
	//Clean up heat, confessions
	g.heat = 0, g.confessions = 0;
	//PLACE PRISONER
	if (g.sentence != 0) imprison(g);
	else
	{
		Armor clothes(getarmortype(tag_ARMOR_CLOTHES));
		g.give_armor(clothes, NULL);
	}

}
/* monthly - hold trial on a liberal */
void trial(Creature &g)
{
	extern Log gamelog;
	extern MusicClass music;
	extern class Ledger ledger;
	extern unsigned long attorneyseed[RNG_SIZE];
	extern unsigned long seed[RNG_SIZE];
	music.play(MUSIC_TRIAL);
	// If their old base is no longer under LCS control, wander back to the
	// homeless shelter instead.
	if (LocationsPool::getInstance().getRentingType(g.base) < 0) g.base = find_site_index_in_same_city(SITE_RESIDENTIAL_SHELTER, g.location);
	g.location = g.base;
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(1, 1, g.name, gamelog);
	addstrAlt(CONST_justice090, gamelog);
	gamelog.newline();
	pressAnyKey();
	set_color_easy(WHITE_ON_BLACK);
	if (!iscriminal(g)) criminalize(g, LAWFLAG_LOITERING);
	int scarefactor = 0;
	for (int i = 0; i < LAWFLAGNUM; i++) if (g.crimes_suspected[i])
	{
		scarefactor += scare_factor(i, g.crimes_suspected[i]);
	}
	//CHECK FOR SLEEPERS
	Creature *sleeperjudge = getSleeperJudge(g);
	Creature *sleeperlawyer = getSleeperLawyer(g);

	//STATE CHARGES
	set_color_easy(WHITE_ON_BLACK);
	if (sleeperjudge)
	{
		mvaddstrAlt(3, 1, string_sleeper, gamelog);
		addstrAlt(sleeperjudge->name, gamelog);
		addstrAlt(CONST_justice037, gamelog);
		g.confessions = 0; //Made sleeper judge prevent these lunatics from testifying
	}
	else mvaddstrAlt(3, 1, CONST_justice038, gamelog);
	gamelog.newline();
	set_color_easy(RED_ON_BLACK_BRIGHT);
	mvaddstrAlt(5, 1, CONST_justice039, gamelog);
	addstrAlt(g.propername, gamelog);
	addstrAlt(CONST_justice040, gamelog);
	int y = listAllCrimes(g);
	gamelog.newline();
	if (g.confessions)
	{
		if (g.confessions > 1)
		{
			mvaddstrAlt(y += 2, 1, g.confessions, gamelog);
			addstrAlt(CONST_justice076, gamelog);
		}
		else mvaddstrAlt(y += 2, 1, CONST_justice077, gamelog);
		addstrAlt(g.name, gamelog);
		addstrAlt(singleDot, gamelog);
		gamelog.newline();
		pressAnyKey();
	}
	//CHOOSE DEFENSE
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(y + 2, 1, CONST_justice078);
	char attorneyname[200];
	unsigned long oldseed[RNG_SIZE];
	copyRNG(oldseed, seed);
	copyRNG(seed, attorneyseed);
	generate_name(attorneyname);
	copyRNG(seed, oldseed);
	y += 4;
	mvaddstrAlt(y++, 1, CONST_justice079);
	mvaddstrAlt(y++, 1, CONST_justice080);
	mvaddstrAlt(y++, 1, CONST_justice081);
	if (ledger.get_funds() < 5000) set_color_easy(BLACK_ON_BLACK_BRIGHT);
	mvaddstrAlt(y++, 1, CONST_justice082);
	addstrAlt(attorneyname);
	addstrAlt(singleDot);
	if (sleeperlawyer)
	{
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(y++, 1, CONST_justice083);
		addstrAlt(sleeperlawyer->name);
		addstrAlt(CONST_justice084);
	}
	if (ledger.get_funds() < 5000) set_color_easy(WHITE_ON_BLACK);
	//SAV - added in display of skills and relevant attributes to help
	// decide when to defend self.
	mvaddstrAlt(++y, 5, CONST_justice085);
	addstrAlt(g.get_attribute(ATTRIBUTE_HEART, true));
	mvaddstrAlt(y, 25, CONST_justice086);
	addstrAlt(g.get_skill(SKILL_PERSUASION));
	mvaddstrAlt(++y, 5, CONST_justice087);
	addstrAlt(g.get_attribute(ATTRIBUTE_CHARISMA, true));
	mvaddstrAlt(y++, 25, CONST_justice088);
	addstrAlt(g.get_skill(SKILL_LAW));
	mvaddstrAlt(y++, 5, CONST_justice089);
	addstrAlt(g.get_attribute(ATTRIBUTE_INTELLIGENCE, true));
	// End SAV's adds
	short defense = -1;
	while (defense == -1) {
		int c = pressSpecificKey('a', 'b', 'c', 'd', 'e');

		if (c == 'a') { defense = 0; }
		else
			if (c == 'b') { defense = 1; }
			else
				if (c == 'c') { defense = 2; }
				else
					if (c == 'd'&&ledger.get_funds() >= 5000)
					{
						ledger.subtract_funds(5000, EXPENSE_LEGAL);
						defense = 3;

					}
					else
						if (c == 'e'&&sleeperlawyer)
						{
							defense = 4;
							strcpy(attorneyname, sleeperlawyer->name);

						}
	}
	//TRIAL
	if (defense != 2) { pleadInnocent(g, *sleeperlawyer, attorneyname, defense, sleeperjudge, scarefactor); }
	//GUILTY PLEA
	// How about CONST_justice142 (Nolo contendere) -- LK
	// I would imagine this would disregard the strength of the defense. -- LK
	else { pleadGuilty(g, sleeperjudge); }
}
void reeducation(Creature &g)
{
	extern Log gamelog;
	extern vector<Creature *> pool;
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(8, 1, g.name, gamelog);
	addstrAlt(pickrandom(reeducation_experiences), gamelog);
	gamelog.newline();
	pressAnyKey();
	moveAlt(10, 1);
	if (!g.attribute_check(ATTRIBUTE_HEART, DIFFICULTY_FORMIDABLE))
	{
		if (g.juice > 0 && LCSrandom(2))
		{
			addstrAlt(g.name, gamelog);
			addstrAlt(CONST_justice144, gamelog);
			addjuice(g, -50, 0);
		}
		else if (LCSrandom(15) > g.get_attribute(ATTRIBUTE_WISDOM, true)
			|| g.get_attribute(ATTRIBUTE_WISDOM, true) < g.get_attribute(ATTRIBUTE_HEART, true))
		{
			addstrAlt(g.name, gamelog);
			addstrAlt(CONST_justice145, gamelog);
			g.adjust_attribute(ATTRIBUTE_WISDOM, +1);
		}
		else if (g.align == ALIGN_LIBERAL && g.flag & CREATUREFLAG_LOVESLAVE && LCSrandom(4))
		{
			addstrAlt(g.name, gamelog);
			addstrAlt(CONST_justice146, gamelog);
			addstrAlt(pool[g.hireid]->name, gamelog);
			addstrAlt(singleDot, gamelog);
		}
		else
		{
			addstrAlt(g.name, gamelog);
			addstrAlt(CONST_justice147, gamelog);
			//Rat out contact
			int contact = getpoolcreature(g.hireid);
			if (contact >= 0)
			{
				criminalize(*pool[contact], LAWFLAG_RACKETEERING);
				pool[contact]->confessions++;
			}
			g.die();
			g.location = -1;
		}
	}
	else
	{
		addstrAlt(g.name, gamelog);
		addstrAlt(CONST_justice148, gamelog);
	}
	gamelog.nextMessage();
	pressAnyKey();
	eraseAlt();
	return;
}
void laborcamp(Creature &g)
{
	extern Log gamelog;
	int escaped = 0;
	const char *experience;
	// Escape attempt!
	if (g.hireid == -1 && !LCSrandom(3))
	{
		escaped = 2;
		experience = CONST_justice149.c_str();
	}
	else if (g.skill_check(SKILL_DISGUISE, DIFFICULTY_HEROIC) && !LCSrandom(10))
	{
		escaped = 1;
		experience = CONST_justice150.c_str();
		g.give_armor(getarmortype(tag_ARMOR_WORKCLOTHES), NULL);
	}
	else if (g.skill_check(SKILL_SECURITY, DIFFICULTY_CHALLENGING) && g.skill_check(SKILL_STEALTH, DIFFICULTY_HARD) && !LCSrandom(10))
	{
		escaped = 1;
		experience = CONST_justice151.c_str();
	}
	else if (g.skill_check(SKILL_SCIENCE, DIFFICULTY_HARD) && !LCSrandom(10))
	{
		escaped = 1;
		experience = CONST_justice152.c_str();
	}
	if (!escaped)experience = (singleSpace + pickrandom(labor_camp_experiences)).data();
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(8, 1, g.name, gamelog);
	addstrAlt(experience, gamelog);
	gamelog.newline();
	pressAnyKey();
	moveAlt(10, 1);
	if (escaped)
	{
		int prison = g.location;
		addstrAlt(g.name, gamelog);
		addstrAlt(CONST_justice164, gamelog);
		addjuice(g, 50, 1000);
		criminalize(g, LAWFLAG_ESCAPED);
		g.location = find_site_index_in_same_city(SITE_RESIDENTIAL_SHELTER, g.location);
		if (escaped == 2)
		{
			int num_escaped = otherPrisonersEscapeWithMe(g, prison);
			if (num_escaped == 1)
			{
				gamelog.nextMessage();
				mvaddstrAlt(11, 1, CONST_justice165, gamelog);
			}
			else if (num_escaped > 1)
			{
				gamelog.nextMessage();
				mvaddstrAlt(11, 1, CONST_justice166, gamelog);
			}
		}
	}
	else if (!LCSrandom(4))
	{
		if (g.get_attribute(ATTRIBUTE_HEALTH, true) > 1)
		{
			addstrAlt(g.name, gamelog);
			addstrAlt(CONST_justice156, gamelog);
			addjuice(g, -40, 0);
			addjuice(g, -10, -50);
		}
		else
		{
			addstrAlt(g.name, gamelog);
			addstrAlt(CONST_justice157, gamelog);
			g.die();
			g.location = -1;
		}
	}
	else
	{
		addstrAlt(g.name, gamelog);
		addstrAlt(CONST_justice158, gamelog);
	}
	gamelog.nextMessage();
	pressAnyKey();
	eraseAlt();
	return;
}
void prisonscene(Creature &g)
{
	extern Log gamelog;
	extern vector<Creature *> pool;
	int escaped = 0;
	int effect = 0;
	const char *experience;
	if (g.juice + int(g.hireid == -1) * 300 > 500)
	{
		// Escape attempt!
		if (g.hireid == -1 && !LCSrandom(10))
		{
			escaped = 2;
			experience = CONST_justice159.c_str();
		}
		else if (g.skill_check(SKILL_COMPUTERS, DIFFICULTY_HARD) && !LCSrandom(5))
		{
			escaped = 2;
			experience = CONST_justice160.c_str();
		}
		else if (g.skill_check(SKILL_DISGUISE, DIFFICULTY_HARD) && !LCSrandom(5))
		{
			escaped = 1;
			experience = CONST_justice161.c_str();
			g.give_armor(getarmortype(tag_ARMOR_CLOTHES), NULL);
		}
		else if (g.skill_check(SKILL_SECURITY, DIFFICULTY_CHALLENGING) && g.skill_check(SKILL_STEALTH, DIFFICULTY_CHALLENGING) && !LCSrandom(5))
		{
			escaped = 1;
			experience = CONST_justice162.c_str();
		}
		else if (g.skill_check(SKILL_SCIENCE, DIFFICULTY_AVERAGE) && g.skill_check(SKILL_HANDTOHAND, DIFFICULTY_EASY) && !LCSrandom(5))
		{
			escaped = 1;
			experience = CONST_justice163.c_str();
		}
	}
	if (escaped == 0)
	{
		if (g.attribute_check(ATTRIBUTE_HEART, DIFFICULTY_HARD)) {
			effect = 1;
			if (LCSrandom(2) > 0) experience = (singleSpace + pickrandom(good_experiences)).data();
			else experience = (singleSpace + pickrandom(general_experiences)).data();
		}
		else if (g.attribute_check(ATTRIBUTE_HEART, DIFFICULTY_CHALLENGING)) {
			effect = 0;
			experience = (singleSpace + pickrandom(general_experiences)).data();
		}
		else {
			effect = -1;
			if (LCSrandom(2) > 0) experience = (singleSpace + pickrandom(bad_experiences)).data();
			else experience = (singleSpace + pickrandom(general_experiences)).data();
		}
	}
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(8, 1, g.name, gamelog);
	addstrAlt(experience, gamelog);
	gamelog.newline();
	pressAnyKey();
	moveAlt(10, 1);
	if (escaped)
	{
		int prison = g.location;
		addstrAlt(g.name, gamelog);
		addstrAlt(CONST_justice164, gamelog);
		addjuice(g, 50, 1000);
		criminalize(g, LAWFLAG_ESCAPED);
		g.location = find_site_index_in_same_city(SITE_RESIDENTIAL_SHELTER, g.location);
		if (escaped == 2)
		{
			int num_escaped = 0;
			for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
			{
				if (pool[p]->location == prison && !(pool[p]->flag & CREATUREFLAG_SLEEPER))
				{
					criminalize(*pool[p], LAWFLAG_ESCAPED);
					pool[p]->location = g.location;
					num_escaped++;
				}
			}
			if (num_escaped == 1)
			{
				gamelog.nextMessage();
				mvaddstrAlt(11, 1, CONST_justice165, gamelog);
			}
			else if (num_escaped > 1)
			{
				gamelog.nextMessage();
				mvaddstrAlt(11, 1, CONST_justice166, gamelog);
			}
		}
	}
	else if (effect > 0)
	{
		addstrAlt(g.name, gamelog);
		addstrAlt(CONST_justice167, gamelog);
		addjuice(g, 20, 1000);
	}
	else if (effect < 0)
	{
		addstrAlt(g.name, gamelog);
		addstrAlt(CONST_justice168, gamelog);
		addjuice(g, -20, -30);
	}
	else
	{
		addstrAlt(g.name, gamelog);
		addstrAlt(CONST_justice169, gamelog);
	}
	gamelog.nextMessage();
	pressAnyKey();
	eraseAlt();
	return;
}
/* monthly - advances a liberal's prison time or executes them */
//RETURNS IF SCREEN WAS ERASED
char prison(Creature &g)
{
	extern Log gamelog;
	extern int stat_dead;
	extern short lawList[LAWNUM];
	extern vector<Creature *> pool;
	char showed = 0;
	// People not on death row or about to be released can have a scene in prison
	if (!g.deathpenalty && g.sentence != 1)
	{
		if (lawList[LAW_PRISONS] == 2)
		{
			//Liberal therapy.
			if (!LCSrandom(5)) reeducation(g);
		}
		else if (lawList[LAW_PRISONS] == -2)
		{
			//Labor camp.
			if (!LCSrandom(5)) laborcamp(g);
		}
		else
		{
			//Normal prison.
			if (!LCSrandom(5)) prisonscene(g);
		}
	}
	if (g.sentence > 0)
	{
		//COMMUTE DEATH IN RIGHT CLIMATE
		if (g.deathpenalty&&lawList[LAW_DEATHPENALTY] == 2)
		{
			eraseAlt();
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(8, 1, g.name, gamelog);
			addstrAlt(CONST_justice170, gamelog);
			mvaddstrAlt(9, 1, CONST_justice171, gamelog);
			gamelog.nextMessage();
			pressAnyKey();
			g.sentence = -1;
			g.deathpenalty = 0;
			return 1;
		}
		//ADVANCE SENTENCE
		g.sentence--;
		if (g.sentence == 0)
		{
			//EXECUTE
			if (g.deathpenalty)
			{
				eraseAlt();
				set_color_easy(RED_ON_BLACK_BRIGHT);
				mvaddstrAlt(8, 1, CONST_justice172, gamelog);
				gamelog.newline();
				mvaddstrAlt(9, 1, CONST_justice173, gamelog);
				addstrAlt(g.name, gamelog);
				gamelog.record(singleSpace); //Log this for formatting purposes.
				mvaddstrAlt(10, 1, CONST_justice174, gamelog);
				if (lawList[LAW_DEATHPENALTY] == -2)
					addstrAlt(pickrandom(cruel_and_unusual_execution_methods), gamelog);
				else if (lawList[LAW_DEATHPENALTY] == -1 || lawList[LAW_DEATHPENALTY] == 0)
					addstrAlt(pickrandom(standard_execution_methods), gamelog);
				else
					addstrAlt(pickrandom(supposedly_painless_execution_method), gamelog);
				addstrAlt(singleDot, gamelog);
				pressAnyKey();
				//dejuice boss
				int boss = getpoolcreature(g.hireid);
				if (boss != -1)
				{
					gamelog.newline();
					set_color_easy(WHITE_ON_BLACK);
					mvaddstrAlt(12, 1, pool[boss]->name, gamelog);
					addstrAlt(CONST_justice175, gamelog);
					gamelog.newline();
					mvaddstrAlt(14, 1, CONST_justice176, gamelog);
					pressAnyKey();
					addjuice(*pool[boss], -50, -50);
				}
				gamelog.nextMessage();
				g.die();
				stat_dead++;
				showed = 1;
			}
			//SET FREE
			else
			{
				eraseAlt();
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(8, 1, g.name, gamelog);
				addstrAlt(CONST_justice177, gamelog);
				gamelog.newline();
				mvaddstrAlt(9, 1, CONST_justice178, gamelog);
				gamelog.nextMessage();
				pressAnyKey();
				Armor clothes(getarmortype(tag_ARMOR_CLOTHES));
				g.give_armor(clothes, NULL);
				// If their old base is no longer under LCS control, wander back to the
				// homeless shelter instead.
				if (LocationsPool::getInstance().getRentingType(g.base) < 0) g.base = find_site_index_in_same_city(SITE_RESIDENTIAL_SHELTER, g.location);
				g.location = g.base;
				showed = 1;
			}
		}
		//NOTIFY OF IMPENDING THINGS
		else if (g.sentence == 1)
		{
			if (g.deathpenalty)
			{
				eraseAlt();
				set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				mvaddstrAlt(8, 1, g.name, gamelog);
				addstrAlt(CONST_justice179, gamelog);
				gamelog.nextMessage();
				pressAnyKey();
				showed = 1;
			}
			else
			{
				eraseAlt();
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(8, 1, g.name, gamelog);
				addstrAlt(CONST_justice180, gamelog);
				gamelog.nextMessage();
				pressAnyKey();
				showed = 1;
			}
		}
		else
		{
			if (g.deathpenalty)
			{
				eraseAlt();
				set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				mvaddstrAlt(8, 1, g.name, gamelog);
				addstrAlt(CONST_justice181, gamelog);
				addstrAlt(g.sentence, gamelog);
				addstrAlt(CONST_justice182, gamelog);
				gamelog.nextMessage();
				pressAnyKey();
				showed = 1;
			}
		}
	}
	return showed;
}

// #include "../includes.h"
const string CONST_lcsmonthly140 = "Press any key to reflect on the report.";
const string CONST_lcsmonthly139 = "Press Enter to reflect on the report.  ";
const string CONST_lcsmonthly138 = "$";
const string CONST_lcsmonthly137 = "Total Liquid Assets:";
const string CONST_lcsmonthly135 = "Miscellaneous Loot";
const string CONST_lcsmonthly133 = "Ammunition";
const string CONST_lcsmonthly131 = "Clothing and Armor";
const string CONST_lcsmonthly129 = "Tools and Weapons";
const string CONST_lcsmonthly127 = "Cash";
const string CONST_lcsmonthly126 = " ($0)";
const string CONST_lcsmonthly125 = " (-$";
const string CONST_lcsmonthly124 = " (+$";
const string CONST_lcsmonthly122 = "-";
const string CONST_lcsmonthly121 = "+";
const string CONST_lcsmonthly120 = "Net Change This Month (Day):";
const string CONST_lcsmonthly117 = "-$";
const string CONST_lcsmonthly114 = "+$";
const string CONST_lcsmonthly113 = "Liberal Crime Squad: Funding Report";
const string CONST_lcsmonthly111 = "This is bound to get the Conservative masses a little riled up.";
const string CONST_lcsmonthly110 = "planning to drum up a false scandal about a Liberal figure.";
const string CONST_lcsmonthly109 = "saying 'it's okay to lie, they don't need the truth'.";
const string CONST_lcsmonthly108 = "calling listeners 'sheep to be told what to think'.";
const string CONST_lcsmonthly107 = "The Liberal Guardian runs a story featuring AM radio plans ";
const string CONST_lcsmonthly105 = "instructing a female anchor to 'get sexier or get a new job'.";
const string CONST_lcsmonthly103 = "mandating negative coverage of Liberal politicians.";
const string CONST_lcsmonthly102 = "calling their news 'the vanguard of Conservative thought'.";
const string CONST_lcsmonthly101 = "The Liberal Guardian runs a story featuring cable news memos ";
const string CONST_lcsmonthly100 = "documenting gladiatorial matches held between prisoners by guards.";
const string CONST_lcsmonthly099 = "documenting widespread corruption among prison employees.";
const string CONST_lcsmonthly098 = "documenting a prison torture case.";
const string CONST_lcsmonthly097 = "documenting human rights abuses by prison guards.";
const string CONST_lcsmonthly096 = "The Liberal Guardian runs a story featuring prison documents ";
const string CONST_lcsmonthly095 = "showing human test subjects dying under genetic research.";
const string CONST_lcsmonthly094 = "covering up the accidental creation of a genetic monster.";
const string CONST_lcsmonthly093 = "studying the effects of torture on cats.";
const string CONST_lcsmonthly092 = "documenting horrific animal rights abuses.";
const string CONST_lcsmonthly091 = "The Liberal Guardian runs a story featuring research papers ";
const string CONST_lcsmonthly090 = "promising Conservative rulings in exchange for appointments.";
const string CONST_lcsmonthly089 = "taking bribes to acquit murderers.";
const string CONST_lcsmonthly088 = "The Liberal Guardian runs a story with evidence of a Conservative judge ";
const string CONST_lcsmonthly086 = "documenting widespread corruption in the force.";
const string CONST_lcsmonthly085 = "documenting a forced confession.";
const string CONST_lcsmonthly084 = "documenting a systematic invasion of privacy by the force.";
const string CONST_lcsmonthly083 = "documenting a police torture case.";
const string CONST_lcsmonthly082 = "documenting human rights abuses by the force.";
const string CONST_lcsmonthly081 = "The Liberal Guardian runs a story featuring police records ";
const string CONST_lcsmonthly080 = "This is bound to get the Government a little riled up.";
const string CONST_lcsmonthly079 = "documenting the infiltration of a pro-choice group.";
const string CONST_lcsmonthly078 = "used to keep tabs on gay citizens.";
const string CONST_lcsmonthly077 = "documenting \"harmful speech\" made by innocent citizens.";
const string CONST_lcsmonthly076 = "containing private information on innocent citizens.";
const string CONST_lcsmonthly075 = "documenting the planned assassination of a Liberal federal judge.";
const string CONST_lcsmonthly074 = "documenting the overthrow of a government.";
const string CONST_lcsmonthly073 = "The Liberal Guardian runs a story featuring CIA and other intelligence files ";
const string CONST_lcsmonthly072 = "This is the beginning of the end for the Conservative Crime Squad.";
const string CONST_lcsmonthly071 = "News denounce the CCS.";
const string CONST_lcsmonthly070 = "toward the revelations, and the speed with which even AM Radio and Cable";
const string CONST_lcsmonthly069 = "for months. One thing is clear, however, from the immediate public reaction";
const string CONST_lcsmonthly068 = "country, and the full ramifications of this revelation may not be felt";
const string CONST_lcsmonthly067 = "The scandal reaches into the heart of the Conservative leadership in the";
const string CONST_lcsmonthly066 = "against.";
const string CONST_lcsmonthly065 = "as a foil when no other enemies were present to direct public energy";
const string CONST_lcsmonthly064 = "above prosecution, and could hunt down law-abiding Liberals and act";
const string CONST_lcsmonthly063 = "extensive planning to create an extra-judicial death squad that would be";
const string CONST_lcsmonthly062 = "in the state and federal governments. Sections precisely document the";
const string CONST_lcsmonthly061 = "responsibilities of Conservative Crime Squad sympathizers and supporters";
const string CONST_lcsmonthly060 = "the CCS organization, also revealing in extreme detail the names and ";
const string CONST_lcsmonthly059 = "The Liberal Guardian runs more than one thousand pages of documents about ";
const string CONST_lcsmonthly058 = "describing an intricate tax scheme.";
const string CONST_lcsmonthly057 = "cheerfully describing foreign corporate sweatshops.";
const string CONST_lcsmonthly056 = "containing a memo: \"Terminate the pregnancy, I terminate you.\"";
const string CONST_lcsmonthly055 = "with a list of gay employees entitled \"Homo-workers\".";
const string CONST_lcsmonthly054 = "describing a genetic monster created in a lab.";
const string CONST_lcsmonthly053 = "The Liberal Guardian runs a story featuring Corporate files ";
const string CONST_lcsmonthly052 = "showing that he has engaged in consistent tax evasion.";
const string CONST_lcsmonthly051 = "The Liberal Guardian runs a story featuring a major CEO's tax papers ";
const string CONST_lcsmonthly050 = "promising someone company profits in exchange for sexual favors.";
const string CONST_lcsmonthly049 = "that seem to touch on every fetish known to man.";
const string CONST_lcsmonthly048 = "to the FDA official overseeing the CEO's products.";
const string CONST_lcsmonthly047 = "implying that he has enslaved his houseservants.";
const string CONST_lcsmonthly046 = "to himself.  They're very steamy.";
const string CONST_lcsmonthly045 = "to an illicit gay lover.";
const string CONST_lcsmonthly044 = "to the judge that acquit him in a corruption trial.";
const string CONST_lcsmonthly043 = "addressed to his pet dog.  Yikes.";
const string CONST_lcsmonthly042 = "The Liberal Guardian runs a story featuring love letters from a major CEO ";
const string CONST_lcsmonthly041 = "playing with feces and urine.";
const string CONST_lcsmonthly040 = "torturing an employee with a hot iron.";
const string CONST_lcsmonthly039 = "waving a Nazi flag at a supremacist rally.";
const string CONST_lcsmonthly038 = "castrating himself.";
const string CONST_lcsmonthly037 = "making out with an FDA official overseeing the CEO's products.";
const string CONST_lcsmonthly036 = "tongue-kissing an infamous dictator.";
const string CONST_lcsmonthly035 = "engaging in heavy bondage.  A cucumber was involved in some way.";
const string CONST_lcsmonthly034 = "participating in a murder.";
const string CONST_lcsmonthly033 = "digging up graves and sleeping with the dead.";
const string CONST_lcsmonthly032 = "engaging in lewd behavior with animals.";
const string CONST_lcsmonthly031 = "The Liberal Guardian runs a story featuring photos of a major CEO ";
const string CONST_lcsmonthly030 = "Enter - Not in this month's Liberal Guardian";
const string CONST_lcsmonthly029 = "Do you want to run a special edition?";
const string CONST_lcsmonthly028 = "Liberal Guardian.";
const string CONST_lcsmonthly027 = "The response is electric. Everyone is talking about this month's ";
const string CONST_lcsmonthly026 = "The response is very strong. People are changing their minds.";
const string CONST_lcsmonthly025 = "Many people are reading it.";
const string CONST_lcsmonthly024 = "A fair number of people are reading it.";
const string CONST_lcsmonthly023 = "Very few people seem to be interested.";
const string CONST_lcsmonthly022 = "Unfortunately, nobody seems interested.";
const string CONST_lcsmonthly021 = "The only readers are Conservatives, who seem to think it's funny.";
const string CONST_lcsmonthly020 = " is published.";
const string CONST_lcsmonthly019 = "The monthly Liberal Guardian online newsletter";
const string CONST_lcsmonthly018 = "The monthly Liberal Guardian newspaper";

const string tag_LOOT_PRISONFILES = "LOOT_PRISONFILES";
const string tag_LOOT_INTHQDISK = "LOOT_INTHQDISK";
const string tag_LOOT_CCS_BACKERLIST = "LOOT_CCS_BACKERLIST";
const string tag_LOOT_CEOTAXPAPERS = "LOOT_CEOTAXPAPERS";
const string tag_LOOT_CEOLOVELETTERS = "LOOT_CEOLOVELETTERS";
const string tag_LOOT_CEOPHOTOS = "LOOT_CEOPHOTOS";

#include "../items/lootTypePool.h"
//// #include "../common/equipment.h"
void consolidateloot(vector<Item *> &loot);
//// #include "../common/translateid.h"
int getloottype(const string &idname);
string bound_to_rile_up;
string major_news_take_it_up;
map<short, string> expenseTypes;
map<short, string> incomeTypes;
//TODO: Log the monthly report? --Addictgamer
/* monthly - reports the guardian's power to the player */
void guardianupdate(char size, int power)
{
	extern Log gamelog;
	extern MusicClass music;
	music.play(MUSIC_NEWSPAPER);
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK);
	moveAlt(5, 2);
	if (size)
	{
		addstrAlt(CONST_lcsmonthly018, gamelog);
	}
	else
	{
		addstrAlt(CONST_lcsmonthly019, gamelog);
	}
	addstrAlt(CONST_lcsmonthly020, gamelog);
	gamelog.newline();
	moveAlt(7, 2);
	if (power < 0)
	{
		addstrAlt(CONST_lcsmonthly021, gamelog);
	}
	else if (power == 0)
	{
		addstrAlt(CONST_lcsmonthly022, gamelog);
	}
	else if (power < 5)
	{
		addstrAlt(CONST_lcsmonthly023, gamelog);
	}
	else if (power < 50)
	{
		addstrAlt(CONST_lcsmonthly024, gamelog);
	}
	else if (power < 100)
	{
		addstrAlt(CONST_lcsmonthly025, gamelog);
	}
	else if (power < 250)
	{
		addstrAlt(CONST_lcsmonthly026, gamelog);
	}
	else
	{
		addstrAlt(CONST_lcsmonthly027, gamelog);
		mvaddstrAlt(8, 2, CONST_lcsmonthly028, gamelog);
	}
	gamelog.nextMessage();
	pressAnyKey();
	return;
}
/* monthly - lets the player choose a special edition for the guardian */
int choosespecialedition(char &clearformess)
{
	extern short interface_pgup;
	extern short interface_pgdn;
	extern MusicClass music;
	extern vector<squadst *> squad;
	//Temporary, maybe put special edition definition into an xml file. -XML
	static const string document_types[] =
	{  // This list MUST be in alphabetical order for binary_search() to work right
		tag_LOOT_AMRADIOFILES,
		tag_LOOT_CABLENEWSFILES,
		tag_LOOT_CCS_BACKERLIST,
		tag_LOOT_CEOLOVELETTERS,
		tag_LOOT_CEOPHOTOS,
		tag_LOOT_CEOTAXPAPERS,
		tag_LOOT_CORPFILES,
		tag_LOOT_INTHQDISK,
		tag_LOOT_JUDGEFILES,
		tag_LOOT_POLICERECORDS,
		tag_LOOT_PRISONFILES,
		tag_LOOT_RESEARCHFILES,
		tag_LOOT_SECRETDOCUMENTS
	};
	static const vector<string> dox(document_types, document_types + len(document_types));
	int page = 0;
	//char havetype[LOOTNUM];
	//for(int l=0;l<LOOTNUM;l++)havetype[l]=0;
	vector<bool> havetype(LootTypePool::getInstance().lenpool(), false);
	vector<int> loottypeindex;
	LocationsPool::getInstance().findAllLootTypes(havetype, loottypeindex, dox);
	for (int sq = 0; sq < len(squad); sq++)
	{
		consolidateloot(squad[sq]->loot);
		for (int l = 0; l < len(squad[sq]->loot); l++)
		{
			if (!(squad[sq]->loot[l]->whatIsThis() == THIS_IS_LOOT)) continue;
			if (!binary_search(dox.begin(), dox.end(), squad[sq]->loot[l]->get_itemtypename())) continue;
			if (!havetype[getloottype(squad[sq]->loot[l]->get_itemtypename())])
			{
				loottypeindex.push_back(getloottype(squad[sq]->loot[l]->get_itemtypename()));
				havetype[getloottype(squad[sq]->loot[l]->get_itemtypename())] = true;
			}
		}
	}
	if (!len(loottypeindex)) return -1;
	clearformess = 1;
	//PICK ONE
	while (true)
	{
		music.play(MUSIC_NEWSPAPER);
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(0, 0, CONST_lcsmonthly029);
		int x = 1, y = 10;
		char str[200];
		for (int l = page * 18; l < len(loottypeindex) && l < page * 18 + 18; l++)
		{
			str[0] = l - page * 18 + 'A';
			str[1] = '\x0';
			strcat(str, spaceDashSpace.c_str());
			strcat(str, LootTypePool::getInstance().getIdName(loottypeindex[l]).c_str());
			mvaddstrAlt(y, x, str);
			x += 26;
			if (x > 53) x = 1, y++;
		}
		//PAGE UP
		if (page > 0)
		{
			mvaddstrAlt(17, 1, addprevpagestr());
		}
		//PAGE DOWN
		if ((page + 1) * 18 < LootTypePool::getInstance().lenpool())
		{
			mvaddstrAlt(17, 53, addnextpagestr());
		}
		mvaddstrAlt(24, 1, CONST_lcsmonthly030);
		int c = getkeyAlt();
		if (c >= 'a'&&c <= 'r')
		{
			int slot = c - 'a' + page * 18;
			if (slot >= 0 && slot < len(loottypeindex))
			{
				// remove item from location
				int output = LocationsPool::getInstance().deleteSpecialItem(slot, loottypeindex);
				if (output != -1) {
					return output;
				}
				// if not in location, remove item from squad
				for (int sq = 0; sq < len(squad); sq++)
				{
					for (int l = 0; l < len(squad[sq]->loot); l++)
					{
						if (!(squad[sq]->loot[l]->whatIsThis() == THIS_IS_LOOT)) continue;
						if (getloottype(squad[sq]->loot[l]->get_itemtypename()) == loottypeindex[slot])
						{
							squad[sq]->loot[l]->decrease_number(1);
							if (squad[sq]->loot[l]->empty())
								delete_and_remove(squad[sq]->loot, l);
							return loottypeindex[slot];
						}
					}
				}
				//WHOOPS!
				return loottypeindex[slot];
			}
		}
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) return -1;
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0) page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 18 < LootTypePool::getInstance().lenpool()) page++;
	}
	return -1;
}
/* monthly - guardian - prints liberal guardian special editions */
void printnews(short li, short newspaper)
{
	extern CCSexposure ccsexposure;
	extern short offended_firemen;
	extern short offended_corps;
	extern short offended_cia;
	extern short offended_amradio;
	extern short offended_cablenews;
	extern Log gamelog;
	extern MusicClass music;
	extern short lawList[LAWNUM];
	//// TODO Move to XML
	music.play(MUSIC_NEWSPAPER);
	if (lawList[LAW_FREESPEECH] == -2)offended_firemen = 1;
	string lootIDName = LootTypePool::getInstance().getIdName(li);
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	if (lootIDName == tag_LOOT_CEOPHOTOS) // Tmp -XML
	{
		mvaddstrAlt(6, 1, CONST_lcsmonthly031, gamelog);
		moveAlt(7, 1);
		change_public_opinion(VIEW_LIBERALCRIMESQUAD, 10);
		change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, 10);
		switch (LCSrandom(10))
		{
		case 0:
			addstrAlt(CONST_lcsmonthly032, gamelog);
			change_public_opinion(VIEW_ANIMALRESEARCH, 15);
			break;
		case 1:addstrAlt(CONST_lcsmonthly033, gamelog); break;
		case 2:
			addstrAlt(CONST_lcsmonthly034, gamelog);
			change_public_opinion(VIEW_POLICEBEHAVIOR, 15);
			change_public_opinion(VIEW_JUSTICES, 10);
			break;
		case 3:addstrAlt(CONST_lcsmonthly035, gamelog); break;
		case 4:addstrAlt(CONST_lcsmonthly036, gamelog); break;
		case 5:
			addstrAlt(CONST_lcsmonthly037, gamelog);
			change_public_opinion(VIEW_GENETICS, 10);
			change_public_opinion(VIEW_POLLUTION, 10);
			break;
		case 6:addstrAlt(CONST_lcsmonthly038, gamelog); break;
		case 7:addstrAlt(CONST_lcsmonthly039, gamelog); break;
		case 8:
			addstrAlt(CONST_lcsmonthly040, gamelog);
			change_public_opinion(VIEW_SWEATSHOPS, 10);
			break;
		case 9:addstrAlt(CONST_lcsmonthly041, gamelog); break;
		}
		gamelog.newline();
		mvaddstrAlt(9, 1, major_news_take_it_up, gamelog);
		gamelog.newline();
		mvaddstrAlt(10, 1, bound_to_rile_up, gamelog);
		gamelog.nextMessage();
		change_public_opinion(VIEW_CEOSALARY, 50);
		change_public_opinion(VIEW_CORPORATECULTURE, 50);
		offended_corps = 1;
	}
	else if (lootIDName == tag_LOOT_CEOLOVELETTERS)
	{
		mvaddstrAlt(6, 1, CONST_lcsmonthly042, gamelog);
		moveAlt(7, 1);
		change_public_opinion(VIEW_LIBERALCRIMESQUAD, 10);
		change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, 10);
		switch (LCSrandom(8))
		{
		case 0:
			addstrAlt(CONST_lcsmonthly043, gamelog);
			change_public_opinion(VIEW_ANIMALRESEARCH, 15);
			break;
		case 1:
			addstrAlt(CONST_lcsmonthly044, gamelog);
			change_public_opinion(VIEW_JUSTICES, 15);
			break;
		case 2:
			addstrAlt(CONST_lcsmonthly045, gamelog);
			change_public_opinion(VIEW_GAY, 15);
			break;
		case 3:addstrAlt(CONST_lcsmonthly046, gamelog); break;
		case 4:
			addstrAlt(CONST_lcsmonthly047, gamelog);
			change_public_opinion(VIEW_SWEATSHOPS, 10);
			break;
		case 5:
			addstrAlt(CONST_lcsmonthly048, gamelog);
			change_public_opinion(VIEW_GENETICS, 10);
			change_public_opinion(VIEW_POLLUTION, 10);
			break;
		case 6:addstrAlt(CONST_lcsmonthly049, gamelog); break;
		case 7:addstrAlt(CONST_lcsmonthly050, gamelog); break;
		}
		gamelog.newline();
		mvaddstrAlt(9, 1, major_news_take_it_up, gamelog);
		gamelog.newline();
		mvaddstrAlt(10, 1, bound_to_rile_up, gamelog);
		gamelog.nextMessage();
		change_public_opinion(VIEW_CEOSALARY, 50);
		change_public_opinion(VIEW_CORPORATECULTURE, 50);
		offended_corps = 1;
	}
	else if (lootIDName == tag_LOOT_CEOTAXPAPERS)
	{
		mvaddstrAlt(6, 1, CONST_lcsmonthly051, gamelog);
		moveAlt(7, 1);
		change_public_opinion(VIEW_LIBERALCRIMESQUAD, 10);
		change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, 10);
		switch (LCSrandom(1))
		{
		default:
			addstrAlt(CONST_lcsmonthly052, gamelog);
			change_public_opinion(VIEW_TAXES, 25);
			break;
		}
		gamelog.newline();
		mvaddstrAlt(9, 1, major_news_take_it_up, gamelog);
		gamelog.newline();
		mvaddstrAlt(10, 1, bound_to_rile_up, gamelog);
		gamelog.nextMessage();
		change_public_opinion(VIEW_CEOSALARY, 50);
		change_public_opinion(VIEW_CORPORATECULTURE, 50);
		offended_corps = 1;
	}
	else if (lootIDName == tag_LOOT_CORPFILES)
	{
		mvaddstrAlt(6, 1, CONST_lcsmonthly053, gamelog);
		moveAlt(7, 1);
		change_public_opinion(VIEW_LIBERALCRIMESQUAD, newspaper * 10);
		change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, newspaper * 10);
		switch (LCSrandom(5))
		{
		case 0:
			addstrAlt(CONST_lcsmonthly054, gamelog);
			change_public_opinion(VIEW_GENETICS, 50);
			break;
		case 1:
			addstrAlt(CONST_lcsmonthly055, gamelog);
			change_public_opinion(VIEW_GAY, 50);
			break;
		case 2:
			addstrAlt(CONST_lcsmonthly056, gamelog);
			change_public_opinion(VIEW_WOMEN, 50);
			break;
		case 3:
			addstrAlt(CONST_lcsmonthly057, gamelog);
			change_public_opinion(VIEW_SWEATSHOPS, 50);
			break;
		case 4:
			addstrAlt(CONST_lcsmonthly058, gamelog);
			change_public_opinion(VIEW_TAXES, 50);
			break;
		}
		gamelog.newline();
		mvaddstrAlt(9, 1, major_news_take_it_up, gamelog);
		gamelog.newline();
		mvaddstrAlt(10, 1, bound_to_rile_up, gamelog);
		gamelog.nextMessage();
		change_public_opinion(VIEW_CEOSALARY, 50);
		change_public_opinion(VIEW_CORPORATECULTURE, 50);
		offended_corps = 1;
	}
	else if (lootIDName == tag_LOOT_CCS_BACKERLIST)
	{
		mvaddstrAlt(5, 1, CONST_lcsmonthly059, gamelog);
		gamelog.newline();
		mvaddstrAlt(6, 1, CONST_lcsmonthly060, gamelog);
		gamelog.newline();
		mvaddstrAlt(7, 1, CONST_lcsmonthly061, gamelog);
		gamelog.newline();
		mvaddstrAlt(8, 1, CONST_lcsmonthly062, gamelog);
		gamelog.newline();
		mvaddstrAlt(9, 1, CONST_lcsmonthly063, gamelog);
		gamelog.newline();
		mvaddstrAlt(10, 1, CONST_lcsmonthly064, gamelog);
		gamelog.newline();
		mvaddstrAlt(11, 1, CONST_lcsmonthly065, gamelog);
		gamelog.newline();
		mvaddstrAlt(12, 1, CONST_lcsmonthly066, gamelog);
		mvaddstrAlt(14, 1, CONST_lcsmonthly067, gamelog);
		gamelog.newline();
		mvaddstrAlt(15, 1, CONST_lcsmonthly068, gamelog);
		gamelog.newline();
		mvaddstrAlt(16, 1, CONST_lcsmonthly069, gamelog);
		gamelog.newline();
		mvaddstrAlt(17, 1, CONST_lcsmonthly070, gamelog);
		gamelog.newline();
		mvaddstrAlt(18, 1, CONST_lcsmonthly071, gamelog);
		gamelog.newline();
		mvaddstrAlt(20, 1, CONST_lcsmonthly072, gamelog);
		gamelog.nextMessage();
		change_public_opinion(VIEW_INTELLIGENCE, 50);
		change_public_opinion(VIEW_CONSERVATIVECRIMESQUAD, 100);
		ccsexposure = CCSEXPOSURE_EXPOSED;
	}
	else if (lootIDName == tag_LOOT_INTHQDISK
		|| lootIDName == tag_LOOT_SECRETDOCUMENTS)
	{
		mvaddstrAlt(6, 1, CONST_lcsmonthly073, gamelog);
		moveAlt(7, 1);
		change_public_opinion(VIEW_LIBERALCRIMESQUAD, 10);
		change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, 10);
		switch (LCSrandom(6))
		{
		case 0:addstrAlt(CONST_lcsmonthly074, gamelog); break;
		case 1:
			addstrAlt(CONST_lcsmonthly075, gamelog);
			change_public_opinion(VIEW_JUSTICES, 50);
			break;
		case 2:addstrAlt(CONST_lcsmonthly076, gamelog); break;
		case 3:
			addstrAlt(CONST_lcsmonthly077, gamelog);
			change_public_opinion(VIEW_FREESPEECH, 50);
			break;
		case 4:
			addstrAlt(CONST_lcsmonthly078, gamelog);
			change_public_opinion(VIEW_GAY, 50);
			break;
		case 5:
			addstrAlt(CONST_lcsmonthly079, gamelog);
			change_public_opinion(VIEW_WOMEN, 50);
			break;
		}
		gamelog.newline();
		mvaddstrAlt(9, 1, major_news_take_it_up, gamelog);
		gamelog.newline();
		mvaddstrAlt(10, 1, CONST_lcsmonthly080, gamelog);
		gamelog.nextMessage();
		change_public_opinion(VIEW_INTELLIGENCE, 50);
		offended_cia = 1;
	}
	else if (lootIDName == tag_LOOT_POLICERECORDS)
	{
		mvaddstrAlt(6, 1, CONST_lcsmonthly081, gamelog);
		moveAlt(7, 1);
		change_public_opinion(VIEW_LIBERALCRIMESQUAD, 10);
		change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, 10);
		switch (LCSrandom(6))
		{
		case 0:
			addstrAlt(CONST_lcsmonthly082, gamelog);
			change_public_opinion(VIEW_TORTURE, 15);
			break;
		case 1:
			addstrAlt(CONST_lcsmonthly083, gamelog);
			change_public_opinion(VIEW_TORTURE, 50);
			break;
		case 2:
			addstrAlt(CONST_lcsmonthly084, gamelog);
			change_public_opinion(VIEW_INTELLIGENCE, 15);
			break;
		case 3:
			addstrAlt(CONST_lcsmonthly085, gamelog);
			break;
		case 4:
			addstrAlt(CONST_lcsmonthly086, gamelog);
			break;
		case 5:
			addstrAlt(CONST_lcsmonthly100, gamelog);
			change_public_opinion(VIEW_DEATHPENALTY, 50);
			change_public_opinion(VIEW_PRISONS, 20);
			break;
		}
		moveAlt(9, 1);
		gamelog.newline();
		addstrAlt(major_news_take_it_up, gamelog);
		gamelog.nextMessage();
		change_public_opinion(VIEW_POLICEBEHAVIOR, 50);
	}
	else if (lootIDName == tag_LOOT_JUDGEFILES)
	{
		mvaddstrAlt(6, 1, CONST_lcsmonthly088, gamelog);
		moveAlt(7, 1);
		change_public_opinion(VIEW_LIBERALCRIMESQUAD, 10);
		change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, 10);
		switch (LCSrandom(2))
		{
		case 0:addstrAlt(CONST_lcsmonthly089, gamelog); break;
		case 1:addstrAlt(CONST_lcsmonthly090, gamelog); break;
		}
		gamelog.newline();
		mvaddstrAlt(8, 1, major_news_take_it_up, gamelog);
		gamelog.nextMessage();
		change_public_opinion(VIEW_JUSTICES, 50);
	}
	else if (lootIDName == tag_LOOT_RESEARCHFILES)
	{
		mvaddstrAlt(6, 1, CONST_lcsmonthly091, gamelog);
		moveAlt(7, 1);
		change_public_opinion(VIEW_LIBERALCRIMESQUAD, 10);
		change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, 10);
		switch (LCSrandom(4))
		{
		case 0:addstrAlt(CONST_lcsmonthly092, gamelog);
			change_public_opinion(VIEW_ANIMALRESEARCH, 50); break;
		case 1:addstrAlt(CONST_lcsmonthly093, gamelog);
			change_public_opinion(VIEW_ANIMALRESEARCH, 50); break;
		case 2:addstrAlt(CONST_lcsmonthly094, gamelog);
			change_public_opinion(VIEW_GENETICS, 50); break;
		case 3:addstrAlt(CONST_lcsmonthly095, gamelog);
			change_public_opinion(VIEW_GENETICS, 50); break;
		}
		gamelog.newline();
		mvaddstrAlt(9, 1, major_news_take_it_up, gamelog);
		gamelog.nextMessage();
	}
	else if (lootIDName == tag_LOOT_PRISONFILES)
	{
		mvaddstrAlt(6, 1, CONST_lcsmonthly096, gamelog);
		moveAlt(7, 1);
		change_public_opinion(VIEW_LIBERALCRIMESQUAD, 10);
		change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, 10);
		change_public_opinion(VIEW_PRISONS, 50);
		switch (LCSrandom(4))
		{
		case 0:addstrAlt(CONST_lcsmonthly097, gamelog); break;
		case 1:
			addstrAlt(CONST_lcsmonthly098, gamelog);
			change_public_opinion(VIEW_TORTURE, 50);
			break;
		case 2:addstrAlt(CONST_lcsmonthly099, gamelog); break;
		case 3:
			addstrAlt(CONST_lcsmonthly100, gamelog);
		}
		gamelog.newline();
		mvaddstrAlt(9, 1, major_news_take_it_up, gamelog);
		gamelog.nextMessage();
		change_public_opinion(VIEW_DEATHPENALTY, 50);
	}
	else if (lootIDName == tag_LOOT_CABLENEWSFILES)
	{
		mvaddstrAlt(6, 1, CONST_lcsmonthly101, gamelog);
		moveAlt(7, 1);
		change_public_opinion(VIEW_LIBERALCRIMESQUAD, 10);
		change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, 10);
		switch (LCSrandom(4))
		{
		case 0:addstrAlt(CONST_lcsmonthly102, gamelog); break;
		case 1:addstrAlt(CONST_lcsmonthly103, gamelog); break;
		case 2:addstrAlt(CONST_lcsmonthly110, gamelog); break;
		case 3:addstrAlt(CONST_lcsmonthly105, gamelog);
			break;
		}
		gamelog.newline();
		mvaddstrAlt(9, 1, major_news_take_it_up, gamelog);
		gamelog.newline();
		mvaddstrAlt(10, 1, CONST_lcsmonthly111, gamelog);
		gamelog.nextMessage();
		change_public_opinion(VIEW_CABLENEWS, 50);
		offended_cablenews = 1;
	}
	else if (lootIDName == tag_LOOT_AMRADIOFILES)
	{
		mvaddstrAlt(6, 1, CONST_lcsmonthly107, gamelog);
		moveAlt(7, 1);
		change_public_opinion(VIEW_LIBERALCRIMESQUAD, 10);
		change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, 10);
		switch (LCSrandom(3))
		{
		case 0:addstrAlt(CONST_lcsmonthly108, gamelog); break;
		case 1:addstrAlt(CONST_lcsmonthly109, gamelog); break;
		case 2:addstrAlt(CONST_lcsmonthly110, gamelog); break;
		}
		gamelog.newline();
		mvaddstrAlt(9, 1, major_news_take_it_up, gamelog);
		gamelog.newline();
		mvaddstrAlt(10, 1, CONST_lcsmonthly111, gamelog);
		gamelog.nextMessage();
		change_public_opinion(VIEW_AMRADIO, 50);
		offended_amradio = 1;
	}
	pressAnyKey();
}
/* monthly - LCS finances report */
void fundreport(char &clearformess)
{
	extern short interface_pgup;
	extern short interface_pgdn;
	extern char disbanding;
	extern MusicClass music;
	extern class Ledger ledger;
	if (disbanding) return;
	music.play(MUSIC_FINANCES);
	clearformess = true;
	int page = 0;
	bool showledger = false;
	std::string num;
	static const char dotdotdot[] = ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
	int expenselines = 0;
	for (int i = 0; i < EXPENSETYPENUM; i++)
		if (ledger.expense[i])
			expenselines++;
	while (true)
	{
		eraseAlt();
		int y = 2, totalmoney = 0, dailymoney = 0, numpages = 1;
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, CONST_lcsmonthly113);
		for (int i = 0; i < INCOMETYPENUM; i++)
		{
			if (ledger.income[i])
			{
				showledger = true;
				if (page == numpages - 1)
				{
					set_color_easy(WHITE_ON_BLACK);
					mvaddstrAlt(y, 0, dotdotdot);
					set_color_easy(GREEN_ON_BLACK);
					num = CONST_lcsmonthly114 + tostring(ledger.income[i]);
					mvaddstrAlt(y, 60 - len(num), num);
					if (ledger.dailyIncome[i])
						num = CONST_lcsmonthly124 + tostring(ledger.dailyIncome[i]) + closeParenthesis;
					else
					{
						set_color_easy(WHITE_ON_BLACK);
						num = CONST_lcsmonthly126;
					}
					mvaddstrAlt(y, 73 - len(num), num);
					set_color_easy(WHITE_ON_BLACK);
					if (incomeTypes.count(i)) {
						mvaddstrAlt(y, 0, incomeTypes[i]);
					}
					else {
						mvaddstrAlt(y, 0, incomeTypes[INCOMETYPENUM]);
					}
				}
				totalmoney += ledger.income[i];
				dailymoney += ledger.dailyIncome[i];
				if (++y >= 23) y = 2, numpages++;
			}
		}
		// If expenses are too long to fit on this page, start them on the next page so it isn't broken in half unnecessarily
		if (y + expenselines >= 23 && y > 2) y = 2, numpages++;
		for (int i = 0; i < EXPENSETYPENUM; i++)
		{
			if (ledger.expense[i])
			{
				showledger = true;
				if (page == numpages - 1)
				{
					set_color_easy(WHITE_ON_BLACK);
					mvaddstrAlt(y, 0, dotdotdot);
					set_color_easy(RED_ON_BLACK);
					num = CONST_lcsmonthly117 + tostring(ledger.expense[i]);
					mvaddstrAlt(y, 60 - len(num), num);
					if (ledger.dailyExpense[i])
						num = CONST_lcsmonthly125 + tostring(ledger.dailyExpense[i]) + closeParenthesis;
					else
					{
						set_color_easy(WHITE_ON_BLACK);
						num = CONST_lcsmonthly126;
					}
					mvaddstrAlt(y, 73 - len(num), num);
					set_color_easy(WHITE_ON_BLACK);
					if (expenseTypes.count(i)) {
						mvaddstrAlt(y, 0, expenseTypes[i]);
					}
					else {
						mvaddstrAlt(y, 0, expenseTypes[EXPENSETYPENUM]);
					}
				}
				totalmoney -= ledger.expense[i];
				dailymoney -= ledger.dailyExpense[i];
				if (++y >= 23) y = 2, numpages++;
			}
		}
		if (showledger)
		{
			if (page == numpages - 1) makedelimiter(y);
			if (++y >= 23) y = 2, numpages++;
			if (page == numpages - 1)
			{
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(y, 0, CONST_lcsmonthly120);
				if (totalmoney > 0) { set_color_easy(GREEN_ON_BLACK_BRIGHT); num = CONST_lcsmonthly121; }
				else if (totalmoney < 0) { set_color_easy(RED_ON_BLACK_BRIGHT); num = CONST_lcsmonthly122; }
				else { set_color_easy(WHITE_ON_BLACK_BRIGHT); num = blankString; }
				num += CONST_lcsmonthly138 + tostring(abs(totalmoney));
				mvaddstrAlt(y, 60 - len(num), num);
				if (dailymoney > 0)
				{
					set_color_easy(GREEN_ON_BLACK_BRIGHT);
					num = CONST_lcsmonthly124 + tostring(abs(dailymoney)) + closeParenthesis;
				}
				else if (dailymoney < 0)
				{
					set_color_easy(RED_ON_BLACK_BRIGHT);
					num = CONST_lcsmonthly125 + tostring(abs(dailymoney)) + closeParenthesis;
				}
				else
				{
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					num = CONST_lcsmonthly126;
				}
				mvaddstrAlt(y, 73 - len(num), num);
			}
			if (++y >= 23) y = 2, numpages++;
		}
		if (y > 2) y++; // Blank line between income/expenses and assets if not starting a new page
		if (y + 7 >= 23) y = 2, numpages++; //Start a new page if the liquid assets won't fit on the rest of the current page.
											// tally up liquid assets
		long weaponValue = 0, armorValue = 0, clipValue = 0, lootValue = 0;
		LocationsPool::getInstance().getAssetValues(weaponValue, armorValue, clipValue, lootValue);

		if (page == numpages - 1)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(y, 0, dotdotdot);
			mvaddstrAlt(y, 0, CONST_lcsmonthly127);
			set_color_easy(ledger.get_funds() ? GREEN_ON_BLACK : WHITE_ON_BLACK);
			num = CONST_lcsmonthly138 + tostring(ledger.get_funds());
			mvaddstrAlt(y, 60 - len(num), num);
		}
		if (++y >= 23) y = 2, numpages++;
		if (page == numpages - 1)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(y, 0, dotdotdot);
			mvaddstrAlt(y, 0, CONST_lcsmonthly129);
			set_color_easy(weaponValue ? GREEN_ON_BLACK : WHITE_ON_BLACK);
			num = CONST_lcsmonthly138 + tostring(weaponValue);
			mvaddstrAlt(y, 60 - len(num), num);
		}
		if (++y >= 23) y = 2, numpages++;
		if (page == numpages - 1)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(y, 0, dotdotdot);
			mvaddstrAlt(y, 0, CONST_lcsmonthly131);
			set_color_easy(armorValue ? GREEN_ON_BLACK : WHITE_ON_BLACK);
			num = CONST_lcsmonthly138 + tostring(armorValue);
			mvaddstrAlt(y, 60 - len(num), num);
		}
		if (++y >= 23) y = 2, numpages++;
		if (page == numpages - 1)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(y, 0, dotdotdot);
			mvaddstrAlt(y, 0, CONST_lcsmonthly133);
			set_color_easy(clipValue ? GREEN_ON_BLACK : WHITE_ON_BLACK);
			num = CONST_lcsmonthly138 + tostring(clipValue);
			mvaddstrAlt(y, 60 - len(num), num);
		}
		if (++y >= 23) y = 2, numpages++;
		if (page == numpages - 1)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(y, 0, dotdotdot);
			mvaddstrAlt(y, 0, CONST_lcsmonthly135);
			set_color_easy(lootValue ? GREEN_ON_BLACK : WHITE_ON_BLACK);
			num = CONST_lcsmonthly138 + tostring(lootValue);
			mvaddstrAlt(y, 60 - len(num), num);
		}
		if (++y >= 23) y = 2, numpages++;
		if (page == numpages - 1) makedelimiter(y);
		if (++y >= 23) y = 2, numpages++;
		if (page == numpages - 1)
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(y, 0, CONST_lcsmonthly137);
			long netWorth = ledger.get_funds() + weaponValue + armorValue + clipValue + lootValue;
			set_color_easy(netWorth ? GREEN_ON_BLACK_BRIGHT : WHITE_ON_BLACK_BRIGHT);
			num = CONST_lcsmonthly138 + tostring(netWorth);
			mvaddstrAlt(y, 60 - len(num), num);
		}
		set_color_easy(WHITE_ON_BLACK);
		if (numpages > 1)
		{
			mvaddstrAlt(24, 0, CONST_lcsmonthly139 + addpagestr());
			while (true)
			{
				int c = getkeyAlt();
				if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR)
				{
					music.play(MUSIC_PREVIOUS);
					return;
				}
				//PAGE UP
				if (c == interface_pgup || c == KEY_UP || c == KEY_LEFT) { page--; if (page < 0) page = numpages - 1; break; }
				//PAGE DOWN
				if (c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) { page++; if (page >= numpages) page = 0; break; }
			}
		}
		else
		{
			mvaddstrAlt(24, 0, CONST_lcsmonthly140);
			pressAnyKey();
			music.play(MUSIC_PREVIOUS);
			return;
		}
	}
}


// #include "../includes.h"

const string CONST_liberalagenda054 = "The country has been Stalinized.";
const string CONST_liberalagenda053 = "The country has been Reaganified.";
const string CONST_liberalagenda052 = "The country has achieved Elite Liberal status!";
const string CONST_liberalagenda051 = "The country has achieved Liberal status!";
const string CONST_liberalagenda050 = "ÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍ¼          ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ";
const string CONST_liberalagenda049 = "³ GENERAL SUMMARY ³ ISSUES A º ISSUES B º";
const string CONST_liberalagenda048 = "ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÉÍÍÍÍÍÍÍÍÍÍ»";
const string CONST_liberalagenda047 = "ÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼          ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ";
const string CONST_liberalagenda046 = "³ GENERAL SUMMARY º ISSUES A º ISSUES B ³";
const string CONST_liberalagenda045 = "ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÉÍÍÍÍÍÍÍÍÍÍ»ÄÄÄÄÄÄÄÄÄÄ¿";

const string CONST_liberalagenda017 = "The Status of the Liberal Agenda";
const string CONST_liberalagenda016 = "The Abject Failure of the Liberal Agenda";
const string CONST_liberalagenda015 = "The Triumph of the Liberal Agenda";
const string CONST_liberalagenda014 = "Type this Liberal phrase to confirm (press a wrong letter to rethink it):";
const string CONST_liberalagenda013 = "Are you sure you want to disband?";
const string CONST_liberalagenda012 = "courtChars.txt";
const string CONST_liberalagenda011 = "supremeChars.txt";
const string CONST_liberalagenda010 = "issue_phrases.txt";
const string CONST_liberalagenda009 = "disbandingMessage.txt";

string getlaw(int l);
void cleangonesquads();
vector<string> supremeChars;
vector<string> courtChars;
string pressLToViewHighScores;
map<short, vector<string> > endgameLawStrings;
enum Pages
{
	PAGE_LEADERS,
	PAGE_ISSUES_A,
	PAGE_ISSUES_B,
	//PAGE_POLLS_A,
	//PAGE_POLLS_B
	PAGENUM
};
vector<string> disbandingMessage;
vector<string> issue_phrases;
vector<file_and_text_collection> liberl_agenda_text_file_collection = {
	customText(&disbandingMessage, mostlyendings + CONST_liberalagenda009),
	customText(&issue_phrases, mostlyendings + CONST_liberalagenda010),
	customText(&supremeChars, mostlyendings + CONST_liberalagenda011),
	customText(&courtChars, mostlyendings + CONST_liberalagenda012),
};
/* base - liberal agenda - disband */
bool confirmdisband()
{
	extern int year;
	extern int disbandtime;
	string word = pickrandom(issue_phrases);
	for (int pos = 0; pos < len(word);)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, CONST_liberalagenda013);
		set_color_easy(WHITE_ON_BLACK);
		for (int i = 0; i < len(disbandingMessage); i++) {
			mvaddstrAlt(i + 2, 0, disbandingMessage[i]);
		}
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(13, 0, CONST_liberalagenda014);
		for (int x = 0; x < len(word); x++)
		{
			if (x == pos) set_color_easy(GREEN_ON_BLACK);
			else if (x < pos) set_color_easy(GREEN_ON_BLACK_BRIGHT);
			else set_color_easy(WHITE_ON_BLACK);
			mvaddcharAlt(15, x, word[x]);
		}
		if (getkeyAlt() == ::tolower(word[pos]))
		{
			pos++;
			if (word[pos] == ' ' || word[pos] == '\'' || word[pos] == '-') pos++;
		}
		else return false;
	}
	//SET UP THE DISBAND
	CreaturePool::getInstance().setupDisband();
	cleangonesquads();
	disbandtime = year;
	return true;
}
void printDisbandOption() {
	const string CONST_liberalagenda066 = "Press D to disband and wait. Use cursors for other pages. Any other key to exit.";
	//const string CONST_liberalagenda065 = "Once these are Green, the country will have achieved Elite Liberal status.";
	const string CONST_liberalagenda064 = "Arch-Conservative";
	const string CONST_liberalagenda063 = "-  ";
	const string CONST_liberalagenda062 = "Conservative  ";
	const string CONST_liberalagenda060 = "moderate  ";
	const string CONST_liberalagenda058 = "Liberal  ";
	const string CONST_liberalagenda056 = "Elite Liberal  ";
	const string CONST_liberalagenda055 = "Stalinist  ";
	extern bool stalinmode;

	moveAlt(23, 0);
	if (stalinmode)
	{
		set_color_easy(RED_ON_BLACK_BRIGHT);
		addstrAlt(CONST_liberalagenda055);
	}
	set_color_easy(GREEN_ON_BLACK_BRIGHT);
	addstrAlt(CONST_liberalagenda056);
	if (!stalinmode)
	{
		set_color_easy(WHITE_ON_BLACK);
		addstrAlt(CONST_liberalagenda063);
	}
	set_color_easy(CYAN_ON_BLACK_BRIGHT);
	addstrAlt(CONST_liberalagenda058);
	if (!stalinmode)
	{
		set_color_easy(WHITE_ON_BLACK);
		addstrAlt(CONST_liberalagenda063);
	}
	set_color_easy(YELLOW_ON_BLACK_BRIGHT);
	addstrAlt(CONST_liberalagenda060);
	if (!stalinmode)
	{
		set_color_easy(WHITE_ON_BLACK);
		addstrAlt(CONST_liberalagenda063);
	}
	set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
	addstrAlt(CONST_liberalagenda062);
	if (!stalinmode)
	{
		set_color_easy(WHITE_ON_BLACK);
		addstrAlt(CONST_liberalagenda063);
	}
	set_color_easy(RED_ON_BLACK_BRIGHT);
	addstrAlt(CONST_liberalagenda064);
	set_color_easy(WHITE_ON_BLACK);
	//mvaddstrAlt(23,0,CONST_liberalagenda065);
	mvaddstrAlt(24, 0, CONST_liberalagenda066);
}
void printLaws(const int startinglaw, const signed char won) {
	extern short wincondition;
	extern short lawList[LAWNUM];
	for (int l = startinglaw, y = 4; l < startinglaw + 18 && l < LAWNUM; l++, y++)
	{
		if (won == -1 || won == -2)
			set_alignment_color(ALIGN_ARCHCONSERVATIVE, true);
		else set_alignment_color(lawList[l], true);
		moveAlt(y, 0);
		if (won == -2)addstrAlt(endgameLawStrings[l][0]);
		else if (won == -1)addstrAlt(endgameLawStrings[l][1]);
		else if (lawList[l] == ALIGN_ARCHCONSERVATIVE)
			addstrAlt(endgameLawStrings[l][2]);
		else if (lawList[l] == -1)addstrAlt(endgameLawStrings[l][3]);
		else if (lawList[l] == 0)addstrAlt(endgameLawStrings[l][4]);
		else if (lawList[l] == 1)addstrAlt(endgameLawStrings[l][5]);
		else if (won != 1 || wincondition != WINCONDITION_ELITE)addstrAlt(endgameLawStrings[l][6]);
		else addstrAlt(endgameLawStrings[l][7]);
	}
}
void printPage(const int page, const signed char won) {
	const string CONST_liberalagenda044 = "Trial Judges";
	const string CONST_liberalagenda043 = "Stalinist Show";
	const string CONST_liberalagenda042 = "Replaced By";
	const string CONST_liberalagenda041 = "Ethics Officers";
	const string CONST_liberalagenda040 = "By Corporate";
	const string CONST_liberalagenda039 = "Replaced";
	const string CONST_liberalagenda038 = "Senate: ";
	const string CONST_liberalagenda037 = "House: ";
	const string CONST_liberalagenda036 = "The Congress consists of Stalinist Party loyalists.";
	const string CONST_liberalagenda035 = "The Congress consists of CEOs and televangelists.";
	const string CONST_liberalagenda034 = "Attorney General: ";
	const string CONST_liberalagenda033 = "Internal Affairs Commissar: ";
	const string CONST_liberalagenda032 = "Minister of Truth: ";
	const string CONST_liberalagenda031 = "Secretary of State: ";
	const string CONST_liberalagenda030 = "Foreign Affairs Commissar: ";
	const string CONST_liberalagenda029 = "Minister of Peace: ";
	const string CONST_liberalagenda028 = "Vice President: ";
	const string CONST_liberalagenda027 = "Premier: ";
	const string CONST_liberalagenda026 = "Minister of Love: ";
	const string CONST_liberalagenda025 = "(2nd Term):";
	const string CONST_liberalagenda024 = "(1st Term):";
	const string CONST_liberalagenda023 = "President ";
	const string CONST_liberalagenda022 = "General Secretary: ";
	const string CONST_liberalagenda021 = "King: ";
	const string CONST_liberalagenda020 = "¼                 ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ";
	const string CONST_liberalagenda019 = "º GENERAL SUMMARY º ISSUES A ³ ISSUES B ³";
	const string CONST_liberalagenda018 = "ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»ÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿";

	extern short execterm;
	extern short exec[EXECNUM];
	extern char execname[EXECNUM][POLITICIAN_NAMELEN];
	extern bool stalinmode;
	extern short house[HOUSENUM];
	extern short senate[SENATENUM];
	extern short court[COURTNUM];
	extern char courtname[COURTNUM][POLITICIAN_NAMELEN];
	extern short wincondition;
	extern short lawList[LAWNUM];
	switch (page)
	{
	case PAGE_LEADERS:
	{
		mvaddstrAlt(1, 0, CONST_liberalagenda018);
		mvaddstrAlt(2, 0, CONST_liberalagenda019);
		mvaddstrAlt(3, 0, CONST_liberalagenda020);
		signed char align = exec[EXEC_PRESIDENT];
		set_alignment_color(align, true);
		moveAlt(5, 0);
		if (won == -1) addstrAlt(CONST_liberalagenda021);
		else if (won == -2) addstrAlt(CONST_liberalagenda022);
		else
		{
			addstrAlt(CONST_liberalagenda023);
			if (execterm == 1)addstrAlt(CONST_liberalagenda024);
			else addstrAlt(CONST_liberalagenda025);
		}
		if (won == -2) moveAlt(5, 30);
		else mvaddstrAlt(5, 25, execname[EXEC_PRESIDENT]);
		align = exec[EXEC_VP];
		set_alignment_color(align, true);
		moveAlt(6, 0);
		if (won == -1) addstrAlt(CONST_liberalagenda026);
		else if (won == -2) addstrAlt(CONST_liberalagenda027);
		else addstrAlt(CONST_liberalagenda028);
		if (won == -2) moveAlt(6, 30);
		else mvaddstrAlt(6, 25, execname[EXEC_VP]);
		align = exec[EXEC_STATE];
		set_alignment_color(align, true);
		moveAlt(7, 0);
		if (won == -1) addstrAlt(CONST_liberalagenda029);
		else if (won == -2) addstrAlt(CONST_liberalagenda030);
		else addstrAlt(CONST_liberalagenda031);
		if (won == -2) moveAlt(7, 30);
		else mvaddstrAlt(7, 25, execname[EXEC_STATE]);
		align = exec[EXEC_ATTORNEY];
		set_alignment_color(align, true);
		moveAlt(8, 0);
		if (won == -1) addstrAlt(CONST_liberalagenda032);
		else if (won == -2) addstrAlt(CONST_liberalagenda033);
		else addstrAlt(CONST_liberalagenda034);
		if (won == -2) moveAlt(8, 30);
		else mvaddstrAlt(8, 25, execname[EXEC_ATTORNEY]);
		if (won == -1)
		{
			set_color_easy(RED_ON_BLACK_BRIGHT);
			mvaddstrAlt(10, 0, CONST_liberalagenda035);
		}
		else if (won == -2)
		{
			set_color_easy(RED_ON_BLACK_BRIGHT);
			mvaddstrAlt(10, 0, CONST_liberalagenda036);
		}
		else
		{
			int housemake[6] = { 0,0,0,0,0,0 };
			for (int h = 0; h < HOUSENUM; h++) housemake[house[h] + 2]++;
			if (housemake[5] + min(housemake[0], housemake[4]) >= HOUSEMAJORITY) align = ALIGN_STALINIST; // Stalinists have a majority (perhaps with help from extremists on both sides)
			else if (housemake[0] >= HOUSEMAJORITY) align = ALIGN_ARCHCONSERVATIVE; // Arch-Conservatives have a majority
			else if (housemake[4] >= HOUSEMAJORITY) align = ALIGN_ELITELIBERAL; // Elite Liberals have a majority
			else if (housemake[0] + housemake[1] >= HOUSEMAJORITY) align = ALIGN_CONSERVATIVE; // Conservatives plus Arch-Conservatives have a majority
			else if (housemake[3] + housemake[4] >= HOUSEMAJORITY) align = ALIGN_LIBERAL; // Liberals plus Elite Liberals have a majority
			else align = ALIGN_MODERATE; // nobody has a majority
			set_alignment_color(align, true);
			mvaddstrAlt(10, 0, CONST_liberalagenda037);
			if (stalinmode) addstrAlt(tostring(housemake[5]) + tag_Sta);
			addstrAlt(tostring(housemake[4]) + tag_Libp);
			addstrAlt(tostring(housemake[3]) + tag_Lib);
			addstrAlt(tostring(housemake[2]) + tag_Mod);
			addstrAlt(tostring(housemake[1]) + tag_Cons);
			addstrAlt(tostring(housemake[0]) + tag_Consp);
			int senatemake[6] = { 0,0,0,0,0,0 };
			for (int s = 0; s < SENATENUM; s++) senatemake[senate[s] + 2]++;
			senatemake[exec[EXEC_VP] + 2]++; // Vice President is tie-breaking vote in the Senate
			if (senatemake[5] + min(senatemake[0], senatemake[4]) >= SENATEMAJORITY) align = ALIGN_STALINIST; // Stalinists have a majority (perhaps with help from extremists on both sides)
			else if (senatemake[0] >= SENATEMAJORITY) align = ALIGN_ARCHCONSERVATIVE; // Arch-Conservatives have a majority
			else if (senatemake[4] >= SENATEMAJORITY) align = ALIGN_ELITELIBERAL; // Elite Liberals have a majority
			else if (senatemake[0] + senatemake[1] >= SENATEMAJORITY) align = ALIGN_CONSERVATIVE; // Conservatives plus Arch-Conservatives have a majority
			else if (senatemake[3] + senatemake[4] >= SENATEMAJORITY) align = ALIGN_LIBERAL; // Liberals plus Elite Liberals have a majority
			else align = ALIGN_MODERATE; // nobody has a majority
			set_alignment_color(align, true);
			senatemake[exec[EXEC_VP] + 2]--; // Vice President isn't actually a Senator though
			mvaddstrAlt(11, 0, CONST_liberalagenda038);
			if (stalinmode) addstrAlt(tostring(senatemake[5]) + tag_Sta);
			addstrAlt(tostring(senatemake[4]) + tag_Libp);
			addstrAlt(tostring(senatemake[3]) + tag_Lib);
			addstrAlt(tostring(senatemake[2]) + tag_Mod);
			addstrAlt(tostring(senatemake[1]) + tag_Cons);
			addstrAlt(tostring(senatemake[0]) + tag_Consp);
		}
		if (won == -1 || won == -2) set_color_easy(RED_ON_BLACK_BRIGHT);
		else if (won == 1) set_color_easy(GREEN_ON_BLACK_BRIGHT);
		else
		{
			int courtmake[6] = { 0,0,0,0,0,0 };
			for (int s = 0; s < COURTNUM; s++) courtmake[court[s] + 2]++;
			if (courtmake[5] + min(courtmake[0], courtmake[4]) >= COURTMAJORITY) align = ALIGN_STALINIST; // Stalinists have a majority (perhaps with help from extremists on both sides)
			else if (courtmake[0] >= COURTMAJORITY) align = ALIGN_ARCHCONSERVATIVE; // Arch-Conservatives have a majority
			else if (courtmake[4] >= COURTMAJORITY) align = ALIGN_ELITELIBERAL; // Elite Liberals have a majority
			else if (courtmake[0] + courtmake[1] >= COURTMAJORITY) align = ALIGN_CONSERVATIVE; // Conservatives plus Arch-Conservatives have a majority
			else if (courtmake[3] + courtmake[4] >= COURTMAJORITY) align = ALIGN_LIBERAL; // Liberals plus Elite Liberals have a majority
			else align = ALIGN_MODERATE; // nobody has a majority
			set_alignment_color(align, true);
		}
		for (int i = 0; i < len(supremeChars); i++) {
			mvaddstrAlt(5 + i, 56, supremeChars[i]);
		}
		for (int i = 0; i < len(courtChars); i++) {
			mvaddstrAlt(6 + i, 58, courtChars[i]);
		}
		if (won == -1)
		{
			mvaddstrAlt(7, 65, CONST_liberalagenda039);
			mvaddstrAlt(8, 63, CONST_liberalagenda040);
			mvaddstrAlt(9, 62, CONST_liberalagenda041);
		}
		else if (won == -2)
		{
			mvaddstrAlt(7, 63, CONST_liberalagenda042);
			mvaddstrAlt(8, 62, CONST_liberalagenda043);
			mvaddstrAlt(9, 63, CONST_liberalagenda044);
		}
		else
		{
			for (int c = 0, y = 4; c < COURTNUM; c++, y++)
			{
				set_alignment_color(court[c], true);
				mvaddstrAlt(y, 60, courtname[c]);
			}
		}
		for (int l = 0; l < LAWNUM; l++)
		{
			if (won == -1 || won == -2)
				set_alignment_color(ALIGN_ARCHCONSERVATIVE, true);
			else if (won == 1 && wincondition == WINCONDITION_ELITE)
				set_alignment_color(ALIGN_ELITELIBERAL, true);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(14 + l / 3, l % 3 * 26, "\x11ÄÄÄÄÄ\x10");
			if (won == -1 || won == -2)
				set_alignment_color(ALIGN_ARCHCONSERVATIVE, true);
			else set_alignment_color(lawList[l], true);
			addstrAlt(getlaw(l));
			mvaddcharAlt(14 + l / 3, l % 3 * 26 + 3 - lawList[l], 'O');
		}
		break;
	}
	case PAGE_ISSUES_A:
		mvaddstrAlt(1, 0, CONST_liberalagenda045);
		mvaddstrAlt(2, 0, CONST_liberalagenda046);
		mvaddstrAlt(3, 0, CONST_liberalagenda047);


		printLaws(0, won);
		break;
	case PAGE_ISSUES_B:
	
			mvaddstrAlt(1, 0, CONST_liberalagenda048);
			mvaddstrAlt(2, 0, CONST_liberalagenda049);
			mvaddstrAlt(3, 0, CONST_liberalagenda050);
		
		printLaws(18, won);
		break;

	}
}
/* base - liberal agenda */
bool liberalagenda(signed char won)
{
	extern MusicClass music;
	extern short interface_pgup;
	extern short interface_pgdn;
	extern short wincondition;

	int page = 0;
	while (true)
	{
		eraseAlt();
		if (won == 1)
		{
			set_color_easy(GREEN_ON_BLACK_BRIGHT);
			mvaddstrAlt(0, 0, CONST_liberalagenda015);
			music.play(MUSIC_VICTORY);
		}
		else if (won == -1 || won == -2)
		{
			set_color_easy(RED_ON_BLACK_BRIGHT);
			mvaddstrAlt(0, 0, CONST_liberalagenda016);
			if (won == -1) music.play(MUSIC_REAGANIFIED);
			if (won == -2) music.play(MUSIC_STALINIZED);
		}
		else
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(0, 0, CONST_liberalagenda017);
			music.play(MUSIC_LIBERALAGENDA);
		}
		if (page < 0) page = PAGENUM - 1;
		if (page >= PAGENUM) page = 0;
		printPage(page, won);
		if (won == 1)
		{
			set_color_easy(GREEN_ON_BLACK_BRIGHT);
			if (wincondition == WINCONDITION_EASY)
				mvaddstrAlt(23, 0, CONST_liberalagenda051);
			else mvaddstrAlt(23, 0, CONST_liberalagenda052);
			mvaddstrAlt(24, 0, pressLToViewHighScores);
			int c = getkeyAlt();
			if (c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) page++;
			else if (c == interface_pgup || c == KEY_UP || c == KEY_LEFT) page--;
			else if (c == 'l') break;
		}
		else if (won == -1)
		{
			set_color_easy(RED_ON_BLACK_BRIGHT);
			mvaddstrAlt(23, 0, CONST_liberalagenda053);
			mvaddstrAlt(24, 0, pressLToViewHighScores);
			int c = getkeyAlt();
			if (c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) page++;
			else if (c == interface_pgup || c == KEY_UP || c == KEY_LEFT) page--;
			else if (c == 'l') break;
		}
		else if (won == -2)
		{
			set_color_easy(RED_ON_BLACK_BRIGHT);
			mvaddstrAlt(23, 0, CONST_liberalagenda054);
			mvaddstrAlt(24, 0, pressLToViewHighScores);
			int c = getkeyAlt();
			if (c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) page++;
			else if (c == interface_pgup || c == KEY_UP || c == KEY_LEFT) page--;
			else if (c == 'l') break;
		}
		else
		{
			printDisbandOption();
			int c = getkeyAlt();
			if (c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) page++;
			else if (c == interface_pgup || c == KEY_UP || c == KEY_LEFT) page--;
			else if (c == 'd') return confirmdisband();
			else break;
		}
	}
	return false;
}


// #include "../includes.h"
const string CONST_locationsB130 = "Bunker";
const string CONST_locationsB129 = "Bar & Grill";
const string CONST_locationsB128 = "Bomb Shelter";
const string CONST_locationsB127 = "Oubliette";
const string CONST_locationsB126 = "Clinic";
const string CONST_locationsB125 = "U Hospital";
const string CONST_locationsB124 = "Radio Station";
const string CONST_locationsB123 = "News Station";
const string CONST_locationsB122 = "Chem Fact";
const string CONST_locationsB121 = "Refinery";
const string CONST_locationsB120 = "Plast Fact";
const string CONST_locationsB119 = "Alum Fact";
const string CONST_locationsB118 = "Shelter";
const string CONST_locationsB117 = "CEO House";
const string CONST_locationsB116 = "Bank";
const string CONST_locationsB115 = "Corp. HQ";
const string CONST_locationsB114 = "Minipax";
const string CONST_locationsB113 = "Int. HQ";
const string CONST_locationsB112 = "Miniluv";
const string CONST_locationsB111 = "NPower Plant";
const string CONST_locationsB110 = "NWaste Center";
const string CONST_locationsB109 = "Judge Hall";
const string CONST_locations114 = "Black Market";
const string CONST_locations113 = "Robert E. Lee Bunker";
const string CONST_locations112 = "Desert Eagle Bar & Grill";
const string CONST_locations111 = "Fallout Shelter";
const string CONST_locations110 = "Park";
const string CONST_locations109 = " Park";
const string CONST_locations108 = "Latte Stand";
const string CONST_locations107 = " Latte Stand";
const string CONST_locations106 = "Cigar Bar";
const string CONST_locations105 = " Gentlemen's Club";
const string CONST_locations104 = "Net Cafe";
const string CONST_locations103 = " Internet Cafe";
const string CONST_locations102 = "Vegan Co-op";
const string CONST_locations101 = " Vegan Co-op";
const string CONST_locations100 = "Juice Bar";
const string CONST_locations099 = " Juice Bar";
const string CONST_locations098 = "Crack House";
const string CONST_locations096 = "Dispensary";
const string CONST_locations095 = "Marijuana Dispensary";
const string CONST_locations094 = "Cannabis Lounge";
const string CONST_locations092 = "Coffee House";
const string CONST_locations090 = "Drugs Center";
const string CONST_locations089 = "Recreational Drugs Center";
const string CONST_locations088 = " St. ";
const string CONST_locations087 = "Sweatshop";
const string CONST_locations086 = " Garment Makers";
const string CONST_locations085 = "The Oubliette";
const string CONST_locations084 = "Dept. Store";
const string CONST_locations083 = "'s Department Store";
const string CONST_locations082 = "Used Cars";
const string CONST_locations081 = "'s Used Cars";
const string CONST_locations080 = "Cosmetics Lab";
const string CONST_locations079 = " Cosmetics";
const string CONST_locations078 = "Genetics Lab";
const string CONST_locations077 = " Genetics";
const string CONST_locations076 = "The Free Clinic";
const string CONST_locations075 = "The University Hospital";
const string CONST_locations074 = "Projects";
const string CONST_locations073 = " St. Housing Projects";
const string CONST_locations072 = " Apts";
const string CONST_locations071 = " Apartments";
const string CONST_locations070 = " Condos";
const string CONST_locations069 = " Condominiums";
const string CONST_locations068 = "AM Radio Station";
const string CONST_locations067 = "Cable News Station";
const string CONST_locations066 = "Chemical Factory";
const string CONST_locations065 = "Auto Plant";
const string CONST_locations064 = "Oil Refinery";
const string CONST_locations063 = "Plastic Factory";
const string CONST_locations062 = "Aluminum Factory";
const string CONST_locations061 = "Building";
const string CONST_locations060 = "Building Site";
const string CONST_locations059 = "Toy";
const string CONST_locations058 = "Toy Factory";
const string CONST_locations057 = "Packing";
const string CONST_locations056 = "Packing Plant";
const string CONST_locations055 = "Steel";
const string CONST_locations054 = "Steel Plant";
const string CONST_locations053 = "Drill";
const string CONST_locations052 = "Drill Factory";
const string CONST_locations051 = "Fertilizer";
const string CONST_locations050 = "Fertilizer Plant";
const string CONST_locations049 = "Cement";
const string CONST_locations048 = "Cement Factory";
const string CONST_locations047 = "Paper Mill";
const string CONST_locations045 = "Warehouse";
const string CONST_locations043 = "Meat Plant";
const string CONST_locations041 = "Abandoned ";
const string CONST_locations040 = "Homeless Shelter";
const string CONST_locations039 = "CEO Residence";
const string CONST_locations038 = "CEO Castle";
const string CONST_locations037 = "Pawnshop";
const string CONST_locations036 = " Pawn & Gun";
const string CONST_locations035 = "'s Pawnshop";
const string CONST_locations034 = "American Bank Corp";
const string CONST_locations033 = "Corporate HQ";
const string CONST_locations032 = "White House";
const string CONST_locations031 = "Army Base";
const string CONST_locations030 = " Army Base";
const string CONST_locations029 = "Ministry of Peace";
const string CONST_locations028 = "Intelligence HQ";
const string CONST_locations027 = "Ministry of Love";
const string CONST_locations026 = "Nuclear Power Plant";
const string CONST_locations025 = "Nuclear Waste Center";
const string CONST_locations024 = "Prison";
const string CONST_locations023 = " Prison";
const string CONST_locations022 = "Joycamp";
const string CONST_locations021 = " Forced Labor Camp";
const string CONST_locations020 = "Fire Station";
const string CONST_locations019 = "Fireman HQ";
const string CONST_locations018 = "Courthouse";
const string CONST_locations017 = "Halls of Ultimate Judgment";
const string CONST_locations016 = "Police Station";
const string CONST_locations015 = "Death Squad HQ";
const string CONST_locations014 = "latte_name_2.txt";
const string CONST_locations013 = "latte_name.txt";
const string CONST_locations012 = "cafe_name_2.txt";
const string CONST_locations011 = "cafe_name.txt";
const string CONST_locations010 = "vegan_name_2.txt";
const string CONST_locations009 = "vegan_name.txt";
const string CONST_locations008 = "juice_name_2.txt";
const string CONST_locations007 = "juice_name.txt";
const string CONST_locations006 = "labor_camp_name_2.txt";
const string CONST_locations005 = "labor_camp_name.txt";

vector<string> labor_camp_name;
vector<string> labor_camp_name_2;
vector<string> juice_name;
vector<string> juice_name_2;
vector<string> vegan_name;
vector<string> vegan_name_2;
vector<string> cafe_name;
vector<string> cafe_name_2;
vector<string> latte_name;
vector<string> latte_name_2;
// #include "../customMaps.h"
const string locations = "locations\\";
vector<file_and_text_collection> locations_text_file_collection = {
	/*locations.cpp*/
	customText(&labor_camp_name, locations + CONST_locations005),
	customText(&labor_camp_name_2, locations + CONST_locations006),
	customText(&juice_name, locations + CONST_locations007),
	customText(&juice_name_2, locations + CONST_locations008),
	customText(&vegan_name, locations + CONST_locations009),
	customText(&vegan_name_2, locations + CONST_locations010),
	customText(&cafe_name, locations + CONST_locations011),
	customText(&cafe_name_2, locations + CONST_locations012),
	customText(&latte_name, locations + CONST_locations013),
	customText(&latte_name_2, locations + CONST_locations014),
};
void Location::init()
{
	haveflag = 0;
	newrental = 0;
	heat = 0;
	heat_protection = 0;
	closed = 0;
	mapped = 0;
	highsecurity = 0;
	initOtherRNG(mapseed);
	changes.clear();
	compound_walls = 0;
	compound_stores = 0;
	front_business = -1;
}
map<short, string> getCityDescription;
string Location::city_description()
{
	if (getCityDescription.count(type)) {
		return getCityDescription[type];
	}
	else {
		return blankString;
	}
}
bool Location::can_be_fortified()
{
	if (!upgradable) return false;
	switch (type)
	{
	default:
		return !fortified();
	case SITE_OUTDOOR_BUNKER:
	case SITE_BUSINESS_BARANDGRILL:
		return false;
	}
}
bool Location::fortified()
{
	switch (type)
	{
	default:
		return compound_walls & COMPOUND_BASIC;
	case SITE_OUTDOOR_BUNKER:
		return true;
	}
}
bool Location::can_be_trapped()
{
	if (!upgradable) return false;
	return !trapped();
}
bool Location::can_install_tanktraps()
{
	if (!upgradable) return false;
	switch (type)
	{
	default:
		return !tank_traps();
	case SITE_BUSINESS_BARANDGRILL:
	case SITE_OUTDOOR_BUNKER:
	case SITE_RESIDENTIAL_BOMBSHELTER:
		return false;
	}
}
bool Location::tank_traps()
{
	switch (type)
	{
	default:
		return compound_walls & COMPOUND_TANKTRAPS;
	case SITE_OUTDOOR_BUNKER:
	case SITE_RESIDENTIAL_BOMBSHELTER:
		return true;
	}
}
bool Location::can_have_businessfront()
{
	if (!upgradable) return false;
	switch (type)
	{
	default:
		return !has_business_front();
	case SITE_BUSINESS_BARANDGRILL:
	case SITE_OUTDOOR_BUNKER:
	case SITE_RESIDENTIAL_BOMBSHELTER:
		return false;
	}
}
bool Location::has_business_front()
{
	return front_business != -1 ||
		type == SITE_BUSINESS_BARANDGRILL;
}
bool Location::bomb_resistant()
{
	return type == SITE_RESIDENTIAL_BOMBSHELTER;
}
bool Location::part_of_justice_system()
{
	return type == SITE_GOVERNMENT_POLICESTATION ||
		type == SITE_GOVERNMENT_COURTHOUSE ||
		type == SITE_GOVERNMENT_PRISON;
}
void Location::rename(const char* name_, const char* shortname_)
{
	strcpy(this->name, name_);
	strcpy(this->shortname, shortname_);
}
map<short, vector<string> > getSiteName;
/* daily - seeds and names a site (will re-seed and rename if used after start) */
void initlocation(Location &loc)
{  // NOTE: make sure to keep code here matching code in updateworld_laws() in monthly.cpp for when names are changed
	extern short lawList[LAWNUM];
	loc.init();
	switch (loc.type)
	{
	case SITE_CITY_SEATTLE:
	case SITE_CITY_LOS_ANGELES:
	case SITE_CITY_NEW_YORK:
	case SITE_CITY_CHICAGO:
	case SITE_CITY_DETROIT:
	case SITE_CITY_ATLANTA:
	case SITE_CITY_MIAMI:
	case SITE_CITY_WASHINGTON_DC:
	case SITE_DOWNTOWN:
	case SITE_UDISTRICT:
	case SITE_COMMERCIAL:
	case SITE_INDUSTRIAL:
	case SITE_OUTOFTOWN:
	case SITE_TRAVEL:
		loc.rename(getSiteName[loc.type][0].data(), getSiteName[loc.type][1].data());
		break;
	case SITE_GOVERNMENT_POLICESTATION:
		if (lawList[LAW_POLICEBEHAVIOR] == -2 && lawList[LAW_DEATHPENALTY] == -2) {
			loc.rename(CONST_locations015.c_str(), CONST_locations015.c_str());
		}
		else {
			loc.rename(CONST_locations016.c_str(), CONST_locations016.c_str());
		} break;
	case SITE_GOVERNMENT_COURTHOUSE:
		if (lawList[LAW_DEATHPENALTY] == -2) {
			loc.rename(CONST_locations017.c_str(), CONST_locationsB109.c_str());
		}
		else {
			loc.rename(CONST_locations018.c_str(), CONST_locations018.c_str());
		} break;
	case SITE_GOVERNMENT_FIRESTATION:
		if (lawList[LAW_FREESPEECH] == -2) {
			loc.rename(CONST_locations019.c_str(), CONST_locations019.c_str());
			loc.hidden = false;
		}
		else {
			loc.rename(CONST_locations020.c_str(), CONST_locations020.c_str());
			loc.hidden = true;
		} break;
	case SITE_GOVERNMENT_PRISON:
		if (lawList[LAW_PRISONS] == -2)
		{
			strcpy(loc.name, pickrandom(labor_camp_name).data());
			strcat(loc.name, singleSpace.data());
			strcat(loc.name, pickrandom(labor_camp_name_2).data());
			strcat(loc.name, CONST_locations021.c_str());
			strcpy(loc.shortname, CONST_locations022.c_str());
		}
		else
		{
			strcpy(loc.name, lastname(true).data());
			strcat(loc.name, CONST_locations023.c_str());
			strcpy(loc.shortname, CONST_locations024.c_str());
		}
		break;
	case SITE_INDUSTRY_NUCLEAR:
		if (lawList[LAW_NUCLEARPOWER] == 2) {
			loc.rename(CONST_locations025.c_str(), CONST_locationsB110.c_str());
		}
		else {
			loc.rename(CONST_locations026.c_str(), CONST_locationsB111.c_str());
		} break;
	case SITE_GOVERNMENT_INTELLIGENCEHQ:
		if (lawList[LAW_PRIVACY] == -2 && lawList[LAW_POLICEBEHAVIOR] == -2) {
			loc.rename(CONST_locations027.c_str(), CONST_locationsB112.c_str());
		}
		else {
			loc.rename(CONST_locations028.c_str(), CONST_locationsB113.c_str());
		} break;
	case SITE_GOVERNMENT_ARMYBASE:
		if (lawList[LAW_MILITARY] == -2) {
			loc.rename(CONST_locations029.c_str(), CONST_locationsB114.c_str());
		}
		else {
			strcpy(loc.name, lastname(true).data());
			strcat(loc.name, CONST_locations030.c_str());
			strcpy(loc.shortname, CONST_locations031.c_str());
		} break;
	case SITE_GOVERNMENT_WHITE_HOUSE:
		loc.rename(CONST_locations032.c_str(), CONST_locations032.c_str());
		break;
	case SITE_CORPORATE_HEADQUARTERS:
		loc.rename(CONST_locations033.c_str(), CONST_locationsB115.c_str());
		break;
	case SITE_BUSINESS_BANK:
		loc.rename(CONST_locations034.c_str(), CONST_locationsB116.c_str());
		break;
	case SITE_BUSINESS_PAWNSHOP:
		strcpy(loc.name, lastname(true).data());
		if (lawList[LAW_GUNCONTROL] == ALIGN_ELITELIBERAL)
			strcat(loc.name, CONST_locations035.c_str());
		else
			strcat(loc.name, CONST_locations036.c_str());
		strcpy(loc.shortname, CONST_locations037.c_str());
		break;
	case SITE_CORPORATE_HOUSE:
		if (lawList[LAW_CORPORATE] == -2 && lawList[LAW_TAX] == -2)
			loc.rename(CONST_locations038.c_str(), CONST_locations038.c_str());
		else
			loc.rename(CONST_locations039.c_str(), CONST_locationsB117.c_str());
		break;
	case SITE_RESIDENTIAL_SHELTER:
		loc.rename(CONST_locations040.c_str(), CONST_locationsB118.c_str());
		break;
	case SITE_INDUSTRY_WAREHOUSE:
		do {
			strcpy(loc.name, CONST_locations041.c_str());
			/*lastname(loc.name,true);
			strcat(loc.name,singleSpace);*/
			switch (LCSrandom(10))
			{
			case 0:
				strcat(loc.name, CONST_locations043.c_str());
				strcpy(loc.shortname, CONST_locations043.c_str());
				break;
			case 1:
				strcat(loc.name, CONST_locations045.c_str());
				strcpy(loc.shortname, CONST_locations045.c_str());
				break;
			case 2:
				strcat(loc.name, CONST_locations047.c_str());
				strcpy(loc.shortname, CONST_locations047.c_str());
				break;
			case 3:
				strcat(loc.name, CONST_locations048.c_str());
				strcpy(loc.shortname, CONST_locations049.c_str());
				break;
			case 4:
				strcat(loc.name, CONST_locations050.c_str());
				strcpy(loc.shortname, CONST_locations051.c_str());
				break;
			case 5:
				strcat(loc.name, CONST_locations052.c_str());
				strcpy(loc.shortname, CONST_locations053.c_str());
				break;
			case 6:
				strcat(loc.name, CONST_locations054.c_str());
				strcpy(loc.shortname, CONST_locations055.c_str());
				break;
			case 7:
				strcat(loc.name, CONST_locations056.c_str());
				strcpy(loc.shortname, CONST_locations057.c_str());
				break;
			case 8:
				strcat(loc.name, CONST_locations058.c_str());
				strcpy(loc.shortname, CONST_locations059.c_str());
				break;
			case 9:
				strcat(loc.name, CONST_locations060.c_str());
				strcpy(loc.shortname, CONST_locations061.c_str());
				break;
			}
		} while (loc.duplicatelocation());
		break;
	case SITE_INDUSTRY_POLLUTER:
		switch (LCSrandom(5))
		{
		case 0:
			loc.rename(CONST_locations062.c_str(), CONST_locationsB119.c_str());
			break;
		case 1:
			loc.rename(CONST_locations063.c_str(), CONST_locationsB120.c_str());
			break;
		case 2:
			loc.rename(CONST_locations064.c_str(), CONST_locationsB121.c_str());
			break;
		case 3:
			loc.rename(CONST_locations065.c_str(), CONST_locations065.c_str());
			break;
		case 4:
			loc.rename(CONST_locations066.c_str(), CONST_locationsB122.c_str());
			break;
		}
		break;
	case SITE_MEDIA_CABLENEWS:
		loc.rename(CONST_locations067.c_str(), CONST_locationsB123.c_str());
		break;
	case SITE_MEDIA_AMRADIO:
		loc.rename(CONST_locations068.c_str(), CONST_locationsB124.c_str());
		break;
	case SITE_RESIDENTIAL_APARTMENT_UPSCALE:
		do {
			strcpy(loc.name, lastname(true).data());
			strcpy(loc.shortname, loc.name);
			strcat(loc.name, CONST_locations069.c_str());
			strcat(loc.shortname, CONST_locations070.c_str());
		} while (loc.duplicatelocation());
		break;
	case SITE_RESIDENTIAL_APARTMENT:
		do {
			strcpy(loc.name, lastname(true).data());
			strcpy(loc.shortname, loc.name);
			strcat(loc.name, CONST_locations071.c_str());
			strcat(loc.shortname, CONST_locations072.c_str());
		} while (loc.duplicatelocation());
		break;
	case SITE_RESIDENTIAL_TENEMENT:
		do {
			do {
				strcpy(loc.name, lastname(true).data());
			} while (len(loc.name) > 7);
			strcat(loc.name, CONST_locations073.c_str());
			strcpy(loc.shortname, CONST_locations074.c_str());
		} while (loc.duplicatelocation());
		break;
	case SITE_HOSPITAL_UNIVERSITY:
		loc.rename(CONST_locations075.c_str(), CONST_locationsB125.c_str());
		break;
	case SITE_HOSPITAL_CLINIC:
		loc.rename(CONST_locations076.c_str(), CONST_locationsB126.c_str());
		break;
	case SITE_LABORATORY_GENETIC:
		strcpy(loc.name, lastname(true).data());
		strcat(loc.name, CONST_locations077.c_str());
		strcpy(loc.shortname, CONST_locations078.c_str());
		break;
	case SITE_LABORATORY_COSMETICS:
		strcpy(loc.name, lastname(true).data());
		strcat(loc.name, CONST_locations079.c_str());
		strcpy(loc.shortname, CONST_locations080.c_str());
		break;
	case SITE_BUSINESS_CARDEALERSHIP:
		generate_name(loc.name, GENDER_WHITEMALEPATRIARCH);
		strcat(loc.name, CONST_locations081.c_str());
		strcpy(loc.shortname, CONST_locations082.c_str());
		break;
	case SITE_BUSINESS_DEPTSTORE:
		strcpy(loc.name, lastname(true).data());
		strcat(loc.name, CONST_locations083.c_str());
		strcpy(loc.shortname, CONST_locations084.c_str());
		break;
	case SITE_BUSINESS_HALLOWEEN:
		loc.rename(CONST_locations085.c_str(), CONST_locationsB127.c_str());
		break;
	case SITE_INDUSTRY_SWEATSHOP:
		strcpy(loc.name, lastname(true).data());
		strcat(loc.name, CONST_locations086.c_str());
		strcpy(loc.shortname, CONST_locations087.c_str());
		break;
	case SITE_BUSINESS_CRACKHOUSE:
		do {
			strcpy(loc.name, lastname(true).data());
			strcat(loc.name, CONST_locations088.c_str());
			if (lawList[LAW_DRUGS] == 2)
			{
				switch (LCSrandom(4))
				{
					//TODO IsaacG Migrate Strings
				case 0:
					strcat(loc.name, CONST_locations089.c_str());
					strcpy(loc.shortname, CONST_locations090.c_str());
					break;
				case 1:
					strcat(loc.name, CONST_locations092.c_str());
					strcpy(loc.shortname, CONST_locations092.c_str());
					break;
				case 2:
					strcat(loc.name, CONST_locations094.c_str());
					strcpy(loc.shortname, CONST_locations094.c_str());
					break;
				case 3:
					strcat(loc.name, CONST_locations095.c_str());
					strcpy(loc.shortname, CONST_locations096.c_str());
					break;
				}
			}
			else
			{
				strcat(loc.name, CONST_locations098.c_str());
				strcpy(loc.shortname, CONST_locations098.c_str());
			}
		} while (loc.duplicatelocation());
	break; case SITE_BUSINESS_JUICEBAR:
		strcpy(loc.name, blankString.c_str());
		strcat(loc.name, pickrandom(juice_name).data());
		strcat(loc.name, singleSpace.data());
		strcat(loc.name, pickrandom(juice_name_2).data());
		strcat(loc.name, CONST_locations099.c_str());
		strcpy(loc.shortname, CONST_locations100.c_str());
		break;
	case SITE_BUSINESS_VEGANCOOP:
		strcpy(loc.name, blankString.c_str());
		strcat(loc.name, pickrandom(vegan_name).data());
		strcat(loc.name, singleSpace.data());
		strcat(loc.name, pickrandom(vegan_name_2).data());
		strcat(loc.name, CONST_locations101.c_str());
		strcpy(loc.shortname, CONST_locations102.c_str());
		break;
	case SITE_BUSINESS_INTERNETCAFE:
		strcpy(loc.name, blankString.c_str());
		strcat(loc.name, pickrandom(cafe_name).data());
		strcat(loc.name, singleSpace.data());
		strcat(loc.name, pickrandom(cafe_name_2).data());
		strcat(loc.name, CONST_locations103.c_str());
		strcpy(loc.shortname, CONST_locations104.c_str());
		break;
	case SITE_BUSINESS_CIGARBAR:
		strcpy(loc.name, tag_The.c_str());
		strcat(loc.name, lastname(true).data());
		strcat(loc.name, CONST_locations105.c_str());
		strcpy(loc.shortname, CONST_locations106.c_str());
		break;
	case SITE_BUSINESS_LATTESTAND:
		strcpy(loc.name, blankString.c_str());
		strcat(loc.name, pickrandom(latte_name).data());
		strcat(loc.name, singleSpace.data());
		strcat(loc.name, pickrandom(latte_name_2).data());
		strcat(loc.name, CONST_locations107.c_str());
		strcpy(loc.shortname, CONST_locations108.c_str());
		break;
	case SITE_OUTDOOR_PUBLICPARK:
		strcpy(loc.name, lastname(true).data());
		strcat(loc.name, CONST_locations109.c_str());
		strcpy(loc.shortname, CONST_locations110.c_str());
		break;
	case SITE_RESIDENTIAL_BOMBSHELTER:
		loc.rename(CONST_locations111.c_str(), CONST_locationsB128.c_str());
		break;
	case SITE_BUSINESS_BARANDGRILL:
		loc.rename(CONST_locations112.c_str(), CONST_locationsB129.c_str());
		break;
	case SITE_OUTDOOR_BUNKER:
		loc.rename(CONST_locations113.c_str(), CONST_locationsB130.c_str());
		break;
	case SITE_BUSINESS_ARMSDEALER:
		loc.rename(CONST_locations114.c_str(), CONST_locations114.c_str());
		break;
	}
}

const string CONST_loottype009 = "::cloth: ";
const string CONST_loottype008 = "Invalid boolean value for loot type ";
const string CONST_loottype007 = "::no_quick_fencing: ";
const string CONST_loottype005 = "::stackable: ";

const string tag_cloth = "cloth";
const string tag_no_quick_fencing = "no_quick_fencing";
const string tag_stackable = "stackable";
#include "../items/loottype.h"
LootType::LootType(MCD_STR xmlstring)
	: ItemType(xmlstring), stackable_(true),
	no_quick_fencing_(false), cloth_(false)
{
	CMarkup xml;
	xml.SetDoc(xmlstring);
	xml.FindElem();
	xml.IntoElem();
	while (xml.FindElem()) //Loop over all the elements inside the loottype element.
	{
		std::string element = xml.GetTagName();
		if (element == tag_stackable)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				stackable_ = true;
			else if (b == 0)
				stackable_ = false;
			/*else
			errorlog << CONST_loottype008 << idname
			<< CONST_loottype005 << xml.GetData() << std::endl;*/
		}
		else if (element == tag_no_quick_fencing)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				no_quick_fencing_ = true;
			else if (b == 0)
				no_quick_fencing_ = false;
			/*else
			errorlog << CONST_loottype008 << idname
			<< CONST_loottype007 << xml.GetData() << std::endl;*/
		}
		else if (element == tag_cloth)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1)
				cloth_ = true;
			else if (b == 0)
				cloth_ = false;
			/*else
			errorlog << CONST_loottype008 << idname
			<< CONST_loottype009 << xml.GetData() << std::endl;*/
		}
	}
}


// #include "../includes.h"
const string CONST_miscC026 = "): ";

const string CONST_miscB025 = ".mid:  ";
const string CONST_miscB024 = ".mid";
const string CONST_miscB023 = ".ogg:  ";
const string CONST_miscB022 = ".ogg";
const string CONST_miscB021 = "/";
const string CONST_miscB020 = ".mid as MIDI fallback)";
const string CONST_misc019 = "1234567890-";
const string CONST_misc018 = "SDL_mixer function Mix_PlayMusic() failed:  ";
const string CONST_misc017 = "Pastorale";
const string CONST_misc016 = "Mars";
const string CONST_misc015 = "Ogg Vorbis support failed to load. MIDI music will be used instead if possible.";
const string CONST_misc014 = "Unable to initialize SDL_mixer:  ";
const string CONST_misc013 = "Unable to initialize SDL:  ";
const string CONST_misc012 = "SDL_mixer function Mix_LoadMUS() failed to load ";
const string CONST_misc011 = "midi/";
const string CONST_misc009 = "ogg/";
const string CONST_misc008 = "Loading MIDI music (";
const string CONST_misc007 = "(with ";
const string CONST_misc006 = "Loading Ogg Vorbis music (";
const string CONST_misc005 = "listOfStates.txt";
const string CONST_misc004 = "sextypeAcronym.txt";
const string CONST_misc003 = "sexseekAcronym.txt";
const string CONST_misc002 = "sexwhoAcronym.txt";
const string CONST_misc001 = "sexdescAcronym.txt";

/* pick a descriptor acronym */
vector<string> sexdescAcronym;
/* what kind of person? */
vector<string> sexwhoAcronym;
/* seeking acronym */
vector<string> sexseekAcronym;
/* what type of sex? */
vector<string> sextypeAcronym;
map<short, string> musicList;

string sexdesc()
{
	return pickrandom(sexdescAcronym);
}
string sexwho()
{
	return pickrandom(sexwhoAcronym);
}
string sexseek()
{
	return pickrandom(sexseekAcronym);
}
string sextype()
{
	return pickrandom(sextypeAcronym);
}
vector<string> listOfStates;
vector<file_and_text_collection> misc_text_file_collection = {
	customText(&sexdescAcronym, mostlyendings + CONST_misc001),
	customText(&sexwhoAcronym, mostlyendings + CONST_misc002),
	customText(&sexseekAcronym, mostlyendings + CONST_misc003),
	customText(&sextypeAcronym, mostlyendings + CONST_misc004),
	customText(&listOfStates, mostlyendings + CONST_misc005),
};

#ifndef DONT_INCLUDE_SDL
bool oggsupport = true;
Mix_Music* songs[MUSIC_OFF];
bool songsinitialized = false;
int musicmode = MUSIC_OFF;
int previous = MUSIC_OFF;
/* helper function for initsongs() */
void loadsong(int i, const char* filename)
{
	extern Log gamelog;
	extern char artdir[MAX_PATH_SIZE];
	// the reason it prints progress on the screen is because it might be a little slow sometimes so this reassures the user progress is being made
	eraseAlt();
	if (oggsupport)
	{
		mvaddstrAlt(12, 0, CONST_misc006 + tostring(i + 1) + CONST_miscB021 + tostring(MUSIC_OFF) + CONST_miscC026 + artdir + CONST_misc009 + filename + CONST_miscB022);
		mvaddstrAlt(13, 0, string(CONST_misc007) + artdir + CONST_misc011 + filename + CONST_miscB020);
	}
	else mvaddstrAlt(12, 0, CONST_misc008 + tostring(i + 1) + CONST_miscB021 + tostring(MUSIC_OFF) + CONST_miscC026 + artdir + CONST_misc011 + filename + CONST_miscB024);
	refreshAlt();
	if (oggsupport) songs[i] = Mix_LoadMUS((string(artdir) + CONST_misc009 + filename + CONST_miscB022).c_str()); // only attempt loading Ogg if we have Ogg support
	if (!songs[i] || !oggsupport) // it failed to load Ogg Vorbis music or Ogg support doesn't exist, let's try MIDI instead
	{
		if (oggsupport) gamelog.log(string(CONST_misc012) + artdir + CONST_misc009 + filename + CONST_miscB023 + Mix_GetError()); // Ogg Vorbis music failed to load
		songs[i] = Mix_LoadMUS((string(artdir) + CONST_misc011 + filename + CONST_miscB024).c_str());
	}
	if (!songs[i]) // there was an error with Mix_LoadMUS() when called on the MIDI file
		gamelog.log(string(CONST_misc012) + artdir + CONST_misc011 + filename + CONST_miscB025 + Mix_GetError()); // MIDI music failed to load
}
#endif // DONT_INCLUDE_SDL
/* initialize SDL, SDL_mixer, and songs */
void MusicClass::init()
{
#ifndef DONT_INCLUDE_SDL
	extern Log gamelog;
	if (songsinitialized) return; // only initialize once
	if (SDL_Init(SDL_INIT_AUDIO) != 0) // initialize what we need from SDL for audio
	{  // SDL failed to initialize, so log it and exit
		addstrAlt(string(CONST_misc013) + SDL_GetError(), gamelog);
		gamelog.nextMessage();
		pressAnyKey();
		endwinAlt();
		exit(EXIT_FAILURE);
	}
	if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 4096) != 0) // initialize the audio mixer at 44.1 kHz with a large buffer size, since we're just playing music not sound effects
	{  // SDL_mixer failed to initialize, so log it and exit
		addstrAlt(string(CONST_misc014) + Mix_GetError(), gamelog);
		gamelog.nextMessage();
		pressAnyKey();
		SDL_Quit();
		endwinAlt();
		exit(EXIT_FAILURE);
	}
	if ((Mix_Init(MIX_INIT_OGG | MIX_INIT_FLUIDSYNTH)&MIX_INIT_OGG) != MIX_INIT_OGG) // initialize Ogg Vorbis support (and FluidSynth if it's there for better MIDI quality)
	{  // Ogg Vorbis support failed to load, we'll use MIDI instead
		gamelog.log(CONST_misc015);
		gamelog.nextMessage();
		oggsupport = false;
	}
	else oggsupport = true; // we have Ogg Vorbis support!

							// titlemode.ogg or .mid - Also sprach Zarathustra, introduction by Richard Strauss
	loadsong(MUSIC_TITLEMODE, musicList[MUSIC_TITLEMODE].data()), // load title mode music
																  // newgame.ogg or .mid- The Liberty Bell March by John Philip Sousa
		loadsong(MUSIC_NEWGAME, musicList[MUSIC_NEWGAME].data()), // load new game music
																  // basemode.ogg or .mid - The Stars and Stripes Forever by John Philip Sousa
		loadsong(MUSIC_BASEMODE, musicList[MUSIC_BASEMODE].data()), // load regular base mode music
																	// siege.ogg or .mid- The Planets, 1st Movement CONST_misc016 by Gustav Holst
		loadsong(MUSIC_SIEGE, musicList[MUSIC_SIEGE].data()), // load base mode while under siege music
															  // activate.ogg or .mid - Piano Sonata #11, 3rd Movement "Rondo Alla Turca" by Wolfgang Amadeus Mozart
		loadsong(MUSIC_ACTIVATE, musicList[MUSIC_ACTIVATE].data()), // load activate Liberals music
																	// sleepers.ogg or .mid - Toccata and Fugue in D Minor, BWV 565 by Johann Sebastian Bach
		loadsong(MUSIC_SLEEPERS, musicList[MUSIC_SLEEPERS].data()), // load activate Sleepers music
																	// stopevil.ogg or .mid - Hungarian Dance #5 by Johannes Brahms (based on the csardas "Bartfai emlek" by Bela Keler)
		loadsong(MUSIC_STOPEVIL, musicList[MUSIC_STOPEVIL].data()), // load go forth to stop evil music
																	// reviewmode.ogg or .mid - Symphony #94, 2nd Movement "Surprise Symphony" by Joseph Haydn
		loadsong(MUSIC_REVIEWMODE, musicList[MUSIC_REVIEWMODE].data()), // load review mode music
																		// liberalagenda.ogg or .mid - Beautiful Dreamer by Stephen Foster
		loadsong(MUSIC_LIBERALAGENDA, musicList[MUSIC_LIBERALAGENDA].data()), // load status of the Liberal agenda music
																			  // disbanded.ogg or .mid - La Cucaracha, a traditional Mexican folk song originally from Spain
		loadsong(MUSIC_DISBANDED, musicList[MUSIC_DISBANDED].data()), // load disbanded music
																	  // finances.ogg or .mid - Minuet in G Major by Christian Petzold (falsely attributed to Johann Sebastian Bach until 1970)
		loadsong(MUSIC_FINANCES, musicList[MUSIC_FINANCES].data()), // load finance report music
																	// cartheft.ogg or .mid - The Ride of the Valkyries by Richard Wanger
		loadsong(MUSIC_CARTHEFT, musicList[MUSIC_CARTHEFT].data()), // load car theft music
																	// elections.ogg or .mid - Habanera from Carmen by Georges Bizet
		loadsong(MUSIC_ELECTIONS, musicList[MUSIC_ELECTIONS].data()), // load elections music
																	  // shopping.ogg or .mid - The Entertainer by Scott Joplin
		loadsong(MUSIC_SHOPPING, musicList[MUSIC_SHOPPING].data()), // load shopping music
																	// sitemode.ogg or .mid - Dance of the Sugar Plum Fairy by Pyotr Ilyich Tchaikovsky
		loadsong(MUSIC_SITEMODE, musicList[MUSIC_SITEMODE].data()), // load site mode music
																	// suspicious.ogg or .mid - Hall of the Mountain King by Edvard Grieg
		loadsong(MUSIC_SUSPICIOUS, musicList[MUSIC_SUSPICIOUS].data()), // load suspicious music
																		// alarmed.ogg or .mid - 5th Symphony, 1st Movement by Ludwig van Beethoven
		loadsong(MUSIC_ALARMED, musicList[MUSIC_ALARMED].data()), // load alarmed music
																  // heavycombat.ogg or .mid - 6th Symphony CONST_misc017, 4th Movement by Ludwig van Beethoven
		loadsong(MUSIC_HEAVYCOMBAT, musicList[MUSIC_HEAVYCOMBAT].data()), // load massive Conservative response music
																		  // defense.ogg or .mid - Danse Macabre by Camille Saint-Saens
		loadsong(MUSIC_DEFENSE, musicList[MUSIC_DEFENSE].data()), // load escaping/engaging a siege music
																  // conquer.ogg or .mid - Infernal Galop / Can-Can from Orpheus in the Underworld by Jacques Offenbach
		loadsong(MUSIC_CONQUER, musicList[MUSIC_CONQUER].data()), // load success in conquering a siege or safehouse or the CCS music
																  // carchase.ogg or .mid - The William Tell Overture by Gioacchino Antonio Rossini
		loadsong(MUSIC_CARCHASE, musicList[MUSIC_CARCHASE].data()), // load car chase music
																	// footchase.ogg or .mid - The Maple Leaf Rag by Scott Joplin
		loadsong(MUSIC_FOOTCHASE, musicList[MUSIC_FOOTCHASE].data()), // load foot chase music
																	  // InterrogationST.ogg or .mid - Night on Bald Mountain by Modest Mussorgsky
		loadsong(MUSIC_INTERROGATION, musicList[MUSIC_INTERROGATION].data()), // load InterrogationST music
																			  // trial.ogg or .mid - Hungarian Rhapsody #2 by Franz Liszt
		loadsong(MUSIC_TRIAL, musicList[MUSIC_TRIAL].data()), // load trial music
															  // recruiting.ogg or .mid - Dance of the Hours by Amilcare Ponchielli
		loadsong(MUSIC_RECRUITING, musicList[MUSIC_RECRUITING].data()), // load recruiting music
																		// dating.ogg or .mid - The Blue Danube Waltz by Johann Strauss Jr.
		loadsong(MUSIC_DATING, musicList[MUSIC_DATING].data()), // load dating music
																// newspaper.ogg or .mid - Eine Kleine Nachtmusik, 1st Movement by Wolfgang Amadeus Mozart
		loadsong(MUSIC_NEWSPAPER, musicList[MUSIC_NEWSPAPER].data()), // load newspaper music
																	  // lacops.ogg or .mid - The Flight of the Bumblebee by Nikolai Rimsky-Korsakov
		loadsong(MUSIC_LACOPS, musicList[MUSIC_LACOPS].data()), // load LA cops beating black man and getting caught on video music
																// newscast.ogg or .mid - La Marseillaise, The French National Anthem by Claude Joseph Rouget de Lisle
		loadsong(MUSIC_NEWSCAST, musicList[MUSIC_NEWSCAST].data()), // load newscast where smart liberal guest gets some words in edgewise music
																	// glamshow.ogg or .mid - Das Deutschlandlied, The German National Anthem by Joseph Haydn
		loadsong(MUSIC_GLAMSHOW, musicList[MUSIC_GLAMSHOW].data()), // load glamorous TV show about lifestyles of the rich and famous music
																	// anchor.ogg or .mid - I Am the Very Model of a Modern Major-General by Sir Arthur Seymour Sullivan
		loadsong(MUSIC_ANCHOR, musicList[MUSIC_ANCHOR].data()), // load handsome charismatic new Conservative cable news anchor music
																// abort.ogg or .mid - Tarantella Napoletana, a traditional Italian folk song from Naples
		loadsong(MUSIC_ABORT, musicList[MUSIC_ABORT].data()), // load failed partial birth abortion on trashy daytime talk show music
															  // victory.ogg or .mid - The Star-Spangled Banner, The U.S. National Anthem by John Stafford Smith
		loadsong(MUSIC_VICTORY, musicList[MUSIC_VICTORY].data()), // load victory music
																  // defeat.ogg or .mid - Piano Sonata #2, 3rd Movement "Funeral March" by Frederic Francois Chopin
		loadsong(MUSIC_DEFEAT, musicList[MUSIC_DEFEAT].data()), // load defeat music
																// reagainified.ogg or .mid - Dixie, The Confederate National Anthem by Daniel Decatur Emmett
		loadsong(MUSIC_REAGANIFIED, musicList[MUSIC_REAGANIFIED].data()), // load Reaganified music
																		  // stalinized.ogg or .mid - The Soviet (and now Russian) National Anthem by Alexander Vasilyevich Alexandrov
		loadsong(MUSIC_STALINIZED, musicList[MUSIC_STALINIZED].data()), // load Stalinized music
		eraseAlt();
	refreshAlt();
	songsinitialized = true;
#endif // DONT_INCLUDE_SDL
}
/* shut down SDL, SDL_mixer, and songs */
void MusicClass::quit()
{
#ifndef DONT_INCLUDE_SDL
	extern MusicClass music;
	if (!songsinitialized) return; // only shut down once
	music.play(MUSIC_OFF);
	for (int c = 0; c < MUSIC_OFF; c++) if (songs[c]) Mix_FreeMusic(songs[c]);
	while (Mix_Init(0)) Mix_Quit();
	Mix_CloseAudio();
	SDL_Quit();
	songsinitialized = false;
#endif // DONT_INCLUDE_SDL
}
/* play music specified by a MusicMode */
void MusicClass::play(int _musicmode)
{
#ifndef DONT_INCLUDE_SDL
	extern Log gamelog;
	if (!songsinitialized) init(); // if it hasn't been initialized already, do it now
	if (_musicmode == MUSIC_CURRENT) return; // keep playing current music if that's what's requested
	if (_musicmode == MUSIC_RANDOM) _musicmode = LCSrandom(MUSIC_OFF); // play a random song if that's what's requested
	if (_musicmode == MUSIC_PREVIOUS) _musicmode = previous; // restore previous setting if that's what's requested
	if (musicmode == _musicmode) return; // already playing the right music
	previous = musicmode; // store previous setting
	musicmode = _musicmode; // set musicmode to input
	Mix_HaltMusic(); // stop any music that we're playing
	if (musicmode < 0 || musicmode >= MUSIC_OFF)
	{
		musicmode = MUSIC_OFF; // just in case we had odd input, make sure we keep track that music is off
		return; // return without playing music
	}
	if (!songs[musicmode]) // there was an error with Mix_LoadMUS() back when it was called on this song
		return; // we can't play music if it isn't loaded, might as well return
	if (Mix_PlayMusic(songs[musicmode], -1) != 0) // start playing the music, and have it loop indefinitely
		gamelog.log(string(CONST_misc018) + Mix_GetError()); // Music failed to play
	enableIf(isEnabled());
#endif // DONT_INCLUDE_SDL
}
Interval::Interval() : min(0), max(0) { }
Interval::Interval(int value) : min(value), max(value) { }
Interval::Interval(int low, int high) : min(low), max(high) { }
void Interval::set_interval(int low, int high) { min = low, max = high; }
// Sets the interval according to a string that is either a number or two
// number separated by a dash. Returns false and does not change the
// interval if the given string is not a valid interval.
// Sets the interval according to a string that is either a number or two
// number separated by a dash. Returns false and does not change the
// interval if the given string is not a valid interval.
bool valid(const string& v);
bool Interval::set_interval(const string& interval)
{
	if (!len(interval) ||
		interval.find_first_not_of(CONST_misc019) != string::npos)
		return false;
	size_t dashpos = interval.find('-', 1);
	if (dashpos == string::npos) // Just a constant.
	{
		if (!valid(interval)) return false;
		max = min = atoi(interval.c_str());
	}
	else
	{
		string smin = interval.substr(0, dashpos), smax = interval.substr(dashpos + 1);
		if (!valid(smin) || !valid(smax)) return false;
		int tmin = atoi(smin.c_str()), tmax = atoi(smax.c_str());
		if (tmin > tmax) return false;
		min = tmin, max = tmax;
	}
	return true;
}
int Interval::roll() const { return LCSrandom(max - min + 1) + min; }
bool valid(const string& v)
{
	return len(v) &&                       // Blank string is invalid.
		(len(v) != 1 || v[0] != '-') &&        // Just a dash is invalid.
		v.find('-', 1) == string::npos;
}
Ledger::Ledger() : funds(7), total_income(0), total_expense(0)
{
	for (int i = 0; i < INCOMETYPENUM; i++) income[i] = 0, dailyIncome[i] = 0;
	for (int e = 0; e < EXPENSETYPENUM; e++) expense[e] = 0, dailyExpense[e] = 0;
}
class Ledger ledger;
int Ledger::get_funds() { return funds; }
void Ledger::force_funds(int amount) { funds = amount; }
void Ledger::add_funds(int amount, int incometype)
{
	funds += amount,
		income[incometype] += amount,
		dailyIncome[incometype] += amount,
		total_income += amount;
}
void Ledger::subtract_funds(int amount, int expensetype)
{
	funds -= amount,
		expense[expensetype] += amount,
		dailyExpense[expensetype] += amount,
		total_expense += amount;
}
void Ledger::resetMonthlyAmounts()
{
	for (int i = 0; i < INCOMETYPENUM; i++) income[i] = 0;
	for (int e = 0; e < EXPENSETYPENUM; e++) expense[e] = 0;
}
void Ledger::resetDailyAmounts()
{
	for (int i = 0; i < INCOMETYPENUM; i++) dailyIncome[i] = 0;
	for (int e = 0; e < EXPENSETYPENUM; e++) dailyExpense[e] = 0;
}
MusicClass::MusicClass() : enabled(true) { }
bool MusicClass::isEnabled() { return enabled; }
void MusicClass::enableIf(bool e)
{
	enabled = e;
#ifndef DONT_INCLUDE_SDL
	Mix_VolumeMusic(enabled*(MIX_MAX_VOLUME / 2)); // half volume if music enabled, muted if music disabled
#endif // DONT_INCLUDE_SDL
}

// #include "../includes.h"
const string CONST_miscactions077 = "You'll have to come back later.";
const string CONST_miscactions076 = "There's nobody left to carry the others.";
const string CONST_miscactions074 = "There's nobody left to carry ";
const string CONST_miscactions073 = " will have to haul a Liberal.";
const string CONST_miscactions072 = "so ";
const string CONST_miscactions071 = " from the Conservatives.";
const string CONST_miscactions070 = "You've rescued ";
const string CONST_miscactions067 = "at their desks.  The Squad might yet escape.";
const string CONST_miscactions066 = "The show was so good that security listened to it ";
const string CONST_miscactions065 = " that security watched it ";
const string CONST_miscactions064 = "entertaining";
const string CONST_miscactions063 = "hilarious";
const string CONST_miscactions062 = "The show was so ";
const string CONST_miscactions061 = "after the show!";
const string CONST_miscactions060 = "Security is waiting for the Squad ";
const string CONST_miscactions059 = "They no longer feel alienated.";
const string CONST_miscactions058 = "Moderates at the station appreciated the show.";
const string CONST_miscactions057 = ", the hostage, is kept off-air.";
const string CONST_miscactions056 = " is forced on to ";
const string CONST_miscactions055 = "The hostage ";
const string CONST_miscactions054 = "It was the best hour of AM radio EVER.";
const string CONST_miscactions053 = "It was thought-provoking, even humorous.";
const string CONST_miscactions052 = "The Squad put on a good show.";
const string CONST_miscactions051 = "The show was all right.";
const string CONST_miscactions050 = "It is mediocre radio.";
const string CONST_miscactions049 = "It is a very boring hour.";
const string CONST_miscactions048 = "The show really sucks.";
const string CONST_miscactions047 = "The Squad sounds wholly insane.";
const string CONST_miscactions046 = "It was the best hour of Cable TV EVER.";
const string CONST_miscactions042 = "It is mediocre TV.";
const string CONST_miscactions039 = "The Squad looks completely insane.";
const string CONST_miscactions038 = "The Squad takes control of the microphone and ";
const string CONST_miscactions037 = "The Squad steps in front of the cameras and ";
const string CONST_miscactions036 = "the broadcast never happens.";
const string CONST_miscactions035 = "The Conservatives in the room hurry the Squad, so ";
const string CONST_miscactions034 = "Including the BLIND HACKER you brought.";
const string CONST_miscactions033 = "You can't find anyone to do the job.";
const string CONST_miscactions032 = " bypass the vault's electronic lock.";
const string CONST_miscactions031 = " bypass the supercomputer security.";
const string CONST_miscactions030 = " see how to";
const string CONST_miscactions029 = " couldn't";
const string CONST_miscactions028 = "!";
const string CONST_miscactions027 = " despite being blind";
const string CONST_miscactions026 = " disabled the second layer of security";
const string CONST_miscactions025 = " burned a disk of top secret files";
const string CONST_miscactions024 = " has";
const string CONST_miscactions022 = " kicks the door";
const string CONST_miscactions021 = " rams into the door";
const string CONST_miscactions020 = "Alarms go off!";
const string CONST_miscactions018 = "kicks in the door";
const string CONST_miscactions017 = "rams open the door";
const string CONST_miscactions016 = "smashes in the door";
const string CONST_miscactions015 = "uses a crowbar on the door";
const string CONST_miscactions013 = " can't figure the lock out.";
const string CONST_miscactions012 = " is close, but can't quite get the lock open.";
const string CONST_miscactions010 = "cracks the combo locks";
const string CONST_miscactions009 = "unlocks the cell";
const string CONST_miscactions008 = "opens the armory";
const string CONST_miscactions007 = "cracks the safe";
const string CONST_miscactions006 = "unlocks the cage";
const string CONST_miscactions005 = "unlocks the door";
const string CONST_miscactions004 = "was_abused.txt";

void printparty();
char securityable(int type);

vector<string> was_abused;
vector<file_and_text_collection> misc_activities_text_file_collection = {
	/*miscactions.cpp*/
	customText(&was_abused, activities + CONST_miscactions004),
};
void fillEncounter(CreatureTypes c, int numleft);
map<short, string> discussIssues;
map<short, string> discussesIssues;
map<int, CheckDifficulty> unlockDifficulty = {
	map<int, CheckDifficulty>::value_type(UNLOCK_CAGE,        DIFFICULTY_VERYEASY),
	map<int, CheckDifficulty>::value_type(UNLOCK_CAGE_HARD,   DIFFICULTY_AVERAGE),
	map<int, CheckDifficulty>::value_type(UNLOCK_CELL,        DIFFICULTY_FORMIDABLE),
	map<int, CheckDifficulty>::value_type(UNLOCK_ARMORY,      DIFFICULTY_HEROIC),
	map<int, CheckDifficulty>::value_type(UNLOCK_SAFE,        DIFFICULTY_HEROIC),
	map<int, CheckDifficulty>::value_type(UNLOCK_VAULT,       DIFFICULTY_HEROIC),
};
char unlock(short type, char &actual)
{
	extern squadst *activesquad;
	extern Log gamelog;
	extern short cursite;
	extern short fieldskillrate;
	int difficulty = 0;
	if (type == UNLOCK_DOOR) {
		if (securityable(LocationsPool::getInstance().getLocationType(cursite)) == 1)
			difficulty = DIFFICULTY_CHALLENGING;
		else if (securityable(LocationsPool::getInstance().getLocationType(cursite)) > 1)
			difficulty = DIFFICULTY_HARD;
		else
			difficulty = DIFFICULTY_EASY;
	}
	else {
		if (unlockDifficulty.count(type)) {
			difficulty = unlockDifficulty[type];
		}
	}
	int maxattack = -1;
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] != NULL)
		{
			if (activesquad->squad[p]->alive)
			{
				if (activesquad->squad[p]->get_skill(SKILL_SECURITY) > maxattack)
				{
					maxattack = activesquad->squad[p]->get_skill(SKILL_SECURITY);
				}
			}
		}
	}
	vector<int> goodp;
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] != NULL)
		{
			if (activesquad->squad[p]->alive)
			{
				if (activesquad->squad[p]->get_skill(SKILL_SECURITY) == maxattack)
				{
					goodp.push_back(p);
				}
			}
		}
	}
	if (len(goodp))
	{
		int p = pickrandom(goodp);
		//lock pick succeeded.
		if (activesquad->squad[p]->skill_check(SKILL_SECURITY, difficulty))
		{
			//skill goes up in proportion to the chance of you failing.
			if (maxattack <= difficulty)
			{
				switch (fieldskillrate)
				{
				case FIELDSKILLRATE_FAST:
					activesquad->squad[p]->train(SKILL_SECURITY, 10 * difficulty); break;
				case FIELDSKILLRATE_CLASSIC:
					activesquad->squad[p]->train(SKILL_SECURITY, 1 + (difficulty - maxattack)); break;
				case FIELDSKILLRATE_HARD:
					activesquad->squad[p]->train(SKILL_SECURITY, 0); break;
				}
			}
			clearmessagearea(false);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, activesquad->squad[p]->name, gamelog);
			addstrAlt(singleSpace, gamelog);
			switch (type)
			{
			case UNLOCK_DOOR:addstrAlt(CONST_miscactions005, gamelog); break;
			case UNLOCK_CAGE_HARD:
			case UNLOCK_CAGE:addstrAlt(CONST_miscactions006, gamelog); break;
			case UNLOCK_SAFE:addstrAlt(CONST_miscactions007, gamelog); break;
			case UNLOCK_ARMORY:addstrAlt(CONST_miscactions008, gamelog); break;
			case UNLOCK_CELL:addstrAlt(CONST_miscactions009, gamelog); break;
			case UNLOCK_VAULT:addstrAlt(CONST_miscactions010, gamelog); break;
			}
			addstrAlt(CONST_miscactions028, gamelog);
			gamelog.newline();
			for (int j = 0; j < 6; j++) //If people witness a successful unlock, they learn a little bit.
			{
				if (j == p) continue;
				if (activesquad->squad[j] != NULL &&
					activesquad->squad[j]->alive&&
					activesquad->squad[j]->get_skill(SKILL_SECURITY) < difficulty)
				{
					if (activesquad->squad[j]->alive)
					{
						switch (fieldskillrate)
						{
						case FIELDSKILLRATE_FAST:
							activesquad->squad[j]->train(SKILL_SECURITY, 5 * difficulty); break;
						case FIELDSKILLRATE_CLASSIC:
							activesquad->squad[j]->train(SKILL_SECURITY, difficulty - activesquad->squad[j]->get_skill(SKILL_SECURITY)); break;
						case FIELDSKILLRATE_HARD:
							activesquad->squad[j]->train(SKILL_SECURITY, 0); break;
						}
					}
				}
			}
			pressAnyKey();
			actual = 1;
			return 1;
		}
		else
		{
			clearmessagearea(false);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			int i;
			//gain some experience for failing only if you could have succeeded.
			for (i = 0; i < 3; i++)
			{
				if (activesquad->squad[p]->skill_check(SKILL_SECURITY, difficulty))
				{
					switch (fieldskillrate)
					{
					case FIELDSKILLRATE_FAST:
						activesquad->squad[p]->train(SKILL_SECURITY, 50); break;
					case FIELDSKILLRATE_CLASSIC:
						activesquad->squad[p]->train(SKILL_SECURITY, 10); break;
					case FIELDSKILLRATE_HARD:
						activesquad->squad[p]->train(SKILL_SECURITY, 10); break;
					}
					mvaddstrAlt(16, 1, activesquad->squad[p]->name, gamelog);
					addstrAlt(CONST_miscactions012, gamelog);
					gamelog.newline();
					break;
				}
			}
			if (i == 3)
			{
				mvaddstrAlt(16, 1, activesquad->squad[p]->name, gamelog);
				addstrAlt(CONST_miscactions013, gamelog);
				gamelog.newline();
			}
			pressAnyKey();
			actual = 1;
			return 0;
		}
	}
	else
	{
		clearmessagearea();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, CONST_miscactions033, gamelog);
		gamelog.newline();
		pressAnyKey();
	}
	actual = 0;
	return 0;
}
/* bash attempt */
char bash(short type, char &actual)
{
	extern squadst *activesquad;
	extern Log gamelog;
	extern short sitealarmtimer;
	extern short sitealarm;
	extern short cursite;
	int difficulty = 0;
	bool crowable = false;
	switch (type)
	{
	case BASH_DOOR:
		if (!securityable(LocationsPool::getInstance().getLocationType(cursite)))
		{
			difficulty = DIFFICULTY_EASY; // Run down dump
			crowable = true;
		}
		else if (LocationsPool::getInstance().getLocationType(cursite) != SITE_GOVERNMENT_PRISON &&
			LocationsPool::getInstance().getLocationType(cursite) != SITE_GOVERNMENT_INTELLIGENCEHQ)
		{
			difficulty = DIFFICULTY_CHALLENGING; // Respectable place
			crowable = true;
		}
		else
		{
			difficulty = DIFFICULTY_FORMIDABLE; // Very high security
			crowable = false;
		}
		break;
	}
	if (crowable)
	{
		//if(!squadhasitem(*activesquad,ITEM_WEAPON,WEAPON_CROWBAR))
		//{
		crowable = false;
		for (int p = 0; p < 6; p++)
		{
			if (activesquad->squad[p] != NULL)
			{
				if (activesquad->squad[p]->get_weapon().auto_breaks_locks())
					crowable = true;
			}
		}
		if (!crowable) //didn't find in hands of any squad member
		{
			for (int l = 0; l < len(activesquad->loot); l++)
			{
				if (activesquad->loot[l]->whatIsThis() == THIS_IS_WEAPON)
				{
					Weapon *w = static_cast<Weapon*>(activesquad->loot[l]); //cast -XML
					if (w->auto_breaks_locks())
						crowable = true;
				}
			}
		}
		//}
	}
	int maxp = 0;
	if (!crowable)
	{
		int maxattack = 0;
		for (int p = 0; p < 6; p++)
		{
			if (activesquad->squad[p] != NULL)
			{
				if (activesquad->squad[p]->alive)
				{
					if (activesquad->squad[p]->get_attribute(ATTRIBUTE_STRENGTH, true)*
						activesquad->squad[p]->get_weapon().get_bashstrengthmod() > maxattack)
					{
						maxattack = static_cast<int>(activesquad->squad[p]->get_attribute(ATTRIBUTE_STRENGTH, true)*
							activesquad->squad[p]->get_weapon().get_bashstrengthmod());
						maxp = p;
					}
				}
			}
		}
	}
	difficulty = static_cast<int>(difficulty / activesquad->squad[maxp]->get_weapon().get_bashstrengthmod());
	if (crowable || activesquad->squad[maxp]->attribute_check(ATTRIBUTE_STRENGTH, difficulty))
	{
		clearmessagearea(false);
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, activesquad->squad[maxp]->name, gamelog);
		addstrAlt(singleSpace, gamelog);
		switch (type)
		{
		case BASH_DOOR:
			if (crowable) addstrAlt(CONST_miscactions015, gamelog);
			else if (activesquad->squad[maxp]->get_weapon().get_bashstrengthmod() > 1)
				addstrAlt(CONST_miscactions016, gamelog);
			else if (activesquad->squad[maxp]->flag&CREATUREFLAG_WHEELCHAIR)
				addstrAlt(CONST_miscactions017, gamelog);
			else addstrAlt(CONST_miscactions018, gamelog);
			break;
		}
		addstrAlt(CONST_miscactions028, gamelog);
		gamelog.newline();
		pressAnyKey();
		int timer = 5;
		if (crowable) timer = 20;
		if (sitealarmtimer<0 || sitealarmtimer>timer)
			sitealarmtimer = timer;
		else sitealarmtimer = 0;
		//Bashing doors in secure areas sets off alarms
		if ((LocationsPool::getInstance().getLocationType(cursite) == SITE_GOVERNMENT_PRISON ||
			LocationsPool::getInstance().getLocationType(cursite) == SITE_GOVERNMENT_INTELLIGENCEHQ) &&
			sitealarm == 0)
		{
			sitealarm = 1;
			set_color_easy(RED_ON_BLACK_BRIGHT);
			mvaddstrAlt(17, 1, CONST_miscactions020, gamelog);
			gamelog.newline();
			pressAnyKey();
		}
		actual = 1;
		return 1;
	}
	else
	{
		clearmessagearea(false);
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, activesquad->squad[maxp]->name, gamelog);
		switch (type)
		{
		case BASH_DOOR:
			if (activesquad->squad[maxp]->flag&CREATUREFLAG_WHEELCHAIR)
				addstrAlt(CONST_miscactions021, gamelog);
			else addstrAlt(CONST_miscactions022, gamelog);
			break;
		}
		addstrAlt(CONST_miscactions028, gamelog);
		gamelog.newline();
		pressAnyKey();
		if (sitealarmtimer < 0) sitealarmtimer = 25;
		else if (sitealarmtimer > 10) sitealarmtimer -= 10;
		else sitealarmtimer = 0;
		actual = 1;
		return 0;
	}
}
/* computer hack attempt */
char hack(short type, char &actual)
{
	extern squadst *activesquad;
	extern Log gamelog;
	int difficulty = 0;
	switch (type)
	{
	case HACK_SUPERCOMPUTER:difficulty = DIFFICULTY_HEROIC; break;
	case HACK_VAULT:difficulty = DIFFICULTY_CHALLENGING; break;
	}
	int maxattack = 0, maxblindattack = -3, hacker = -1, blind = -1;
	for (int p = 0; p < 6; p++) if (activesquad->squad[p] != NULL)
		if (activesquad->squad[p]->alive && activesquad->squad[p]->get_skill(SKILL_COMPUTERS))
		{
			int roll = activesquad->squad[p]->skill_roll(SKILL_COMPUTERS);
			if (!activesquad->squad[p]->special[SPECIALWOUND_RIGHTEYE] &&
				!activesquad->squad[p]->special[SPECIALWOUND_LEFTEYE])
			{  // we got a blind person here
				roll -= 3; // blindness handicaps you by 3, highest roll you can get is 15 instead of 18
				if (roll > maxblindattack) maxblindattack = roll, blind = p; // best blind hacker so far
			}
			else
			{  // we got someone who can see here
				if (roll > maxattack) maxattack = roll, hacker = p; // best hacker with eyeballs so far
			}
		}
	if (blind > -1 && (hacker == -1 || (maxblindattack > maxattack&&maxblindattack > 0)))
		hacker = blind, maxattack = maxblindattack, blind = true; // the best hacker is a blind person
	else if (blind > -1 && hacker == -1 && maxblindattack <= 0)
		blind = true; // we only have a blind hacker, and their roll with the handicap is 0 or less
	else blind = false; // either our hacker has eyeballs or there is no hacker at all
	if (hacker > -1)
	{
		activesquad->squad[hacker]->train(SKILL_COMPUTERS, difficulty);
		if (maxattack > difficulty)
		{
			clearmessagearea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, activesquad->squad[hacker]->name, gamelog);
			if (!blind) addstrAlt(CONST_miscactions024, gamelog);
			switch (type)
			{
			case HACK_SUPERCOMPUTER:addstrAlt(CONST_miscactions025, gamelog); break;
			case HACK_VAULT:addstrAlt(CONST_miscactions026, gamelog); break;
			}
			if (blind)
				addstrAlt(CONST_miscactions027, gamelog);
			addstrAlt(CONST_miscactions028, gamelog);
			gamelog.newline();
			pressAnyKey();
			actual = 1;
			return 1;
		}
		else
		{
			clearmessagearea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, activesquad->squad[hacker]->name, gamelog);
			addstrAlt(CONST_miscactions029, gamelog);
			if (blind) addstrAlt(CONST_miscactions030, gamelog);
			switch (type)
			{
			case HACK_SUPERCOMPUTER:addstrAlt(CONST_miscactions031, gamelog); break;
			case HACK_VAULT:addstrAlt(CONST_miscactions032, gamelog); break;
			}
			gamelog.newline();
			pressAnyKey();
			actual = 1;
			return 0;
		}
	}
	else
	{
		clearmessagearea();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, CONST_miscactions033, gamelog);
		gamelog.newline();
		if (blind)
		{  // your only hacker was blind and had a skill roll, after the handicap, of 0 or less
			pressAnyKey();
			mvaddstrAlt(17, 1, CONST_miscactions034, gamelog);
			gamelog.newline();
		}
		pressAnyKey();
	}
	actual = 0;
	return 0;
}
/* run a broadcast */
char run_broadcast(bool tv_broadcase)
{
	extern squadst *activesquad;
	extern Log gamelog;
	extern short sitealarm;
	extern short sitealienate;
	extern Creature encounter[ENCMAX];
	sitealarm = 1;
	int enemy = 0;
	for (int e = 0; e < ENCMAX; e++)
	{
		if (encounter[e].exists&&encounter[e].alive)
		{
			if (encounter[e].align == -1)enemy++;
		}
	}
	if (enemy > 0)
	{
		clearmessagearea();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, CONST_miscactions035, gamelog);
		mvaddstrAlt(17, 1, CONST_miscactions036, gamelog);
		gamelog.newline();
		pressAnyKey();
		return 0;
	}
	criminalizeparty(LAWFLAG_DISTURBANCE);
	clearmessagearea();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	if (tv_broadcase) {
		mvaddstrAlt(16, 1, CONST_miscactions037, gamelog);
	}
	else {
		mvaddstrAlt(16, 1, CONST_miscactions038, gamelog);
	}
	int viewhit = LCSrandom(VIEWNUM);
	if (discussesIssues.count(viewhit)) {
		mvaddstrAlt(17, 1, discussesIssues[viewhit], gamelog);
	}
	else {
		mvaddstrAlt(17, 1, discussesIssues[VIEW_LIBERALCRIMESQUADPOS], gamelog);
	}
	gamelog.newline();
	pressAnyKey();
	int segmentpower = 0, partysize = squadalive(activesquad);
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] != NULL)
		{
			if (!activesquad->squad[p]->alive)continue;
			segmentpower += activesquad->squad[p]->get_attribute(ATTRIBUTE_INTELLIGENCE, true);
			segmentpower += activesquad->squad[p]->get_attribute(ATTRIBUTE_HEART, true);
			segmentpower += activesquad->squad[p]->get_attribute(ATTRIBUTE_CHARISMA, true);
			segmentpower += activesquad->squad[p]->get_skill(SKILL_MUSIC);
			segmentpower += activesquad->squad[p]->get_skill(SKILL_RELIGION);
			segmentpower += activesquad->squad[p]->get_skill(SKILL_SCIENCE);
			segmentpower += activesquad->squad[p]->get_skill(SKILL_BUSINESS);
			segmentpower += activesquad->squad[p]->get_skill(SKILL_PERSUASION);
			activesquad->squad[p]->train(SKILL_PERSUASION, 50);
		}
	}
	// LCS colors enhance the broadcast significantly
	if (tv_broadcase) {
		if (activesquad->stance == SQUADSTANCE_BATTLECOLORS)
			segmentpower = (segmentpower * 3) / 2;
	}
	int segmentbonus = segmentpower / 4;
	if (partysize > 1)segmentpower /= partysize;
	segmentpower += segmentbonus;
	clearmessagearea();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	if (tv_broadcase) {
		if (segmentpower < 25)mvaddstrAlt(16, 1, CONST_miscactions039, gamelog);
		else if (segmentpower < 35)mvaddstrAlt(16, 1, CONST_miscactions048, gamelog);
		else if (segmentpower < 45)mvaddstrAlt(16, 1, CONST_miscactions049, gamelog);
		else if (segmentpower < 55)mvaddstrAlt(16, 1, CONST_miscactions042, gamelog);
		else if (segmentpower < 70)mvaddstrAlt(16, 1, CONST_miscactions051, gamelog);
		else if (segmentpower < 85)mvaddstrAlt(16, 1, CONST_miscactions052, gamelog);
		else if (segmentpower < 100)mvaddstrAlt(16, 1, CONST_miscactions053, gamelog);
		else mvaddstrAlt(16, 1, CONST_miscactions046, gamelog);
	}
	else {
		if (segmentpower < 25)mvaddstrAlt(16, 1, CONST_miscactions047, gamelog);
		else if (segmentpower < 35)mvaddstrAlt(16, 1, CONST_miscactions048, gamelog);
		else if (segmentpower < 45)mvaddstrAlt(16, 1, CONST_miscactions049, gamelog);
		else if (segmentpower < 55)mvaddstrAlt(16, 1, CONST_miscactions050, gamelog);
		else if (segmentpower < 70)mvaddstrAlt(16, 1, CONST_miscactions051, gamelog);
		else if (segmentpower < 85)mvaddstrAlt(16, 1, CONST_miscactions052, gamelog);
		else if (segmentpower < 100)mvaddstrAlt(16, 1, CONST_miscactions053, gamelog);
		else mvaddstrAlt(16, 1, CONST_miscactions054, gamelog);
	}
	gamelog.newline();
	pressAnyKey();
	//CHECK PUBLIC OPINION
	change_public_opinion(VIEW_LIBERALCRIMESQUAD, 10);
	if (tv_broadcase) {
		change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, (segmentpower - 50) / 10);
		if (viewhit != VIEW_LIBERALCRIMESQUAD)change_public_opinion(viewhit, (segmentpower - 50) / 5, 1);
		else change_public_opinion(viewhit, segmentpower / 10);
	}
	else {
		change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, (segmentpower - 50) / 2);
		if (viewhit != VIEW_LIBERALCRIMESQUAD)change_public_opinion(viewhit, (segmentpower - 50) / 2, 1);
		else change_public_opinion(viewhit, segmentpower / 2);
	}
	//PRISONER PARTS
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] != NULL)
		{
			if (activesquad->squad[p]->prisoner != NULL && activesquad->squad[p]->prisoner->alive)
			{
				if (((activesquad->squad[p]->prisoner->type == CREATURE_NEWSANCHOR) && tv_broadcase) || ((activesquad->squad[p]->prisoner->type == CREATURE_RADIOPERSONALITY) && !tv_broadcase))
				{
					clearmessagearea();
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(16, 1, CONST_miscactions055, gamelog);
					addstrAlt(activesquad->squad[p]->prisoner->name, gamelog);
					addstrAlt(CONST_miscactions056, gamelog);
					viewhit = LCSrandom(VIEWNUM);
					if (discussIssues.count(viewhit)) {
						mvaddstrAlt(17, 1, discussIssues[viewhit], gamelog);
					}
					else {
						mvaddstrAlt(17, 1, discussIssues[VIEW_LIBERALCRIMESQUADPOS], gamelog);
					}
					gamelog.newline();
					int usegmentpower = 10; //FAME BONUS
					usegmentpower += activesquad->squad[p]->prisoner->get_attribute(ATTRIBUTE_INTELLIGENCE, true);
					usegmentpower += activesquad->squad[p]->prisoner->get_attribute(ATTRIBUTE_HEART, true);
					usegmentpower += activesquad->squad[p]->prisoner->get_attribute(ATTRIBUTE_CHARISMA, true);
					usegmentpower += activesquad->squad[p]->prisoner->get_skill(SKILL_PERSUASION);
					if (tv_broadcase) {
						if (viewhit != VIEW_LIBERALCRIMESQUAD)change_public_opinion(viewhit, (usegmentpower - 10) / 2);
						else change_public_opinion(viewhit, usegmentpower / 2, 1);
					}
					else {
						if (viewhit != VIEW_LIBERALCRIMESQUAD)change_public_opinion(viewhit, (usegmentpower - 10) / 2, 1, 80);
						else change_public_opinion(viewhit, usegmentpower / 2);
					}
					segmentpower += usegmentpower;
					pressAnyKey();
				}
				else
				{
					clearmessagearea();
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(16, 1, activesquad->squad[p]->prisoner->name, gamelog);
					addstrAlt(CONST_miscactions057, gamelog);
					gamelog.newline();
					pressAnyKey();
				}
			}
		}
	}
	if (sitealienate >= 1 && segmentpower >= 40)
	{
		sitealienate = 0;
		clearmessagearea();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, CONST_miscactions058, gamelog);
		gamelog.newline();
		mvaddstrAlt(17, 1, CONST_miscactions059, gamelog);
		gamelog.newline();
		pressAnyKey();
	}
	//POST-SECURITY BLITZ IF IT SUCKED
	if (((segmentpower < 85 && segmentpower >= 25) && tv_broadcase) || ((segmentpower < 90) && !tv_broadcase))
	{
		clearmessagearea();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, CONST_miscactions060, gamelog);
		mvaddstrAlt(17, 1, CONST_miscactions061, gamelog);
		gamelog.newline();
		pressAnyKey();
		int numleft = LCSrandom(8) + 2;
		fillEncounter(CREATURE_SECURITYGUARD, numleft);
	}
	else
	{
		clearmessagearea();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		if (tv_broadcase) {
			mvaddstrAlt(16, 1, CONST_miscactions062, gamelog);
			if (segmentpower < 50)
				addstrAlt(CONST_miscactions063, gamelog);
			else
				addstrAlt(CONST_miscactions064, gamelog);
			addstrAlt(CONST_miscactions065, gamelog);
		}
		else {
			mvaddstrAlt(16, 1, CONST_miscactions066, gamelog);
		}
		mvaddstrAlt(17, 1, CONST_miscactions067, gamelog);
		gamelog.newline();
		pressAnyKey();
	}
	return 1;
}
// #include "../common/creaturePoolCreature.h"
/* rescues people held at the activeparty's current location */
void partyrescue(short special)
{
	extern Log gamelog;
	extern squadst *activesquad;
	extern short cursite;
	int freeslots = 0;
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] == NULL)freeslots++;
	}
	int hostslots = 0;
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] != NULL)
		{
			if (activesquad->squad[p]->alive&&activesquad->squad[p]->prisoner == NULL)
			{
				hostslots++;
			}
		}
	}
	vector<Creature*> waiting_for_rescue;

	whoAreWaitingForRescue(waiting_for_rescue, cursite, special);
	for (int pl = 0; pl < len(waiting_for_rescue); pl++)
	{
		if (LCSrandom(2) && freeslots)
		{
			for (int p = 0; p < 6; p++)
			{
				if (activesquad->squad[p] == NULL)
				{
					activesquad->squad[p] = waiting_for_rescue[pl];
					activesquad->squad[p]->squadid = activesquad->id;
					criminalize(*activesquad->squad[p], LAWFLAG_ESCAPED);
					activesquad->squad[p]->flag |= CREATUREFLAG_JUSTESCAPED;
					break;
				}
			}
			hostslots++;
			freeslots--;
			clearmessagearea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, CONST_miscactions070, gamelog);
			addstrAlt(waiting_for_rescue[pl]->name, gamelog);
			addstrAlt(CONST_miscactions071, gamelog);
			gamelog.newline();
			printparty();
			pressAnyKey();
			waiting_for_rescue[pl]->location = -1;
			waiting_for_rescue[pl]->base = activesquad->squad[0]->base;
			waiting_for_rescue.erase(waiting_for_rescue.begin() + pl);
			--pl;
		}
	}
	for (int pl = 0; pl < len(waiting_for_rescue); pl++)
	{
		if (hostslots)
		{
			for (int p = 0; p < 6; p++)
			{
				if (activesquad->squad[p] != NULL)
				{
					if (activesquad->squad[p]->alive&&activesquad->squad[p]->prisoner == NULL)
					{
						activesquad->squad[p]->prisoner = waiting_for_rescue[pl];
						waiting_for_rescue[pl]->squadid = activesquad->id;
						criminalize(*waiting_for_rescue[pl], LAWFLAG_ESCAPED);
						waiting_for_rescue[pl]->flag |= CREATUREFLAG_JUSTESCAPED;
						clearmessagearea();
						set_color_easy(WHITE_ON_BLACK_BRIGHT);
						mvaddstrAlt(16, 1, CONST_miscactions070, gamelog);
						addstrAlt(waiting_for_rescue[pl]->name, gamelog);
						addstrAlt(CONST_miscactions071, gamelog);
						gamelog.newline();
						pressAnyKey();
						clearmessagearea();
						mvaddstrAlt(16, 1, waiting_for_rescue[pl]->name, gamelog);
						addstrAlt(singleSpace, gamelog);
						addstrAlt(pickrandom(was_abused), gamelog);
						mvaddstrAlt(17, 1, CONST_miscactions072, gamelog);
						addstrAlt(activesquad->squad[p]->name, gamelog);
						addstrAlt(CONST_miscactions073, gamelog);
						gamelog.newline();
						waiting_for_rescue[pl]->location = -1;
						waiting_for_rescue[pl]->base = activesquad->squad[p]->base;
						printparty();
						pressAnyKey();
						waiting_for_rescue.erase(waiting_for_rescue.begin() + pl);
						--pl;
						break;
					}
				}
			}
			hostslots--;
		}
		if (!hostslots)break;
	}
	if (len(waiting_for_rescue) == 1)
	{
		clearmessagearea();
		set_color_easy(YELLOW_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, CONST_miscactions074, gamelog);
		addstrAlt(waiting_for_rescue[0]->name, gamelog);
		addstrAlt(singleDot, gamelog);
		gamelog.newline();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(17, 1, CONST_miscactions077, gamelog);
		gamelog.newline();
		pressAnyKey();
	}
	else if (len(waiting_for_rescue) > 1)
	{
		clearmessagearea();
		set_color_easy(YELLOW_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, CONST_miscactions076, gamelog);
		gamelog.newline();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(17, 1, CONST_miscactions077, gamelog);
		gamelog.newline();
		pressAnyKey();
	}
}
/* everybody reload! */
void reloadparty(bool wasteful)
{
	extern squadst *activesquad;
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] == NULL)continue;
		if (!activesquad->squad[p]->alive)continue;
		if (activesquad->squad[p]->has_thrown_weapon)
		{
			activesquad->squad[p]->ready_another_throwing_weapon();
		}
		else if (activesquad->squad[p]->can_reload())
		{
			activesquad->squad[p]->reload(wasteful);
		}
	}
}

// #include "../includes.h"
const string CONST_money003 = "$";
const string CONST_money002 = "amount";

Money::Money(const std::string& inputXml) : Item(inputXml)
{
	CMarkup xml;
	xml.SetDoc(inputXml);
	xml.FindElem();
	xml.IntoElem();
	while (xml.FindElem()) if (xml.GetTagName() == CONST_money002) amount_ = atoi(xml.GetData().c_str());
}
string Money::showXml() const
{
	CMarkup xml;
	xml.AddElem(tag_money);
	xml.IntoElem();
	addBaseValues(xml);
	xml.AddElem(CONST_money002, tostring(amount_));
	return xml.GetDoc();
}
Money* Money::split(int number)
{
	flatten();
	if (number > amount_) number = amount_;
	Money* newi = clone();
	newi->amount_ = number;
	amount_ -= number;
	return newi;
}
bool Money::merge(Item& i)
{
	flatten();
	if (i.whatIsThis() == THIS_IS_MONEY && is_same_type(i))
	{
		Money& m = static_cast<Money&>(i); //cast -XML
		m.flatten();
		take_all_from(m);
		m.set_number(0);
		return true;
	}
	else return false;
}
bool Money::sort_compare_special(Item* other) const
{
	return other && !(other->whatIsThis() == THIS_IS_MONEY);
}
string Money::equip_title() const
{
	return CONST_money003 + tostring(amount_);
}


// #include "../includes.h"
const string CONST_monthly017 = "They will never see the utopia they dreamed of...";
const string CONST_monthly016 = "The last LCS members have all been hunted down.";
const string CONST_monthly015 = "The Liberal Crime Squad is now just a memory.";
const string CONST_monthly014 = "Press any key to reflect on these poll numbers.";
const string CONST_monthly013 = "Arch-Conservative";
const string CONST_monthly012 = "-  ";
const string CONST_monthly011 = "Conservative  ";
const string CONST_monthly009 = "moderate  ";
const string CONST_monthly007 = "Liberal  ";
const string CONST_monthly005 = "Elite Liberal ";
const string CONST_monthly004 = "ÄÄÄ";
const string CONST_monthly003 = "CURRENT POLITICAL TRENDS";
const string CONST_monthly002 = "LCS MONTHLY INTELLIGENCE REPORT";

//// #include "../common/commonactions.h"
char endcheck(char cause);
//// #include "../monthly/lcsmonthly.h"
void fundreport(char &clearformess);
//// #include "../daily/daily.h"
//for dispersalcheck and securitytable
void dispersalcheck(char &clearformess);
// #include "../cursesAlternative.h"
// #include "../set_color_support.h"
//// #include <common\\getnames.h>
std::string getview(short view, bool shortname);
// #include "../locations/locationsPool.h"
// #include "../locations/locationsEnums.h"
// #include "../common/creaturePool.h"
#include "../common/creaturePoolHeader.h"
/* end the game and clean up */
//void end_game(int err = EXIT_SUCCESS);
void clearRentExemptions();
void publishSpecialEditions(char &clearformess);
void manageGrafiti();

//extern string singleDot;

// #include "../common/musicClass.h"
/* rename various buildings according to the new laws */
void updateworld_laws(short *law, short *oldlaw)
{  // NOTE: make sure to keep code here matching code in initlocation() in locations.cpp for when names are changed
	if (((law[LAW_POLICEBEHAVIOR] == -2 && law[LAW_DEATHPENALTY] == -2) ||
		(oldlaw[LAW_POLICEBEHAVIOR] == -2 && oldlaw[LAW_DEATHPENALTY] == -2)) &&
		(law[LAW_POLICEBEHAVIOR] != oldlaw[LAW_POLICEBEHAVIOR] ||
			law[LAW_DEATHPENALTY] != oldlaw[LAW_DEATHPENALTY]))
		for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++)
			if (LocationsPool::getInstance().getLocationType(l) == SITE_GOVERNMENT_POLICESTATION) // Police Station or Death Squad HQ?
				LocationsPool::getInstance().initSite(l);
	if ((law[LAW_DEATHPENALTY] == -2 || oldlaw[LAW_DEATHPENALTY] == -2) &&
		law[LAW_DEATHPENALTY] != oldlaw[LAW_DEATHPENALTY])
		for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++)
			if (LocationsPool::getInstance().getLocationType(l) == SITE_GOVERNMENT_COURTHOUSE) // Courthouse or judge hall?
				LocationsPool::getInstance().initSite(l);
	if ((law[LAW_FREESPEECH] == -2 || oldlaw[LAW_FREESPEECH] == -2) &&
		law[LAW_FREESPEECH] != oldlaw[LAW_FREESPEECH])
		for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++)
			if (LocationsPool::getInstance().getLocationType(l) == SITE_GOVERNMENT_FIRESTATION) // Fire station or Fireman HQ?
				LocationsPool::getInstance().initSite(l);
	if ((law[LAW_PRISONS] == -2 || oldlaw[LAW_PRISONS] == -2) &&
		law[LAW_PRISONS] != oldlaw[LAW_PRISONS])
		for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++)
			if (LocationsPool::getInstance().getLocationType(l) == SITE_GOVERNMENT_PRISON) // Prison or re-ed camp?
				LocationsPool::getInstance().initSite(l);
	if ((law[LAW_NUCLEARPOWER] == 2 || oldlaw[LAW_NUCLEARPOWER] == 2) &&
		law[LAW_NUCLEARPOWER] != oldlaw[LAW_NUCLEARPOWER])
		for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++)
			if (LocationsPool::getInstance().getLocationType(l) == SITE_INDUSTRY_NUCLEAR) // Nuclear Power Plant, or Nuclear Waste Center?
				LocationsPool::getInstance().initSite(l);
	if (((law[LAW_PRIVACY] == -2 && law[LAW_POLICEBEHAVIOR] == -2) ||
		(oldlaw[LAW_PRIVACY] == -2 && oldlaw[LAW_POLICEBEHAVIOR] == -2)) &&
		(law[LAW_PRIVACY] != oldlaw[LAW_PRIVACY] ||
			law[LAW_POLICEBEHAVIOR] != oldlaw[LAW_POLICEBEHAVIOR]))
		for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++)
			if (LocationsPool::getInstance().getLocationType(l) == SITE_GOVERNMENT_INTELLIGENCEHQ) // Intelligence HQ or ministry of love?
				LocationsPool::getInstance().initSite(l);
	if ((law[LAW_MILITARY] == -2 || oldlaw[LAW_MILITARY] == -2) &&
		law[LAW_MILITARY] != oldlaw[LAW_MILITARY])
		for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++)
			if (LocationsPool::getInstance().getLocationType(l) == SITE_GOVERNMENT_ARMYBASE) // Army Base or Ministry of Peace?
				LocationsPool::getInstance().initSite(l);
	if ((law[LAW_GUNCONTROL] == 2 || oldlaw[LAW_GUNCONTROL] == 2) &&
		law[LAW_GUNCONTROL] != oldlaw[LAW_GUNCONTROL])
		for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++)
			if (LocationsPool::getInstance().getLocationType(l) == SITE_BUSINESS_PAWNSHOP) // Do they mention guns in the title?
				LocationsPool::getInstance().initSite(l);
	if (((law[LAW_CORPORATE] == -2 && law[LAW_TAX] == -2) ||
		(oldlaw[LAW_CORPORATE] == -2 && oldlaw[LAW_TAX] == -2)) &&
		(law[LAW_CORPORATE] != oldlaw[LAW_CORPORATE] ||
			law[LAW_TAX] != oldlaw[LAW_TAX]))
		for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++)
			if (LocationsPool::getInstance().getLocationType(l) == SITE_CORPORATE_HOUSE) // CEO house or CEO Castle?
				LocationsPool::getInstance().initSite(l);
	if ((law[LAW_DRUGS] == 2 || oldlaw[LAW_DRUGS] == 2) &&
		law[LAW_DRUGS] != oldlaw[LAW_DRUGS])
		for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++)
			if (LocationsPool::getInstance().getLocationType(l) == SITE_BUSINESS_CRACKHOUSE  // Crack House, or Recreational Drugs Center?
				&& LocationsPool::getInstance().getRentingType(l) < 0) // Only rename locations not under LCS control, to avoid switching names around under the player
				LocationsPool::getInstance().initSite(l);
}
/* does end of month actions */
void passmonth(char &clearformess, char canseethings)
{
	// Show polls when you can't see things
	extern bool SHOWWAIT;
	// Show die rolls, 100% accurate poll numbers
	extern bool SHOWMECHANICS;
	extern Log gamelog;
	extern MusicClass music;
	extern int year;
	extern char endgamestate;
	extern char newscherrybusted;
	extern int day;
	extern int month;
	extern char disbanding;
	extern bool stalinmode;
	extern int disbandtime;
	extern class Ledger ledger;
	extern short lawList[LAWNUM];
	extern short attitude[VIEWNUM];
	extern short public_interest[VIEWNUM];
	extern short background_liberal_influence[VIEWNUM];
	short oldlaw[LAWNUM];
	memmove(oldlaw, lawList, sizeof(short)*LAWNUM);
	int l, p;
	//TIME ADVANCE
	day = 1;
	month++;
	if (month == 13)
	{
		month = 1;
		year++;
	}
	switch (endgamestate)
	{
	case ENDGAME_NONE:
		if (publicmood(-1) > 60)
		{
			endgamestate = ENDGAME_CCS_APPEARANCE;
			attitude[VIEW_CONSERVATIVECRIMESQUAD] = 0;
		}
		break;
	case ENDGAME_CCS_APPEARANCE:
		if (publicmood(-1) > 80)
			endgamestate = ENDGAME_CCS_ATTACKS;
		break;
	case ENDGAME_CCS_ATTACKS:
		if (publicmood(-1) > 90)
			endgamestate = ENDGAME_CCS_SIEGES;
		break;
	case ENDGAME_CCS_SIEGES:
	case ENDGAME_CCS_DEFEATED:
		//if(publicmood(-1)>85&&presparty!=LIBERAL_PARTY)
		//   endgamestate=ENDGAME_MARTIALLAW;
		break;
	}
	//CLEAR RENT EXEMPTIONS
	clearRentExemptions();
	// Check for game over
	endcheck(END_DEAD);
	dispersalcheck(clearformess);
	if (!disbanding) {
		publishSpecialEditions(clearformess);
	}
	int libpower[VIEWNUM] = { 0 };
	//STORIES STALE EVEN IF NOT PRINTED
	for (int v = 0; v < VIEWNUM; v++)public_interest[v] /= 2;
	int conspower = 200 - attitude[VIEW_AMRADIO] - attitude[VIEW_CABLENEWS];
	//HAVING SLEEPERS
	havingSleepers(clearformess, canseethings, libpower);
	manageGrafiti();
	int mediabalance = 0;
	int issuebalance[VIEWNUM - 5];
	//int stimulus=0;
	//double cost=0;
	//double tax=0;
	//PUBLIC OPINION NATURAL MOVES
	for (int v = 0; v < VIEWNUM; v++)
	{
		// Liberal essays add their power to the effect of sleepers
		libpower[v] += background_liberal_influence[v];
		background_liberal_influence[v] = static_cast<short>(background_liberal_influence[v] * 0.66);
		if (v == VIEW_LIBERALCRIMESQUADPOS) continue;
		if (v == VIEW_LIBERALCRIMESQUAD) continue;
		//if(v==VIEW_POLITICALVIOLENCE)
		//{
		//   change_public_opinion(VIEW_POLITICALVIOLENCE,-1,0);
		//   continue;
		//}
		if (v == VIEW_CONSERVATIVECRIMESQUAD) continue;
		if (v != VIEW_AMRADIO && v != VIEW_CABLENEWS)
		{
			issuebalance[v] = libpower[v] - conspower;
			mediabalance += issuebalance[v];
			// Heavy randomization -- balance of power just biases the roll
			int roll = issuebalance[v] + LCSrandom(400) - 200;
			// If +/-50 to either side, that side wins the tug-of-war
			if (roll < -50)
				change_public_opinion(v, -1, 0);
			else if (roll > 50)
				change_public_opinion(v, 1, 0);
			else // Else random movement
				change_public_opinion(v, LCSrandom(2) * 2 - 1, 0);
		}
		// AM Radio and Cable News popularity slowly shift to reflect public
		// opinion over time -- if left unchecked, their subtle influence
		// on society will become a self-perpetuating Conservative nightmare!
		else if (v == VIEW_AMRADIO || v == VIEW_CABLENEWS)
		{
			if (publicmood(-1) < attitude[v])change_public_opinion(v, -1);
			else change_public_opinion(v, 1);
		}
	}
	// Temporary Stalinizing Code (TODO: Implement the Stalinist Comrade Squad for changing public opinion, then remove this)
	if (stalinmode) for (int v = 0; v < VIEWNUM - 3; v++)
	{
		if (stalinview(v, false)) { if ((attitude[v] += 3) > 100) attitude[v] = 100; }
		else { if (--attitude[v] < 0) attitude[v] = 0; }
	}
	// End Temporary Stalinizing Code (TODO: Implement the Stalinist Comrade Squad for changing public opinion, then remove this)
	// Seduction monthly experience stipends for those liberals
	// who have been getting it on with their love slaves/masters
	// in the background
	giveSeductionExperienceToLoveSlaves();
	/*******************************************************
	*                 INTELLIGENCE REPORT                  *
	*     ONLY IF SHOWMECHANICS OR SHOWWAIT IS DEFINED     *
	*        EYES ONLY - LCS PROPERTY - TOP SECRET         *
	*******************************************************/
	if (SHOWMECHANICS || SHOWWAIT)
		if (canseethings)
		{
			music.play(MUSIC_ELECTIONS);
			eraseAlt();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(0, 23, CONST_monthly002);
			mvaddstrAlt(2, 27, CONST_monthly003);
			int numviews = (endgamestate >= ENDGAME_CCS_DEFEATED || newscherrybusted < 2) ? VIEWNUM - 1 : VIEWNUM;
			for (int v = -1 - stalinmode, y = 4, x = 0, pip; v < numviews; v++)
			{
				if ((y - 4) * 2 >= numviews + 1 + stalinmode) y = 4, x = 40;
				for (pip = 2; pip >= -2; pip--)
				{
					set_alignment_color(pip, true);
					if (pip == 2) mvaddcharAlt(y, x + 22, '\x11');
					addstrAlt(CONST_monthly004);
					if (pip == -2) addcharAlt('\x10');
				}
				if (v >= 0) pip = 14 - (attitude[v] * 14) / 100;
				else pip = 14 - (publicmood(v) * 14) / 100;
				set_alignment_color((14 - pip) / 3 - 2, true);
				mvaddstrAlt(y, x, getview(v, false));
				mvaddcharAlt(y++, x + 23 + pip, 'O');
			}
			set_color_easy(GREEN_ON_BLACK_BRIGHT);
			mvaddstrAlt(23, 0, CONST_monthly005);
			set_color_easy(WHITE_ON_BLACK);
			addstrAlt(CONST_monthly012);
			set_color_easy(CYAN_ON_BLACK_BRIGHT);
			addstrAlt(CONST_monthly007);
			set_color_easy(WHITE_ON_BLACK);
			addstrAlt(CONST_monthly012);
			set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			addstrAlt(CONST_monthly009);
			set_color_easy(WHITE_ON_BLACK);
			addstrAlt(CONST_monthly012);
			set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
			addstrAlt(CONST_monthly011);
			set_color_easy(WHITE_ON_BLACK);
			addstrAlt(CONST_monthly012);
			set_color_easy(RED_ON_BLACK_BRIGHT);
			addstrAlt(CONST_monthly013);
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(24, 0, CONST_monthly014);
			clearformess = 1;
			pressAnyKey();
		}
	/*******************************************************
	*                                                      *
	*               END INTELLIGENCE REPORT                *
	*                                                      *
	*******************************************************/
	//ELECTIONS
	if (month == 11) { elections(clearformess, canseethings); clearformess = 1; }
	//SUPREME COURT
	if (month == 6) { supremecourt(clearformess, canseethings); clearformess = 1; }
	//CONGRESS
	congress(clearformess, canseethings); clearformess = 1;
	//DID YOU WIN?
	if (wincheck())
	{
		liberalagenda(1);
		savehighscore(END_WON);
		viewhighscores();
		end_game();
	}
	//CONTROL LONG DISBANDS
	if (disbanding&&year - disbandtime >= 50)
	{
		music.play(MUSIC_DEFEAT);
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		eraseAlt();
		mvaddstrAlt(12, 10, CONST_monthly015, gamelog);
		gamelog.newline();
		pressAnyKey();
		set_color_easy(WHITE_ON_BLACK);
		eraseAlt();
		mvaddstrAlt(12, 12, CONST_monthly016, gamelog);
		gamelog.newline();
		pressAnyKey();
		set_color_easy(BLACK_ON_BLACK_BRIGHT);
		eraseAlt();
		mvaddstrAlt(12, 14, CONST_monthly017, gamelog);
		gamelog.newline();
		gamelog.nextMessage();
		pressAnyKey();
		savehighscore(END_DISBANDLOSS);
		viewhighscores();
		end_game();
	}
	//UPDATE THE WORLD IN CASE THE LAWS HAVE CHANGED
	updateworld_laws(lawList, oldlaw);
	//THE SYSTEM!
	if (!disbanding) {
		monthlyRunTheSystem(clearformess);
	}

	//NUKE EXECUTION VICTIMS
	monthlyRunExecutions();

	//MUST DO AN END OF GAME CHECK HERE BECAUSE OF EXECUTIONS
	endcheck(END_EXECUTED);
	//DISPERSAL CHECK
	dispersalcheck(clearformess);
	//FUND REPORTS
	if (canseethings)fundreport(clearformess);
	ledger.resetMonthlyAmounts();
	if (clearformess) eraseAlt();
	//HEAL CLINIC PEOPLE
	if (!disbanding) {
		monthlyRunHealClinicPeople(clearformess);
	}

}


// #include "../locations/locationsPool.h"
void fillEncounter(CreatureTypes c, int numleft);
void emptyEncounter();
/* rolls up a random creature type according to the passed weighting array */
int getrandomcreaturetype(int cr[CREATURENUM])
{
	int sum = 0;
	for (int c = 0; c < CREATURENUM; c++)sum += cr[c];
	if (sum > 0)
	{
		int roll = LCSrandom(sum);
		int sel = 0;
		while (roll >= 0) { roll -= cr[sel]; sel++; }
		return sel - 1;
	}
	else return -1;
}

map<int, vector<int> > locationsSpawners = {
	map<int, vector<int> >::value_type(SITE_BUSINESS_JUICEBAR,{
	CREATURE_TEENAGER, 10,
	CREATURE_JUDGE_LIBERAL, 1,
	CREATURE_COLLEGESTUDENT, 10,
	CREATURE_MUSICIAN, 2,
	CREATURE_MATHEMATICIAN, 1,
	CREATURE_TEACHER, 1,
	CREATURE_HSDROPOUT, 1,
	CREATURE_ENGINEER, 1,
	CREATURE_FASTFOODWORKER, 1,
	CREATURE_BAKER, 1,
	CREATURE_BARISTA, 1,
	CREATURE_BARTENDER, 1,
	CREATURE_TELEMARKETER, 1,
	CREATURE_CARSALESMAN, 1,
	CREATURE_OFFICEWORKER, 1,
	CREATURE_MAILMAN, 1,
	CREATURE_CHEF, 1,
	CREATURE_NURSE, 1,
	CREATURE_AMATEURMAGICIAN, 1,
	CREATURE_HIPPIE, 6,
	CREATURE_CRITIC_ART, 1,
	CREATURE_CRITIC_MUSIC, 1,
	CREATURE_AUTHOR, 1,
	CREATURE_JOURNALIST, 1,
	CREATURE_SOCIALITE, 2,
	CREATURE_PROGRAMMER, 1,
	CREATURE_RETIREE, 1,
	CREATURE_PAINTER, 1,
	CREATURE_SCULPTOR, 1,
	CREATURE_DANCER, 1,
	CREATURE_PHOTOGRAPHER, 1,
	CREATURE_CAMERAMAN, 1,
	CREATURE_HAIRSTYLIST, 1,
	CREATURE_FASHIONDESIGNER, 1,
	CREATURE_CLERK, 1,
	CREATURE_THIEF, 1,
	CREATURE_ACTOR, 1,
	CREATURE_YOGAINSTRUCTOR, 1,
	CREATURE_MARTIALARTIST, 1,
	CREATURE_ATHLETE, 1,
	CREATURE_LOCKSMITH, 1
		}),
	map<int, vector<int> >::value_type(SITE_BUSINESS_CIGARBAR,{
	CREATURE_SCIENTIST_EMINENT, 1,
	CREATURE_CORPORATE_MANAGER, 30,
	CREATURE_COP, 5,
	CREATURE_JUDGE_CONSERVATIVE, 1,
	CREATURE_RADIOPERSONALITY, 1,
	CREATURE_NEWSANCHOR, 1,
	CREATURE_MILITARYOFFICER, 1,
	CREATURE_LAWYER, 15,
	CREATURE_DOCTOR, 10,
	CREATURE_PSYCHOLOGIST, 1,
	CREATURE_MUSICIAN, 1,
	CREATURE_ENGINEER, 10,
	CREATURE_BARTENDER, 10,
	CREATURE_FOOTBALLCOACH, 1,
	CREATURE_CRITIC_ART, 1,
	CREATURE_CRITIC_MUSIC, 1,
	CREATURE_AUTHOR, 1,
	CREATURE_JOURNALIST, 1,
	CREATURE_SOCIALITE, 2,
	CREATURE_RETIREE, 1,
	CREATURE_PAINTER, 1,
	CREATURE_SCULPTOR, 1,
	CREATURE_DANCER, 1,
	CREATURE_PHOTOGRAPHER, 1,
	CREATURE_FASHIONDESIGNER, 1,
	CREATURE_THIEF, 1,
	CREATURE_ACTOR, 1,
	CREATURE_ATHLETE, 1,
	CREATURE_FIREFIGHTER, 1,
	CREATURE_LOCKSMITH, 1, }),
	map<int, vector<int> >::value_type(SITE_BUSINESS_CRACKHOUSE,{
	CREATURE_TEENAGER, 100,
	CREATURE_MUSICIAN, 1,
	CREATURE_MATHEMATICIAN, 1,
	CREATURE_HSDROPOUT, 30,
	CREATURE_BUM, 200,
	CREATURE_GANGMEMBER, 200,
	CREATURE_CRACKHEAD, 200,
	CREATURE_PROSTITUTE, 200,
	CREATURE_BIKER, 5,
	CREATURE_PAINTER, 1,
	CREATURE_SCULPTOR, 1,
	CREATURE_THIEF, 3,
	CREATURE_ACTOR, 1,
	CREATURE_JOURNALIST, 2 }
	),
	map<int, vector<int> >::value_type(SITE_GOVERNMENT_WHITE_HOUSE,{
	CREATURE_SCIENTIST_EMINENT, 1,
	CREATURE_WORKER_JANITOR, 2,
	CREATURE_WORKER_SECRETARY, 2,
	CREATURE_TEENAGER, 1,
	CREATURE_JUDGE_LIBERAL, 1,
	CREATURE_JUDGE_CONSERVATIVE, 1,
	CREATURE_AGENT, 2,
	CREATURE_MILITARYOFFICER, 3,
	CREATURE_LAWYER, 3,
	CREATURE_DOCTOR, 1,
	CREATURE_COLLEGESTUDENT, 1,
	CREATURE_TEACHER, 1,
	CREATURE_OFFICEWORKER, 5,
	CREATURE_FOOTBALLCOACH, 1,
	CREATURE_CHEF, 1,
	CREATURE_VETERAN, 1,
	CREATURE_JOURNALIST, 2,
	CREATURE_SOCIALITE, 1,
	CREATURE_PHOTOGRAPHER, 2,
	CREATURE_CAMERAMAN, 1,
	CREATURE_HAIRSTYLIST, 1,
	CREATURE_CLERK, 5,
	CREATURE_ACTOR, 1,
	CREATURE_ATHLETE, 1 }
	),
	map<int, vector<int> >::value_type(SITE_OUTDOOR_PUBLICPARK,{
	CREATURE_SECURITYGUARD, 5,
	CREATURE_SCIENTIST_LABTECH, 10,
	CREATURE_SCIENTIST_EMINENT, 1,
	CREATURE_CORPORATE_MANAGER, 10,
	CREATURE_WORKER_JANITOR, 5,
	CREATURE_WORKER_SECRETARY, 15,
	CREATURE_TEENAGER, 5,
	CREATURE_COP, 5,
	CREATURE_JUDGE_LIBERAL, 1,
	CREATURE_JUDGE_CONSERVATIVE, 1,
	CREATURE_AGENT, 1,
	CREATURE_RADIOPERSONALITY, 1,
	CREATURE_NEWSANCHOR, 1,
	CREATURE_MILITARYOFFICER, 1,
	CREATURE_LAWYER, 5,
	CREATURE_DOCTOR, 5,
	CREATURE_PSYCHOLOGIST, 1,
	CREATURE_NURSE, 5,
	CREATURE_SEWERWORKER, 1,
	CREATURE_COLLEGESTUDENT, 30,
	CREATURE_MUSICIAN, 5,
	CREATURE_MATHEMATICIAN, 5,
	CREATURE_TEACHER, 5,
	CREATURE_HSDROPOUT, 1,
	CREATURE_BUM, 1,
	CREATURE_GANGMEMBER, 1,
	CREATURE_CRACKHEAD, 1,
	CREATURE_PRIEST, 1,
	CREATURE_ENGINEER, 5,
	CREATURE_FASTFOODWORKER, 5,
	CREATURE_BAKER, 1,
	CREATURE_BARISTA, 10,
	CREATURE_BARTENDER, 1,
	CREATURE_TELEMARKETER, 5,
	CREATURE_CARSALESMAN, 3,
	CREATURE_OFFICEWORKER, 10,
	CREATURE_FOOTBALLCOACH, 1,
	CREATURE_PROSTITUTE, 1,
	CREATURE_MAILMAN, 1,
	CREATURE_GARBAGEMAN, 1,
	CREATURE_PLUMBER, 1,
	CREATURE_CHEF, 1,
	CREATURE_CONSTRUCTIONWORKER, 3,
	CREATURE_AMATEURMAGICIAN, 1,
	CREATURE_MERC, 1,
	CREATURE_SOLDIER, 1,
	CREATURE_VETERAN, 3,
	CREATURE_HIPPIE, 1,
	CREATURE_CRITIC_ART, 1,
	CREATURE_CRITIC_MUSIC, 1,
	CREATURE_AUTHOR, 1,
	CREATURE_JOURNALIST, 1,
	CREATURE_SOCIALITE, 1,
	CREATURE_BIKER, 1,
	CREATURE_TRUCKER, 1,
	CREATURE_TAXIDRIVER, 1,
	CREATURE_PROGRAMMER, 5,
	CREATURE_RETIREE, 3,
	CREATURE_PAINTER, 1,
	CREATURE_SCULPTOR, 1,
	CREATURE_DANCER, 1,
	CREATURE_PHOTOGRAPHER, 1,
	CREATURE_CAMERAMAN, 1,
	CREATURE_HAIRSTYLIST, 1,
	CREATURE_FASHIONDESIGNER, 1,
	CREATURE_CLERK, 1,
	CREATURE_THIEF, 1,
	CREATURE_ACTOR, 1,
	CREATURE_YOGAINSTRUCTOR, 1,
	CREATURE_MARTIALARTIST, 1,
	CREATURE_ATHLETE, 1,
	CREATURE_FIREFIGHTER, 1,
	CREATURE_LOCKSMITH, 1 }
	),
	map<int, vector<int> >::value_type(SITE_BUSINESS_LATTESTAND,{
	CREATURE_SECURITYGUARD, 5,
	CREATURE_SCIENTIST_LABTECH, 10,
	CREATURE_SCIENTIST_EMINENT, 1,
	CREATURE_CORPORATE_MANAGER, 10,
	CREATURE_WORKER_JANITOR, 5,
	CREATURE_WORKER_SECRETARY, 15,
	CREATURE_TEENAGER, 5,
	CREATURE_COP, 5,
	CREATURE_JUDGE_LIBERAL, 1,
	CREATURE_JUDGE_CONSERVATIVE, 1,
	CREATURE_AGENT, 1,
	CREATURE_RADIOPERSONALITY, 1,
	CREATURE_NEWSANCHOR, 1,
	CREATURE_MILITARYOFFICER, 1,
	CREATURE_LAWYER, 5,
	CREATURE_DOCTOR, 5,
	CREATURE_PSYCHOLOGIST, 1,
	CREATURE_NURSE, 5,
	CREATURE_SEWERWORKER, 1,
	CREATURE_COLLEGESTUDENT, 30,
	CREATURE_MUSICIAN, 5,
	CREATURE_MATHEMATICIAN, 5,
	CREATURE_TEACHER, 5,
	CREATURE_HSDROPOUT, 1,
	CREATURE_BUM, 1,
	CREATURE_GANGMEMBER, 1,
	CREATURE_CRACKHEAD, 1,
	CREATURE_PRIEST, 1,
	CREATURE_ENGINEER, 5,
	CREATURE_FASTFOODWORKER, 5,
	CREATURE_BAKER, 1,
	CREATURE_BARISTA, 10,
	CREATURE_BARTENDER, 1,
	CREATURE_TELEMARKETER, 5,
	CREATURE_CARSALESMAN, 3,
	CREATURE_OFFICEWORKER, 10,
	CREATURE_FOOTBALLCOACH, 1,
	CREATURE_PROSTITUTE, 1,
	CREATURE_MAILMAN, 1,
	CREATURE_GARBAGEMAN, 1,
	CREATURE_PLUMBER, 1,
	CREATURE_CHEF, 1,
	CREATURE_CONSTRUCTIONWORKER, 3,
	CREATURE_AMATEURMAGICIAN, 1,
	CREATURE_MERC, 1,
	CREATURE_SOLDIER, 1,
	CREATURE_VETERAN, 3,
	CREATURE_HIPPIE, 1,
	CREATURE_CRITIC_ART, 1,
	CREATURE_CRITIC_MUSIC, 1,
	CREATURE_AUTHOR, 1,
	CREATURE_JOURNALIST, 1,
	CREATURE_SOCIALITE, 1,
	CREATURE_BIKER, 1,
	CREATURE_TRUCKER, 1,
	CREATURE_TAXIDRIVER, 1,
	CREATURE_PROGRAMMER, 5,
	CREATURE_RETIREE, 3,
	CREATURE_PAINTER, 1,
	CREATURE_SCULPTOR, 1,
	CREATURE_DANCER, 1,
	CREATURE_PHOTOGRAPHER, 1,
	CREATURE_CAMERAMAN, 1,
	CREATURE_HAIRSTYLIST, 1,
	CREATURE_FASHIONDESIGNER, 1,
	CREATURE_CLERK, 1,
	CREATURE_THIEF, 1,
	CREATURE_ACTOR, 1,
	CREATURE_YOGAINSTRUCTOR, 1,
	CREATURE_MARTIALARTIST, 1,
	CREATURE_ATHLETE, 1,
	CREATURE_FIREFIGHTER, 1,
	CREATURE_LOCKSMITH, 1 }
	),
	map<int, vector<int> >::value_type(SITE_BUSINESS_VEGANCOOP,{
	CREATURE_TEENAGER, 5,
	CREATURE_JUDGE_LIBERAL, 1,
	CREATURE_COLLEGESTUDENT, 50,
	CREATURE_MUSICIAN, 20,
	CREATURE_MATHEMATICIAN, 1,
	CREATURE_TEACHER, 1,
	CREATURE_HSDROPOUT, 10,
	CREATURE_BUM, 1,
	CREATURE_HIPPIE, 50,
	CREATURE_CRITIC_ART, 1,
	CREATURE_CRITIC_MUSIC, 1,
	CREATURE_AUTHOR, 1,
	CREATURE_JOURNALIST, 1,
	CREATURE_RETIREE, 1,
	CREATURE_PAINTER, 1,
	CREATURE_SCULPTOR, 1,
	CREATURE_DANCER, 1,
	CREATURE_PHOTOGRAPHER, 1,
	CREATURE_YOGAINSTRUCTOR, 2 }
	),
	map<int, vector<int> >::value_type(SITE_BUSINESS_INTERNETCAFE,{
	CREATURE_SCIENTIST_LABTECH, 5,
	CREATURE_CORPORATE_MANAGER, 3,
	CREATURE_TEENAGER, 15,
	CREATURE_LAWYER, 3,
	CREATURE_COLLEGESTUDENT, 25,
	CREATURE_MUSICIAN, 2,
	CREATURE_MATHEMATICIAN, 1,
	CREATURE_TEACHER, 5,
	CREATURE_ENGINEER, 15,
	CREATURE_DOCTOR, 1,
	CREATURE_BARISTA, 10,
	CREATURE_CARSALESMAN, 3,
	CREATURE_OFFICEWORKER, 15,
	CREATURE_WORKER_SECRETARY, 5,
	CREATURE_HIPPIE, 1,
	CREATURE_PROGRAMMER, 15,
	CREATURE_RETIREE, 5,
	CREATURE_PAINTER, 1,
	CREATURE_SCULPTOR, 1,
	CREATURE_DANCER, 1,
	CREATURE_PHOTOGRAPHER, 1,
	CREATURE_CAMERAMAN, 1,
	CREATURE_CLERK, 1,
	CREATURE_LOCKSMITH, 1 }
	),
	map<int, vector<int> >::value_type(SITE_RESIDENTIAL_SHELTER,{
	CREATURE_WORKER_JANITOR, 5,
	CREATURE_TEENAGER, 20,
	CREATURE_MUSICIAN, 3,
	CREATURE_MATHEMATICIAN, 1,
	CREATURE_BUM, 200,
	CREATURE_GANGMEMBER, 5,
	CREATURE_CRACKHEAD, 50,
	CREATURE_PROSTITUTE, 10,
	CREATURE_AMATEURMAGICIAN, 1,
	CREATURE_HIPPIE, 1,
	CREATURE_NURSE, 5,
	CREATURE_BIKER, 1,
	CREATURE_PAINTER, 1,
	CREATURE_SCULPTOR, 1,
	CREATURE_DANCER, 1,
	CREATURE_PHOTOGRAPHER, 1,
	CREATURE_THIEF, 5,
	CREATURE_ACTOR, 1, }
	),
	map<int, vector<int> >::value_type(SITE_RESIDENTIAL_TENEMENT,{
	CREATURE_SECURITYGUARD, 1,
	CREATURE_SCIENTIST_LABTECH, 1,
	CREATURE_WORKER_JANITOR, 3,
	CREATURE_WORKER_SECRETARY, 2,
	CREATURE_TEENAGER, 5,
	CREATURE_SEWERWORKER, 1,
	CREATURE_COLLEGESTUDENT, 1,
	CREATURE_MUSICIAN, 1,
	CREATURE_MATHEMATICIAN, 1,
	CREATURE_TEACHER, 1,
	CREATURE_HSDROPOUT, 3,
	CREATURE_BUM, 3,
	CREATURE_GANGMEMBER, 3,
	CREATURE_CRACKHEAD, 3,
	CREATURE_FASTFOODWORKER, 1,
	CREATURE_BARISTA, 1,
	CREATURE_BARTENDER, 1,
	CREATURE_TELEMARKETER, 1,
	CREATURE_CARSALESMAN, 1,
	CREATURE_OFFICEWORKER, 1,
	CREATURE_PROSTITUTE, 3,
	CREATURE_MAILMAN, 1,
	CREATURE_GARBAGEMAN, 1,
	CREATURE_CONSTRUCTIONWORKER, 1,
	CREATURE_AMATEURMAGICIAN, 1,
	CREATURE_HICK, 1,
	CREATURE_SOLDIER, 1,
	CREATURE_VETERAN, 2,
	CREATURE_HIPPIE, 1,
	CREATURE_BIKER, 1,
	CREATURE_TAXIDRIVER, 1,
	CREATURE_RETIREE, 1,
	CREATURE_PAINTER, 1,
	CREATURE_SCULPTOR, 1,
	CREATURE_DANCER, 1,
	CREATURE_PHOTOGRAPHER, 1,
	CREATURE_HAIRSTYLIST, 1,
	CREATURE_CLERK, 1,
	CREATURE_THIEF, 1,
	CREATURE_ACTOR, 1,
	CREATURE_FIREFIGHTER, 1,
	CREATURE_LOCKSMITH, 1 }
	),
	map<int, vector<int> >::value_type(SITE_RESIDENTIAL_APARTMENT,{

	CREATURE_SECURITYGUARD, 1,
	CREATURE_SCIENTIST_LABTECH, 1,
	CREATURE_CORPORATE_MANAGER, 1,
	CREATURE_WORKER_JANITOR, 1,
	CREATURE_WORKER_SECRETARY, 1,
	CREATURE_TEENAGER, 3,
	CREATURE_COP, 1,
	CREATURE_LAWYER, 1,
	CREATURE_SEWERWORKER, 1,
	CREATURE_COLLEGESTUDENT, 1,
	CREATURE_MUSICIAN, 1,
	CREATURE_MATHEMATICIAN, 1,
	CREATURE_TEACHER, 1,
	CREATURE_PRIEST, 1,
	CREATURE_ENGINEER, 1,
	CREATURE_FASTFOODWORKER, 1,
	CREATURE_BAKER, 1,
	CREATURE_BARISTA, 1,
	CREATURE_BARTENDER, 1,
	CREATURE_TELEMARKETER, 1,
	CREATURE_CARSALESMAN, 1,
	CREATURE_OFFICEWORKER, 1,
	CREATURE_FOOTBALLCOACH, 1,
	CREATURE_MAILMAN, 1,
	CREATURE_DOCTOR, 1,
	CREATURE_PSYCHOLOGIST, 1,
	CREATURE_NURSE, 1,
	CREATURE_GARBAGEMAN, 1,
	CREATURE_PLUMBER, 1,
	CREATURE_CHEF, 1,
	CREATURE_CONSTRUCTIONWORKER, 1,
	CREATURE_AMATEURMAGICIAN, 1,
	CREATURE_SOLDIER, 1,
	CREATURE_VETERAN, 2,
	CREATURE_HIPPIE, 1,
	CREATURE_CRITIC_ART, 1,
	CREATURE_CRITIC_MUSIC, 1,
	CREATURE_AUTHOR, 1,
	CREATURE_JOURNALIST, 1,
	CREATURE_TAXIDRIVER, 1,
	CREATURE_PROGRAMMER, 1,
	CREATURE_RETIREE, 1,
	CREATURE_PAINTER, 1,
	CREATURE_SCULPTOR, 1,
	CREATURE_DANCER, 1,
	CREATURE_PHOTOGRAPHER, 1,
	CREATURE_CAMERAMAN, 1,
	CREATURE_HAIRSTYLIST, 1,
	CREATURE_CLERK, 1,
	CREATURE_THIEF, 1,
	CREATURE_ACTOR, 1,
	CREATURE_YOGAINSTRUCTOR, 1,
	CREATURE_MARTIALARTIST, 1,
	CREATURE_ATHLETE, 1,
	CREATURE_FIREFIGHTER, 1,
	CREATURE_LOCKSMITH, 1 }
	),
	map<int, vector<int> >::value_type(SITE_RESIDENTIAL_APARTMENT_UPSCALE,{
	CREATURE_SCIENTIST_EMINENT, 1,
	CREATURE_CORPORATE_MANAGER, 5,
	CREATURE_WORKER_JANITOR, 5,
	CREATURE_WORKER_SECRETARY, 1,
	CREATURE_TEENAGER, 3,
	CREATURE_JUDGE_LIBERAL, 1,
	CREATURE_JUDGE_CONSERVATIVE, 1,
	CREATURE_RADIOPERSONALITY, 1,
	CREATURE_NEWSANCHOR, 1,
	CREATURE_LAWYER, 5,
	CREATURE_DOCTOR, 5,
	CREATURE_PSYCHOLOGIST, 1,
	CREATURE_NURSE, 1,
	CREATURE_COLLEGESTUDENT, 1,
	CREATURE_MUSICIAN, 1,
	CREATURE_PROSTITUTE, 3,
	CREATURE_MAILMAN, 1,
	CREATURE_CRITIC_ART, 1,
	CREATURE_CRITIC_MUSIC, 1,
	CREATURE_AUTHOR, 1,
	CREATURE_JOURNALIST, 1,
	CREATURE_SOCIALITE, 2,
	CREATURE_PAINTER, 1,
	CREATURE_SCULPTOR, 1,
	CREATURE_DANCER, 1,
	CREATURE_PHOTOGRAPHER, 1,
	CREATURE_FASHIONDESIGNER, 1,
	CREATURE_THIEF, 1,
	CREATURE_ACTOR, 1,
	CREATURE_ATHLETE, 1,
	CREATURE_LOCKSMITH, 1 }
	),
	map<int, vector<int> >::value_type(SITE_LABORATORY_COSMETICS,{
	CREATURE_SCIENTIST_LABTECH, 10,
	CREATURE_SCIENTIST_EMINENT, 1,
	CREATURE_CORPORATE_MANAGER, 1,
	CREATURE_WORKER_JANITOR, 10,
	CREATURE_WORKER_SECRETARY, 10,
	CREATURE_OFFICEWORKER, 10 }
	),
	map<int, vector<int> >::value_type(SITE_INDUSTRY_NUCLEAR,{
	CREATURE_SCIENTIST_LABTECH, 10,
	CREATURE_SCIENTIST_EMINENT, 1,
	CREATURE_CORPORATE_MANAGER, 1,
	CREATURE_WORKER_JANITOR, 10,
	CREATURE_WORKER_SECRETARY, 10,
	CREATURE_OFFICEWORKER, 10 }
	),
	map<int, vector<int> >::value_type(SITE_LABORATORY_GENETIC,{
	CREATURE_SCIENTIST_LABTECH, 10,
	CREATURE_SCIENTIST_EMINENT, 1,
	CREATURE_CORPORATE_MANAGER, 1,
	CREATURE_DOCTOR, 1,
	CREATURE_WORKER_JANITOR, 10,
	CREATURE_WORKER_SECRETARY, 10,
	CREATURE_OFFICEWORKER, 10 }
	),
	map<int, vector<int> >::value_type(SITE_GOVERNMENT_POLICESTATION,{
	CREATURE_SCIENTIST_LABTECH, 1,
	CREATURE_CORPORATE_MANAGER, 1,
	CREATURE_WORKER_JANITOR, 50,
	CREATURE_WORKER_SECRETARY, 1,
	CREATURE_TEENAGER, 5,
	CREATURE_JUDGE_LIBERAL, 1,
	CREATURE_JUDGE_CONSERVATIVE, 1,
	CREATURE_AGENT, 1,
	CREATURE_RADIOPERSONALITY, 1,
	CREATURE_NEWSANCHOR, 1,
	CREATURE_MILITARYOFFICER, 1,
	CREATURE_LAWYER, 1,
	CREATURE_DOCTOR, 1,
	CREATURE_PSYCHOLOGIST, 1,
	CREATURE_NURSE, 1,
	CREATURE_SEWERWORKER, 1,
	CREATURE_COLLEGESTUDENT, 1,
	CREATURE_MUSICIAN, 1,
	CREATURE_MATHEMATICIAN, 1,
	CREATURE_TEACHER, 1,
	CREATURE_HSDROPOUT, 10,
	CREATURE_BUM, 10,
	CREATURE_GANGMEMBER, 10,
	CREATURE_CRACKHEAD, 10,
	CREATURE_PRIEST, 5,
	CREATURE_ENGINEER, 1,
	CREATURE_FASTFOODWORKER, 1,
	CREATURE_BAKER, 1,
	CREATURE_BARISTA, 1,
	CREATURE_BARTENDER, 1,
	CREATURE_TELEMARKETER, 1,
	CREATURE_CARSALESMAN, 1,
	CREATURE_OFFICEWORKER, 1,
	CREATURE_FOOTBALLCOACH, 1,
	CREATURE_PROSTITUTE, 10,
	CREATURE_MAILMAN, 1,
	CREATURE_GARBAGEMAN, 1,
	CREATURE_PLUMBER, 1,
	CREATURE_CHEF, 1,
	CREATURE_CONSTRUCTIONWORKER, 1,
	CREATURE_AMATEURMAGICIAN, 1,
	CREATURE_HICK, 1,
	CREATURE_SOLDIER, 1,
	CREATURE_VETERAN, 2,
	CREATURE_HIPPIE, 1,
	CREATURE_CRITIC_ART, 1,
	CREATURE_CRITIC_MUSIC, 1,
	CREATURE_AUTHOR, 1,
	CREATURE_JOURNALIST, 1,
	CREATURE_SOCIALITE, 1,
	CREATURE_BIKER, 5,
	CREATURE_TRUCKER, 1,
	CREATURE_TAXIDRIVER, 1,
	CREATURE_PROGRAMMER, 1,
	CREATURE_NUN, 1,
	CREATURE_RETIREE, 1,
	CREATURE_PAINTER, 1,
	CREATURE_SCULPTOR, 1,
	CREATURE_DANCER, 1,
	CREATURE_PHOTOGRAPHER, 1,
	CREATURE_CAMERAMAN, 1,
	CREATURE_HAIRSTYLIST, 1,
	CREATURE_FASHIONDESIGNER, 1,
	CREATURE_CLERK, 1,
	CREATURE_THIEF, 10,
	CREATURE_ACTOR, 1,
	CREATURE_YOGAINSTRUCTOR, 1,
	CREATURE_MARTIALARTIST, 1,
	CREATURE_ATHLETE, 1,
	//CREATURE_FIREFIGHTER]+=1,
	CREATURE_LOCKSMITH, 5 }       //Forensic locksmiths
	),
	map<int, vector<int> >::value_type(SITE_GOVERNMENT_COURTHOUSE,{
	CREATURE_SCIENTIST_LABTECH, 1,
	CREATURE_SCIENTIST_EMINENT, 1,
	CREATURE_CORPORATE_MANAGER, 1,
	CREATURE_WORKER_JANITOR, 50,
	CREATURE_WORKER_SECRETARY, 50,
	CREATURE_TEENAGER, 1,
	CREATURE_JUDGE_LIBERAL, 20,
	CREATURE_JUDGE_CONSERVATIVE, 20,
	CREATURE_AGENT, 1,
	CREATURE_RADIOPERSONALITY, 1,
	CREATURE_NEWSANCHOR, 1,
	CREATURE_MILITARYOFFICER, 1,
	CREATURE_LAWYER, 200,
	CREATURE_PSYCHOLOGIST, 20,
	CREATURE_SEWERWORKER, 1,
	CREATURE_COLLEGESTUDENT, 1,
	CREATURE_MUSICIAN, 1,
	CREATURE_MATHEMATICIAN, 1,
	CREATURE_TEACHER, 1,
	CREATURE_HSDROPOUT, 1,
	CREATURE_BUM, 1,
	CREATURE_GANGMEMBER, 1,
	CREATURE_CRACKHEAD, 1,
	CREATURE_PRIEST, 1,
	CREATURE_ENGINEER, 1,
	CREATURE_FASTFOODWORKER, 1,
	CREATURE_BAKER, 1,
	CREATURE_BARISTA, 1,
	CREATURE_BARTENDER, 1,
	CREATURE_TELEMARKETER, 1,
	CREATURE_CARSALESMAN, 2,
	CREATURE_OFFICEWORKER, 50,
	CREATURE_FOOTBALLCOACH, 1,
	CREATURE_PROSTITUTE, 1,
	CREATURE_MAILMAN, 1,
	CREATURE_GARBAGEMAN, 1,
	CREATURE_PLUMBER, 1,
	CREATURE_CHEF, 1,
	CREATURE_CONSTRUCTIONWORKER, 1,
	CREATURE_AMATEURMAGICIAN, 1,
	CREATURE_HICK, 1,
	CREATURE_SOLDIER, 1,
	CREATURE_VETERAN, 2,
	CREATURE_HIPPIE, 1,
	CREATURE_CRITIC_ART, 1,
	CREATURE_CRITIC_MUSIC, 1,
	CREATURE_AUTHOR, 1,
	CREATURE_JOURNALIST, 1,
	CREATURE_SOCIALITE, 1,
	CREATURE_BIKER, 1,
	CREATURE_TRUCKER, 1,
	CREATURE_TAXIDRIVER, 1,
	CREATURE_PROGRAMMER, 1,
	CREATURE_NUN, 1,
	CREATURE_RETIREE, 1,
	CREATURE_PAINTER, 1,
	CREATURE_SCULPTOR, 1,
	CREATURE_DANCER, 1,
	CREATURE_PHOTOGRAPHER, 1,
	CREATURE_CAMERAMAN, 1,
	CREATURE_HAIRSTYLIST, 1,
	CREATURE_FASHIONDESIGNER, 1,
	CREATURE_CLERK, 1,
	CREATURE_THIEF, 3,
	CREATURE_ACTOR, 1,
	CREATURE_YOGAINSTRUCTOR, 1,
	CREATURE_MARTIALARTIST, 1,
	CREATURE_ATHLETE, 1,
	//CREATURE_FIREFIGHTER]+=1,
	CREATURE_LOCKSMITH, 5 }
	),
	map<int, vector<int> >::value_type(SITE_GOVERNMENT_FIRESTATION,{
	CREATURE_WORKER_JANITOR, 5,
	CREATURE_WORKER_SECRETARY, 2,
	CREATURE_NURSE, 2,
	CREATURE_PRIEST, 5,
	CREATURE_JOURNALIST, 1,
	CREATURE_PHOTOGRAPHER, 1,
	CREATURE_FIREFIGHTER, 100 }
	),
	map<int, vector<int> >::value_type(SITE_GOVERNMENT_INTELLIGENCEHQ,{
	CREATURE_WORKER_JANITOR, 50,
	CREATURE_WORKER_SECRETARY, 50,
	CREATURE_GUARDDOG, 50,
	CREATURE_MATHEMATICIAN, 5,
	CREATURE_PROGRAMMER, 5,
	CREATURE_MILITARYOFFICER, 5 }


	),
	map<int, vector<int> >::value_type(SITE_GOVERNMENT_ARMYBASE,{
	CREATURE_SOLDIER, 750,
	CREATURE_GUARDDOG, 20,
	CREATURE_MILITARYPOLICE, 100,
	CREATURE_MILITARYOFFICER, 20,
	CREATURE_SEAL, 20 }


	),
	map<int, vector<int> >::value_type(SITE_INDUSTRY_SWEATSHOP,{
	CREATURE_CORPORATE_MANAGER, 5,
	CREATURE_WORKER_SWEATSHOP, 800 }

	),
	map<int, vector<int> >::value_type(SITE_INDUSTRY_POLLUTER,{
	CREATURE_CORPORATE_MANAGER, 1,
	CREATURE_WORKER_JANITOR, 10,
	CREATURE_WORKER_SECRETARY, 10 }
	),
	map<int, vector<int> >::value_type(SITE_CORPORATE_HEADQUARTERS,{

	CREATURE_CORPORATE_MANAGER, 20,
	CREATURE_WORKER_JANITOR, 20,
	CREATURE_WORKER_SECRETARY, 40,
	CREATURE_JUDGE_CONSERVATIVE, 1,
	CREATURE_LAWYER, 20,
	CREATURE_PRIEST, 1,
	CREATURE_OFFICEWORKER, 80,
	CREATURE_PROSTITUTE, 1 }


	),
	map<int, vector<int> >::value_type(SITE_CORPORATE_HOUSE,{
	CREATURE_WORKER_SERVANT, 30,
	CREATURE_WORKER_SECRETARY, 5,
	CREATURE_TEENAGER, 5,
	CREATURE_GENETIC, 1,
	CREATURE_LAWYER, 5,
	CREATURE_PRIEST, 1,
	CREATURE_PROSTITUTE, 1 }

	),
	map<int, vector<int> >::value_type(SITE_MEDIA_AMRADIO,{
	CREATURE_CORPORATE_MANAGER, 2,
	CREATURE_WORKER_JANITOR, 10,
	CREATURE_WORKER_SECRETARY, 10,
	CREATURE_RADIOPERSONALITY, 2,
	CREATURE_ENGINEER, 20,
	CREATURE_OFFICEWORKER, 40 }


	),
	map<int, vector<int> >::value_type(SITE_MEDIA_CABLENEWS,{
	CREATURE_CORPORATE_MANAGER, 5,
	CREATURE_WORKER_JANITOR, 20,
	CREATURE_WORKER_SECRETARY, 20,
	CREATURE_NEWSANCHOR, 2,
	CREATURE_ENGINEER, 40,
	CREATURE_OFFICEWORKER, 40,
	CREATURE_PHOTOGRAPHER, 5,
	CREATURE_CAMERAMAN, 5 }

	)
};

void addBank(int creaturearray[CREATURENUM], const char sec) {
	extern short mode;
	extern int locx;
	extern int locy;
	extern int locz;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	extern short lawList[LAWNUM];
	if (mode == GAMEMODE_SITE && !(levelmap[locx][locy][locz].flag & SITEBLOCK_RESTRICTED))
	{
		creaturearray[CREATURE_BANK_MANAGER] = 20;
		creaturearray[CREATURE_SCIENTIST_LABTECH] = 1;
		creaturearray[CREATURE_WORKER_JANITOR] = 1;
		creaturearray[CREATURE_WORKER_SECRETARY] = 1;
		creaturearray[CREATURE_TEENAGER] = 3;
		creaturearray[CREATURE_COP] += 1;
		creaturearray[CREATURE_LAWYER] = 1;
		creaturearray[CREATURE_SEWERWORKER] = 1;
		creaturearray[CREATURE_COLLEGESTUDENT] = 1;
		creaturearray[CREATURE_MUSICIAN] = 1;
		creaturearray[CREATURE_MATHEMATICIAN] = 1;
		creaturearray[CREATURE_TEACHER] = 1;
		creaturearray[CREATURE_PRIEST] = 1;
		creaturearray[CREATURE_ENGINEER] = 1;
		creaturearray[CREATURE_FASTFOODWORKER] = 1;
		creaturearray[CREATURE_BAKER] = 1;
		creaturearray[CREATURE_BARISTA] = 1;
		creaturearray[CREATURE_BARTENDER] = 1;
		creaturearray[CREATURE_TELEMARKETER] = 1;
		creaturearray[CREATURE_CARSALESMAN] = 1;
		creaturearray[CREATURE_OFFICEWORKER] = 1;
		creaturearray[CREATURE_FOOTBALLCOACH] = 1;
		creaturearray[CREATURE_MAILMAN] = 1;
		creaturearray[CREATURE_DOCTOR] = 1;
		creaturearray[CREATURE_PSYCHOLOGIST] += 1;
		creaturearray[CREATURE_NURSE] = 1;
		creaturearray[CREATURE_GARBAGEMAN] = 1;
		creaturearray[CREATURE_PLUMBER] = 1;
		creaturearray[CREATURE_CHEF] = 1;
		creaturearray[CREATURE_CONSTRUCTIONWORKER] = 1;
		creaturearray[CREATURE_AMATEURMAGICIAN] = 1;
		creaturearray[CREATURE_SOLDIER] = 1;
		creaturearray[CREATURE_VETERAN] = 2;
		creaturearray[CREATURE_HIPPIE] = 1;
		creaturearray[CREATURE_CRITIC_ART] = 1;
		creaturearray[CREATURE_CRITIC_MUSIC] = 1;
		creaturearray[CREATURE_AUTHOR] = 1;
		creaturearray[CREATURE_JOURNALIST] = 1;
		creaturearray[CREATURE_TAXIDRIVER] = 1;
		creaturearray[CREATURE_PROGRAMMER] = 1;
		creaturearray[CREATURE_RETIREE] = 1;
		creaturearray[CREATURE_PAINTER] = 1;
		creaturearray[CREATURE_SCULPTOR] = 1;
		creaturearray[CREATURE_DANCER] = 1;
		creaturearray[CREATURE_PHOTOGRAPHER] = 1;
		creaturearray[CREATURE_CAMERAMAN] = 1;
		creaturearray[CREATURE_HAIRSTYLIST] = 1;
		creaturearray[CREATURE_CLERK] = 1;
		creaturearray[CREATURE_THIEF] = 1;
		creaturearray[CREATURE_ACTOR] = 1;
		creaturearray[CREATURE_YOGAINSTRUCTOR] = 1;
		creaturearray[CREATURE_MARTIALARTIST] += 1;
		creaturearray[CREATURE_ATHLETE] = 1;
		creaturearray[CREATURE_FIREFIGHTER] += 1;
		creaturearray[CREATURE_LOCKSMITH] += 1;


		if (sec) creaturearray[CREATURE_MERC] = 100;
		else creaturearray[CREATURE_SECURITYGUARD] = 50;
		if (lawList[LAW_LABOR] < 2)creaturearray[CREATURE_WORKER_FACTORY_NONUNION] = 1;
		if (lawList[LAW_LABOR] >= 0)creaturearray[CREATURE_WORKER_FACTORY_UNION] = 1;
		if (lawList[LAW_DEATHPENALTY] == -2 &&
			lawList[LAW_POLICEBEHAVIOR] == -2)creaturearray[CREATURE_DEATHSQUAD] += 1;
		if (lawList[LAW_POLICEBEHAVIOR] <= -1)creaturearray[CREATURE_GANGUNIT] += 1;
		if (lawList[LAW_DEATHPENALTY] == -2 &&
			lawList[LAW_POLICEBEHAVIOR] == -2)creaturearray[CREATURE_EDUCATOR] += 1;
		else creaturearray[CREATURE_PRISONGUARD] += 1;
	}
	else
	{
		creaturearray[CREATURE_BANK_MANAGER] = 200;
		creaturearray[CREATURE_THIEF] = 1;


		if (sec) creaturearray[CREATURE_MERC] = 2000;
		else creaturearray[CREATURE_SECURITYGUARD] = 1000;
	}
}
void addUpscaleApartment(int creaturearray[CREATURENUM], const char sec) {
	extern short mode;
	extern int locx;
	extern int locy;
	extern int locz;
	extern short lawList[LAWNUM];
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];



	if (mode == GAMEMODE_SITE && !(levelmap[locx][locy][locz].flag & SITEBLOCK_RESTRICTED))
	{
		if (sec)creaturearray[CREATURE_SECURITYGUARD] += 100;
		else creaturearray[CREATURE_SECURITYGUARD] += 10;
		if (sec)creaturearray[CREATURE_GUARDDOG] += 50;
	}
	else if (mode == GAMEMODE_SITE && sec)
	{
		//inside someone's room when security is high. Might meet a policeman.
		if (lawList[LAW_DEATHPENALTY] == -2 && lawList[LAW_POLICEBEHAVIOR] == -2)
			creaturearray[CREATURE_DEATHSQUAD] += 5;
		if (lawList[LAW_POLICEBEHAVIOR] <= -1)
			creaturearray[CREATURE_GANGUNIT] += 10;
		creaturearray[CREATURE_COP] += 15;
	}
}

void addPrison(int creaturearray[CREATURENUM], const char sec) {
	extern int locx;
	extern int locy;
	extern int locz;
	extern short lawList[LAWNUM];
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];

	if (levelmap[locx][locy][locz].flag & SITEBLOCK_RESTRICTED)
		creaturearray[CREATURE_PRISONER] = 8; // prisoners only in restricted areas
	if (sec)
	{
		if (lawList[LAW_DEATHPENALTY] == -2 &&
			lawList[LAW_POLICEBEHAVIOR] == -2)creaturearray[CREATURE_EDUCATOR] += 3;
		else creaturearray[CREATURE_PRISONGUARD] += 3;
	}
	else
	{
		if (lawList[LAW_DEATHPENALTY] == -2 &&
			lawList[LAW_POLICEBEHAVIOR] == -2)creaturearray[CREATURE_EDUCATOR] += 2;
		else creaturearray[CREATURE_PRISONGUARD] += 2;
	}
}

void addPoliceOrMilitary(int creaturearray[CREATURENUM]) {
	extern short siteonfire;
	extern short sitetype;
	extern short lawList[LAWNUM];
	switch (sitetype)
	{
	case SITE_GOVERNMENT_ARMYBASE:
		creaturearray[CREATURE_SOLDIER] = 1000;
		creaturearray[CREATURE_MILITARYPOLICE] = 300;
		creaturearray[CREATURE_MILITARYOFFICER] = 150;
		creaturearray[CREATURE_SEAL] = 150;
		creaturearray[CREATURE_GUARDDOG] = 100;
		creaturearray[CREATURE_TANK] = 100;
		break;
	case SITE_GOVERNMENT_WHITE_HOUSE:
		creaturearray[CREATURE_SECRET_SERVICE] = 1000;
		creaturearray[CREATURE_MILITARYOFFICER] = 100;
		break;
	case SITE_GOVERNMENT_INTELLIGENCEHQ:
		creaturearray[CREATURE_AGENT] = 1000;
		creaturearray[CREATURE_MILITARYOFFICER] = 100;
		creaturearray[CREATURE_GUARDDOG] = 50;
		break;
	case SITE_CORPORATE_HEADQUARTERS:
	case SITE_CORPORATE_HOUSE:
		creaturearray[CREATURE_MERC] = 1000;
		break;
	case SITE_MEDIA_AMRADIO:
	case SITE_MEDIA_CABLENEWS:
		creaturearray[CREATURE_HICK] = 1000;
		break;
	case SITE_GOVERNMENT_POLICESTATION:
		if (lawList[LAW_DEATHPENALTY] == -2 &&
			lawList[LAW_POLICEBEHAVIOR] == -2)creaturearray[CREATURE_DEATHSQUAD] = 1000;
		else creaturearray[CREATURE_SWAT] = 1000;
		break;
	default:
		if (lawList[LAW_DEATHPENALTY] == -2 &&
			lawList[LAW_POLICEBEHAVIOR] == -2)creaturearray[CREATURE_DEATHSQUAD] = 1000;
		else if (lawList[LAW_POLICEBEHAVIOR] <= -1)creaturearray[CREATURE_GANGUNIT] = 1000;
		else creaturearray[CREATURE_COP] = 1000;
		break;
	}
	if (siteonfire && lawList[LAW_FREESPEECH] != -2)creaturearray[CREATURE_FIREFIGHTER] = 1000;
}
void addCCS(int creaturearray[CREATURENUM]) {
	creaturearray[CREATURE_CCS_VIGILANTE] += 50;
	//creaturearray[CREATURE_CCS_ARCHCONSERVATIVE]+=endgamestate;
	creaturearray[CREATURE_PROSTITUTE] += 5;
	creaturearray[CREATURE_CRACKHEAD] += 5;
	creaturearray[CREATURE_PRIEST] += 5;
	creaturearray[CREATURE_RADIOPERSONALITY] += 1;

}
bool populateEncounter(const int type, int creaturearray[CREATURENUM], const char sec);
/* generates a new random encounter */
void prepareencounter(short type, char sec)
{
	extern short mode;
	extern int locx;
	extern int locy;
	extern int locz;
	extern short postalarmtimer;
	extern short cursite;
	extern Creature encounter[ENCMAX];
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	int encslot = 0;
	emptyEncounter();
	int creaturearray[CREATURENUM];
	memset(creaturearray, 0, CREATURENUM * sizeof(int));
	if (postalarmtimer > 80)
	{
		addPoliceOrMilitary(creaturearray);
	}
	if (LocationsPool::getInstance().getRentingType(cursite) == RENTING_CCS)
	{
		addCCS(creaturearray);
		for (int n = 0; n < LCSrandom(6) + 1; n++)
		{
			makecreature(encounter[encslot], getrandomcreaturetype(creaturearray));
			conservatise(encounter[encslot]);
			encslot++;
		}
	}
	else
	{
		if (type != SITE_BUSINESS_BANK && type != SITE_GOVERNMENT_PRISON) {
			for (int i = 0; i < len(locationsSpawners[type]); i += 2) {
				creaturearray[locationsSpawners[type][i]] += locationsSpawners[type][i + 1];
			}
		}
		int encnum = 6;
		const int variableEncnum = mode == GAMEMODE_SITE && !(levelmap[locx][locy][locz].flag & SITEBLOCK_RESTRICTED) ? 4 : 1;
		bool variableEncounter = false;
		switch (type) {
		case SITE_GOVERNMENT_PRISON:
		{
			addPrison(creaturearray, sec);
			break;
		}
		case SITE_BUSINESS_BANK:
		{
			addBank(creaturearray, sec);
			variableEncounter = true;
			break;
		}
		case SITE_RESIDENTIAL_APARTMENT_UPSCALE:
		{
			addUpscaleApartment(creaturearray, sec);
			variableEncounter = true;
			break;
		}
		default:
			variableEncounter = populateEncounter(type, creaturearray, sec);
			break;
		}
		if (variableEncounter) {
			encnum = variableEncnum;

		}
		for (int n = 0; n < LCSrandom(encnum) + 1; n++)
		{
			makecreature(encounter[encslot], getrandomcreaturetype(creaturearray));
			encslot++;
		}
	}
}
/* generates a new siege encounter */
char addsiegeencounter(char type)
{
	extern short sitetype;
	extern short cursite;
	extern short lawList[LAWNUM];
	extern Creature encounter[ENCMAX];
	int num;
	int freeslots = 0;
	for (int e = 0; e < ENCMAX; e++)
	{
		if (!encounter[e].exists)freeslots++;
	}
	switch (type)
	{
	case SIEGEFLAG_UNIT:
	case SIEGEFLAG_UNIT_DAMAGED:
	{
		if (freeslots < 6)return 0;
		num = LCSrandom(3) + 4;
		if (LocationsPool::getInstance().isThereASiegeHere(cursite))
		{
			switch (LocationsPool::getInstance().getSiegeType(cursite))
			{
			case SIEGE_POLICE:
				if (LocationsPool::getInstance().getSiegeEscalationState(cursite) == 0)
					fillEncounter(CREATURE_SWAT, num);
				else
				{
					if (LocationsPool::getInstance().getSiegeEscalationState(cursite) < 3) fillEncounter(CREATURE_SOLDIER, num);
					else fillEncounter(CREATURE_SEAL, num);
				}
				break;
			case SIEGE_CIA:
				fillEncounter(CREATURE_AGENT, num);
				break;
			case SIEGE_HICKS:
				fillEncounter(CREATURE_HICK, num);
				break;
			case SIEGE_CORPORATE:
				fillEncounter(CREATURE_MERC, num);
				break;
			case SIEGE_CCS:
				for (int e = 0; e < ENCMAX && num > 0; e++) {
					if (!encounter[e].exists) {
						if (!LCSrandom(12))
							makecreature(encounter[e], CREATURE_CCS_ARCHCONSERVATIVE);
						else if (!LCSrandom(11))
							makecreature(encounter[e], CREATURE_CCS_MOLOTOV);
						else if (!LCSrandom(10))
							makecreature(encounter[e], CREATURE_CCS_SNIPER);
						else makecreature(encounter[e], CREATURE_CCS_VIGILANTE);
						num--;
					}
				}
				break;
			case SIEGE_FIREMEN:
				fillEncounter(CREATURE_FIREFIGHTER, num);
				break;
			}
		}
		else
		{
			switch (sitetype)
			{
			case SITE_GOVERNMENT_ARMYBASE:
				if (!encounter[0].exists && !LCSrandom(2)) {
					makecreature(encounter[0], CREATURE_TANK);
					num--;
				}
				fillEncounter(CREATURE_SOLDIER, num);
				break;
			case SITE_GOVERNMENT_INTELLIGENCEHQ:
				fillEncounter(CREATURE_AGENT, num);
				break;
			case SITE_CORPORATE_HEADQUARTERS:
			case SITE_CORPORATE_HOUSE:
				fillEncounter(CREATURE_MERC, num);
				break;
			case SITE_MEDIA_AMRADIO:
			case SITE_MEDIA_CABLENEWS:
				fillEncounter(CREATURE_HICK, num);
				break;
			case SITE_GOVERNMENT_POLICESTATION:
				if (lawList[LAW_DEATHPENALTY] == -2 &&
					lawList[LAW_POLICEBEHAVIOR] == -2)fillEncounter(CREATURE_DEATHSQUAD, num);
				else fillEncounter(CREATURE_SWAT, num);
				break;
			case SITE_BUSINESS_CRACKHOUSE:
				// TODO this causes all encountered creatures to become conservative, not just the gangmembers
				fillEncounter(CREATURE_GANGMEMBER, num);
				for (int e = 0; e < ENCMAX; e++) {
					if (encounter[e].exists)
						encounter[e].align = ALIGN_CONSERVATIVE;
				}
				break;
			default:
				if (LocationsPool::getInstance().getRentingType(cursite) == RENTING_CCS)
				{
					for (int e = 0; e < ENCMAX && num > 0; e++) {
						if (!LCSrandom(11))
							makecreature(encounter[e], CREATURE_CCS_MOLOTOV);
						else if (!LCSrandom(10))
							makecreature(encounter[e], CREATURE_CCS_SNIPER);
						else makecreature(encounter[e], CREATURE_CCS_VIGILANTE);
						num--;
					}
				}
				else if (lawList[LAW_DEATHPENALTY] == -2 &&
					lawList[LAW_POLICEBEHAVIOR] == -2)fillEncounter(CREATURE_DEATHSQUAD, num);
				else fillEncounter(CREATURE_SWAT, num);
				break;
			}
		}
		// TODO this causes all encountered creatures to be damaged, not just the newly generated ones
		if (type == SIEGEFLAG_UNIT_DAMAGED)
			for (int e = 0; e < ENCMAX; e++) {
				if (encounter[e].exists)
					encounter[e].blood = LCSrandom(75) + 1;
			}
		break;
	}
	case SIEGEFLAG_HEAVYUNIT:
	{
		if (freeslots < 1)return 0;
		num = 1;
		fillEncounter(CREATURE_TANK, num);
		break;
	}
	}
	return 1;
}

const string tag_SPORTS_CAR = "SPORTS_CAR";
const string tag_ASSAULT_RIFLE = "ASSAULT_RIFLE";
const string tag_RECRUITS_GANG = "RECRUITS_GANG";
const string tag_JUICE = "JUICE";
const string tag_BASE = "BASE";
const string tag_CREATURE = "CREATURE";
const string tag_HASMAPS = "HASMAPS";
const string tag_GAY = "GAY";
const string tag_DATING_LAWYER = "DATING_LAWYER";
const string tag_MONEY = "MONEY";
const string tag_YEAR = "YEAR";
const string tag_DAY = "DAY";
const string tag_MONTH = "MONTH";
const string tag_BIRTHDAY_ = "BIRTHDAY_";
const string tag_STARTING_ = "STARTING_";
const string tag_ATTRIBUTE_ = "ATTRIBUTE_";
const string tag_SKILL_ = "SKILL_";
const string tag__2 = "_2";
const string tag_QUESTION = "QUESTION";
const string tag_ANSWER = "ANSWER";
const string tag_HEADER = "HEADER";


string theLCS;
string notASkill;
string notAnAttribute;
Vehicle* newSportsCar();
string aNewConEra;
string theYearIs;
string conservativePresident;
string endsSecondTerm;
string highSeventiesApprovePres;
string conMajorityHouse;
string senateConMajority;
string beginningOfNew;
string conEra;
string thePresident;
string hasAskedCongressBeQuick;
string rubberStampArchCon;
string theLeftSeems;
string powerlessToStop;
string inThisDarkTime;
string whatIsYourName;
string pressEnterToBeRealName;
string invalidTag;
string theDocSaid;
string aBoy;
string aGirl;
string intersex;
string myParents;
string insistedOtherwise;
string they;
string namedMe;
string error;
string theFounder;
string firstName;
string pressAtoReconsider;
string lastName;
string pressBtoBeReborn;
string sexIs;
string male;
string female;
string itsComplicated;
string pressCtoChangeSex;
string history;
string letMeChoose;
string letFateDecide;
string pressDtoToggle;
string city;
string pressEtoRelocate;
string pressAnyKeyString;
string allOptions;
string unSelected;
string isSelected;
string pressAnyOtherKey;
string notCreature;
string notValidMap;
string notSpecialWound;
string newGameAdvanced;
string a_classicMode;
string b_weDidntStartIt;
string c_nightmareMode;
string d_nationalLCS;
string e_marathonMode;
string f_stalinistMode;
string newGameYourAgenda;
string a_noComprimise;
string b_democrat;
string newGameFieldLearn;
string affectsTheseSkills;
string a_fastSkills;
string b_classic;
string c_hardMode;
void newVehicle(Vehicle *startcar);
vector<string> founderQuestions;
// #include "../customMaps.h"
vector<file_and_text_collection> newgame_file_collection = {
	/*newgame.cpp*/
	customText(&founderQuestions, "newgame\\founderQuestions.txt"),
};
map<string, short> getSkillEnumFromString;
map<short, string> enumToCreature;
map<string, short> getBaseEnumFromString;
map<string, short> getSpecialWoundEnumFromString;
bool getSetValue(const string& s) {
	int j = -1;
	for (int i = 0; i < s.size(); i++) {
		if (s[i] == ' ') {
			j = i;
			break;
		}
	}
	return j > -1 && (s[j] == '-' || s[j] == '+');
}
int getMagnitudeFromString(const string& s) {
	bool spaceUnfound = true;
	int j = 0;
	for (int i = s.size() - 2; i > 0 && spaceUnfound; i--) {
		if (s[i] == ' ') {
			spaceUnfound = false;
			j = i;
		}
	}
	if (spaceUnfound) {
		clearAlt();
		mvaddstrAlt(0, 0, error);
		mvaddstrAlt(1, 0, s);
		pressAnyKey();
	}
	return atoi(s.substr(j).data());
}
// IsaacG Brute force substring matching
// suboptimal, but very very easy to code.
short findSubstring(map<string, short> str, const string& s) {
	for (int i = strlen(s.data()); i >= 0; i--) {
		for (int j = 0; j <= strlen(s.data() - i); j++) {
			if (str.count(s.substr(j, i))) {
				return str[s.substr(j, i)];
			}
		}
	}
	return -1;
}
int getSkillFromString(const string& s) {
	int output = findSubstring(getSkillEnumFromString, s);
	if (output >= 0) {
		return output;
	}
	else {// ERROR
		addstrAlt(error);
		addstrAlt(s);
		addstrAlt(notASkill);
		pressAnyKey();
		return -1;
	}
}
map<string, short> getAttributeEnumFromString;
int getAttributeFromString(const string& s) {
	int output = findSubstring(getAttributeEnumFromString, s);
	if (output >= 0) {
		return output;
	}
	else {// ERROR
		addstrAlt(error);
		addstrAlt(s);
		addstrAlt(notAnAttribute);
		pressAnyKey();
		return -1;
	}
}
map<string, short> getCreatureEnumFromString;
int getCreatureFromString(const string& s) {
	int output = findSubstring(getCreatureEnumFromString, s);
	if (output >= 0) {
		return output;
	}
	else
	{// ERROR
		addstrAlt(error);
		addstrAlt(s);
		addstrAlt(notCreature);
		pressAnyKey();
		return -1;
	}
}
string enumToCreatureString(const int i) {
	if (enumToCreature.count(i)) {
		return enumToCreature[i];
	}
	else {
		return blankString;
	}
}
int getBaseFromString(const string& s) {
	const string baseString = s.substr(5);
	int output = findSubstring(getBaseEnumFromString, baseString);
	if (output >= 0) {
		return output;
	}
	else {// ERROR
		addstrAlt(error);
		addstrAlt(s);
		addstrAlt(notValidMap);
		pressAnyKey();
		return -1;
	}
}
int getSpecialWoundFromString(const string& s) {
	int output = findSubstring(getSpecialWoundEnumFromString, s);
	if (output >= 0) {
		return output;
	}
	else {// ERROR
		addstrAlt(error);
		addstrAlt(s);
		addstrAlt(notSpecialWound);
		pressAnyKey();
		return -1;
	}
}
/* select new game options */
void setup_newgame()
{
	// Allow experimental, incomplete Stalinist Comrade Squad mode to be chosen for new games
	extern bool ALLOWSTALIN;
	extern char endgamestate;
	extern short wincondition;
	extern short fieldskillrate;
	extern bool notermlimit;           //These determine if ELAs can take place --kviiri
	extern bool nocourtpurge;
	extern bool stalinmode;
	extern bool multipleCityMode;
	extern MusicClass music;
	extern short lawList[LAWNUM];
	extern short house[HOUSENUM];
	extern short senate[SENATENUM];
	extern short court[COURTNUM];
	extern char courtname[COURTNUM][POLITICIAN_NAMELEN];
	extern short attitude[VIEWNUM];
	//TODO IsaacG Get rid of these while(true) break; loops
	music.play(MUSIC_NEWGAME);
	bool classicmode = false;
	bool strongccs = false;
	bool nightmarelaws = false;
	multipleCityMode = false;
	stalinmode = false;
	clearAlt();
	while (true)
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(4, 6, newGameAdvanced);
		set_color_easy(WHITE_ON_BLACK);
		{
			string isThisSelected;
			if (classicmode)
				isThisSelected = (isSelected);
			else isThisSelected = (unSelected);
			mvaddstrAlt(7, 0, isThisSelected);
			addstrAlt(a_classicMode);
			if (!classicmode)
				set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			if (strongccs)
				isThisSelected = (isSelected);
			else isThisSelected = (unSelected);
			mvaddstrAlt(9, 0, isThisSelected);
			addstrAlt(b_weDidntStartIt);
			set_color_easy(WHITE_ON_BLACK);
			if (nightmarelaws)
				isThisSelected = (isSelected);
			else isThisSelected = (unSelected);
			mvaddstrAlt(11, 0, isThisSelected);
			addstrAlt(c_nightmareMode);
			set_color_easy(WHITE_ON_BLACK);
			if (multipleCityMode)
				isThisSelected = (isSelected);
			else isThisSelected = (unSelected);
			mvaddstrAlt(13, 0, isThisSelected);
			addstrAlt(d_nationalLCS);
			if (nocourtpurge)
				isThisSelected = (isSelected);
			else isThisSelected = (unSelected);
			mvaddstrAlt(15, 0, isThisSelected);
			addstrAlt(e_marathonMode);
			int bottomRow;
			if (ALLOWSTALIN) {
				if (stalinmode)
					isThisSelected = (isSelected);
				else isThisSelected = (unSelected);
				mvaddstrAlt(17, 0, isThisSelected);
				addstrAlt(f_stalinistMode);
				bottomRow = 21;
			}
			else {// ALLOWSTALIN
				bottomRow = 19;
			}// ALLOWSTALIN
			mvaddstrAlt(bottomRow, 4, pressAnyOtherKey);
		}
		const int c = getkeyAlt();
		if (c == 'a')
		{
			classicmode = !classicmode;
			continue;
		}
		if (c == 'b')
		{
			strongccs = !strongccs;
			continue;
		}
		if (c == 'c')
		{
			nightmarelaws = !nightmarelaws;
			continue;
		}
		if (c == 'd')
		{
			multipleCityMode = !multipleCityMode;
			continue;
		}
		if (c == 'e')
		{
			nocourtpurge = !nocourtpurge;
			notermlimit = !notermlimit;
			continue;
		}
		if (ALLOWSTALIN) {
			if (c == 'f')
			{
				stalinmode = !stalinmode;
				continue;
			}
		}
		break;
	}
	if (nightmarelaws)
	{
		for (int l = 0; l < LAWNUM; l++)
			lawList[l] = ALIGN_ARCHCONSERVATIVE;
		for (int a = 0; a < VIEWNUM - 3; a++)
			attitude[a] = (LCSrandom(20));
		for (int s = 0; s < SENATENUM; s++)
		{
			if (s < 55) senate[s] = ALIGN_ARCHCONSERVATIVE;
			else if (s < 70) senate[s] = ALIGN_CONSERVATIVE;
			else if (s < 80) senate[s] = ALIGN_MODERATE;
			else if (s < 97) senate[s] = ALIGN_LIBERAL;
			else senate[s] = ALIGN_ELITELIBERAL;
		}
		for (int h = 0; h < HOUSENUM; h++)
		{
			if (h < 220) house[h] = ALIGN_ARCHCONSERVATIVE;
			else if (h < 350) house[h] = ALIGN_CONSERVATIVE;
			else if (h < 400) house[h] = ALIGN_MODERATE;
			else if (h < 425) house[h] = ALIGN_LIBERAL;
			else house[h] = ALIGN_ELITELIBERAL;
		}
		for (int c = 0; c < COURTNUM; c++)
		{
			if (c < 5) court[c] = ALIGN_ARCHCONSERVATIVE;
			else if (c < 7) court[c] = ALIGN_CONSERVATIVE;
			else if (c < 8) court[c] = ALIGN_MODERATE;
			else if (c < 8) court[c] = ALIGN_LIBERAL;
			else court[c] = ALIGN_ELITELIBERAL;
			do
			{
				if (court[c] == ALIGN_ARCHCONSERVATIVE)
					generate_name(courtname[c], GENDER_WHITEMALEPATRIARCH);
				else generate_name(courtname[c]);
			} while (len(courtname[c]) > 20);
		}
	}
	if (classicmode)
		endgamestate = ENDGAME_CCS_DEFEATED;
	else if (strongccs)
	{
		endgamestate = ENDGAME_CCS_ATTACKS;
		//attitude[VIEW_POLITICALVIOLENCE]=90;
	}
	clearAlt();
	while (true)
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(4, 6, newGameYourAgenda);
		set_color_easy(WHITE_ON_BLACK);
		string isThisSelected;
		if (wincondition == WINCONDITION_ELITE)
			isThisSelected = (isSelected);
		else isThisSelected = (unSelected);
		mvaddstrAlt(7, 0, isThisSelected);
		addstrAlt(a_noComprimise);
		ColorSetup useThisColor;
		if (!classicmode)
			useThisColor = (WHITE_ON_BLACK);
		else useThisColor = (BLACK_ON_BLACK_BRIGHT);
		set_color_easy(useThisColor);
		if (wincondition == WINCONDITION_EASY)
			isThisSelected = (isSelected);
		else isThisSelected = (unSelected);
		mvaddstrAlt(9, 0, isThisSelected);
		addstrAlt(b_democrat);
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(13, 4, pressAnyOtherKey);
		const int c = getkeyAlt();
		if (c == 'a')
		{
			wincondition = WINCONDITION_ELITE;
			continue;
		}
		if (c == 'b')
		{
			wincondition = WINCONDITION_EASY;
			continue;
		}
		break;
	}
	clearAlt();
	while (true)
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(4, 6, newGameFieldLearn);
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(5, 6, affectsTheseSkills);
		string isThisSelected;
		if (fieldskillrate == FIELDSKILLRATE_FAST)
			isThisSelected = (isSelected);
		else isThisSelected = (unSelected);
		mvaddstrAlt(8, 0, isThisSelected);
		addstrAlt(a_fastSkills);
		if (fieldskillrate == FIELDSKILLRATE_CLASSIC)
			isThisSelected = (isSelected);
		else isThisSelected = (unSelected);
		mvaddstrAlt(10, 0, isThisSelected);
		addstrAlt(b_classic);
		if (fieldskillrate == FIELDSKILLRATE_HARD)
			isThisSelected = (isSelected);
		else isThisSelected = (unSelected);
		mvaddstrAlt(12, 0, isThisSelected);
		addstrAlt(c_hardMode);
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(16, 4, pressAnyOtherKey);
		const int c = getkeyAlt();
		if (c == 'a')
		{
			fieldskillrate = FIELDSKILLRATE_FAST;
			continue;
		}
		if (c == 'b')
		{
			fieldskillrate = FIELDSKILLRATE_CLASSIC;
			continue;
		}
		if (c == 'c')
		{
			fieldskillrate = FIELDSKILLRATE_HARD;
			continue;
		}
		break;
	}
}
enum Stat_Or_Attribute {
	SKILL,
	ATTRIBUTE,
	OTHER
};
enum Other_Influence {
	BIRTH_MONTH,
	BIRTH_DAY,
	BIRTH_YEAR,
	STARTING_MONTH,
	STARTING_DAY,
	STARTING_YEAR,
	GAY,
	DATING_LAWYER,
	DATING,
	HAS_MAPS,
	JUICE,
	SPORTS_CAR,
	ASSAULT_RIFLE,
	MONEY,
	BASE,
	CREATURE,
	ARMOR,
	RECRUITS
};
struct Impact {
	Stat_Or_Attribute type;
	int item_to_influcence;
	int magnitude;
	bool set_value;
};
struct Choice {
	string ANSWER;
	string ANSWER_2;
	vector<Impact> impact;
};
struct Question {
	string HEADER;
	string HEADER_2;
	string QUESTION;
	string QUESTION_2;
	vector<Choice> choices;
};
void printIntroduction() {
	extern Log gamelog;
	extern char execname[EXECNUM][POLITICIAN_NAMELEN];
	extern int year;
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(2, 2, aNewConEra, gamelog);
	gamelog.newline();
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(4, 2, theYearIs, gamelog);
	addstrAlt(year, gamelog);
	addstrAlt(singleDot, gamelog);
	gamelog.newline();
	mvaddstrAlt(6, 2, conservativePresident, gamelog);
	char president[80];
	generate_name(president, GENDER_WHITEMALEPATRIARCH);
	addstrAlt(president, gamelog);
	addstrAlt(endsSecondTerm, gamelog);
	gamelog.newline();
	mvaddstrAlt(7, 2, highSeventiesApprovePres, gamelog);
	gamelog.newline();
	mvaddstrAlt(8, 2, execname[EXEC_PRESIDENT], gamelog);
	addstrAlt(singleDot, gamelog);
	gamelog.nextMessage();
	mvaddstrAlt(10, 2, conMajorityHouse, gamelog);
	gamelog.newline();
	mvaddstrAlt(11, 2, senateConMajority, gamelog);
	gamelog.newline();
	mvaddstrAlt(12, 2, beginningOfNew, gamelog);
	gamelog.newline();
	mvaddstrAlt(13, 2, conEra, gamelog);
	gamelog.nextMessage();
	set_color_easy(RED_ON_BLACK_BRIGHT);
	mvaddstrAlt(15, 2, thePresident, gamelog);
	addstrAlt(execname[EXEC_PRESIDENT], gamelog);
	addstrAlt(hasAskedCongressBeQuick, gamelog);
	gamelog.newline();
	mvaddstrAlt(16, 2, rubberStampArchCon, gamelog);
	set_color_easy(WHITE_ON_BLACK);
	addstrAlt(theLeftSeems, gamelog);
	gamelog.newline();
	mvaddstrAlt(17, 2, powerlessToStop, gamelog);
	gamelog.nextMessage();
	mvaddstrAlt(19, 2, inThisDarkTime, gamelog);
	gamelog.nextMessage();
	pressAnyKey();
}
vector<Question> gatherAllFounderQuestions() {
	const int MAX_CHOICES = 10;
	vector<Question> allQuestions;
	bool firstQuestion = true;
	bool firstAnswer = true;
	Question currentQuestion;
	Choice currentChoice;
	string header = blankString;
	string header_2 = blankString;
	string answer = blankString;
	string answer_2 = blankString;
	//IsaacG This loop needs a rewrite
	for (int i = 0; i < founderQuestions.size(); i++) {
		const string first = founderQuestions[i];
		if (first.substr(0, 6) == tag_HEADER) {
			if (first.substr(6, 1) == singleSpace) {
				header = first.substr(7);
				header_2 = blankString;
			}
			else  if (first.substr(6, 2) == tag__2) {
				header_2 = first.substr(9);
			}
		}
		else if (first.substr(0, 6) == tag_ANSWER) {
			if (firstAnswer) {
				if (first.substr(6, 1) == singleSpace) {
					answer = first.substr(7);
					answer_2 = blankString;
					firstAnswer = false;
				}
				else  if (first.substr(6, 2) == tag__2) {
					answer_2 = first.substr(9);
				}
			}
			else {
				if (first.substr(6, 1) == singleSpace) {
					currentChoice.ANSWER = answer;
					currentChoice.ANSWER_2 = answer_2;
					if (currentQuestion.choices.size() < MAX_CHOICES - 1) {
						currentQuestion.choices.push_back(currentChoice);
					}
					currentChoice.impact.clear();
					answer = first.substr(7);
					answer_2 = blankString;
				}
				else  if (first.substr(6, 2) == tag__2) {
					answer_2 = first.substr(9);
				}
			}
		}
		else if (first.substr(0, 8) == tag_QUESTION) {
			if (!firstQuestion) {
				if (first.substr(8, 1) == singleSpace) {
					currentChoice.ANSWER = answer;
					currentChoice.ANSWER_2 = answer_2;
					currentQuestion.choices.push_back(currentChoice);
					allQuestions.push_back(currentQuestion);
					currentQuestion.choices.clear();
					currentChoice.impact.clear();
					currentChoice.ANSWER = blankString;
					currentChoice.ANSWER_2 = blankString;
					currentQuestion.HEADER = header;
					currentQuestion.HEADER_2 = header_2;
					currentQuestion.QUESTION = first.substr(9);
					currentQuestion.QUESTION_2 = blankString;
					firstAnswer = true;
				}
				else if (first.substr(8, 2) == tag__2) {
					currentQuestion.QUESTION_2 = first.substr(12);
				}
			}
			else {
				firstQuestion = false;
				firstAnswer = true;
				currentChoice.ANSWER = blankString;
				currentChoice.ANSWER_2 = blankString;
				currentQuestion.HEADER = header;
				currentQuestion.HEADER_2 = header_2;
				currentQuestion.QUESTION = first.substr(9);
				currentQuestion.QUESTION_2 = blankString;
			}
		}
		else {
			bool invalidTag = false;
			Impact currentImpact;
			if (first.substr(0, 6) == tag_SKILL_) {
				currentImpact.type = SKILL;
				currentImpact.item_to_influcence = getSkillFromString(founderQuestions[i]);
				currentImpact.set_value = getSetValue(founderQuestions[i]);
				currentImpact.magnitude = getMagnitudeFromString(founderQuestions[i]);
				if (currentImpact.item_to_influcence == -1) {
					invalidTag = true;
				}
			}
			else if (first.substr(0, 10) == tag_ATTRIBUTE_) {
				currentImpact.type = ATTRIBUTE;
				currentImpact.item_to_influcence = getAttributeFromString(founderQuestions[i]);
				currentImpact.set_value = getSetValue(founderQuestions[i]);
				currentImpact.magnitude = getMagnitudeFromString(founderQuestions[i]);
				if (currentImpact.item_to_influcence == -1) {
					invalidTag = true;
				}
			}
			else if (first.substr(0, 9) == tag_STARTING_) {
				currentImpact.type = OTHER;
				currentImpact.set_value = true;
				currentImpact.magnitude = getMagnitudeFromString(founderQuestions[i]);
				if (first.substr(9, 5) == tag_MONTH) {
					currentImpact.item_to_influcence = STARTING_MONTH;
				}
				else if (first.substr(9, 3) == tag_DAY) {
					currentImpact.item_to_influcence = STARTING_DAY;
				}
				else if (first.substr(9, 4) == tag_YEAR) {
					currentImpact.item_to_influcence = STARTING_YEAR;
				}
				else {
					invalidTag = true;
				}
			}
			else if (first.substr(0, 9) == tag_BIRTHDAY_) {
				currentImpact.type = OTHER;
				currentImpact.item_to_influcence = 0;
				currentImpact.set_value = true;
				currentImpact.magnitude = getMagnitudeFromString(founderQuestions[i]);
				if (first.substr(9, 5) == tag_MONTH) {
					currentImpact.item_to_influcence = BIRTH_MONTH;
				}
				else if (first.substr(9, 3) == tag_DAY) {
					currentImpact.item_to_influcence = BIRTH_DAY;
				}
				else if (first.substr(9, 4) == tag_YEAR) {
					currentImpact.item_to_influcence = BIRTH_YEAR;
				}
				else {
					invalidTag = true;
				}
			}
			else if (first.substr(0, 5) == tag_MONEY) {
				currentImpact.type = OTHER;
				currentImpact.item_to_influcence = MONEY;
				currentImpact.set_value = getSetValue(founderQuestions[i]);
				currentImpact.magnitude = getMagnitudeFromString(founderQuestions[i]);
			}
			else if (first.substr(0, 13) == tag_DATING_LAWYER) {
				currentImpact.type = OTHER;
				currentImpact.item_to_influcence = DATING_LAWYER;
				currentImpact.set_value = true;
				currentImpact.magnitude = getMagnitudeFromString(founderQuestions[i]);
			}
			else if (first.substr(0, 3) == tag_GAY) {
				currentImpact.type = OTHER;
				currentImpact.item_to_influcence = GAY;
				currentImpact.set_value = true;
				currentImpact.magnitude = getMagnitudeFromString(founderQuestions[i]);
			}
			else if (first.substr(0, 7) == tag_HASMAPS) {
				currentImpact.type = OTHER;
				currentImpact.item_to_influcence = HAS_MAPS;
				currentImpact.set_value = true;
				currentImpact.magnitude = getMagnitudeFromString(founderQuestions[i]);
			}
			else if (first.substr(0, 8) == tag_CREATURE) {
				currentImpact.type = OTHER;
				currentImpact.item_to_influcence = CREATURE;
				currentImpact.set_value = true;
				currentImpact.magnitude = getCreatureFromString(founderQuestions[i].substr(9));
			}
			else if (first.substr(0, 4) == tag_BASE) {
				currentImpact.type = OTHER;
				currentImpact.item_to_influcence = BASE;
				currentImpact.set_value = true;
				currentImpact.magnitude = getBaseFromString(founderQuestions[i]);
				if (currentImpact.magnitude == -1) {
					invalidTag = true;
				}
			}
			else if (first.substr(0, 5) == tag_ARMOR) {
				currentImpact.type = OTHER;
				currentImpact.item_to_influcence = ARMOR;
				currentImpact.set_value = true;
				invalidTag = true;
			}
			else if (first.substr(0, 5) == tag_JUICE) {
				currentImpact.type = OTHER;
				currentImpact.item_to_influcence = JUICE;
				currentImpact.set_value = getSetValue(founderQuestions[i]);
				currentImpact.magnitude = getMagnitudeFromString(founderQuestions[i]);
			}
			else if (first.substr(0, 13) == tag_RECRUITS_GANG) {
				currentImpact.type = OTHER;
				currentImpact.item_to_influcence = RECRUITS;
				currentImpact.set_value = true;
				currentImpact.magnitude = getMagnitudeFromString(founderQuestions[i]);
			}
			else if (first.substr(0, 13) == tag_ASSAULT_RIFLE) {
				currentImpact.type = OTHER;
				currentImpact.item_to_influcence = ASSAULT_RIFLE;
				currentImpact.set_value = true;
				currentImpact.magnitude = getMagnitudeFromString(founderQuestions[i]);
			}
			else if (first.substr(0, 10) == tag_SPORTS_CAR) {
				currentImpact.type = OTHER;
				currentImpact.item_to_influcence = SPORTS_CAR;
				currentImpact.set_value = true;
				currentImpact.magnitude = getMagnitudeFromString(founderQuestions[i]);
			}
			else {
				clearAlt();
				addstrAlt(invalidTag);
				addstrAlt(founderQuestions[i]);
				pressAnyKey();
				clearAlt();
			}
			if (invalidTag) {
				clearAlt();
				addstrAlt(invalidTag);
				addstrAlt(founderQuestions[i]);
				pressAnyKey();
				clearAlt();
			}
			else {
				currentChoice.impact.push_back(currentImpact);
			}
		}
	}
	// The last choice and question added after the loop ends
	currentChoice.ANSWER = answer;
	currentChoice.ANSWER_2 = answer_2;
	currentQuestion.choices.push_back(currentChoice);
	allQuestions.push_back(currentQuestion);
	return allQuestions;
}
vector<Impact> printQuestionsThenGatherImpacts(vector<Question> allQuestions, const bool choices, const int gender_conservative, const string propername) {

	vector<Impact> impactsToApply;
	for (int i = 0; i < allQuestions.size(); i++) {
		clearAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, allQuestions[i].HEADER);
		mvaddstrAlt(1, 0, allQuestions[i].HEADER_2);
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(2, 0, allQuestions[i].QUESTION);
		mvaddstrAlt(3, 0, allQuestions[i].QUESTION_2);
		// print answers
		if (i == 0) {
			mvaddstrAlt(17, 0, theDocSaid);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			if (gender_conservative == GENDER_MALE)
				addstrAlt(aBoy);
			else if (gender_conservative == GENDER_FEMALE)
				addstrAlt(aGirl);
			else
				addstrAlt(intersex);
			set_color_easy(WHITE_ON_BLACK);
			addstrAlt(singleDot);
			mvaddstrAlt(19, 0, myParents);
			if (gender_conservative == GENDER_NEUTRAL)
			{
				addstrAlt(insistedOtherwise);
				mvaddstrAlt(20, 0, they);
			}
			addstrAlt(namedMe);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			addstrAlt(propername);
			set_color_easy(WHITE_ON_BLACK);
			addstrAlt(singleDot);
		}
		char selection;
		if (!choices) {
			int offset = LCSrandom(allQuestions[i].choices.size());
			selection = 'a' + offset;
			string currentOption = spaceDashSpace;
			mvaddstrAlt(5 + 2 * offset, 0, allOptions.substr(offset, 1) + currentOption + allQuestions[i].choices[offset].ANSWER);
			mvaddstrAlt(6 + 2 * offset, 0, allQuestions[i].choices[offset].ANSWER_2);
			pressAnyKey();
		}
		else {
			for (int j = 0; j < allQuestions[i].choices.size(); j++) {
				string currentOption = spaceDashSpace;
				mvaddstrAlt(5 + 2 * j, 0, allOptions.substr(j, 1) + currentOption + allQuestions[i].choices[j].ANSWER);
				mvaddstrAlt(6 + 2 * j, 0, allQuestions[i].choices[j].ANSWER_2);
			}
			selection = getkeyAlt();
		}
		if (selection >= 'a' && selection < 'a' + allQuestions[i].choices.size()) {
			//IsaacG I assume there's a way to combine vectors that is easier and/or
			// more elegant than this, but whatever, this works.
			int impactNumber = allQuestions[i].choices[selection - 'a'].impact.size();
			vector<Impact> currentImpacts = allQuestions[i].choices[selection - 'a'].impact;
			for (int j = 0; j < impactNumber; j++) {
				impactsToApply.push_back(currentImpacts[j]);
			}
		}
		else {
			i--;
		}
	}
	return impactsToApply;
}
void initiateNewgameLocations(char base, char recruits, Vehicle * startcar, bool makelawyer, bool gaylawyer, Creature * newcr);
#include "../recruits.h"
/* creates your founder */
void makecharacter()
{
	extern UniqueCreatures uniqueCreatures;
	// Make the founder blind
	extern bool BLIND;
	// Make the founder unable to walk
	extern bool NOWALK;
	// Make the founder have no face
	extern bool NOFACE;
	// Make the founder have a severely injured spine
	extern bool SPINE;
	// Make the founder have severe internal damage
	extern bool INTERNAL;
	extern Log gamelog;
	extern bool multipleCityMode;
	extern int year;
	extern int day;
	extern int month;
	extern class Ledger ledger;
	extern char execname[EXECNUM][POLITICIAN_NAMELEN];
	extern char lcityname[CITY_NAMELEN];
	extern vector<ClipType *> cliptype;
	extern vector<WeaponType *> weapontype;
	Creature *newcr = new Creature;
	newcr->align = ALIGN_LIBERAL;
	newcr->set_attribute(ATTRIBUTE_HEART, 0);
	newcr->set_attribute(ATTRIBUTE_WISDOM, 0);
	newcr->set_attribute(ATTRIBUTE_INTELLIGENCE, 0);
	newcr->set_attribute(ATTRIBUTE_AGILITY, 0);
	newcr->set_attribute(ATTRIBUTE_STRENGTH, 0);
	newcr->set_attribute(ATTRIBUTE_HEALTH, 0);
	newcr->set_attribute(ATTRIBUTE_CHARISMA, 0);
	if (BLIND) {
		newcr->special[SPECIALWOUND_RIGHTEYE] = 1;
		newcr->special[SPECIALWOUND_LEFTEYE] = 1;
	}
	if (SPINE) {
		newcr->special[SPECIALWOUND_UPPERSPINE] = 1;
		newcr->special[SPECIALWOUND_LOWERSPINE] = 1;
	}
	if (NOFACE) {
		newcr->special[SPECIALWOUND_TONGUE] = 1;
		newcr->special[SPECIALWOUND_RIGHTEYE] = 1;
		newcr->special[SPECIALWOUND_LEFTEYE] = 1;
		newcr->special[SPECIALWOUND_NOSE] = 1;
	}
	if (NOWALK) {
		newcr->special[SPECIALWOUND_UPPERSPINE] = 1;
		newcr->special[SPECIALWOUND_LOWERSPINE] = 1;
		newcr->special[SPECIALWOUND_NECK] = 1;
		newcr->wound[BODYPART_LEG_RIGHT] = 1;
		newcr->wound[BODYPART_LEG_LEFT] = 1;
	}
	if (INTERNAL) {
		newcr->special[SPECIALWOUND_RIGHTLUNG] = 1;
		newcr->special[SPECIALWOUND_LEFTLUNG] = 1;
		newcr->special[SPECIALWOUND_HEART] = 1;
		newcr->special[SPECIALWOUND_LIVER] = 1;
		newcr->special[SPECIALWOUND_STOMACH] = 1;
		newcr->special[SPECIALWOUND_LEFTKIDNEY] = 1;
		newcr->special[SPECIALWOUND_RIGHTKIDNEY] = 1;
		newcr->special[SPECIALWOUND_SPLEEN] = 1;
	}
	char first[3][80];
	char last[80];
	const bool is_male = LCSrandom(2); // whether or not starting gender is male
	char gender = newcr->gender_liberal = newcr->gender_conservative = (is_male ? GENDER_MALE : GENDER_FEMALE);
	do {
		firstname(first[0], GENDER_NEUTRAL);
		firstname(first[1], GENDER_MALE);
		firstname(first[2], GENDER_FEMALE);
		strcpy(last, lastname());
	} while (strcmp(first[0], last) == 0 && strcmp(first[1], last) == 0 && strcmp(first[2], last) == 0);
	{
		Armor a(getarmortype(tag_ARMOR_CLOTHES));
		newcr->give_armor(a, NULL);
	}

	bool choices = true;
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(4, 6, theFounder);
		mvaddstrAlt(7, 2, firstName);
		addstrAlt(first[(int)gender]);
		set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(7, 30, pressAtoReconsider);
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(9, 2, lastName);
		addstrAlt(last);
		set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(9, 30, pressBtoBeReborn);
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(11, 2, sexIs);
		if (newcr->gender_conservative == GENDER_MALE)
		{
			set_color_easy(CYAN_ON_BLACK_BRIGHT);
			addstrAlt(male);
		}
		else if (newcr->gender_conservative == GENDER_FEMALE)
		{
			set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
			addstrAlt(female);
		}
		else
		{
			set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			addstrAlt(itsComplicated);
		}
		set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(11, 30, pressCtoChangeSex);
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(13, 2, history);
		if (choices)
		{
			set_color_easy(GREEN_ON_BLACK_BRIGHT);
			addstrAlt(letMeChoose);
		}
		else
		{
			set_color_easy(RED_ON_BLACK_BRIGHT);
			addstrAlt(letFateDecide);
		}
		set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(13, 30, pressDtoToggle);
		if (!multipleCityMode)
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(15, 2, city);
			addstrAlt(lcityname);
			set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(15, 30, pressEtoRelocate);
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(19 - multipleCityMode * 2, 4, pressAnyKeyString);
		const int c = getkeyAlt();
		if (c == 'a')
		{
			do {
				firstname(first[(int)gender], newcr->gender_conservative);
			} while (strcmp(first[(int)gender], last) == 0);
			continue;
		}
		if (c == 'b')
		{
			do {
				strcpy(last, lastname());
			} while (strcmp(first[0], last) == 0 && strcmp(first[1], last) == 0 && strcmp(first[2], last) == 0);
			continue;
		}
		if (c == 'c')
		{
			if ((newcr->gender_conservative == GENDER_FEMALE && !is_male) ||
				(newcr->gender_conservative == GENDER_NEUTRAL && is_male))
				newcr->gender_conservative = GENDER_MALE;
			else if ((newcr->gender_conservative == GENDER_MALE && !is_male) ||
				(newcr->gender_conservative == GENDER_FEMALE && is_male))
				newcr->gender_conservative = GENDER_NEUTRAL;
			else
				newcr->gender_conservative = GENDER_FEMALE;
			gender = newcr->gender_liberal = newcr->gender_conservative;
			continue;
		}
		if (c == 'd')
		{
			choices = !choices;
			continue;
		}
		if (c == 'e' && !multipleCityMode)
		{
			strcpy(lcityname, cityname());
			continue;
		}
		break;
	}
	strcpy(newcr->propername, first[(int)gender]);
	strcat(newcr->propername, singleSpace);
	strcat(newcr->propername, last);
	int c;
	bool hasmaps = false;
	bool makelawyer = false;
	bool gaylawyer = false;
	Vehicle * startcar = NULL;
	char recruits = RECRUITS_NONE;
	char base = SITE_RESIDENTIAL_SHELTER;
	for (int sk = 0; sk < SKILLNUM; sk++)newcr->set_skill((sk), 0);
	bool assault_rifle = false;
	bool sports_car = false;	
	int birth_year = 1984; // default birth year, month, and day in case left undefined
	int birth_month = 1;
	int birth_day = 1;

	vector<Question> allQuestions = gatherAllFounderQuestions();

	vector<Impact> impactsToApply = printQuestionsThenGatherImpacts(allQuestions, choices, newcr->gender_conservative, newcr->propername);
	
	for (int i = 0; i < impactsToApply.size(); i++) {
		const Impact currentImpact = impactsToApply[i];
		switch (currentImpact.type) {
		case SKILL:
			if (currentImpact.set_value) {
				newcr->set_skill((currentImpact.item_to_influcence), currentImpact.magnitude);
			}
			else {
				newcr->set_skill((currentImpact.item_to_influcence), newcr->get_skill((currentImpact.item_to_influcence)) + currentImpact.magnitude);
			}
			break;
		case ATTRIBUTE:
			if (currentImpact.set_value) {
				newcr->set_attribute((currentImpact.item_to_influcence), currentImpact.magnitude);
			}
			else {
				newcr->adjust_attribute((currentImpact.item_to_influcence), currentImpact.magnitude);
			}
			break;
		case OTHER:
			switch (currentImpact.item_to_influcence) {
			case BIRTH_MONTH:
				birth_month = currentImpact.magnitude;
				break;
			case				   BIRTH_DAY:
				birth_day = currentImpact.magnitude;
				break;
			case				   BIRTH_YEAR:
				birth_year = currentImpact.magnitude;
				break;
			case				   STARTING_MONTH:
				month = currentImpact.magnitude;
				break;
			case				   STARTING_DAY:
				day = currentImpact.magnitude;
				break;
			case				   STARTING_YEAR:
				year = currentImpact.magnitude;
				break;
			case				   GAY:
				gaylawyer = currentImpact.magnitude == 1;
				break;
			case				   DATING_LAWYER:
				makelawyer = currentImpact.magnitude == 1;
				break;
			case				   HAS_MAPS:
				hasmaps = currentImpact.magnitude == 1;
				break;
			case JUICE:
				if (currentImpact.set_value) {
					newcr->juice = currentImpact.magnitude;
				}
				else {
					newcr->juice += currentImpact.magnitude;
				}
				break;
			case				   SPORTS_CAR:
				sports_car = currentImpact.magnitude == 1;
				break;
			case				   ASSAULT_RIFLE:
				assault_rifle = currentImpact.magnitude == 1;
				break;
			case				   MONEY:
				if (currentImpact.set_value) {
					ledger.force_funds(currentImpact.magnitude);
				}
				else {
					ledger.force_funds(ledger.get_funds() + currentImpact.magnitude);
				}
				break;
			case				   BASE:
				base = currentImpact.magnitude;
				break;
			case				   CREATURE:
				newcr->type = (CreatureTypes)currentImpact.magnitude;
				newcr->type_idname = enumToCreatureString(currentImpact.magnitude);
				break;
			case				   ARMOR:
				// TODO Not Implemented
				break;
			case				   RECRUITS:
				if (currentImpact.magnitude == 1) {
					recruits = RECRUITS_GANG;
				}
				else {
					recruits = RECRUITS_NONE;
				}
				break;
			default:
				clearAlt();
				mvaddstrAlt(0, 0, error);
				mvaddstrAlt(1, 0, currentImpact.item_to_influcence);
				break;
			}
			break;
		default:
			clearAlt();
			mvaddstrAlt(0, 0, error);
			mvaddstrAlt(1, 0, currentImpact.type);
			break;
		}
	}
	//calculate founder's birthday and age
	newcr->birthday_day = birth_day;
	newcr->birthday_month = birth_month;
	newcr->age = year - birth_year;
	// Don't count this year in founder's age if starting before birthday
	if (month < newcr->birthday_month ||
		(month == newcr->birthday_month && day < newcr->birthday_day))
	{
		newcr->age--;
	}
	if (assault_rifle) {
		Weapon neww(*weapontype[getweapontype(tag_WEAPON_AUTORIFLE_AK47)]);
		Clip newc(*cliptype[getcliptype(tag_CLIP_ASSAULT)], 9);
		newcr->give_weapon(neww, NULL);
		newcr->take_clips(newc, 9);
	}
	if (sports_car) {
		startcar = newSportsCar();
		startcar->add_heat(10);
		newVehicle(startcar);
		newcr->pref_carid = startcar->id();
	}
	printIntroduction();
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(0, 0, whatIsYourName);
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(1, 0, pressEnterToBeRealName);
	enter_name(2, 0, newcr->name, CREATURE_NAMELEN, newcr->propername);
	addCreature(newcr);
	make_world(hasmaps);
	initiateNewgameLocations(base, recruits, startcar, makelawyer, gaylawyer, newcr);
	uniqueCreatures.initialize();
}


// #include "../includes.h"


const string CONST_newsB955 = ".\"";
const string CONST_newsB948 = "Reagan was wrong";
const string CONST_newsB947 = "rb";
const string CONST_newsB941 = "himself";
const string CONST_newsB940 = "he ";
const string CONST_newsB939 = "Miss ";
const string CONST_newsB937 = "If I were to be released, I would surely kill again.\"";
const string CONST_newsB935 = "he";
const string CONST_newsB928 = "\"Make things right with the Almighty Father.\"";

const string CONST_news999 = "burned unrecognizable. ";
const string CONST_news998 = "The recovered body was ";
const string CONST_news997 = "The recovered bodies were ";
const string CONST_news996 = "They have to be stopped before they kill again";
const string CONST_news995 = "This is the doing of the Conservative Crime Squad butchers. ";
const string CONST_news994 = "no names, no faces, not even where it happened really";
const string CONST_news993 = "Look, it was a Conservative Crime Squad hit, that's all we know, ";
const string CONST_news992 = "just covering it up";
const string CONST_news991 = "with in the past. *When* the police can't figure this one out, they're ";
const string CONST_news990 = "known to work with several corporations we've had confrontations ";
const string CONST_news989 = "This massacre has the signature mark of a group of mercenaries ";
const string CONST_news988 = "It was execution style. Professional. We've got nothing";
const string CONST_news987 = "inspired by the Conservative media's brainwashing propaganda";
const string CONST_news986 = "We have reason to believe that this brutal massacre was ";
const string CONST_news985 = "been bite marks. Nothing recognizable left. Complete carnage.";
const string CONST_news984 = "Burned... stabbed with, maybe, pitchforks. There may have ";
const string CONST_news983 = "intelligence community";
const string CONST_news982 = "previous actions to uncover human rights abuses and corruption in the ";
const string CONST_news981 = "carried out by the Central Intelligence Agency in retaliation for our ";
const string CONST_news980 = "We have strong evidence that this was an extra-judicial slaughter ";
const string CONST_news979 = "D*mnd*st thing I've ever seen";
const string CONST_news978 = "Damnedest thing I've ever seen";
const string CONST_news977 = "[Craziest] thing I've ever seen";
const string CONST_news976 = "fingerprints. Like, it was all smooth. ";
const string CONST_news975 = "The body had no face or ";
const string CONST_news974 = "The bodies had no faces or ";
const string CONST_news973 = "According to an LCS spokesperson, \"";
const string CONST_news972 = "of the LCS targeted simply due to their political beliefs. ";
const string CONST_news971 = "victim was a member ";
const string CONST_news970 = "victims were members ";
const string CONST_news969 = " The Liberal Crime Squad has claimed that the ";
const string CONST_news968 = "unwilling to pursue the case with any serious effort.";
const string CONST_news967 = " The police have opened an investigation into the massacre, but seem ";
const string CONST_news965 = " Privately, sources in the department confide that there aren't any leads. ";
const string CONST_news964 = "the police department, the matter is under investigation as a homicide.";
const string CONST_news963 = " According to a spokesperson for ";
const string CONST_news962 = " yesterday.";
const string CONST_news961 = " found in the ";
const string CONST_news960 = " A body was ";
const string CONST_news959 = " Two bodies were ";
const string CONST_news958 = " bodies were ";
const string CONST_news957 = "MASSACRE";
const string CONST_news955 = "MYSTERIOUS";
const string CONST_news954 = "CCS MASSACRE";
const string CONST_news947 = "\" before passing out.";
const string CONST_news945 = "\" was found painted on the walls.";
const string CONST_news943 = "The Liberal Crime Squad ended the dangerous high-speed chase in order to protect the public, and attempted to escape on foot. ";
const string CONST_news942 = "There was also a foot chase when the suspect or suspects bailed out after the high-speed pursuit. ";
const string CONST_news941 = "Details about injuries were not released. ";
const string CONST_news940 = "One vehicle crashed. ";
const string CONST_news939 = " vehicles crashed. ";
const string CONST_news938 = "pursuit of the LCS. ";
const string CONST_news937 = " Conservative operatives engaged in a reckless ";
const string CONST_news936 = "following the incident. ";
const string CONST_news935 = " It is known that there was a high-speed chase ";
const string CONST_news934 = "picked locks";
const string CONST_news933 = "unlawful entry";
const string CONST_news932 = "broke down doors";
const string CONST_news931 = "breaking and entering";
const string CONST_news930 = "marked the site for Liberation";
const string CONST_news929 = "vandalism";
const string CONST_news928 = "damaged enemy infrastructure";
const string CONST_news927 = "destruction of private property";
const string CONST_news926 = "liberated abused animals";
const string CONST_news925 = "tampering with lab animals";
const string CONST_news924 = "liberated enemy resources";
const string CONST_news923 = "theft";
const string CONST_news922 = "engaged in combat with Conservative forces";
const string CONST_news921 = "violence";
const string CONST_news920 = "more violence";
const string CONST_news918 = "murder";
const string CONST_news917 = "set fire to Conservative property";
const string CONST_news916 = "arson";
const string CONST_news915 = "engaged in ";
const string CONST_news914 = " Further details are sketchy, but police sources suggest that the CCS ";
const string CONST_news913 = " The Liberal Crime Squad ";
const string CONST_news911 = " Further details are sketchy, but police sources suggest that the LCS ";
const string CONST_news910 = " The Liberal Crime Squad was attempting to uncover the company's Conservative corruption.";
const string CONST_news909 = "executives on the scene seemed very nervous about something.";
const string CONST_news908 = " The Liberal Crime Squad was attempting to uncover the CEO's Conservative corruption.";
const string CONST_news907 = "the owner of the house seemed very frantic about some missing property.";
const string CONST_news906 = " Liberal Crime Squad infiltration specialists worked to liberate weapons from the oppressors.";
const string CONST_news905 = "the Liberal Crime Squad attempted to break into the armory.";
const string CONST_news903 = " Liberal Crime Squad computer specialists worked to liberate information from CIA computers.";
const string CONST_news902 = "intelligence officials seemed very nervous about something.";
const string CONST_news901 = "may have interfered with jury deliberations.";
const string CONST_news900 = " The Liberal Crime Squad has apologized over reports that the operation ";
const string CONST_news899 = "trust and attempted to influence a jury.";
const string CONST_news898 = "the Liberal Crime Squad allegedly violated the sacred ";
const string CONST_news897 = "at the prison.";
const string CONST_news896 = " The Liberal Crime Squad attempted to rescue innocent people from the abusive Conservative conditions ";
const string CONST_news895 = "the Liberal Crime Squad allegedly freed prisoners while in the facility.";
const string CONST_news894 = "saving them from the highly corrupt Conservative justice system.";
const string CONST_news893 = " The Liberal Crime Squad attempted to rescue innocent people from the courthouse lockup, ";
const string CONST_news892 = "the Liberal Crime Squad allegedly freed or attempted to free prisoners from the courthouse lockup.";
const string CONST_news891 = "hoping to acquire the resources to overcome evil.";
const string CONST_news890 = " The Liberal Crime Squad demanded access to the bank vault, ";
const string CONST_news889 = "the Liberal Crime Squad threatened innocent bystanders in order to rob the bank vault.";
const string CONST_news888 = "showing the triumph of Liberal ideals over Conservative economics.";
const string CONST_news887 = " The Liberal Crime Squad opened the bank vault, ";
const string CONST_news886 = "the Liberal Crime Squad opened the bank vault, which held more than $100,000 at the time.";
const string CONST_news885 = "saving them from torture and brutality at the hands of Conservative police interrogators.";
const string CONST_news884 = " The Liberal Crime Squad attempted to rescue innocent people from the police lockup, ";
const string CONST_news883 = "the Liberal Crime Squad allegedly freed or attempted to free prisoners from the police lockup.";
const string CONST_news882 = "demonstrating the extreme vulnerability and danger of Nuclear Power Plants. ";
const string CONST_news881 = " The Liberal Crime Squad brought the reactor to the verge of a nuclear meltdown, ";
const string CONST_news880 = "reactor.";
const string CONST_news879 = "the Liberal Crime Squad nearly caused a catastrophic meltdown of the nuclear ";
const string CONST_news878 = "demonstrating the extreme dangers of Nuclear Waste. ";
const string CONST_news877 = " The Liberal Crime Squad tampered with the state's water supply yesterday, ";
const string CONST_news876 = "yesterday by tampering with equipment on the site.";
const string CONST_news875 = "the Liberal Crime Squad contaminated the state's water supply";

const string CONST_news850 = "Several";
const string CONST_news849 = "Two";
const string CONST_news789 = "newspic.cpc";
const string CONST_news788 = "newstops.cpc";
const string CONST_news787 = "largecap.cpc";
const string CONST_news786 = "SQUAD RAMPAGE";
const string CONST_news785 = "LIBERAL CRIME";
const string CONST_news784 = "LCS SORRY";
const string CONST_news783 = "LCS RAMPAGE";
const string CONST_news782 = "SQUAD STRIKES";
const string CONST_news780 = "LCS STRIKES";
const string CONST_news779 = "HEROIC STRIKE";
const string CONST_news778 = "LCS HITS TV";
const string CONST_news777 = "LCS HITS AM";
const string CONST_news776 = "LCS HITS CORP";
const string CONST_news775 = "POLLUTER HIT";
const string CONST_news774 = "NO JUSTICE";
const string CONST_news773 = "EVIL RESEARCH";
const string CONST_news772 = "LCS VS CIA";
const string CONST_news771 = "PRISON WAR";
const string CONST_news770 = "LCS VS COPS";
const string CONST_news769 = "MELTDOWN RISK";
const string CONST_news768 = "CLASS WAR";
const string CONST_news766 = "UNSTOPPABLE";
const string CONST_news765 = "CCS RAMPAGE";
const string CONST_news764 = "CCS STRIKES";
const string CONST_news763 = "CRIME SQUAD";
const string CONST_news762 = "LCS MARTYRS";
const string CONST_news761 = "POLICE KILL";
const string CONST_news760 = "TRAGIC END";
const string CONST_news759 = "LCS SIEGE";
const string CONST_news758 = "OFF COPS";
const string CONST_news757 = "LCS FIGHTS";
const string CONST_news756 = "POLICE SIEGE";
const string CONST_news755 = "LCS ESCAPES";
const string CONST_news754 = "POLICE KILLED";
const string CONST_news753 = "RAIDS END CCS";
const string CONST_news752 = "FBI HUNTS CCS";
const string CONST_news751 = "ASSASSINATED";
const string CONST_news750 = "MISSING";
const string CONST_news748 = "RESCUED";
const string CONST_news747 = "FOUND DEAD";
const string CONST_news746 = "BELIEVED DEAD";
const string CONST_news745 = "IMPEACHED";
const string CONST_news744 = "ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼";
const string CONST_news743 = "º audience and viewers nationwide feel its pain. º";
const string CONST_news742 = "º popular afternoon talk show. The studio º";
const string CONST_news741 = "º A failed partial birth abortion goes on a º";
const string CONST_news740 = "ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»";
const string CONST_news739 = "abort.cmv";
const string CONST_news737 = "º by impressive advertising, America tunes in. º";
const string CONST_news736 = "º new anchor for one of its news shows. Guided º";
const string CONST_news735 = "º A major Cable News channel has hired a slick º";
const string CONST_news733 = "anchor.cmv";
const string CONST_news731 = "º advertising blitz, it's bound to be popular. º";
const string CONST_news730 = "º begins airing this week. With the nationwide º";
const string CONST_news729 = "º A new show glamorizing the lives of the rich º";
const string CONST_news727 = "glamshow.cmv";
const string CONST_news725 = "º viewers across the nation were listening. º";
const string CONST_news724 = "º bright Liberal guest finish a sentence. Many º";
const string CONST_news723 = "º A Cable News anchor accidentally let a º";
const string CONST_news721 = "newscast.cmv";
const string CONST_news720 = " with ";
const string CONST_news719 = "Tonight on a Cable News channel: ";
const string CONST_news717 = "º taped by a passerby and saturates the news. º";
const string CONST_news716 = "º Los Angeles again. This time, the incident is º";
const string CONST_news715 = "º The police have beaten a black man in º";
const string CONST_news713 = "lacops.cmv";
const string CONST_news222 = "~";
const string CONST_news221 = "&r";
const string CONST_news220 = "Fortunately, the CCS thugs were stopped by brave citizens. ";
const string CONST_news219 = "Everyone in the CCS group was arrested or killed. ";
const string CONST_news218 = "Fortunately, the LCS thugs were stopped by brave citizens. ";
const string CONST_news217 = "Everyone in the LCS group was arrested or killed. ";
const string CONST_news216 = "Unfortunately, the LCS group was defeated by the forces of evil. ";
const string CONST_news214 = "A Liberal Crime Squad operation went horribly wrong, and came to a tragic end. ";
const string CONST_news213 = "The Liberal Crime Squad has gone on a rampage, and they got what they deserved. ";
const string CONST_news211 = "The Liberal Crime Squad has struck again, albeit with a tragic end. ";
const string CONST_news209 = "to a spokesperson from the police department. ";
const string CONST_news208 = "went on a suicidal rampage yesterday, according ";
const string CONST_news207 = "A group of thugs calling itself the Liberal Crime Squad ";
const string CONST_news204 = "burst briefly onto the scene of political activism yesterday, according ";
const string CONST_news203 = "A group calling itself the Liberal Crime Squad ";
const string CONST_news201 = "The Conservative Crime Squad has gone on another rampage, and they got what they deserved. ";
const string CONST_news199 = "The Conservative Crime Squad has struck again, albeit with a tragic end. ";
const string CONST_news197 = "rampage yesterday, according to a spokesperson from the police department. ";
const string CONST_news196 = "calling themselves the Conservative Crime Squad went on a ";
const string CONST_news195 = "M16-toting ";
const string CONST_news194 = "A group of ";
const string CONST_news190 = "A group of M16-wielding vigilantes calling themselves the Conservative Crime Squad ";
const string CONST_news188 = "The Conservative Crime Squad has gone on another rampage. ";
const string CONST_news186 = "The Conservative Crime Squad has struck again. ";
const string CONST_news185 = "to a spokesperson from the police department.";
const string CONST_news184 = "went on a rampage yesterday, according ";
const string CONST_news183 = "A group of worthless M16-toting hicks calling itself the Conservative Crime Squad ";
const string CONST_news180 = "burst onto the scene of political activism yesterday, according ";
const string CONST_news179 = "A group of M16-wielding vigilantes calling itself the Conservative Crime Squad ";
const string CONST_news177 = "A Liberal Crime Squad operation went horribly wrong. ";
const string CONST_news176 = "The Liberal Crime Squad has gone on a rampage. ";
const string CONST_news174 = "The Liberal Crime Squad has struck again. ";
const string CONST_news164 = ", the very symbol of economic inequality. ";
const string CONST_news163 = ", known for its Extreme Conservative Bias. ";
const string CONST_news162 = ", a building with enough square footage enough to house a hundred people if it weren't in Conservative Hands. ";
const string CONST_news161 = ", where evil and Conservatism coagulate in the hallways. ";
const string CONST_news160 = ", also known to be a Conservative storage facility for radioactive waste. ";
const string CONST_news159 = ", a factory whose Conservative smokestacks choke the city with deadly pollutants. ";
const string CONST_news158 = ", a Conservative sweatshop and human rights abuser. ";
const string CONST_news157 = ", pride of Conservative torturers and warmongers everywhere. ";
const string CONST_news156 = ", the Conservative headquarters of one of the biggest privacy violators in the world. ";
const string CONST_news155 = ", where innocent people are regularly beaten by Conservative guards. ";
const string CONST_news154 = ", site of numerous Conservative Injustices. ";
const string CONST_news153 = ", headquarters of one of the most oppressive and Conservative police forces in the country. ";
const string CONST_news152 = ", a dangerous Conservative genetic research lab. ";
const string CONST_news151 = ", a Conservative animal rights abuser. ";
const string CONST_news150 = ", a spawning ground of Wrong Conservative Ideas. ";
const string CONST_news149 = ", known for its rich and snooty residents. ";
const string CONST_news147 = "Richard Dawkins Food Bank. ";
const string CONST_news146 = "ACLU Branch Office. ";
const string CONST_news145 = "Greenpeace Offices. ";
const string CONST_news144 = "Network News Station. ";
const string CONST_news143 = "Public Radio Station. ";
const string CONST_news142 = "Tax Collection Agency. ";
const string CONST_news141 = "Welfare Assistance Agency. ";
const string CONST_news140 = "Whirled Peas Museum. ";
const string CONST_news138 = "Labor Union HQ. ";
const string CONST_news137 = "WikiLeaks HQ. ";
const string CONST_news136 = "Rehabilitation Center. ";
const string CONST_news135 = "Abortion Clinic. ";
const string CONST_news134 = "Seedy Back Alley(tm). ";
const string CONST_news133 = "Research Ethics Commission HQ. ";
const string CONST_news132 = "Animal Shelter. ";
const string CONST_news131 = "Lady Luck Strip Club. ";
const string CONST_news130 = "University Dormitory. ";
const string CONST_news129 = "notorious ";
const string CONST_news128 = "at the ";
const string CONST_news127 = "the notorious ";
const string CONST_news126 = "at ";
const string CONST_news121 = "'s";
const string CONST_news120 = "in the ";
const string CONST_news119 = "on the ";
const string CONST_news118 = "in ";
const string CONST_news115 = "on ";
const string CONST_news113 = "Orange County";
const string CONST_news111 = "Travel Agency";
const string CONST_news109 = "Shopping Mall";
const string CONST_news107 = "and";
const string CONST_news106 = " The events took place ";
const string CONST_news105 = " w/ ";
const string CONST_news104 = "Call Today";
const string CONST_news1033 = ". Police were seen searching the surrounding area yesterday.";
const string CONST_news1032 = "'s last known location was the ";
const string CONST_news1031 = " According to sources, ";
const string CONST_news103 = " Years Experience";
const string CONST_news1029 = "To the citizens, please contact the department if you have any additional information.";
const string CONST_news1028 = "As the investigation is ongoing, I cannot be more specific at this time. ";
const string CONST_news1027 = " back home and bring the kidnappers to justice. ";
const string CONST_news1026 = "bring ";
const string CONST_news1025 = "We have several leads and are confident that we will ";
const string CONST_news1024 = " days ago, by a person or persons as yet undetermined. ";
const string CONST_news1023 = " was taken ";
const string CONST_news1022 = "\"We now believe that ";
const string CONST_news1021 = ", speaking on behalf of the police department, stated ";
const string CONST_news102 = "Liberal Defense Lawyer";
const string CONST_news1019 = "according to a police spokesperson.";
const string CONST_news1018 = " is now considered a kidnapping, ";
const string CONST_news1017 = " - The disappearance of ";
const string CONST_news1016 = "KIDNAPPED";
const string CONST_news1015 = "SOMEONE";
const string CONST_news1014 = "COP";
const string CONST_news1013 = "JUDGE";
const string CONST_news1012 = "SCIENTIST";
const string CONST_news1011 = "NEWS ANCHOR";
const string CONST_news1010 = "RADIO HOST";
const string CONST_news1009 = "KIDNAPPING";
const string CONST_news1008 = "LCS DENIES";
const string CONST_news1006 = "This is clearly the work of conservative butchers enforcing the prohibition on a free press";
const string CONST_news1005 = "working for this very paper. ";
const string CONST_news1004 = "The murdered was a reporter ";
const string CONST_news1003 = "The murdered were reporters ";
const string CONST_news1002 = "Fortunately, firemen were able to respond before the fire could spread to other buildings";
const string CONST_news1001 = "we are working closely with the Fire Department to track down the arsonist. ";
const string CONST_news1000 = "Scorch marks throughout the site indicate that this was no accident; ";
const string CONST_news100 = "Only $";
const string CONST_news099 = "Sedan 4D";
const string CONST_news098 = "Lexus GS 300";
const string CONST_news097 = "Vehicles&r";
const string CONST_news096 = "Quality Pre-Owned";
const string CONST_news095 = "Now $";
const string CONST_news094 = "Special Purchase";
const string CONST_news093 = "Fine Leather Chairs";
const string CONST_news092 = "caseNEWSSTORY_CCS_NOBACKERS.txt";
const string CONST_news091 = "caseNEWSSTORY_CCS_DEFEATED.txt";
const string CONST_news090 = "adListB.txt";
const string CONST_news089 = "adList.txt";
const string CONST_news088 = "personalAdsLG.txt";
const string CONST_news087 = "personalAds.txt";
const string CONST_news086 = "ccs_noun.txt";
const string CONST_news085 = "ccs_adjective_3.txt";
const string CONST_news084 = "ccs_adjective_2.txt";
const string CONST_news083 = "ccs_adjective.txt";
const string CONST_news082 = "cable_city_2.txt";
const string CONST_news081 = "cable_city.txt";
const string CONST_news080 = "cable_name_2.txt";
const string CONST_news079 = "cable_name.txt";
const string CONST_news078 = "reagan_good_2.txt";
const string CONST_news077 = "reagan_good.txt";
const string CONST_news076 = "ceo_behaving_badly.txt";
const string CONST_news075 = "reagan_bad_2.txt";
const string CONST_news074 = "reagan_bad.txt";
const string CONST_news073 = "public_place.txt";
const string CONST_news072 = "fm_radio_name_2.txt";
const string CONST_news071 = "fm_radio_name.txt";
const string CONST_news070 = "tech_giant_name_2.txt";
const string CONST_news069 = "tech_giant_name.txt";
const string CONST_news068 = "distrust_liberals.txt";
const string CONST_news067 = "i_like_polution.txt";
const string CONST_news066 = "pollution_consumption_2.txt";
const string CONST_news065 = "pollution_consumption.txt";
const string CONST_news064 = "family_values_company_name_3.txt";
const string CONST_news063 = "family_values_company_name_2.txt";
const string CONST_news062 = "family_values_company_name.txt";
const string CONST_news061 = "radio_host_lost_mind.txt";
const string CONST_news060 = "radio_host_crazy_quote.txt";
const string CONST_news059 = "judge_with_prostitute_full_free_speech.txt";
const string CONST_news058 = "judge_with_prostitute_no_free_speech.txt";
const string CONST_news057 = "judge_with_prostitute.txt";
const string CONST_news056 = "brother_sister.txt";
const string CONST_news055 = "older_younger.txt";
const string CONST_news054 = "his_her.txt";
const string CONST_news053 = "petty_violence.txt";
const string CONST_news052 = "bullshit.txt";
const string CONST_news051 = "bullshit_no_free_speech.txt";
const string CONST_news050 = "gene_product_cost.txt";
const string CONST_news049 = "gene_product_benefit.txt";
const string CONST_news048 = "gene_product_name_2.txt";
const string CONST_news047 = "gene_product_name.txt";
const string CONST_news046 = "gene_corp_name_2.txt";
const string CONST_news045 = "gene_corp_name.txt";
const string CONST_news044 = "terrorist_plot_no_free_speech.txt";
const string CONST_news043 = "terrorist_plot.txt";
const string CONST_news042 = "terrorist_group.txt";
const string CONST_news041 = "chimp_drug_horror.txt";
const string CONST_news040 = "chimp_drug_impact.txt";
const string CONST_news039 = "drug_name_2.txt";
const string CONST_news038 = "drug_name.txt";
const string CONST_news037 = "animal_research_country.txt";
const string CONST_news036 = "break_in_murder_case.txt";
const string CONST_news035 = "evidence_of_child_murder.txt";
const string CONST_news034 = "mutilated_corpse.txt";
const string CONST_news033 = "prison_book_title_2.txt";
const string CONST_news032 = "prison_book_title.txt";
const string CONST_news031 = "my_idol.txt";
const string CONST_news030 = "bribe_officers.txt";
const string CONST_news029 = "crazy_conservative_act.txt";
const string CONST_news028 = "why_chase_ended.txt";
const string CONST_news027 = "vigilante_murder.txt";
const string CONST_news026 = "radio_name_2.txt";
const string CONST_news025 = "radio_name.txt";
const string CONST_news024 = "conservative_oppose_book.txt";
const string CONST_news023 = "random_nationality.txt";
const string CONST_news022 = "book_title_2.txt";
const string CONST_news021 = "book_title.txt";
const string CONST_news020 = "AMorPM.txt";
const string CONST_news019 = "liberalCrime.txt";

const string tag_Downtown = "Downtown";
const string tag_National_Mall = "National Mall";
const string tag_Arlington = "Arlington";
const string tag_Manhattan = "Manhattan";
const string tag_Manhattan_Island = "Manhattan Island";
const string tag_Hollywood = "Hollywood";
const string tag_Greater_Hollywood = "Greater Hollywood";
const string tag_Long_Island = "Long Island";
const string tag_Brooklyn_and_Queens = "Brooklyn and Queens";
const string tag_Outskirts_and_Orange_County = "Outskirts and Orange County";
const string tag_Outskirts = "Outskirts";
const string tag_Travel = "Travel";
const string tag_Shopping = "Shopping";

#define CH_BOX_DRAWINGS_LIGHT_VERTICAL_AND_HORIZONTAL 0xc5
#define CH_FULL_BLOCK 0xdb
#define CH_LIGHT_SHADE 0xb0
#define CH_MEDIUM_SHADE 0xb1
#define CH_DARK_SHADE 0xb2
// daily.h
int monthday();
#include "../cursesmovie.h"
vector<newsstoryst *> newsstory;
newsstoryst* lastNewsStory() {
	return newsstory[len(newsstory) - 1];
}
string ampersandR;
string membersOfLCS;
string lcsSpokeseperson;
string policeSpokesperson;
map<short, vector<string> > newsStories;
map<short, string> cityNames;
string accordingToSourcesAtScene;
string accordingToPoliceSources;
string ampersandC;
vector<string> liberalCrime;
vector<string> AMorPM;
vector<string> book_title;
vector<string> book_title_2;
vector<string> random_nationality;
vector<string> conservative_oppose_book;
vector<string> radio_name;
vector<string> radio_name_2;
vector<string> vigilante_murder;
vector<string> why_chase_ended;
vector<string> crazy_conservative_act;
vector<string> bribe_officers;
vector<string> my_idol;
vector<string> prison_book_title;
vector<string> prison_book_title_2;
vector<string> mutilated_corpse;
vector<string> evidence_of_child_murder;
vector<string> break_in_murder_case;
vector<string> animal_research_country;
vector<string> drug_name;
vector<string> drug_name_2;
vector<string> chimp_drug_impact;
vector<string> chimp_drug_horror;
vector<string> terrorist_group;
vector<string> terrorist_plot;
vector<string> terrorist_plot_no_free_speech;
vector<string> gene_corp_name;
vector<string> gene_corp_name_2;
vector<string> gene_product_name;
vector<string> gene_product_name_2;
vector<string> gene_product_benefit;
vector<string> gene_product_cost;
vector<string> bullshit_no_free_speech;
vector<string> bullshit;
vector<string> petty_violence;
vector<string> his_her;
vector<string> older_younger;
vector<string> brother_sister;
vector<string> judge_with_prostitute;
vector<string> judge_with_prostitute_no_free_speech;
vector<string> judge_with_prostitute_full_free_speech;
vector<string> radio_host_crazy_quote;
vector<string> radio_host_lost_mind;
vector<string> family_values_company_name;
vector<string> family_values_company_name_2;
vector<string> family_values_company_name_3;
vector<string> pollution_consumption;
vector<string> pollution_consumption_2;
vector<string> i_like_polution;
vector<string> distrust_liberals;
vector<string> tech_giant_name;
vector<string> tech_giant_name_2;
vector<string> fm_radio_name;
vector<string> fm_radio_name_2;
vector<string> public_place;
vector<string> reagan_bad;
vector<string> reagan_bad_2;
vector<string> ceo_behaving_badly;
vector<string> reagan_good;
vector<string> reagan_good_2;
vector<string> cable_name;
vector<string> cable_name_2;
vector<string> cable_city;
vector<string> cable_city_2;
vector<string> ccs_adjective;
vector<string> ccs_adjective_2;
vector<string> ccs_adjective_3;
vector<string> ccs_noun;
vector<string> personalAds;
vector<string> personalAdsLG;
vector<string> caseNEWSSTORY_CCS_DEFEATED;
vector<string> caseNEWSSTORY_CCS_NOBACKERS;
vector<vector<string> > adListB;
vector<vector<string> > adList;
const int AD_LENGTH = 4;
const string majorevent = "majorevent\\";

vector<file_and_text_collection> majorevent_text_file_collection = {
	/*majorevent.cpp*/
	customText(&liberalCrime, majorevent + CONST_news019),
	customText(&AMorPM, majorevent + CONST_news020),
	customText(&book_title, majorevent + CONST_news021),
	customText(&book_title_2, majorevent + CONST_news022),
	customText(&random_nationality, majorevent + CONST_news023),
	customText(&conservative_oppose_book, majorevent + CONST_news024),
	customText(&radio_name, majorevent + CONST_news025),
	customText(&radio_name_2, majorevent + CONST_news026),
	customText(&vigilante_murder, majorevent + CONST_news027),
	customText(&why_chase_ended, majorevent + CONST_news028),
	customText(&crazy_conservative_act, majorevent + CONST_news029),
	customText(&bribe_officers, majorevent + CONST_news030),
	customText(&my_idol, majorevent + CONST_news031),
	customText(&prison_book_title, majorevent + CONST_news032),
	customText(&prison_book_title_2, majorevent + CONST_news033),
	customText(&mutilated_corpse, majorevent + CONST_news034),
	customText(&evidence_of_child_murder, majorevent + CONST_news035),
	customText(&break_in_murder_case, majorevent + CONST_news036),
	customText(&animal_research_country, majorevent + CONST_news037),
	customText(&drug_name, majorevent + CONST_news038),
	customText(&drug_name_2, majorevent + CONST_news039),
	customText(&chimp_drug_impact, majorevent + CONST_news040),
	customText(&chimp_drug_horror, majorevent + CONST_news041),
	customText(&terrorist_group, majorevent + CONST_news042),
	customText(&terrorist_plot, majorevent + CONST_news043),
	customText(&terrorist_plot_no_free_speech, majorevent + CONST_news044),
	customText(&gene_corp_name, majorevent + CONST_news045),
	customText(&gene_corp_name_2, majorevent + CONST_news046),
	customText(&gene_product_name, majorevent + CONST_news047),
	customText(&gene_product_name_2, majorevent + CONST_news048),
	customText(&gene_product_benefit, majorevent + CONST_news049),
	customText(&gene_product_cost, majorevent + CONST_news050),
	customText(&bullshit_no_free_speech, majorevent + CONST_news051),
	customText(&bullshit, majorevent + CONST_news052),
	customText(&petty_violence, majorevent + CONST_news053),
	customText(&his_her, majorevent + CONST_news054),
	customText(&older_younger, majorevent + CONST_news055),
	customText(&brother_sister, majorevent + CONST_news056),
	customText(&judge_with_prostitute, majorevent + CONST_news057),
	customText(&judge_with_prostitute_no_free_speech, majorevent + CONST_news058),
	customText(&judge_with_prostitute_full_free_speech, majorevent + CONST_news059),
	customText(&radio_host_crazy_quote, majorevent + CONST_news060),
	customText(&radio_host_lost_mind, majorevent + CONST_news061),
	customText(&family_values_company_name, majorevent + CONST_news062),
	customText(&family_values_company_name_2, majorevent + CONST_news063),
	customText(&family_values_company_name_3, majorevent + CONST_news064),
	customText(&pollution_consumption, majorevent + CONST_news065),
	customText(&pollution_consumption_2, majorevent + CONST_news066),
	customText(&i_like_polution, majorevent + CONST_news067),
	customText(&distrust_liberals, majorevent + CONST_news068),
	customText(&tech_giant_name, majorevent + CONST_news069),
	customText(&tech_giant_name_2, majorevent + CONST_news070),
	customText(&fm_radio_name, majorevent + CONST_news071),
	customText(&fm_radio_name_2, majorevent + CONST_news072),
	customText(&public_place, majorevent + CONST_news073),
	customText(&reagan_bad, majorevent + CONST_news074),
	customText(&reagan_bad_2, majorevent + CONST_news075),
	customText(&ceo_behaving_badly, majorevent + CONST_news076),
	customText(&reagan_good, majorevent + CONST_news077),
	customText(&reagan_good_2, majorevent + CONST_news078),
	customText(&cable_name, majorevent + CONST_news079),
	customText(&cable_name_2, majorevent + CONST_news080),
	customText(&cable_city, majorevent + CONST_news081),
	customText(&cable_city_2, majorevent + CONST_news082),
	/*squadstory_text.cpp*/
	customText(&ccs_adjective, majorevent + CONST_news083),
	customText(&ccs_adjective_2, majorevent + CONST_news084),
	customText(&ccs_adjective_3, majorevent + CONST_news085),
	customText(&ccs_noun, majorevent + CONST_news086),
	customText(&personalAds, mostlyendings + CONST_news087),
	customText(&personalAdsLG, mostlyendings + CONST_news088),
	customText(&adList, mostlyendings + CONST_news089, AD_LENGTH),
	customText(&adListB, mostlyendings + CONST_news090, AD_LENGTH),
	customText(&caseNEWSSTORY_CCS_DEFEATED, mostlyendings + CONST_news091),
	customText(&caseNEWSSTORY_CCS_NOBACKERS, mostlyendings + CONST_news092),
};
newsstoryst* ccs_strikes_story()
{
	newsstoryst *ns = new newsstoryst;
	// Chance of CCS squad wipe
	if (LCSrandom(10))ns->type = NEWSSTORY_CCS_SITE;
	else ns->type = NEWSSTORY_CCS_KILLED_SITE;
	// Chance of positive CCS story
	ns->positive = true;
	do {
		ns->loc = LCSrandom(LocationsPool::getInstance().lenpool());
	} while (LocationsPool::getInstance().getRentingType(ns->loc) != -1);
	return ns;
}
newsstoryst* ccs_fbi_raid_story()
{
	extern char endgamestate;
	newsstoryst* ns = new newsstoryst;
	ns->type = NEWSSTORY_CCS_DEFEATED;
	ns->priority = 8000;
	endgamestate = ENDGAME_CCS_DEFEATED;
	// arrest or kill ccs sleepers
	CreaturePool::getInstance().arrestOrKillCCSSleepers();
	LocationsPool::getInstance().hideCCSSafehouses();
	// go militarized police
	change_public_opinion(VIEW_POLICEBEHAVIOR, -20);
	return ns;
}
newsstoryst* ccs_exposure_story()
{
	extern CCSexposure ccsexposure;
	extern short lawList[LAWNUM];
	extern short house[HOUSENUM];
	extern short senate[SENATENUM];
	newsstoryst* ns = new newsstoryst;
	ns->type = NEWSSTORY_CCS_NOBACKERS;
	ns->priority = 8000;
	ccsexposure = CCSEXPOSURE_NOBACKERS;
	// arrest seventeen representatives and eight senators
	int arrestsleft = 8;
	for (int i = 0; i < SENATENUM; i++)
	{
		if ((senate[i] == -2 || senate[i] == -1) && !LCSrandom(4))
		{
			senate[i] = ALIGN_ELITELIBERAL;
			arrestsleft--;
			if (arrestsleft <= 0) break;
		}
	}
	arrestsleft = 17;
	for (int i = 0; i < HOUSENUM; i++)
	{
		if ((house[i] == -2 || house[i] == -1) && !LCSrandom(4))
		{
			house[i] = ALIGN_ELITELIBERAL;
			arrestsleft--;
			if (arrestsleft <= 0) break;
		}
	}
	// change police regulation issue to be more liberal
	lawList[LAW_POLICEBEHAVIOR] += 2;
	if (lawList[LAW_POLICEBEHAVIOR] > ALIGN_ELITELIBERAL)
		lawList[LAW_POLICEBEHAVIOR] = ALIGN_ELITELIBERAL;
	change_public_opinion(VIEW_POLICEBEHAVIOR, 50);
	change_public_opinion(VIEW_CONSERVATIVECRIMESQUAD, 50);
	return ns;
}
void advance_ccs_defeat_storyline()
{
	extern CCSexposure ccsexposure;
	switch (ccsexposure)
	{
	default:
	case CCSEXPOSURE_NONE:
	case CCSEXPOSURE_LCSGOTDATA:
		break;
	case CCSEXPOSURE_EXPOSED:
		newsstory.push_back(ccs_exposure_story());
		break;
	case CCSEXPOSURE_NOBACKERS:
		newsstory.push_back(ccs_fbi_raid_story());
		break;
	}
}
newsstoryst* new_major_event()
{
	extern short lawList[LAWNUM];
	extern short public_interest[VIEWNUM];
	newsstoryst *ns = new newsstoryst;
	ns->type = NEWSSTORY_MAJOREVENT;
	while (true)
	{
		ns->view = LCSrandom(VIEWNUM - 3);
		ns->positive = LCSrandom(2);
		// Skip issues that we have no news stories for
		if (ns->view == VIEW_IMMIGRATION)continue;
		if (ns->view == VIEW_DRUGS)continue;
		if (ns->view == VIEW_MILITARY)continue;
		if (ns->view == VIEW_CIVILRIGHTS)continue;
		if (ns->view == VIEW_TORTURE)continue;
		//if(ns->view==VIEW_POLITICALVIOLENCE)continue;
		// News stories that don't apply when the law is extreme -- covering
		// nuclear power when it's banned, police corruption when it doesn't
		// exist, out of control pollution when it's under control, etc.
		if (ns->positive) {
			if (ns->view == VIEW_WOMEN && lawList[LAW_ABORTION] == -2)continue; // Abortion banned
			if (ns->view == VIEW_DEATHPENALTY && lawList[LAW_DEATHPENALTY] == 2)continue; // Death penalty banned
			if (ns->view == VIEW_NUCLEARPOWER && lawList[LAW_NUCLEARPOWER] == 2)continue; // Nuclear power banned
			if (ns->view == VIEW_ANIMALRESEARCH && lawList[LAW_ANIMALRESEARCH] == 2)continue; // Animal research banned
			if (ns->view == VIEW_POLICEBEHAVIOR && lawList[LAW_POLICEBEHAVIOR] == 2)continue; // Police corruption eliminated
			if (ns->view == VIEW_INTELLIGENCE && lawList[LAW_PRIVACY] == 2)continue; // Privacy rights respected
			if (ns->view == VIEW_SWEATSHOPS && lawList[LAW_LABOR] == 2)continue; // Sweatshops nonexistant
			if (ns->view == VIEW_POLLUTION && lawList[LAW_POLLUTION] >= 1)continue; // Pollution under control
			if (ns->view == VIEW_CORPORATECULTURE && lawList[LAW_CORPORATE] == 2)continue; // Regulation controls corporate corruption
			if (ns->view == VIEW_CEOSALARY && lawList[LAW_CORPORATE] == 2)continue; // CEOs aren't rich
		}
		else {
			if (ns->view == VIEW_WOMEN && lawList[LAW_ABORTION] < 2)continue; // Partial birth abortion banned
			if (ns->view == VIEW_AMRADIO && lawList[LAW_FREESPEECH] == -2)continue; // AM Radio is censored to oblivion
			if (ns->view == VIEW_ANIMALRESEARCH && lawList[LAW_ANIMALRESEARCH] == 2)continue; // Animal research banned
		}
		break;
	}
	if (ns->positive) change_public_opinion(ns->view, 20, 0);
	else change_public_opinion(ns->view, -20, 0);
	public_interest[ns->view] += 50;
	return ns;
}
void generate_random_event_news_stories()
{
	extern char endgamestate;
	extern CCSexposure ccsexposure;
	//Conservative Crime Squad Strikes!
	if (endgamestate < ENDGAME_CCS_DEFEATED &&
		LCSrandom(30) < endgamestate)
	{
		newsstory.push_back(ccs_strikes_story());
	}
	// The slow defeat of the conservative crime squad...
	if (endgamestate < ENDGAME_CCS_DEFEATED &&
		ccsexposure >= CCSEXPOSURE_EXPOSED &&
		!LCSrandom(60))
	{
		advance_ccs_defeat_storyline();
	}
	// Random major event news stories
	if (!LCSrandom(60)) {
		newsstory.push_back(new_major_event());
	}
}
void clean_up_empty_news_stories()
{
	// Delete stories that have no content or shouldn't be reported on
	for (int n = len(newsstory) - 1; n >= 0; n--)
	{
		// Squad site action stories without crimes
		if (newsstory[n]->type == NEWSSTORY_SQUAD_SITE &&
			!len(newsstory[n]->crime))
		{
			delete_and_remove(newsstory, n);
			continue;
		}
		// Police killed stories without police being killed
		if (newsstory[n]->type == NEWSSTORY_CARTHEFT ||
			newsstory[n]->type == NEWSSTORY_NUDITYARREST ||
			newsstory[n]->type == NEWSSTORY_WANTEDARREST ||
			newsstory[n]->type == NEWSSTORY_DRUGARREST ||
			newsstory[n]->type == NEWSSTORY_GRAFFITIARREST ||
			newsstory[n]->type == NEWSSTORY_BURIALARREST)
		{
			char conf = 0;
			for (int c = 0; c < len(newsstory[n]->crime); c++)
			{
				if (newsstory[n]->crime[c] == CRIME_KILLEDSOMEBODY)
				{
					conf = 1;
					break;
				}
			}
			if (!conf)
			{
				delete_and_remove(newsstory, n);
				continue;
			}
		}
		// Sieges that aren't police actions
		if ((newsstory[n]->type == NEWSSTORY_SQUAD_ESCAPED ||
			newsstory[n]->type == NEWSSTORY_SQUAD_FLEDATTACK ||
			newsstory[n]->type == NEWSSTORY_SQUAD_DEFENDED ||
			newsstory[n]->type == NEWSSTORY_SQUAD_BROKESIEGE ||
			newsstory[n]->type == NEWSSTORY_SQUAD_KILLED_SIEGEATTACK ||
			newsstory[n]->type == NEWSSTORY_SQUAD_KILLED_SIEGEESCAPE) &&
			newsstory[n]->siegetype != SIEGE_POLICE)
		{
			delete_and_remove(newsstory, n);
			continue;
		}
	}
}
int bonusPriority(const short type, const long loc, long priority) {
	extern short attitude[VIEWNUM];
	switch (type)
	{
	case NEWSSTORY_SQUAD_ESCAPED:
		priority += 10 + attitude[VIEW_LIBERALCRIMESQUAD] / 3;
		break;
	case NEWSSTORY_SQUAD_FLEDATTACK:
		priority += 15 + attitude[VIEW_LIBERALCRIMESQUAD] / 3;
		break;
	case NEWSSTORY_SQUAD_DEFENDED:
		priority += 30 + attitude[VIEW_LIBERALCRIMESQUAD] / 3;
		break;
	case NEWSSTORY_SQUAD_BROKESIEGE:
		priority += 45 + attitude[VIEW_LIBERALCRIMESQUAD] / 3;
		break;
	case NEWSSTORY_SQUAD_KILLED_SIEGEATTACK:
		priority += 10 + attitude[VIEW_LIBERALCRIMESQUAD] / 3;
		break;
	case NEWSSTORY_SQUAD_KILLED_SIEGEESCAPE:
		priority += 15 + attitude[VIEW_LIBERALCRIMESQUAD] / 3;
		break;
	case NEWSSTORY_SQUAD_KILLED_SITE:
		priority += 10 + attitude[VIEW_LIBERALCRIMESQUAD] / 3;
		break;
	default:
		// Suppress actions at CCS safehouses
		if (loc != -1 &&
			LocationsPool::getInstance().getRentingType(loc) == RENTING_CCS)
		{
			priority = 0;
		}
		break;
	}
	return priority;
}
int moreBonusPriority(const short type, const long loc, long priority) {

	switch (LocationsPool::getInstance().getLocationType(loc))
	{
		// Not even reported
	case SITE_BUSINESS_CRACKHOUSE:
		if (type == NEWSSTORY_SQUAD_KILLED_SITE ||
			type == NEWSSTORY_SQUAD_SITE)
		{
			priority = 0;
			break;
		}
		// Nobody cares
	case SITE_RESIDENTIAL_TENEMENT:
		priority /= 8;
		break;
		// Normal priority
	case SITE_RESIDENTIAL_SHELTER:
	case SITE_INDUSTRY_WAREHOUSE:
	case SITE_RESIDENTIAL_BOMBSHELTER:
	case SITE_DOWNTOWN:
	case SITE_COMMERCIAL:
	case SITE_UDISTRICT:
	case SITE_OUTOFTOWN:
	case SITE_INDUSTRIAL:
	case SITE_RESIDENTIAL_APARTMENT:
	case SITE_RESIDENTIAL_APARTMENT_UPSCALE:
	case SITE_LABORATORY_COSMETICS:
	case SITE_LABORATORY_GENETIC:
	case SITE_HOSPITAL_CLINIC:
	case SITE_HOSPITAL_UNIVERSITY:
	case SITE_INDUSTRY_SWEATSHOP:
	case SITE_INDUSTRY_POLLUTER:
	case SITE_BUSINESS_PAWNSHOP:
	case SITE_BUSINESS_JUICEBAR:
	case SITE_BUSINESS_CIGARBAR:
	case SITE_BUSINESS_LATTESTAND:
	case SITE_BUSINESS_VEGANCOOP:
	case SITE_BUSINESS_INTERNETCAFE:
	case SITE_BUSINESS_DEPTSTORE:
	case SITE_BUSINESS_HALLOWEEN:
	case SITE_BUSINESS_BARANDGRILL:
	case SITE_BUSINESS_ARMSDEALER:
	case SITE_BUSINESS_CARDEALERSHIP:
	case SITE_OUTDOOR_PUBLICPARK:
	case SITE_OUTDOOR_BUNKER:
	default:
		break;
		// WOAH OMG
	case SITE_INDUSTRY_NUCLEAR:
	case SITE_GOVERNMENT_POLICESTATION:
	case SITE_GOVERNMENT_COURTHOUSE:
	case SITE_GOVERNMENT_PRISON:
	case SITE_GOVERNMENT_INTELLIGENCEHQ:
	case SITE_GOVERNMENT_ARMYBASE:
	case SITE_GOVERNMENT_FIRESTATION:
	case SITE_CORPORATE_HEADQUARTERS:
	case SITE_CORPORATE_HOUSE:
	case SITE_MEDIA_AMRADIO:
	case SITE_MEDIA_CABLENEWS:
	case SITE_BUSINESS_BANK:
	case SITE_GOVERNMENT_WHITE_HOUSE:
		priority *= 2;
		break;
	}
	return priority;
}
/* news - determines the priority of a news story */
void setpriority(newsstoryst &ns)
{
	extern char endgamestate;
	extern short attitude[VIEWNUM];
	// Priority is set differently based on the type of the news story
	switch (ns.type)
	{
		// Major events always muscle to the front page by having a very high priority
	case NEWSSTORY_MAJOREVENT:
		ns.priority = 30000;
		break;
		// LCS-related news stories are more important if they involve lots of headline-grabbing
		// crimes
	case NEWSSTORY_SQUAD_SITE:
	case NEWSSTORY_SQUAD_ESCAPED:
	case NEWSSTORY_SQUAD_FLEDATTACK:
	case NEWSSTORY_SQUAD_DEFENDED:
	case NEWSSTORY_SQUAD_BROKESIEGE:
	case NEWSSTORY_SQUAD_KILLED_SIEGEATTACK:
	case NEWSSTORY_SQUAD_KILLED_SIEGEESCAPE:
	case NEWSSTORY_SQUAD_KILLED_SITE:
	case NEWSSTORY_CARTHEFT:
	case NEWSSTORY_NUDITYARREST:
	case NEWSSTORY_WANTEDARREST:
	case NEWSSTORY_DRUGARREST:
	case NEWSSTORY_GRAFFITIARREST:
	case NEWSSTORY_BURIALARREST:
	{
		ns.priority = 0;
		int crime[CRIMENUM];
		memset(crime, 0, CRIMENUM * sizeof(int));
		// Record all the crimes in this story
		for (int c = 0; c < len(ns.crime); c++)
			crime[ns.crime[c]]++;
		// Cap publicity for more than ten repeats of an action of some type
		if (crime[CRIME_STOLEGROUND] > 10) crime[CRIME_STOLEGROUND] = 10;
		if (crime[CRIME_BROKEDOWNDOOR] > 10) crime[CRIME_BROKEDOWNDOOR] = 10;
		if (crime[CRIME_ATTACKED_MISTAKE] > 10) crime[CRIME_ATTACKED_MISTAKE] = 10;
		if (crime[CRIME_ATTACKED] > 10) crime[CRIME_ATTACKED] = 10;
		if (crime[CRIME_BREAK_SWEATSHOP] > 10) crime[CRIME_BREAK_SWEATSHOP] = 10;
		if (crime[CRIME_BREAK_FACTORY] > 10) crime[CRIME_BREAK_FACTORY] = 10;
		if (crime[CRIME_FREE_RABBITS] > 10) crime[CRIME_FREE_RABBITS] = 10;
		if (crime[CRIME_FREE_BEASTS] > 10) crime[CRIME_FREE_BEASTS] = 10;
		if (crime[CRIME_TAGGING] > 10) crime[CRIME_TAGGING] = 10;
		// Increase news story priority based on the number of instances of
		// various crimes, scaled by a factor dependant on the crime
		// Unique site crimes
		ns.priority += crime[CRIME_BANKVAULTROBBERY] * 100;
		ns.priority += crime[CRIME_BANKSTICKUP] * 100;
		ns.priority += crime[CRIME_SHUTDOWNREACTOR] * 100;
		ns.priority += crime[CRIME_HACK_INTEL] * 100;
		ns.priority += crime[CRIME_ARMORY] * 100;
		ns.priority += crime[CRIME_HOUSE_PHOTOS] * 100;
		ns.priority += crime[CRIME_CORP_FILES] * 100;
		ns.priority += crime[CRIME_PRISON_RELEASE] * 50;
		ns.priority += crime[CRIME_JURYTAMPERING] * 30;
		ns.priority += crime[CRIME_POLICE_LOCKUP] * 30;
		ns.priority += crime[CRIME_COURTHOUSE_LOCKUP] * 30;
		ns.priority += crime[CRIME_BANKTELLERROBBERY] * 30;
		// Common site crimes
		ns.priority += crime[CRIME_KILLEDSOMEBODY] * 30;
		ns.priority += crime[CRIME_FREE_BEASTS] * 12;
		ns.priority += crime[CRIME_BREAK_SWEATSHOP] * 8;
		ns.priority += crime[CRIME_BREAK_FACTORY] * 8;
		ns.priority += crime[CRIME_FREE_RABBITS] * 8;
		ns.priority += crime[CRIME_ATTACKED_MISTAKE] * 7;
		ns.priority += crime[CRIME_ATTACKED] * 4;
		ns.priority += crime[CRIME_TAGGING] * 2;
		ns.priority += crime[CRIME_VANDALISM] * 2;
		//ns.priority+=crime[CRIME_STOLEGROUND ];
		//ns.priority+=crime[CRIME_BROKEDOWNDOOR ];
		// Set story's political and violence levels for determining whether
		// a story becomes positive or negative
		if (ns.claimed) ns.politics_level = 5;
		else ns.politics_level = 0;
		ns.politics_level += crime[CRIME_SHUTDOWNREACTOR] * 100;
		ns.politics_level += crime[CRIME_HACK_INTEL] * 100;
		ns.politics_level += crime[CRIME_HOUSE_PHOTOS] * 100;
		ns.politics_level += crime[CRIME_CORP_FILES] * 100;
		ns.politics_level += crime[CRIME_PRISON_RELEASE] * 50;
		ns.politics_level += crime[CRIME_POLICE_LOCKUP] * 30;
		ns.politics_level += crime[CRIME_COURTHOUSE_LOCKUP] * 30;
		ns.politics_level += crime[CRIME_FREE_BEASTS] * 10;
		ns.politics_level += crime[CRIME_BREAK_SWEATSHOP] * 10;
		ns.politics_level += crime[CRIME_BREAK_FACTORY] * 10;
		ns.politics_level += crime[CRIME_FREE_RABBITS] * 10;
		ns.politics_level += crime[CRIME_VANDALISM] * 5;
		ns.politics_level += crime[CRIME_TAGGING] * 3;
		ns.violence_level = 0;
		ns.violence_level += crime[CRIME_ARMORY] * 100;
		ns.violence_level += crime[CRIME_KILLEDSOMEBODY] * 20;
		ns.violence_level += crime[CRIME_ATTACKED_MISTAKE] * 12;
		ns.violence_level += crime[CRIME_ATTACKED] * 4;
		// Add additional priority based on the type of news story
		// and how high profile the LCS is
		ns.priority = bonusPriority(ns.type, ns.loc, ns.priority);
		
		// Double profile if the squad moved out in full battle colors
		if (ns.claimed == 2) ns.priority *= 2;
		// Modify notability by location
		if (ns.loc != -1)
		{
			ns.priority = moreBonusPriority(ns.type, ns.loc, ns.priority);
		}
		// Cap news priority, in part so it can't displace major news stories
		if (ns.priority > 20000) ns.priority = 20000;
		break;
	}
	case NEWSSTORY_KIDNAPREPORT:
		// Kidnappings are higher priority if they're an archconservative
		ns.priority = 20;
		if (ns.cr->type == CREATURE_CORPORATE_CEO ||
			ns.cr->type == CREATURE_RADIOPERSONALITY ||
			ns.cr->type == CREATURE_NEWSANCHOR ||
			ns.cr->type == CREATURE_SCIENTIST_EMINENT ||
			ns.cr->type == CREATURE_JUDGE_CONSERVATIVE) ns.priority = 40;
		break;
	case NEWSSTORY_MASSACRE:
		// More people massacred, higher priority (I think; not verified ns.crime[1] is people present)
		ns.priority = 10 + ns.crime[1] * 5;
		break;
	case NEWSSTORY_CCS_SITE:
	case NEWSSTORY_CCS_KILLED_SITE:
		// CCS actions loosely simulate LCS actions; here it adds some
		// random site crimes to the story and increases the
		// priority accordingly
		ns.crime.push_back(CRIME_BROKEDOWNDOOR);
		ns.priority = 1;
		ns.politics_level += 20;
		if (ns.positive == 0)
		{
			ns.crime.push_back(CRIME_ATTACKED_MISTAKE);
			ns.priority += 7;
			ns.violence_level += 12;
		}
		ns.crime.push_back(CRIME_ATTACKED);
		ns.priority += 4 * (LCSrandom(10) + 1);
		ns.violence_level += LCSrandom(10) * 4;
		if (LCSrandom(endgamestate + 1))
		{
			ns.crime.push_back(CRIME_KILLEDSOMEBODY);
			ns.priority += LCSrandom(10) * 30;
			ns.violence_level += LCSrandom(10) * 20;
		}
		if (LCSrandom(endgamestate + 1))
		{
			ns.crime.push_back(CRIME_STOLEGROUND);
			ns.priority += LCSrandom(10);
		}
		if (!LCSrandom(endgamestate + 4))
		{
			ns.crime.push_back(CRIME_BREAK_FACTORY);
			ns.priority += LCSrandom(10) * 2;
			ns.politics_level += LCSrandom(10) * 10;
		}
		if (LCSrandom(2))
		{
			ns.crime.push_back(CRIME_CARCHASE);
		}
		break;
	case NEWSSTORY_CCS_DEFENDED:
	case NEWSSTORY_CCS_KILLED_SIEGEATTACK:
		ns.priority = 40 + attitude[VIEW_LIBERALCRIMESQUAD] / 3;
		break;
	}
}
void assign_page_numbers_to_newspaper_stories()
{
	for (int n = len(newsstory) - 1; n >= 0; n--)
	{
		setpriority(*newsstory[n]);
		// Suppress squad actions that aren't worth a story
		if (newsstory[n]->type == NEWSSTORY_SQUAD_SITE &&
			((newsstory[n]->priority < 50 &&
				newsstory[n]->claimed == 0) ||
				newsstory[n]->priority < 4))
		{
			delete_and_remove(newsstory, n);
			continue;
		}
		newsstory[n]->page = -1;
	}
	char acted;
	int curpage = 1, curguardianpage = 1;
	do
	{
		acted = 0;
		// Sort the major newspapers
		int maxn = -1, maxp = -1;
		for (int n = 0; n < len(newsstory); n++)
		{
			if (newsstory[n]->priority > maxp&&
				newsstory[n]->page == -1)
			{
				maxn = n;
				maxp = newsstory[n]->priority;
			}
		}
		if (maxn != -1)
		{
			if (newsstory[maxn]->priority < 30 && curpage == 1) curpage = 2;
			if (newsstory[maxn]->priority < 25 && curpage < 3) curpage = 3 + LCSrandom(2);
			if (newsstory[maxn]->priority < 20 && curpage < 5) curpage = 5 + LCSrandom(5);
			if (newsstory[maxn]->priority < 15 && curpage < 10) curpage = 10 + LCSrandom(10);
			if (newsstory[maxn]->priority < 10 && curpage < 20) curpage = 20 + LCSrandom(10);
			if (newsstory[maxn]->priority < 5 && curpage < 30) curpage = 30 + LCSrandom(20);
			newsstory[maxn]->page = curpage;
			newsstory[maxn]->guardianpage = curguardianpage;
			curpage++;
			curguardianpage++;
			acted = 1;
		}
	} while (acted);
}
/* news - show major news story */
void preparepage(const newsstoryst ns, const bool liberalguardian)
{
	extern int day;
	extern int month;
	extern int year;
	extern unsigned char newstops[6][80][5][4];
	set_color_easy(WHITE_ON_WHITE);
	for (int x = 0; x < 80; x++)
		for (int y = 0; y < 25; y++)
			mvaddcharAlt(y, x, ' ');
	set_color_easy(WHITE_ON_BLACK);
	if (ns.page == 1 || (liberalguardian&&ns.guardianpage == 1))
	{
		//TOP
		int pap = LCSrandom(5);
		for (int x = 0; x < 80; x++)
		{
			for (int y = 0; y < 5; y++)
			{
				if (liberalguardian)
				{
					set_color((newstops[5][x][y][1]),
						(newstops[5][x][y][2]),
						newstops[5][x][y][3]);
					mvaddcharAlt(y, x, newstops[5][x][y][0]);
				}
				else
				{
					set_color((newstops[pap][x][y][1]),
						(newstops[pap][x][y][2]),
						newstops[pap][x][y][3]);
					mvaddcharAlt(y, x, newstops[pap][x][y][0]);
				}
			}
		}
		if (!liberalguardian) // Liberal Guardian graphics don't support adding a date
		{
			//DATE
			set_color_easy(BLACK_ON_WHITE);
			int pday = day, pmonth = month, pyear = year;
			if (pday > monthday()) // Day counter has increased but end-of-month has not yet
			{ // been checked so it has to be accounted for here.
				pday = 1, pmonth++;
				if (pmonth > 12) pmonth = 1, pyear++;
			}
			mvaddstrAlt(3, 66 + (pday < 10), getmonth(pmonth, true));
			addstrAlt(singleSpace);
			addstrAlt(pday);
			addstrAlt(commaSpace);
			addstrAlt(pyear);
		}
	}
	else
	{
		//PAGE
		set_color_easy(BLACK_ON_WHITE);
		mvaddstrAlt(0, 76, liberalguardian ? ns.guardianpage : ns.page);
	}
}
/* news - draws the specified block of text to the screen */
void displaynewsstory(const string story, const short *storyx_s, const short *storyx_e, int y) {
	vector<char *> text;
	vector<char> centered;
	int curpos = 0;
	char addstring[500];
	int cury = y;
	char endparagraph = 0;
	char iscentered = 0;
	int i = 0;
	while (curpos < len(story) && cury < 25)
	{
		char content = 0;
		int totalwidth = 0;
		int addstrcur = 0;
		int length = storyx_e[cury] - storyx_s[cury] + 1;
		if (length == 0) { cury++; if (endparagraph > 0)endparagraph--; continue; }
		for (i = curpos; i < len(story); i++)
		{
			if (story[i] == '&'&&story[i + 1] != '&')
			{
				i++;
				if (story[i] == 'c')iscentered = 1;
				if (story[i] == 'r')
				{
					content = 1;
					i++;
					addstrcur += 1;
					addstring[addstrcur - 1] = ' ';
					addstring[addstrcur] = '\x0';
					endparagraph = 1;
					break;
				}
			}
			else
			{
				content = 1;
				if (story[i] == '&')i++;
				addstring[addstrcur] = story[i];
				addstring[addstrcur + 1] = '\x0';
				totalwidth++;
				if (totalwidth > length)
				{
					while (story[i] != ' ') i--, addstrcur--;
					while (story[i] == ' ') i++;
					addstring[addstrcur] = '\x0';
					break;
				}
				addstrcur++;
			}
		}
		if (i == len(story)) addstring[addstrcur] = '\x0';
		if (len(addstring) && content)
		{
			int words = 0;
			char silent = 1;
			vector<int> spacex;
			for (int s2 = 0; s2 < len(addstring); s2++)
			{
				if (addstring[s2] == ' ')
				{
					if (!silent)
					{
						silent = 1;
						words++;
						spacex.push_back(s2);
					}
				}
				else
				{
					if (silent)
					{
						words++;
						silent = 0;
					}
				}
			}
			while (!endparagraph&&words > 1 && len(addstring) < length && !iscentered)
			{
				int csp = pickrandom(spacex);
				for (int x = 0; x < len(spacex); x++)
					if (spacex[x] > csp) spacex[x]++;
				int l = len(addstring);
				for (int s = l + 1; s > csp; s--)
					addstring[s] = addstring[s - 1];
			}
			char *news = new char[len(addstring) + 1];
			strcpy(news, addstring);
			text.push_back(news);
			centered.push_back(iscentered);
			cury++;
			if (endparagraph > 0)
				endparagraph--, iscentered = 0;
		}
		curpos = i;
	}
	set_color_easy(BLACK_ON_WHITE);
	for (int t = 0; t < len(text); t++)
	{
		if (y + t >= 25) break;
		if (text[t][len(text[t]) - 1] == ' ') // remove trailing space
			text[t][len(text[t]) - 1] = '\x0'; // (necessary for proper centering and to not overwrite borders around an ad)
		if (centered[t])
			moveAlt(y + t, ((storyx_s[y + t] + storyx_e[y + t] - len(text[t]) + 1) >> 1));
		else moveAlt(y + t, storyx_s[y + t]);
		addstrAlt(text[t]);
		delete[] text[t];
	}
	text.clear();
}

void displaysinglead(const bool liberalguardian, char addplace[2][3], short* storyx_s, short* storyx_e)
{
	extern int year;
	int x, y;
	do x = LCSrandom(2), y = LCSrandom(3); while (addplace[x][y]);
	char choice = LCSrandom(6) + 1; // choose an ad from 1 to 6 that isn't already taken
	for (int x2 = 0; x2 < 2; x2++) for (int y2 = 0; y2 < 3; y2++) // loop thru ad places to see ads already up
		if (addplace[x2][y2] == choice) choice = LCSrandom(6) + 1, x2 = 0, y2 = -1; // choose again and restart loop if already taken
	addplace[x][y] = choice; // we got an ad chosen that isn't a duplicate
	int sx = 0, ex = 0, sy = 0, ey = 0;
	if (x == 0) sx = 0, ex = 23 + LCSrandom(4);
	if (x == 1) sx = 57 - LCSrandom(4), ex = 79;
	if (y == 0) sy = 2, ey = 9;
	if (y == 1) sy = 10, ey = 17;
	if (y == 2) sy = 18, ey = 24;
	int ch = '?';
	switch (LCSrandom(6))
	{
	case 0: ch = CH_LIGHT_SHADE; break;
	case 1: ch = CH_MEDIUM_SHADE; break;
	case 2: ch = CH_DARK_SHADE; break;
	case 3: ch = CH_FULL_BLOCK; break;
	case 4: ch = CH_BOX_DRAWINGS_LIGHT_VERTICAL_AND_HORIZONTAL; break;
	case 5: ch = '*'; break;
	}
	for (y = sy; y <= ey; y++)
	{
		if (storyx_s[y] < ex&&ex < 43) storyx_s[y] = ex + 2;
		if (storyx_e[y] > sx&&sx > 43) storyx_e[y] = sx - 2;
		if (ey == 9 && y == 9) continue;
		if (ey == 17 && y == 17) continue;
		for (x = sx; x <= ex; x++)
			if (y == sy || y == 8 || y == 16 || y == 24 || x == sx || x == ex)
				mvaddchAlt(y, x, ch);
	}
	//AD CONTENT
	{
		short storyx_s[25], storyx_e[25];
		for (int it2 = 0; it2 < 25; it2++) storyx_s[it2] = 40, storyx_e[it2] = 40;
		for (int it2 = sy + 1; it2 <= ey - 1; it2++) storyx_s[it2] = sx + 1, storyx_e[it2] = ex - 1;
		string ad;
		if (!liberalguardian)
		{ // regular newspaper (not Liberal Guardian)
			switch (choice) // should be 6 choices from 1 to 6
			{ // location[]->name?
			case 1:
			case 3:
			case 5:
			default:
				ad = blankString;
				for (string str : pickrandom(adList)) {
					ad += str;
				}
				break;
			case 2:
				ad = ampersandC + CONST_news093 + ampersandR + ampersandR;
				ad += ampersandC + CONST_news094 + ampersandR;
				ad += ampersandC + CONST_news095;
				ad += LCSrandom(201) + 400;
				ad += ampersandR;
				break;
			case 4:
				ad = ampersandC + CONST_news096 + ampersandR;
				ad += ampersandC + CONST_news097;
				ad += ampersandC;
				ad += year - LCSrandom(15);
				ad += singleSpace;
				// strcat(ad,cartype);
				//TODO: leading zeros, etc.
				ad += CONST_news098 + ampersandR;
				ad += ampersandC + CONST_news099 + ampersandR;
				ad += ampersandC + CONST_news100;
				ad += LCSrandom(16) + 15;
				ad += ampersandR;
				break;
			case 6:
			{
				ad = ampersandC;
				ad += pickrandom(personalAds);
				ad += ampersandR + ampersandR;
				ad += ampersandC;
				ad += sexdesc();
				ad += singleSpace;				
				ad += sexwho();
				ad += singleSpace;
				ad += sexseek();
				ad += ampersandR;
				ad += ampersandC;				
				ad += sextype();
				ad += CONST_news105;				
				ad += sexwho();
				ad += ampersandR;
				break;
			}
			}
		}
		else
		{ // Liberal Guardian Ads
			switch (choice) // should be 6 choices from 1 to 6
			{
			case 1:
			case 3:
			case 4:
			case 5:
			default:
				ad = blankString;
				for (string str : pickrandom(adListB)) {
					ad += str;
				}
				break;
			case 2:
				ad = ampersandC + CONST_news102 + ampersandR;
				ad += ampersandC;
				ad += LCSrandom(11) + 20;
				ad += CONST_news103 + ampersandR + ampersandR;
				ad += ampersandC + CONST_news104 + ampersandR;
				break;
			case 6:
			{
				ad = ampersandC;
				ad += pickrandom(personalAdsLG);
				ad += ampersandR + ampersandR;
				ad += ampersandC;				
				ad += sexdesc();
				ad += singleSpace;
				ad += sexwho();
				ad += singleSpace;
				ad += sexseek();
				ad += ampersandR;
				ad += ampersandC;
				ad += sextype();
				ad += CONST_news105;
				ad += sexwho();
				ad += ampersandR;
				break;
			}
			}
		}
		displaynewsstory(ad, storyx_s, storyx_e, sy + 1);
	}
}
void displayads(const newsstoryst ns, const bool liberalguardian, short* storyx_s, short* storyx_e)
{
	int adnumber = 0;
	if (!liberalguardian)
	{
		if (ns.page >= 10)adnumber++;
		if (ns.page >= 20)adnumber += LCSrandom(2) + 1;
		if (ns.page >= 30)adnumber += LCSrandom(2) + 1;
		if (ns.page >= 40)adnumber += LCSrandom(2) + 1;
		if (ns.page >= 50)adnumber += LCSrandom(2) + 1;
	}
	else
	{
		if (ns.guardianpage >= 2)adnumber++;
		if (ns.guardianpage >= 3)adnumber += LCSrandom(2) + 1;
		if (ns.guardianpage >= 4)adnumber += LCSrandom(2) + 1;
		if (ns.guardianpage >= 5)adnumber += LCSrandom(2) + 1;
		if (ns.guardianpage >= 6)adnumber += LCSrandom(2) + 1;
	}
	char addplace[2][3] = { { 0,0,0 },{ 0,0,0 } };
	for (adnumber = (adnumber > 6 ? 6 : adnumber); adnumber > 0; adnumber--)
		displaysinglead(liberalguardian, addplace, storyx_s, storyx_e);
}
const string CONST_news485 = ". ";
string squadstory_text_location(const newsstoryst ns, bool liberalguardian, bool ccs)
{
	string story;
	story += CONST_news106;
	string placename = LocationsPool::getInstance().getLocationName(ns.loc);
	if (placename.substr(0, 4) == tag_The)
		placename = placename.substr(4);
	int posand = placename.find('&');
	if (posand != (int)string::npos)
		placename = placename.substr(0, posand) + CONST_news107 + placename.substr(posand + 1);
	switch (LocationsPool::getInstance().getLocationType(ns.loc))
	{
	case SITE_CITY_SEATTLE:
	case SITE_CITY_LOS_ANGELES:
	case SITE_CITY_NEW_YORK:
	case SITE_CITY_CHICAGO:
	case SITE_CITY_DETROIT:
	case SITE_CITY_ATLANTA:
	case SITE_CITY_MIAMI:
	case SITE_CITY_WASHINGTON_DC:
		story += CONST_news118;
		break;
	case SITE_DOWNTOWN:
	case SITE_COMMERCIAL:
	case SITE_UDISTRICT:
	case SITE_OUTOFTOWN:
	case SITE_INDUSTRIAL:
	case SITE_TRAVEL:
		if (placename == tag_Shopping)
		{
			placename = CONST_news109;
			story += CONST_news128;
		}
		else if (placename == tag_Travel)
		{
			placename = CONST_news111;
			story += CONST_news128;
		}
		else if (placename == tag_Outskirts_and_Orange_County)
		{
			placename = CONST_news113;
			story += CONST_news118;
		}
		else if (placename == tag_Brooklyn_and_Queens)
		{
			placename = tag_Long_Island;
			story += CONST_news115;
		}
		else if (placename == tag_Greater_Hollywood)
		{
			placename = tag_Hollywood;
			story += CONST_news118;
		}
		else if (placename == tag_Manhattan_Island)
		{
			placename = tag_Manhattan;
			story += CONST_news118;
		}
		else if (placename == tag_Arlington)
			story += CONST_news118;
		else if (placename == tag_National_Mall)
			story += CONST_news119;
		else if (placename != tag_Downtown)
			story += CONST_news120;
		break;
	case SITE_BUSINESS_PAWNSHOP:
		if (placename.find(CONST_news121) != string::npos)
		{
			story += CONST_news126;
			if (liberalguardian && !ccs)story += CONST_news127;
		}
		else
		{
			story += CONST_news128;
			if (liberalguardian && !ccs)story += CONST_news129;
		}
		break;
	case SITE_RESIDENTIAL_APARTMENT:
	case SITE_BUSINESS_CARDEALERSHIP:
	case SITE_BUSINESS_DEPTSTORE:
	case SITE_OUTDOOR_PUBLICPARK:
		story += CONST_news126;
		if (liberalguardian && !ccs)story += CONST_news127;
		break;
	default:
		story += CONST_news128;
		if (liberalguardian && !ccs)story += CONST_news129;
		break;
	}
	if (ccs)
	{
		switch (LocationsPool::getInstance().getLocationType(ns.loc))
		{
		case SITE_RESIDENTIAL_APARTMENT_UPSCALE:
			story += CONST_news130; break;
		case SITE_BUSINESS_CIGARBAR:
			story += CONST_news131; break;
		case SITE_LABORATORY_COSMETICS:
			story += CONST_news132; break;
		case SITE_LABORATORY_GENETIC:
			story += CONST_news133; break;
		case SITE_GOVERNMENT_POLICESTATION:
			story += CONST_news134; break;
		case SITE_GOVERNMENT_COURTHOUSE:
			story += CONST_news135; break;
		case SITE_GOVERNMENT_PRISON:
			story += CONST_news136; break;
		case SITE_GOVERNMENT_INTELLIGENCEHQ:
			story += CONST_news137; break;
		case SITE_INDUSTRY_SWEATSHOP:
			story += CONST_news138; break;
		case SITE_INDUSTRY_POLLUTER:
			story += CONST_news145; break;
		case SITE_INDUSTRY_NUCLEAR:
			story += CONST_news140; break;
		case SITE_CORPORATE_HEADQUARTERS:
			story += CONST_news141; break;
		case SITE_CORPORATE_HOUSE:
			story += CONST_news142; break;
		case SITE_MEDIA_AMRADIO:
			story += CONST_news143; break;
		case SITE_MEDIA_CABLENEWS:
			story += CONST_news144; break;
		case SITE_GOVERNMENT_ARMYBASE:
			story += CONST_news145; break;
		case SITE_GOVERNMENT_FIRESTATION:
			story += CONST_news146; break;
		case SITE_BUSINESS_BANK:
			story += CONST_news147; break;
		default:
			story += placename;
			story += CONST_news485; break;
		}
	}
	else story += placename;
	if (liberalguardian && !ccs)
	{
		switch (LocationsPool::getInstance().getLocationType(ns.loc))
		{
		case SITE_RESIDENTIAL_APARTMENT_UPSCALE:
			story += CONST_news149; break;
		case SITE_BUSINESS_CIGARBAR:
			story += CONST_news150; break;
		case SITE_LABORATORY_COSMETICS:
			story += CONST_news151; break;
		case SITE_LABORATORY_GENETIC:
			story += CONST_news152; break;
		case SITE_GOVERNMENT_POLICESTATION:
			story += CONST_news153; break;
		case SITE_GOVERNMENT_COURTHOUSE:
			story += CONST_news154; break;
		case SITE_GOVERNMENT_PRISON:
			story += CONST_news155; break;
		case SITE_GOVERNMENT_INTELLIGENCEHQ:
			story += CONST_news156; break;
		case SITE_GOVERNMENT_ARMYBASE:
			story += CONST_news157; break;
		case SITE_INDUSTRY_SWEATSHOP:
			story += CONST_news158; break;
		case SITE_INDUSTRY_POLLUTER:
			story += CONST_news159; break;
		case SITE_INDUSTRY_NUCLEAR:
			story += CONST_news160; break;
		case SITE_CORPORATE_HEADQUARTERS:
			story += CONST_news161; break;
		case SITE_CORPORATE_HOUSE:
			story += CONST_news162; break;
		case SITE_MEDIA_AMRADIO:
		case SITE_MEDIA_CABLENEWS:
			story += CONST_news163; break;
		case SITE_BUSINESS_BANK:
			story += CONST_news164; break;
		default:
			story += CONST_news485; break;
		}
	}
	else if (!ccs)
		story += CONST_news485;

	return story;
}
string squadstory_text_opening(const newsstoryst ns, bool liberalguardian, bool ccs)
{
	string story;
	extern char newscherrybusted;
	if (ns.type == NEWSSTORY_SQUAD_SITE)
	{
		if (!newscherrybusted && !liberalguardian)
		{
			if (ns.positive)
			{
				story += CONST_news203;
				story += CONST_news180;
				story += CONST_news185;
				story += CONST_news221;
			}
			else
			{
				story += CONST_news207;
				story += CONST_news184;
				story += CONST_news185;
			}
		}
		else
		{
			if (ns.positive)
			{
				story += CONST_news174;
				story += CONST_news221;
			}
			else
			{
				if (!liberalguardian)
					story += CONST_news176;
				else
					story += CONST_news177;
				story += CONST_news221;
			}
		}
	}
	else if (ns.type == NEWSSTORY_CCS_SITE)
	{
		if (newscherrybusted < 2)
		{
			if (ns.positive && !liberalguardian)
			{
				story += CONST_news179;
				story += CONST_news180;
				story += CONST_news185;
				story += CONST_news221;
			}
			else
			{
				story += CONST_news183;
				story += CONST_news184;
				story += CONST_news185;
			}
		}
		else
		{
			if (ns.positive && !liberalguardian)
			{
				story += CONST_news186;
				story += CONST_news221;
			}
			else
			{
				story += CONST_news188;
				story += CONST_news221;
			}
		}
	}
	else if (ns.type == NEWSSTORY_CCS_KILLED_SITE)
	{
		if (newscherrybusted < 2)
		{
			if (ns.positive && !liberalguardian)
			{
				story += CONST_news190;
				story += CONST_news204;
				story += CONST_news209;
				story += CONST_news221;
			}
			else
			{
				story += CONST_news194;
				story += pickrandom(ccs_adjective);
				story += pickrandom(ccs_adjective_2);
				story += CONST_news195;
				story += pickrandom(ccs_noun);
				story += CONST_news196;
				story += pickrandom(ccs_adjective_3);
				story += CONST_news197;
				story += CONST_news221;
			}
		}
		else
		{
			if (ns.positive && !liberalguardian)
			{
				story += CONST_news199;
				story += CONST_news221;
			}
			else
			{
				story += CONST_news201;
				story += CONST_news221;
			}
		}
	}
	else
	{
		if (!newscherrybusted && !liberalguardian)
		{
			if (ns.positive)
			{
				story += CONST_news203;
				story += CONST_news204;
				story += CONST_news209;
				story += CONST_news221;
			}
			else
			{
				story += CONST_news207;
				story += CONST_news208;
				story += CONST_news209;
				story += CONST_news221;
			}
		}
		else
		{
			if (ns.positive)
			{
				story += CONST_news211;
				story += CONST_news221;
			}
			else
			{
				if (!liberalguardian)
					story += CONST_news213;
				else
					story += CONST_news214;//XXX: Rewrite me -- LK
				story += CONST_news221;
			}
		}
	}
	story += squadstory_text_location(ns, liberalguardian, ccs);
	if (ns.type == NEWSSTORY_SQUAD_KILLED_SITE)
	{
		if (liberalguardian)story += CONST_news216;
		else if (ns.positive)story += CONST_news217;
		else story += CONST_news218;
	}
	if (ns.type == NEWSSTORY_CCS_KILLED_SITE)
	{
		if (ns.positive && !liberalguardian)story += CONST_news219;
		else story += CONST_news220;
	}
	story += CONST_news221;
	return story;
}

void displaycenterednewsfont(const std::string& str, int y)
{
	extern unsigned char bigletters[27][5][7][4];
	int width = -1;
	for (int s = 0; s < len(str); s++)
	{
		if (str[s] >= 'A'&&str[s] <= 'Z')width += 6;
		else if (str[s] == '\'')width += 4;
		else width += 3;
	}
	int x = 39 - width / 2;
	for (int s = 0; s < len(str); s++)
	{
		if ((str[s] >= 'A'&&str[s] <= 'Z') || str[s] == '\'')
		{
			int p;
			if (str[s] >= 'A'&&str[s] <= 'Z') p = str[s] - 'A';
			else p = 26;
			int lim = 6;
			if (str[s] == '\'') lim = 4;
			if (s == len(str) - 1) lim--;
			for (int x2 = 0; x2 < lim; x2++) for (int y2 = 0; y2 < 7; y2++)
			{
				// Clean the square first.
				set_color_easy(BLACK_ON_BLACK);
				mvaddchAlt(y + y2, x + x2, ' ');
				if (x2 == 5)
				{
					set_color_easy(WHITE_ON_WHITE);
					mvaddchAlt(y + y2, x + x2, ' ');
				}
				else
				{
					set_color((bigletters[p][x2][y2][1]),
						(bigletters[p][x2][y2][2]),
						bigletters[p][x2][y2][3]);
					mvaddcharAlt(y + y2, x + x2, bigletters[p][x2][y2][0]);
				}
			}
			x += lim;
		}
		else
		{
			set_color_easy(WHITE_ON_WHITE);
			for (int x2 = 0; x2 < 3; x2++) for (int y2 = 0; y2 < 7; y2++)
			{
				mvaddcharAlt(y + y2, x + x2, ' ');
			}
			x += 3;
		}
	}
}

string constructeventstory(const short view, const char positive);

const int PICTURE_MUTANT_BEAST = 0;
const int PICTURE_CEO = 1;
const int PICTURE_BOOK = 2;
const int PICTURE_MELTDOWN = 3;
const int PICTURE_GENETICS = 4;
const int PICTURE_RIVERFIRE = 5;
const int PICTURE_DOLLARS = 6;
const int PICTURE_TINKYWINKY = 7;
const int PICTURE_OIL = 8;
const int PICTURE_TERRORISTS = 9;
const int PICTURE_KKK = 10;
const int PICTURE_TSHIRT = 11;
void run_television_news_stories()
{
	extern CursesMoviest movie;
	extern MusicClass music;
	vector<string> CONST_Woman_744 = {
		CONST_news740, CONST_news741, CONST_news742, CONST_news743, CONST_news744
	};
	vector<string> CONST_Cable_744 = {
		CONST_news740, CONST_news735, CONST_news736, CONST_news737, CONST_news744
	};
	vector<string> CONST_CEO_744 = {
		CONST_news740, CONST_news729, CONST_news730, CONST_news731, CONST_news744
	};
	vector<string> CONST_Cable_744POS = {
		CONST_news740, CONST_news723, CONST_news724, CONST_news725, CONST_news744
	};
	vector<string> CONST_Police_744 = {
		CONST_news740, CONST_news715, CONST_news716, CONST_news717, CONST_news744
	};
	for (int n = len(newsstory) - 1; n >= 0; n--)
	{
		char del = 0;
		if (newsstory[n]->type == NEWSSTORY_MAJOREVENT)
		{
			if (newsstory[n]->positive)
			{
				switch (newsstory[n]->view)
				{
				case VIEW_POLICEBEHAVIOR:
					music.play(MUSIC_LACOPS);
					movie.loadmovie(CONST_news713.c_str());
					movie.playmovie(0, 0);

					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					for (int i = 0; i < len(CONST_Police_744); i++) {
						mvaddstrAlt(19 + i, 13, CONST_Police_744[i]);
					}
					pressAnyKey();
					del = 1;
					break;
				case VIEW_CABLENEWS:
				{
					music.play(MUSIC_NEWSCAST);
					string str = CONST_news719 + pickrandom(cable_name) + singleSpace + pickrandom(cable_name_2) + CONST_news720;
					string bname;
					bname = generate_name(GENDER_WHITEMALEPATRIARCH);
					str += bname;
					eraseAlt();
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrCenter(0, str);
					mvaddstrAlt(16, 20, bname);
					mvaddstrAlt(17, 20, pickrandom(cable_city).data());
					moveAlt(16, 41);
					addstrAlt(generate_name());
					mvaddstrAlt(17, 41, pickrandom(cable_city_2).data());
					movie.loadmovie(CONST_news721.c_str());
					movie.playmovie(1, 1);

					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					for (int i = 0; i < len(CONST_Cable_744POS); i++) {
						mvaddstrAlt(19 + i, 13, CONST_Cable_744POS[i]);
					}
					pressAnyKey();
					del = 1;
					break;
				}
				}
			}
			else
			{
				switch (newsstory[n]->view)
				{
				case VIEW_CEOSALARY:
					music.play(MUSIC_GLAMSHOW);
					movie.loadmovie(CONST_news727.c_str());
					movie.playmovie(0, 0);

					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					for (int i = 0; i < len(CONST_CEO_744); i++) {
						mvaddstrAlt(19 + i, 13, CONST_CEO_744[i]);
					}
					pressAnyKey();
					del = 1;
					break;
				case VIEW_CABLENEWS:
					music.play(MUSIC_ANCHOR);
					movie.loadmovie(CONST_news733.c_str());
					movie.playmovie(0, 0);

					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					for (int i = 0; i < len(CONST_Cable_744); i++) {
						mvaddstrAlt(19 + i, 13, CONST_Cable_744[i]);
					}
					pressAnyKey();
					del = 1;
					break;
				case VIEW_WOMEN:
					music.play(MUSIC_ABORT);
					eraseAlt();
					movie.loadmovie(CONST_news739.c_str());
					movie.playmovie(0, 0);

					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					for (int i = 0; i < len(CONST_Woman_744); i++) {
						mvaddstrAlt(19 + i, 13, CONST_Woman_744[i]);
					}
					pressAnyKey();
					del = 1;
					break;
				}
			}
		}
		if (del) delete_and_remove(newsstory, n);
	}
}
string getLastNameForHeadline(char* fullName)
{
	int j = -1;
	char lastName[20];
	// Parse through full name to get the last name
	for (int i = 0; fullName[i] != 0; i++)
	{
		// Start recording last name at the space between first and last
		if (fullName[i] == ' ')
		{
			j = 0;
		}
		// When recording last name, transcribe in uppercase
		else if (j >= 0)
		{
			lastName[j++] = toupper(fullName[i]);
		}
	}
	lastName[j] = 0; // To finish, NULL terminate the transcribed string
					 // Write to string
	string ret = lastName;
	return ret;
}
void displaystoryheader(const newsstoryst ns, const bool liberalguardian, int& y, int header)
{
	extern char newscherrybusted;
	extern char oldPresidentName[POLITICIAN_NAMELEN];
	switch (ns.type)
	{
	case NEWSSTORY_PRESIDENT_IMPEACHED:
		displaycenterednewsfont(getLastNameForHeadline(oldPresidentName), 5);
		displaycenterednewsfont(CONST_news745, 13);
		break;
	case NEWSSTORY_PRESIDENT_BELIEVED_DEAD:
		displaycenterednewsfont(getLastNameForHeadline(oldPresidentName), 5);
		displaycenterednewsfont(CONST_news746, 13);
		break;
	case NEWSSTORY_PRESIDENT_FOUND_DEAD:
		displaycenterednewsfont(getLastNameForHeadline(oldPresidentName), 5);
		displaycenterednewsfont(CONST_news747, 13);
		break;
	case NEWSSTORY_PRESIDENT_FOUND:
		displaycenterednewsfont(getLastNameForHeadline(oldPresidentName), 5);
		displaycenterednewsfont(CONST_news748, 13);
		break;
	case NEWSSTORY_PRESIDENT_KIDNAPPED:
		displaycenterednewsfont(getLastNameForHeadline(oldPresidentName), 5);
		displaycenterednewsfont(CONST_news1016, 13);
		break;
	case NEWSSTORY_PRESIDENT_MISSING:
		displaycenterednewsfont(getLastNameForHeadline(oldPresidentName), 5);
		displaycenterednewsfont(CONST_news750, 13);
		break;
	case NEWSSTORY_PRESIDENT_ASSASSINATED:
		displaycenterednewsfont(getLastNameForHeadline(oldPresidentName), 5);
		displaycenterednewsfont(CONST_news751, 13);
		break;
	case NEWSSTORY_CCS_NOBACKERS:
		displaycenterednewsfont(CONST_news752, 5);
		y = 13;
		break;
	case NEWSSTORY_CCS_DEFEATED:
		displaycenterednewsfont(CONST_news753, 5);
		y = 13;
		break;
	case NEWSSTORY_NUDITYARREST:
	case NEWSSTORY_CARTHEFT:
	case NEWSSTORY_WANTEDARREST:
	case NEWSSTORY_DRUGARREST:
	case NEWSSTORY_GRAFFITIARREST:
	case NEWSSTORY_BURIALARREST:
		displaycenterednewsfont(CONST_news754, 5);
		y = 13;
		break;
	case NEWSSTORY_SQUAD_ESCAPED:
	case NEWSSTORY_SQUAD_FLEDATTACK:
		displaycenterednewsfont(CONST_news755, 5);
		displaycenterednewsfont(CONST_news756, 13);
		break;
	case NEWSSTORY_SQUAD_DEFENDED:
	case NEWSSTORY_SQUAD_BROKESIEGE:
		displaycenterednewsfont(CONST_news757, 5);
		displaycenterednewsfont(CONST_news758, 13);
		break;
	case NEWSSTORY_SQUAD_KILLED_SIEGEATTACK:
	case NEWSSTORY_SQUAD_KILLED_SIEGEESCAPE:
		if (!liberalguardian)
		{
			displaycenterednewsfont(CONST_news759, 5);
			displaycenterednewsfont(CONST_news760, 13);
		}
		else
		{
			displaycenterednewsfont(CONST_news761, 5);
			displaycenterednewsfont(CONST_news762, 13);
		}
		break;
	case NEWSSTORY_CCS_SITE:
	case NEWSSTORY_CCS_KILLED_SITE:
		if (newscherrybusted < 2)
		{
			displaycenterednewsfont(tag_CONSERVATIVE, 5);
			displaycenterednewsfont(CONST_news763, 13);
		}
		else
		{
			if (ns.positive)
				displaycenterednewsfont(CONST_news764, 5);//AGAIN?
			else
				displaycenterednewsfont(CONST_news765, 5);
			y = 13;
		}
		break;
	default:
		if (ns.positive)
		{
			if (newscherrybusted || liberalguardian)
			{
				if (!liberalguardian)
				{
					if (ns.priority > 250)
					{
						y = 13;
						displaycenterednewsfont(CONST_news766, 5);
					}
					else
					{
						y = 13;
						displaycenterednewsfont(CONST_news780, 5);
					}
				}
				else
				{
					y = 13;
					if (ns.priority > 150)
					{
						change_public_opinion(header, 5, 1); // Bonus for big story
						switch (header)
						{
						case VIEW_TAXES:
						case VIEW_SWEATSHOPS:
						case VIEW_CEOSALARY:
							displaycenterednewsfont(CONST_news768, 5);
							break;
						case VIEW_NUCLEARPOWER:
							displaycenterednewsfont(CONST_news769, 5);
							break;
						case VIEW_POLICEBEHAVIOR:
							displaycenterednewsfont(CONST_news770, 5);
							break;
						case VIEW_DEATHPENALTY:
							displaycenterednewsfont(CONST_news771, 5);
							break;
						case VIEW_INTELLIGENCE:
							displaycenterednewsfont(CONST_news772, 5);
							break;
						case VIEW_ANIMALRESEARCH:
						case VIEW_GENETICS:
							displaycenterednewsfont(CONST_news773, 5);
							break;
						case VIEW_FREESPEECH:
						case VIEW_GAY:
						case VIEW_JUSTICES:
							displaycenterednewsfont(CONST_news774, 5);
							break;
						case VIEW_POLLUTION:
							displaycenterednewsfont(CONST_news775, 5);
							break;
						case VIEW_CORPORATECULTURE:
							displaycenterednewsfont(CONST_news776, 5);
							break;
						case VIEW_AMRADIO:
							displaycenterednewsfont(CONST_news777, 5);
							break;
						case VIEW_CABLENEWS:
							displaycenterednewsfont(CONST_news778, 5);
							break;
						default:
							displaycenterednewsfont(CONST_news779, 5);
						}
					}
					else
					{
						displaycenterednewsfont(CONST_news780, 5);
					}
				}
			}
			else
			{
				displaycenterednewsfont(CONST_news785, 5);
				displaycenterednewsfont(CONST_news782, 13);
			}
		}
		else
		{
			if (newscherrybusted || liberalguardian)
			{
				if (!liberalguardian)
					displaycenterednewsfont(CONST_news783, 5);
				else
					displaycenterednewsfont(CONST_news784, 5);
				y = 13;
			}
			else
			{
				displaycenterednewsfont(CONST_news785, 5);
				displaycenterednewsfont(CONST_news786, 13);
			}
		}
		break;
	}
}
map<char, vector<Views> > siteViews = {
	map<SiteTypes, vector<Views> >::value_type(SITE_LABORATORY_COSMETICS,{
			VIEW_ANIMALRESEARCH,
			VIEW_WOMEN,
		}),
	map<SiteTypes, vector<Views> >::value_type(SITE_LABORATORY_GENETIC,{
	VIEW_ANIMALRESEARCH,
	VIEW_GENETICS,
			}),
	map<SiteTypes, vector<Views> >::value_type(SITE_GOVERNMENT_POLICESTATION,{
	VIEW_POLICEBEHAVIOR,
	VIEW_PRISONS,
	VIEW_DRUGS,
				}),
	map<SiteTypes, vector<Views> >::value_type(SITE_GOVERNMENT_COURTHOUSE,{
	VIEW_DEATHPENALTY,
	VIEW_JUSTICES,
	VIEW_FREESPEECH,
	VIEW_GAY,
	VIEW_WOMEN,
	VIEW_CIVILRIGHTS,
					}),
	map<SiteTypes, vector<Views> >::value_type(SITE_GOVERNMENT_PRISON,{
	VIEW_DEATHPENALTY,
	VIEW_DRUGS,
	VIEW_TORTURE,
	VIEW_PRISONS,
						}),
	map<SiteTypes, vector<Views> >::value_type(SITE_GOVERNMENT_ARMYBASE,{
	VIEW_TORTURE,
	VIEW_MILITARY,
							}),
	map<SiteTypes, vector<Views> >::value_type(SITE_GOVERNMENT_WHITE_HOUSE,{
								}),
	map<SiteTypes, vector<Views> >::value_type(SITE_GOVERNMENT_INTELLIGENCEHQ,{
	VIEW_INTELLIGENCE,
	VIEW_TORTURE,
	VIEW_PRISONS,
									}),
	map<SiteTypes, vector<Views> >::value_type(SITE_INDUSTRY_SWEATSHOP,{
	VIEW_SWEATSHOPS,
	VIEW_IMMIGRATION,
										}),
	map<SiteTypes, vector<Views> >::value_type(SITE_INDUSTRY_POLLUTER,{
	VIEW_SWEATSHOPS,
	VIEW_POLLUTION,
											}),
	map<SiteTypes, vector<Views> >::value_type(SITE_INDUSTRY_NUCLEAR,{
	VIEW_NUCLEARPOWER,
												}),
	map<SiteTypes, vector<Views> >::value_type(SITE_CORPORATE_HEADQUARTERS,{
	VIEW_TAXES,
	VIEW_CORPORATECULTURE,
	VIEW_WOMEN,
													}),
	map<SiteTypes, vector<Views> >::value_type(SITE_CORPORATE_HOUSE,{
	VIEW_TAXES,
	VIEW_CEOSALARY,
														}),
	map<SiteTypes, vector<Views> >::value_type(SITE_MEDIA_AMRADIO,{
	VIEW_AMRADIO,
	VIEW_FREESPEECH,
	VIEW_GAY,
	VIEW_WOMEN,
	VIEW_CIVILRIGHTS,
															}),
	map<SiteTypes, vector<Views> >::value_type(SITE_MEDIA_CABLENEWS,{
	VIEW_CABLENEWS,
	VIEW_FREESPEECH,
	VIEW_GAY,
	VIEW_WOMEN,
	VIEW_CIVILRIGHTS,
																}),
	map<SiteTypes, vector<Views> >::value_type(SITE_RESIDENTIAL_APARTMENT_UPSCALE,{
	VIEW_TAXES,
	VIEW_CEOSALARY,
	VIEW_GUNCONTROL,
																	}),
	map<SiteTypes, vector<Views> >::value_type(SITE_BUSINESS_CIGARBAR,{
	VIEW_TAXES,
	VIEW_CEOSALARY,
	VIEW_WOMEN,
																		}),
	map<SiteTypes, vector<Views> >::value_type(SITE_BUSINESS_BANK,{
	VIEW_TAXES,
	VIEW_CEOSALARY,
	VIEW_CORPORATECULTURE,
																			}),
};
void handle_public_opinion_impact(const newsstoryst &ns)
{
	// Check if this function is meant to handle public opinion impact
	// for this type of news story (primarily deals with squad/site actions)
	int okay_types[] = { NEWSSTORY_SQUAD_SITE, NEWSSTORY_SQUAD_ESCAPED, NEWSSTORY_SQUAD_FLEDATTACK,
		NEWSSTORY_SQUAD_DEFENDED, NEWSSTORY_SQUAD_BROKESIEGE, NEWSSTORY_SQUAD_KILLED_SIEGEATTACK,
		NEWSSTORY_SQUAD_KILLED_SIEGEESCAPE, NEWSSTORY_SQUAD_KILLED_SITE, NEWSSTORY_WANTEDARREST,
		NEWSSTORY_GRAFFITIARREST, NEWSSTORY_CCS_SITE, NEWSSTORY_CCS_KILLED_SITE };
	bool validType = false;
	for (int i = 0; i < len(okay_types) && !validType; i++)
	{
		if (okay_types[i] == ns.type)
			validType = false;
	}
	if (validType) {

		int impact = ns.priority;
		// Magnitude of impact will be affected by which page of the newspaper the story appears on
		if (ns.page == 1) impact *= 5;
		else if (ns.page == 2) impact *= 3;
		else if (ns.page == 3) impact *= 2;
		int maxpower = 1;
		if (ns.page == 1) maxpower = 100;
		else if (ns.page < 5) maxpower = 100 - 10 * ns.page;
		else if (ns.page < 10) maxpower = 40;
		else if (ns.page < 20) maxpower = 20;
		else if (ns.page < 30) maxpower = 10;
		else if (ns.page < 40) maxpower = 5;
		else maxpower = 1;
		// Five times effectiveness with the Liberal Guardian
		if (ns.positive == 2)
			impact *= 5;
		// Cap power
		if (impact > maxpower)
			impact = maxpower;
		impact /= 10;
		impact++;
		// Account for squad responsible, rampages, and Liberal Guardian bias
		int impact_direction = ALIGN_LIBERAL;
		if (ns.type == NEWSSTORY_CCS_SITE || ns.type == NEWSSTORY_CCS_KILLED_SITE)
		{
			impact_direction = ALIGN_CONSERVATIVE;
			if (ns.positive)
				change_public_opinion(VIEW_CONSERVATIVECRIMESQUAD, impact, 0);
			else
				change_public_opinion(VIEW_CONSERVATIVECRIMESQUAD, -impact, 0);
		}
		else
		{
			change_public_opinion(VIEW_LIBERALCRIMESQUAD, 2 + impact);
			impact_direction = ALIGN_LIBERAL;
			if (ns.positive)
				change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, impact);
			else
				change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, -impact);
		}
		impact *= impact_direction;
		int squad_responsible = impact_direction;
		if (!ns.positive) impact /= 4;
		// Impact gun control issue
		change_public_opinion(VIEW_GUNCONTROL, abs(impact) / 10, 0, abs(impact) * 10);
		if (ns.loc == -1) return;
		// Location-specific issue impact
		std::vector<int> issues;

		if (siteViews.count(LocationsPool::getInstance().getLocationType(ns.loc))) {
			for (Views v : siteViews[LocationsPool::getInstance().getLocationType(ns.loc)]) {
				issues.push_back(v);
			}
		}

		for (int i = 0; i < len(issues); i++)
			change_public_opinion(issues[i], impact, squad_responsible, impact * 10);

	}
}
/* news - graphics */
void loadgraphics()
{
	extern unsigned char bigletters[27][5][7][4];
	extern unsigned char newstops[6][80][5][4];
	extern unsigned char newspic[20][78][18][4];
	int picnum, dimx, dimy;
	FILE *h;
	if ((h = LCSOpenFile(CONST_news787.c_str(), CONST_newsB947.c_str(), LCSIO_PRE_ART)) != NULL)
	{
		fread(&picnum, sizeof(int), 1, h);
		fread(&dimx, sizeof(int), 1, h);
		fread(&dimy, sizeof(int), 1, h);
		for (int p = 0; p < picnum; p++)
			for (int x = 0; x < dimx; x++)
				for (int y = 0; y < dimy; y++)
					fread(&bigletters[p][x][y][0], sizeof(char), 4, h);
		LCSCloseFile(h);
	}
	if ((h = LCSOpenFile(CONST_news788.c_str(), CONST_newsB947.c_str(), LCSIO_PRE_ART)) != NULL)
	{
		fread(&picnum, sizeof(int), 1, h);
		fread(&dimx, sizeof(int), 1, h);
		fread(&dimy, sizeof(int), 1, h);
		for (int p = 0; p < picnum; p++)
			for (int x = 0; x < dimx; x++)
				for (int y = 0; y < dimy; y++)
					fread(&newstops[p][x][y][0], sizeof(char), 4, h);
		LCSCloseFile(h);
	}
	if ((h = LCSOpenFile(CONST_news789.c_str(), CONST_newsB947.c_str(), LCSIO_PRE_ART)) != NULL)
	{
		fread(&picnum, sizeof(int), 1, h);
		fread(&dimx, sizeof(int), 1, h);
		fread(&dimy, sizeof(int), 1, h);
		for (int p = 0; p < picnum; p++)
			for (int x = 0; x < dimx; x++)
				for (int y = 0; y < dimy; y++)
					fread(&newspic[p][x][y][0], sizeof(char), 4, h);
		LCSCloseFile(h);
	}
}
void displaycenteredsmallnews(const std::string& str, int y)
{
	set_color_easy(BLACK_ON_WHITE);
	mvaddstrCenter(y, str);
}
void displaynewspicture(int p, int y)
{
	extern unsigned char newspic[20][78][18][4];
	for (int x2 = 0; x2 < 78; x2++)
		for (int y2 = 0; y2 < 15; y2++)
		{
			if (y + y2 > 24) break;
			set_color((newspic[p][x2][y2][1]),
				(newspic[p][x2][y2][2]),
				newspic[p][x2][y2][3]);
			moveAlt(y + y2, 1 + x2);
			addcharAlt(newspic[p][x2][y2][0]);
		}
}
void displaynewsstoryPositiveX(const short view, const string next, const short* storyx_s, const short* storyx_e) {
	displaycenterednewsfont(next, 5);
	displaynewsstory(constructeventstory(view, true), storyx_s, storyx_e, 13);

}
void displaynewsstoryNegativeX(const short view, const string next, const short* storyx_s, const short* storyx_e) {
	displaycenterednewsfont(next, 5);
	displaynewsstory(constructeventstory(view, false), storyx_s, storyx_e, 13);

}
void displaynewsstoryNegativeX(const short view, const string next, const string second, const short* storyx_s, const short* storyx_e) {
	displaycenterednewsfont(next, 5);
	displaycenterednewsfont(second, 13);
	displaynewsstory(constructeventstory(view, false), storyx_s, storyx_e, 21);

}
void displaynewsandpicture(const string news1, const string news2, const int picture) {
	displaycenterednewsfont(news1, 5);
	displaycenteredsmallnews(news2, 12);
	displaynewspicture(picture, 13);
}
void displaymajoreventstory(const newsstoryst ns, const short* storyx_s, const short* storyx_e)
{
	const string CONST_news848 = "OF CULTURE";
	const string CONST_news847 = "THE DEATH";
	const string CONST_news846 = "NEW JOBS";
	const string CONST_news845 = "LOOKING UP";
	const string CONST_news844 = "Fall fashions are previewed in stores across the country.";
	const string CONST_news843 = "Fall fashions hit the stores across the country.";
	const string CONST_news842 = "THEY ARE HERE";
	const string CONST_news841 = "JUSTICE AMOK";
	const string CONST_news840 = "GM FOOD FAIRE";
	const string CONST_news839 = "Free speech advocates fight hard to let a white supremacist rally take place.";
	const string CONST_news838 = "HATE RALLY";
	const string CONST_news837 = "DODGED BULLET";
	const string CONST_news836 = "HOSTAGE SLAIN";
	const string CONST_news835 = "BASTARDS";
	const string CONST_news834 = "[JERKS]";
	const string CONST_news833 = "APE EXPLORERS";
	const string CONST_news832 = "OPEC cuts oil production sharply in response to a US foreign policy decision.";
	const string CONST_news831 = "OIL CRUNCH";
	const string CONST_news830 = ": A new book lauding Reagan and the greatest generation.";
	const string CONST_news829 = "REAGAN THE MAN";
	const string CONST_news828 = "SAVES LIVES";
	const string CONST_news827 = "ARMED CITIZEN";
	const string CONST_news826 = "END IN TEARS";
	const string CONST_news825 = "Our boys defend freedom once again, defeating an evil dictator.";
	const string CONST_news824 = "BIG VICTORY";
	const string CONST_news823 = "LET'S FRY 'EM";
	const string CONST_news822 = "Jerry Falwell explains the truth about Tinky Winky. Again.";
	const string CONST_news821 = "KINKY WINKY";
	const string CONST_news820 = "AM IMPLOSION";
	const string CONST_news819 = "regularly visits prostitutes.";
	const string CONST_news818 = "regularly [donates to sperm banks].";
	const string CONST_news817 = "regularly visits [working women].";
	const string CONST_news816 = "This major CEO ";
	const string CONST_news815 = "AMERICAN CEO";
	const string CONST_news814 = "An enormous company files for bankruptcy, shattering the previous record.";
	const string CONST_news813 = "BELLY UP";
	const string CONST_news812 = "The Ohio River caught on fire again.";
	const string CONST_news811 = "RING OF FIRE";
	const string CONST_news810 = "A T-shirt in a store is found scrawled with a message from a sweatshop worker.";
	const string CONST_news809 = "CHILD'S PLEA";
	const string CONST_news808 = "IN CONTEMPT";
	const string CONST_news807 = "Over a hundred people become sick from genetically modified food.";
	const string CONST_news806 = "KILLER FOOD";
	const string CONST_news805 = "BOOK BANNED";
	const string CONST_news804 = "THE FBI FILES";
	const string CONST_news803 = "ON THE INSIDE";
	const string CONST_news802 = "A mutant animal has escaped from a lab and killed thirty people.";
	const string CONST_news801 = "HELL ON EARTH";
	const string CONST_news800 = "A nuclear power plant suffers a catastrophic meltdown.";
	const string CONST_news799 = "MELTDOWN";
	const string CONST_news798 = ": A new book further documenting the other side of Reagan.";
	const string CONST_news797 = "REAGAN FLAWED";
	const string CONST_news796 = "MASS SHOOTING";
	const string CONST_news795 = "NIGHTMARE";
	const string CONST_news794 = "Is the latest military invasion yet another quagmire?";
	const string CONST_news793 = "CASUALTIES MOUNT";
	const string CONST_news792 = "JUSTICE DEAD";
	const string CONST_news791 = "CRIME OF HATE";
	const string CONST_news790 = "CLINIC MURDER";

	extern int month;
	extern short lawList[LAWNUM];
	if (ns.positive)
	{
		switch (ns.view)
		{
		case VIEW_WOMEN:
			displaynewsstoryPositiveX(ns.view, CONST_news790, storyx_s, storyx_e);
			break;
		case VIEW_GAY:
			displaynewsstoryPositiveX(ns.view, CONST_news791, storyx_s, storyx_e);
			break;
		case VIEW_DEATHPENALTY:
			displaynewsstoryPositiveX(ns.view, CONST_news792, storyx_s, storyx_e);
			break;
		case VIEW_GUNCONTROL:
			displaynewsstoryPositiveX(ns.view, CONST_news796, storyx_s, storyx_e);
			break;
		case VIEW_PRISONS:
			displaynewsstoryPositiveX(ns.view, CONST_news803, storyx_s, storyx_e);
			break;
		case VIEW_INTELLIGENCE:
			displaynewsstoryPositiveX(ns.view, CONST_news804, storyx_s, storyx_e);
			break;
		case VIEW_FREESPEECH:
			displaynewsstoryPositiveX(ns.view, CONST_news805, storyx_s, storyx_e);
			break;
		case VIEW_JUSTICES:
			displaynewsstoryPositiveX(ns.view, CONST_news808, storyx_s, storyx_e);
			break;
		case VIEW_AMRADIO:
			displaynewsstoryPositiveX(ns.view, CONST_news820, storyx_s, storyx_e);
			break;
		case VIEW_TAXES:
		{
			string str = pickrandom(reagan_bad) + singleSpace + pickrandom(reagan_bad_2) + CONST_news798;
			displaynewsandpicture(CONST_news797, str, PICTURE_BOOK);
			break;
		}
		case VIEW_NUCLEARPOWER:
			displaynewsandpicture(CONST_news799, CONST_news800, PICTURE_MELTDOWN);
			break;
		case VIEW_ANIMALRESEARCH:
			displaynewsandpicture(CONST_news801, CONST_news802, PICTURE_MUTANT_BEAST);
			break;

		case VIEW_GENETICS:
			displaynewsandpicture(CONST_news806, CONST_news807, PICTURE_GENETICS);
			break;

		case VIEW_SWEATSHOPS:
			displaynewsandpicture(CONST_news809, CONST_news810, PICTURE_TSHIRT);
			break;
		case VIEW_POLLUTION:
			displaynewsandpicture(CONST_news811, CONST_news812, PICTURE_RIVERFIRE);
			break;
		case VIEW_CORPORATECULTURE:
			displaynewsandpicture(CONST_news813, CONST_news814, PICTURE_DOLLARS);
			break;
		case VIEW_CEOSALARY:
		{

			string str = CONST_news816;
			switch (LCSrandom(ceo_behaving_badly.size()))
			{
			case 0:
				if (lawList[LAW_FREESPEECH] == -2 && lawList[LAW_WOMEN] != -2)str += CONST_news817;
				else if (lawList[LAW_FREESPEECH] == -2 && lawList[LAW_WOMEN] == -2)str += CONST_news818;
				else str += CONST_news819;
				break;
			default:
				str += pickrandom(ceo_behaving_badly);
			}
			displaynewsandpicture(CONST_news816, str, PICTURE_CEO);
			break;
		}

		}
	}
	else
	{
		switch (ns.view)
		{
		case VIEW_GAY:
			displaynewsandpicture(CONST_news821, CONST_news822, PICTURE_TINKYWINKY);
			break;
		case VIEW_DEATHPENALTY:
			displaynewsstoryNegativeX(ns.view, CONST_news823, storyx_s, storyx_e);
			break;
		case VIEW_GUNCONTROL:
			displaynewsstoryNegativeX(ns.view, CONST_news827, CONST_news828, storyx_s, storyx_e);
			break;
		case VIEW_TAXES:
		{
			string str = pickrandom(reagan_good) + singleSpace + pickrandom(reagan_good_2) + CONST_news830;
			displaynewsandpicture(CONST_news829, str, PICTURE_BOOK);
			break;
		}
		case VIEW_NUCLEARPOWER:
			displaynewsandpicture(CONST_news831, CONST_news832, PICTURE_OIL);
			break;
		case VIEW_ANIMALRESEARCH:
			displaynewsstoryNegativeX(ns.view, CONST_news833, storyx_s, storyx_e);
			break;
		case VIEW_POLICEBEHAVIOR:
			if (lawList[LAW_FREESPEECH] == -2)displaycenterednewsfont(CONST_news834, 5);
			else displaycenterednewsfont(CONST_news835, 5);
			displaynewspicture(PICTURE_TERRORISTS, 13);
			break;
		case VIEW_PRISONS:
			displaynewsstoryNegativeX(ns.view, CONST_news836, storyx_s, storyx_e);
			break;
		case VIEW_INTELLIGENCE:
			displaynewsstoryNegativeX(ns.view, CONST_news837, storyx_s, storyx_e);
			break;
		case VIEW_FREESPEECH:
			displaynewsandpicture(CONST_news838, CONST_news839, PICTURE_KKK);
			break;
		case VIEW_GENETICS:
			displaynewsstoryNegativeX(ns.view, CONST_news840, storyx_s, storyx_e);
			break;
		case VIEW_JUSTICES:
			displaynewsstoryNegativeX(ns.view, CONST_news841, storyx_s, storyx_e);
			break;
		case VIEW_SWEATSHOPS:
			displaynewsandpicture(CONST_news842, month >= 8 && month <= 11 ? CONST_news843 : CONST_news844, PICTURE_TSHIRT);
			break;
		case VIEW_POLLUTION:
			displaynewsstoryNegativeX(ns.view, CONST_news845, storyx_s, storyx_e);
			break;
		case VIEW_CORPORATECULTURE:
			displaynewsstoryNegativeX(ns.view, CONST_news846, storyx_s, storyx_e);
			break;
		case VIEW_AMRADIO:
			displaynewsstoryNegativeX(ns.view, CONST_news847, CONST_news848, storyx_s, storyx_e);
			break;
		}
	}
}
const string CONST_news862 = "according to a spokesperson from the police department.";
const string CONST_news873 = "The names of the officers have not been released pending notification of their families.";
string wantedOrGraffitiArrest(const newsstoryst ns) {

	const string CONST_news859 = " while they were attempting to perform an arrest. ";
	const string CONST_news858 = "the police officer ";
	const string CONST_news857 = " officers ";
	const string CONST_news856 = "radical political group known as the Liberal Crime Squad, is believed to have killed ";
	const string CONST_news855 = " A suspect, identified only as a member of the ";
	const string CONST_news853 = " killed in the line of duty yesterday, ";
	const string CONST_news852 = "A police officer was";
	const string CONST_news851 = " police officers were";
	

	string story;
	int crime[CRIMENUM];
	std::memset(crime, 0, sizeof(int)*CRIMENUM);
	for (int c = 0; c < len(ns.crime); c++)
		crime[ns.crime[c]]++;
	if (crime[CRIME_KILLEDSOMEBODY] > 1)
	{
		if (crime[CRIME_KILLEDSOMEBODY] == 2)
			story += CONST_news849;
		else
			story += CONST_news850;
		story += CONST_news851;
	}
	else story += CONST_news852;
	story += CONST_news853;
	story += CONST_news862;
	story += ampersandR;
	story += CONST_news855;
	story += CONST_news856;
	if (crime[CRIME_KILLEDSOMEBODY] > 1)
	{
		story += tostring(crime[CRIME_KILLEDSOMEBODY]);
		story += CONST_news857;
	}
	else story += CONST_news858;
	story += CONST_news859;
	story += CONST_news873;
	story += ampersandR;
	return story;
}
string nudityCarDrugOrBurialArrest(const newsstoryst ns){
	const string CONST_news874 = "The name of the officer has not been released pending notification of the officer's family.";
	const string CONST_news872 = "A passerby had allegedly spotted the suspect committing a car theft. ";
	const string CONST_news871 = "appeared to be a corpse through an empty lot. ";
	const string CONST_news870 = "A passerby allegedly called the authorities after seeing the suspect dragging what ";
	const string CONST_news869 = "The suspect was allegedly selling \"pot brownies\". ";
	const string CONST_news868 = "The incident apparently occurred as a response to a public nudity complaint. ";
	const string CONST_news867 = " attempting to perform an arrest. ";
	const string CONST_news866 = "a police officer that was";
	const string CONST_news865 = " police officers that were";
	const string CONST_news864 = "killed ";
	const string CONST_news863 = " A suspect, whose identity is unclear, ";
	const string CONST_news861 = "A routine arrest went horribly wrong yesterday, ";
	string story;
	int crime[CRIMENUM];
	std::memset(crime, 0, sizeof(int)*CRIMENUM);
	for (int c = 0; c < len(ns.crime); c++)
		crime[ns.crime[c]]++;
	story += CONST_news861;
	story += CONST_news862;
	story += ampersandR;
	story += CONST_news863;
	story += CONST_news864;
	if (crime[CRIME_KILLEDSOMEBODY] > 1)
	{
		story += tostring(crime[CRIME_KILLEDSOMEBODY]);
		story += CONST_news865;
	}
	else story += CONST_news866;
	story += CONST_news867;
	if (ns.type == NEWSSTORY_NUDITYARREST)
		story += CONST_news868;
	else if (ns.type == NEWSSTORY_DRUGARREST)
		story += CONST_news869;
	else if (ns.type == NEWSSTORY_BURIALARREST)
	{
		story += CONST_news870;
		story += CONST_news871;
	}
	else
		story += CONST_news872;
	if (crime[CRIME_KILLEDSOMEBODY] > 1)
		story += CONST_news873;
	else story += CONST_news874;
	story += ampersandR;
	return story;

}

const string CONST_news1030 = "\"";
string otherCrime(const newsstoryst ns, const bool liberalguardian, const bool ccs) {
	const string CONST_newsX10 = " The slogan, \"";
	const string CONST_newsX11 = " One uttered the words, \"";
	const string CONST_newsX12 = " As they left, they shouted, \"";
	const string CONST_newsX13 = " One of them was rumored to have cried out, \"";
	const string CONST_newsX14 = " Witnesses reported hearing the phrase, \"";
		extern short lawList[LAWNUM];
		extern string slogan_str;
		string story;
		int crime[CRIMENUM];
		memset(crime, 0, sizeof(int)*CRIMENUM);
		int typesum = 0;
		for (int c = 0; c < len(ns.crime); c++)
		{
			// Count crimes of each type
			crime[ns.crime[c]]++;
			// Special crimes are described at the start or end of the article;
			// others should be recorded in the body
			if (ns.crime[c] == CRIME_HOUSE_PHOTOS) continue;
			if (ns.crime[c] == CRIME_CORP_FILES) continue;
			if (ns.crime[c] == CRIME_SHUTDOWNREACTOR) continue;
			if (ns.crime[c] == CRIME_BANKVAULTROBBERY) continue;
			if (ns.crime[c] == CRIME_BANKSTICKUP) continue;
			if (ns.crime[c] == CRIME_POLICE_LOCKUP) continue;
			if (ns.crime[c] == CRIME_COURTHOUSE_LOCKUP) continue;
			if (ns.crime[c] == CRIME_PRISON_RELEASE) continue;
			if (ns.crime[c] == CRIME_JURYTAMPERING) continue;
			if (ns.crime[c] == CRIME_HACK_INTEL) continue;
			if (ns.crime[c] == CRIME_ARMORY) continue;
			if (ns.crime[c] == CRIME_HOUSE_PHOTOS) continue;
			if (ns.crime[c] == CRIME_CORP_FILES) continue;
			if (ns.crime[c] == CRIME_CARCHASE) continue;
			if (ns.crime[c] == CRIME_CARCRASH) continue;
			if (ns.crime[c] == CRIME_FOOTCHASE) continue;
			//if(ns.crime[c]==CRIME_TAGGING) continue;
			if (crime[ns.crime[c]] == 1) typesum++;
		}
		if (crime[CRIME_SHUTDOWNREACTOR])
		{
			if (lawList[LAW_NUCLEARPOWER] == 2)
			{
				story += liberalguardian ? CONST_news877 + CONST_news878 : accordingToSourcesAtScene + CONST_news875 + CONST_news876;				
				story += ampersandR;
			}
			else
			{
				story += liberalguardian ? CONST_news881 + CONST_news882 : accordingToSourcesAtScene + CONST_news879 + CONST_news880;
				
				story += ampersandR;
			}
		}
		if (crime[CRIME_POLICE_LOCKUP])
		{
			story += liberalguardian ? CONST_news884 + CONST_news885 : accordingToSourcesAtScene + CONST_news883;
			
			story += ampersandR;
		}
		if (crime[CRIME_BANKVAULTROBBERY])
		{
			story += liberalguardian ? CONST_news887 + CONST_news888 : accordingToSourcesAtScene + CONST_news886;
			
			story += ampersandR;
		}
		else if (crime[CRIME_BANKSTICKUP])
		{
			story += liberalguardian ? CONST_news890 + CONST_news891 : accordingToSourcesAtScene + CONST_news889;
			
			story += ampersandR;
		}
		if (crime[CRIME_COURTHOUSE_LOCKUP])
		{
			story += liberalguardian ? CONST_news893 + CONST_news894 : accordingToSourcesAtScene + CONST_news892;
			
			story += ampersandR;
		}
		if (crime[CRIME_PRISON_RELEASE])
		{
			story += liberalguardian ? CONST_news896 + CONST_news897 : accordingToSourcesAtScene + CONST_news895;
			
			story += ampersandR;
		}
		if (crime[CRIME_JURYTAMPERING])
		{
			story += liberalguardian ? CONST_news900 + CONST_news901 : accordingToPoliceSources + CONST_news898 + CONST_news899;
			
			story += ampersandR;
		}
		if (crime[CRIME_HACK_INTEL])
		{
			story += liberalguardian ? CONST_news903 : accordingToPoliceSources + CONST_news902;
			
			story += ampersandR;
		}
		if (crime[CRIME_ARMORY])
		{
			story += liberalguardian ? CONST_news906 : CONST_news1031 + CONST_news905;
			
			story += ampersandR;
		}
		if (crime[CRIME_HOUSE_PHOTOS])
		{
			story += liberalguardian ? CONST_news908 : accordingToPoliceSources + CONST_news907;
			
			story += ampersandR;
		}
		if (crime[CRIME_CORP_FILES])
		{
			story += liberalguardian ? CONST_news910 : accordingToPoliceSources + CONST_news909;
			
			story += ampersandR;
		}
		if (liberalguardian && !ccs)
		{
			if (crime[CRIME_ATTACKED_MISTAKE]) typesum--;
			if (crime[CRIME_KILLEDSOMEBODY]) typesum--;
		}
		if (typesum > 0)
		{
			if (typesum > 0)
			{
				if (!ccs)
				{
					story += liberalguardian ? CONST_news913 : CONST_news911 + CONST_news915;
				}
				else
				{
					story += CONST_news914;
					story += CONST_news915;
				}
				if (crime[CRIME_ARSON])
				{
					story += liberalguardian || !ccs ? CONST_news917 : CONST_news916;
					
					if (typesum >= 3)story += commaSpace;
					else if (typesum == 2)story += AND;
					typesum--;
				}
				if (!liberalguardian || ccs)
				{
					if (crime[CRIME_KILLEDSOMEBODY])
					{
						story += CONST_news918;
						if (typesum >= 3)story += commaSpace;
						else if (typesum == 2)story += AND;
						typesum--;
					}
					if (crime[CRIME_ATTACKED_MISTAKE])
					{
						story += CONST_news921;
						if (typesum >= 3)story += commaSpace;
						else if (typesum == 2)story += AND;
						typesum--;
					}
					if (crime[CRIME_ATTACKED])
					{
						if (crime[CRIME_ATTACKED_MISTAKE])story += CONST_news920;
						else story += CONST_news921;
						if (typesum >= 3)story += commaSpace;
						else if (typesum == 2)story += AND;
						typesum--;
					}
				}
				else
				{
					if (crime[CRIME_ATTACKED])
					{
						story += CONST_news922;
						if (typesum >= 3)story += commaSpace;
						else if (typesum == 2)story += AND;
						typesum--;
					}
				}
				if (crime[CRIME_STOLEGROUND] || crime[CRIME_BANKTELLERROBBERY])
				{
					story += liberalguardian || !ccs ? CONST_news924 : CONST_news923;
					
					if (typesum >= 3)story += commaSpace;
					else if (typesum == 2)story += AND;
					typesum--;
				}
				if (crime[CRIME_FREE_RABBITS] || crime[CRIME_FREE_BEASTS])
				{
					story += liberalguardian ? CONST_news926 : CONST_news925;

					if (typesum >= 3)story += commaSpace;
					else if (typesum == 2)story += AND;
					typesum--;
				}
				if (crime[CRIME_BREAK_SWEATSHOP] || crime[CRIME_BREAK_FACTORY] || crime[CRIME_VANDALISM])
				{
					story += liberalguardian || !ccs ? CONST_news928 : CONST_news927;
					
					if (typesum >= 3)story += commaSpace;
					else if (typesum == 2)story += AND;
					typesum--;
				}
				if (crime[CRIME_TAGGING])
				{
					story += liberalguardian || !ccs ? CONST_news930 : CONST_news929;
					
					if (typesum >= 3)story += commaSpace;
					else if (typesum == 2)story += AND;
					typesum--;
				}
				if (crime[CRIME_BROKEDOWNDOOR])
				{
					story += liberalguardian || !ccs ? CONST_news932 : CONST_news931;
					
					if (typesum >= 3)story += commaSpace;
					else if (typesum == 2)story += AND;
					typesum--;
				}
				if (crime[CRIME_UNLOCKEDDOOR])
				{
					story += liberalguardian || !ccs ? CONST_news934 : CONST_news933;
					
					if (typesum >= 3)story += commaSpace;
					else if (typesum == 2)story += AND;
					typesum--;
				}
				story += singleDot;
			}
			story += ampersandR;
		}
		if (crime[CRIME_CARCHASE])
		{
			story += liberalguardian || !ccs ? CONST_news937 + CONST_news938 : CONST_news935 + CONST_news936;
			
			if (crime[CRIME_CARCRASH])
			{
				if (crime[CRIME_CARCRASH] > 1)
				{
					story += tostring(crime[CRIME_CARCRASH]);
					story += CONST_news939;
				}
				else story += CONST_news940;
				if (!liberalguardian || ccs)
					story += CONST_news941;//XXX: Why not turn them into martyrs?
			}
			if (crime[CRIME_FOOTCHASE])
			{
				story += liberalguardian || !ccs ? CONST_news943 : CONST_news942;

			}
			story += ampersandR;
		}
		if (!ccs)
		{
			if (!LCSrandom(8))
			{
				if (crime[CRIME_TAGGING])
				{
					story += CONST_newsX10;
					story += slogan_str;
					story += CONST_news945;
				}
				else
				{
					switch (LCSrandom(3))
					{
					case 0:
						if (ns.type == NEWSSTORY_SQUAD_KILLED_SITE)
						{
							story += CONST_newsX11;
							story += slogan_str;
							story += CONST_news947;
						}
						else
						{
							story += CONST_newsX12;
							story += slogan_str;
							story += CONST_news1030;
						}
						return story;
					case 1:
						story += CONST_newsX13;
						story += slogan_str;
						story += CONST_news1030;
						return story;
					case 2:
						story += CONST_newsX14;
						story += slogan_str;
						story += CONST_news1030;
						return story;
					}
				}
				story += ampersandR;
			}
		}
		return story;
	
}

string displayMinorStory(const bool liberalguardian, newsstoryst ns) {
	string story;
	extern short lawList[LAWNUM];
	{
		extern string slogan_str;

		switch (ns.type)
		{
		case NEWSSTORY_CCS_NOBACKERS:
			for (string s : caseNEWSSTORY_CCS_NOBACKERS) {
				story += s;
			}
			break;
		case NEWSSTORY_CCS_DEFEATED:
			for (string s : caseNEWSSTORY_CCS_DEFEATED) {
				story += s;
			}
			break;
		case NEWSSTORY_WANTEDARREST:
		case NEWSSTORY_GRAFFITIARREST:
		{
			story += wantedOrGraffitiArrest(ns);
			break;
		}
		case NEWSSTORY_NUDITYARREST:
		case NEWSSTORY_CARTHEFT:
		case NEWSSTORY_DRUGARREST:
		case NEWSSTORY_BURIALARREST:
		{
			story += nudityCarDrugOrBurialArrest(ns);
			break;
		}
		case NEWSSTORY_SQUAD_ESCAPED:
		case NEWSSTORY_SQUAD_FLEDATTACK:
		case NEWSSTORY_SQUAD_DEFENDED:
		case NEWSSTORY_SQUAD_BROKESIEGE:
		case NEWSSTORY_SQUAD_KILLED_SIEGEATTACK:
		case NEWSSTORY_SQUAD_KILLED_SIEGEESCAPE:
			story += membersOfLCS;
			if (!liberalguardian) {
				story += newsStories[ns.type][0];
				story += policeSpokesperson;
			}
			else
			{
				story += newsStories[ns.type][len(newsStories[ns.type]) - 1];
				story += lcsSpokeseperson;
			}
			story += ampersandR;
			break;
		default:
			bool ccs = 0;
			if (ns.type == NEWSSTORY_CCS_KILLED_SITE || ns.type == NEWSSTORY_CCS_SITE)ccs = 1;
			story += squadstory_text_opening(ns, liberalguardian, ccs);
			story += otherCrime(ns, liberalguardian, ccs);
			break;
		}
	}
	return story;
}
/* news - make some filler junk */
string generatefiller(int amount) {
	string story;
	 //TODO: Use text from filler.cpp
		story += ampersandR + cityname() + spaceDashSpace;
		for (int par = 0; amount > 0; amount--)
		{
			par++;
			for (int i = 0; i < LCSrandom(10) + 3; i++)story += CONST_news222;
			if (amount > 1)story += singleSpace;
			if (par >= 50 && !LCSrandom(5) && amount > 20)
			{
				par = 0;
				story += ampersandR + singleSpace;
			}
		}
		story += ampersandR;
	return story;

}

void displaystory(const newsstoryst ns, const bool liberalguardian, int header)
{
	const string CONST_newsX15 = "According to one person familiar with the case, \"";
	extern char newscherrybusted;
	extern bool multipleCityMode;
	extern MusicClass music;
	extern char lcityname[CITY_NAMELEN];
	extern short lawList[LAWNUM];
	music.play(MUSIC_NEWSPAPER);
	preparepage(ns, liberalguardian);
	short storyx_s[25];
	short storyx_e[25];
	for (int it2 = 0; it2 < 25; it2++) storyx_s[it2] = 1;
	for (int it2 = 0; it2 < 25; it2++) storyx_e[it2] = 78;
	displayads(ns, liberalguardian, storyx_s, storyx_e);
	string city;
	if (multipleCityMode && ns.loc != -1)
	{
		Location * ns_site = find_site_in_city(LocationsPool::getInstance().getLocationCity(ns.loc), -1);
		if (cityNames.count(ns_site->type) > 0) {
			city = cityNames[ns_site->type].data();
		}
		else {
			city = lcityname;
		}
	}
	else city = lcityname;
	switch (ns.type)
	{
	case NEWSSTORY_MAJOREVENT:
		displaymajoreventstory(ns, storyx_s, storyx_e);
		break;
	case NEWSSTORY_CCS_NOBACKERS:
	case NEWSSTORY_CCS_DEFEATED:
	case NEWSSTORY_SQUAD_SITE:
	case NEWSSTORY_SQUAD_ESCAPED:
	case NEWSSTORY_SQUAD_FLEDATTACK:
	case NEWSSTORY_SQUAD_DEFENDED:
	case NEWSSTORY_SQUAD_BROKESIEGE:
	case NEWSSTORY_SQUAD_KILLED_SIEGEATTACK:
	case NEWSSTORY_SQUAD_KILLED_SIEGEESCAPE:
	case NEWSSTORY_SQUAD_KILLED_SITE:
	case NEWSSTORY_CCS_SITE:
	case NEWSSTORY_CCS_KILLED_SITE:
	case NEWSSTORY_CARTHEFT:
	case NEWSSTORY_NUDITYARREST:
	case NEWSSTORY_WANTEDARREST:
	case NEWSSTORY_DRUGARREST:
	case NEWSSTORY_GRAFFITIARREST:
	case NEWSSTORY_BURIALARREST:
	{
		string story;
		int y = 2;
		if ((!liberalguardian&&ns.page == 1) || (liberalguardian&&ns.guardianpage == 1))
		{
			y = 21;
			displaystoryheader(ns, liberalguardian, y, header);
		}
		(story = city);
		(story += spaceDashSpace);
		story += displayMinorStory(liberalguardian, ns);
		story += generatefiller(200);
		displaynewsstory(story, storyx_s, storyx_e, y);
		if (!newscherrybusted)newscherrybusted = 1;
		if (ns.type == NEWSSTORY_CCS_SITE ||
			ns.type == NEWSSTORY_CCS_KILLED_SITE)newscherrybusted = 2;

		break;
	}
	case NEWSSTORY_MASSACRE:
	{
		int y = 3;
		if (ns.page == 1)
		{
			y = 21;
			if (ns.crime[0] == SIEGE_CCS)
			{
				displaycenterednewsfont(CONST_news954, 5);
			}
			else if (!liberalguardian)
			{
				displaycenterednewsfont(CONST_news955, 5);
				displaycenterednewsfont(CONST_news957, 13);
			}
			else
			{
				displaycenterednewsfont(tag_CONSERVATIVE, 5);
				displaycenterednewsfont(CONST_news957, 13);
			}
		}
		string story;
		(story = city);
		(story += spaceDashSpace);
		if (ns.crime[1] > 2)
		{
			(story += tostring(ns.crime[1]));
			(story += CONST_news958); //Gruesome pile, large pile.
		}
		else if (ns.crime[1] > 1)(story += CONST_news959);
		else (story += CONST_news960);
		(story += CONST_news961);
		(story += LocationsPool::getInstance().getLocationName(ns.loc));
		(story += CONST_news962);
		if (!liberalguardian)
		{
			(story += CONST_news963);
			(story += CONST_news964);
			(story += ampersandR);
			(story += CONST_news965);
			(story += CONST_newsX15);
		}
		else
		{
			(story += CONST_news967);
			(story += CONST_news968);
			(story += ampersandR);
			(story += CONST_news969);
			if (ns.crime[1] > 1)(story += CONST_news970);
			else (story += CONST_news971);
			(story += CONST_news972);
			(story += CONST_news973);
		}
		switch (ns.crime[0])
		{
		case SIEGE_CIA:
			if (!liberalguardian)
			{
				if (ns.crime[1] > 1)(story += CONST_news974);
				else (story += CONST_news975);
				(story += CONST_news976);
				if (lawList[LAW_FREESPEECH] == -2)(story += CONST_news977);
				else if (lawList[LAW_FREESPEECH] == 2)(story += CONST_news978);
				else (story += CONST_news979);
			}
			else
			{
				(story += CONST_news980);
				(story += CONST_news981);
				(story += CONST_news982);
				(story += CONST_news983);
			}
			break;
		case SIEGE_POLICE:
		case SIEGE_HICKS:
			if (!liberalguardian)
			{
				(story += CONST_news984);
				(story += CONST_news985);
			}
			else
			{
				(story += CONST_news986);
				(story += CONST_news987);
			}
			break;
		case SIEGE_CORPORATE:
			if (!liberalguardian)
			{
				(story += CONST_news988);
			}
			else
			{
				(story += CONST_news989);
				(story += CONST_news990);
				(story += CONST_news991);
				(story += CONST_news992);
			}
			break;
		case SIEGE_CCS:
			if (!liberalguardian)
			{
				(story += CONST_news993);
				(story += CONST_news994);
			}
			else
			{
				(story += CONST_news995);
				(story += CONST_news996);
			}
			break;
		case SIEGE_FIREMEN:
			if (!liberalguardian)
			{
				if (ns.crime[1] > 1)(story += CONST_news997);
				else (story += CONST_news998);
				(story += CONST_news999);
				(story += CONST_news1000);
				(story += CONST_news1001);
				(story += CONST_news1002);
			}
			else
			{
				if (ns.crime[1] > 1)(story += CONST_news1003);
				else (story += CONST_news1004);
				(story += CONST_news1005);
				(story += CONST_news1006);
			}
		}
		(story += CONST_newsB955);
		(story += ampersandR);
		story += generatefiller(200);
		displaynewsstory(story, storyx_s, storyx_e, y);
		break;
	}
	case NEWSSTORY_KIDNAPREPORT:
	{
		int y = 2;
		if (ns.page == 1)
		{
			y = 21;
			if (liberalguardian)
			{
				displaycenterednewsfont(CONST_news1008, 5);
				displaycenterednewsfont(CONST_news1009, 13); break;
			}
			else
			{
				switch (ns.cr->type)
				{
				case CREATURE_CORPORATE_CEO:
					displaycenterednewsfont(tag_CEO, 5); break;
				case CREATURE_RADIOPERSONALITY:
					displaycenterednewsfont(CONST_news1010, 5); break;
				case CREATURE_NEWSANCHOR:
					displaycenterednewsfont(CONST_news1011, 5); break;
				case CREATURE_SCIENTIST_EMINENT:
					displaycenterednewsfont(CONST_news1012, 5); break;
				case CREATURE_JUDGE_CONSERVATIVE:
					displaycenterednewsfont(CONST_news1013, 5); break;
				case CREATURE_COP:
				case CREATURE_GANGUNIT:
				case CREATURE_DEATHSQUAD:
					displaycenterednewsfont(CONST_news1014, 5); break;
				default:
					displaycenterednewsfont(CONST_news1015, 5); break;
				}
				displaycenterednewsfont(CONST_news1016, 13);
			}
		}
		string story;
		story = city;
		story += CONST_news1017;
		story += ns.cr->propername;
		story += CONST_news1018;
		story += CONST_news1019;
		story += ampersandR;
		char dstr[200], dstr2[200];
		story += singleSpace;
		generate_name(dstr, dstr2);
		story += dstr;
		story += singleSpace;
		story += dstr2;
		story += CONST_news1021;
		story += CONST_news1022;
		story += ns.cr->propername;
		story += CONST_news1023;
		story += tostring(ns.cr->joindays - 1);
		story += CONST_news1024;
		story += CONST_news1025;
		story += CONST_news1026;
		story += ns.cr->propername;
		story += CONST_news1027;
		story += CONST_news1028;
		story += CONST_news1029;
		story += CONST_news1030;
		story += ampersandR;
		story += CONST_news1031;
		story += ns.cr->propername;
		story += CONST_news1032;
		story += LocationsPool::getInstance().getLocationName(ns.cr->worklocation);
		story += CONST_news1033;
		story += ampersandR;
		story += generatefiller(200);
		displaynewsstory(story, storyx_s, storyx_e, y);
		break;
	}
	}

	pressSpecificKey('x', ESC, ENTER, SPACEBAR);
}
void display_newspaper()
{
	int writers = CreaturePool::getInstance().liberal_guardian_writing_power();
	for (int n = 0; n < len(newsstory); n++)
	{
		bool liberalguardian = 0;
		int header = -1;
		if (writers&&newsstory[n]->type != NEWSSTORY_MAJOREVENT)
			liberalguardian = 1;
		switch (newsstory[n]->type)
		{
		case NEWSSTORY_SQUAD_SITE:
		case NEWSSTORY_SQUAD_KILLED_SITE:
			switch (LocationsPool::getInstance().getLocationType(newsstory[n]->loc))
			{
			case SITE_LABORATORY_COSMETICS:
				header = VIEW_ANIMALRESEARCH;
				break;
			case SITE_LABORATORY_GENETIC:
				header = VIEW_GENETICS;
				break;
			case SITE_GOVERNMENT_POLICESTATION:
				header = VIEW_POLICEBEHAVIOR;
				break;
			case SITE_GOVERNMENT_COURTHOUSE:
				header = VIEW_JUSTICES;
				break;
			case SITE_GOVERNMENT_PRISON:
				header = VIEW_DEATHPENALTY;
				break;
			case SITE_GOVERNMENT_INTELLIGENCEHQ:
				header = VIEW_INTELLIGENCE;
				break;
			case SITE_INDUSTRY_SWEATSHOP:
				header = VIEW_SWEATSHOPS;
				break;
			case SITE_INDUSTRY_POLLUTER:
				header = VIEW_POLLUTION;
				break;
			case SITE_INDUSTRY_NUCLEAR:
				header = VIEW_NUCLEARPOWER;
				break;
			case SITE_CORPORATE_HEADQUARTERS:
				header = VIEW_CORPORATECULTURE;
				break;
			case SITE_CORPORATE_HOUSE:
				header = VIEW_CEOSALARY;
				break;
			case SITE_MEDIA_AMRADIO:
				header = VIEW_AMRADIO;
				break;
			case SITE_MEDIA_CABLENEWS:
				header = VIEW_CABLENEWS;
				break;
			case SITE_RESIDENTIAL_APARTMENT_UPSCALE:
			case SITE_BUSINESS_CIGARBAR:
			case SITE_BUSINESS_BANK:
				header = VIEW_TAXES;
				break;
			}
			break;
		case NEWSSTORY_SQUAD_ESCAPED:
		case NEWSSTORY_SQUAD_FLEDATTACK:
		case NEWSSTORY_SQUAD_DEFENDED:
		case NEWSSTORY_SQUAD_BROKESIEGE:
		case NEWSSTORY_SQUAD_KILLED_SIEGEATTACK:
		case NEWSSTORY_SQUAD_KILLED_SIEGEESCAPE:
			break;
		case NEWSSTORY_CCS_NOBACKERS:
		case NEWSSTORY_CCS_DEFEATED:
			break;
		}
		if (liberalguardian)
		{
			if (newsstory[n]->type == NEWSSTORY_CCS_SITE ||
				newsstory[n]->type == NEWSSTORY_CCS_KILLED_SITE)
			{
				newsstory[n]->positive = 0;
			}
			displaystory(*newsstory[n], liberalguardian, header);
			if (newsstory[n]->positive)newsstory[n]->positive += 1;
		}
		else displaystory(*newsstory[n], 0, -1);
	}
}
/* news - major newspaper reporting on lcs and other topics */
void majornewspaper(char &clearformess, char canseethings)
{
	clearformess = true;
	generate_random_event_news_stories();
	clean_up_empty_news_stories();
	if (canseethings) run_television_news_stories();
	assign_page_numbers_to_newspaper_stories();
	if (canseethings) display_newspaper();
	//DELETE STORIES
	for (int n = 0; n < len(newsstory); n++)
		handle_public_opinion_impact(*newsstory[n]);
	delete_and_clear(newsstory);
}

// #include "../includes.h"
const string CONST_politics112 = "pro-Human Rights";
const string CONST_politics110 = "    ";
const string CONST_politics109 = "None of the items made it to the President's desk.";
const string CONST_politics107 = "*** VETO ***";
const string CONST_politics106 = "FORCED BY CONGRESS";
const string CONST_politics105 = "Dead in Congress";
const string CONST_politics104 = "President";
const string CONST_politics103 = "Press any key to watch the President.                   ";
const string CONST_politics102 = "VP";
const string CONST_politics100 = "Senate";
const string CONST_politics099 = "House";
const string CONST_politics098 = "Press any key to watch the votes unfold.";
const string CONST_politics095 = "To ";
const string CONST_politics094 = "Joint Resolution ";
const string CONST_politics093 = "Legislative Agenda ";
const string CONST_politics092 = "Congress is acting on legislation!";
const string CONST_politics091 = ", is appointed to the bench.";
const string CONST_politics090 = "the Honorable ";
const string CONST_politics089 = "Comrade ";
const string CONST_politics088 = "After much debate and televised testimony, a new justice,";
const string CONST_politics087 = "Press any key to see what happens.";
const string CONST_politics086 = ", is stepping down.";
const string CONST_politics085 = "Justice ";
const string CONST_politics084 = "Changing the Guard!";
const string CONST_politics083 = " for Status Quo";
const string CONST_politics082 = " for Change";
const string CONST_politics080 = "Press any key to watch the decisions unfold.";
const string CONST_politics077 = "A Decision could ";
const string CONST_politics076 = " vs. ";
const string CONST_politics075 = "United States";
const string CONST_politics074 = "Supreme Court Watch ";
const string CONST_politics073 = "The Supreme court is handing down decisions!";
const string CONST_politics072 = "A Recount was Necessary";
const string CONST_politics071 = "% No";
const string CONST_politics070 = "% Yes";
const string CONST_politics069 = "Press any key to watch the elections unfold.";
const string CONST_politics065 = "Proposition ";
const string CONST_politics064 = "Important Propositions ";
const string CONST_politics063 = "Press any key to continue the elections.   ";
const string CONST_politics062 = " (After Recount)";
const string CONST_politics061 = "Press any key to watch the election unfold.";
const string CONST_politics060 = "Mrs. ";
const string CONST_politics059 = "Mr. ";
const string CONST_politics058 = "Representative ";
const string CONST_politics057 = "Ret. General ";
const string CONST_politics056 = "Senator ";
const string CONST_politics055 = "Governor ";
const string CONST_politics054 = "Vice President ";
const string CONST_politics053 = "President ";
const string CONST_politics052 = "After a long primary campaign, the people have rallied around two leaders...";
const string CONST_politics051 = "After a long primary campaign, the people have rallied around three leaders...";
const string CONST_politics050 = "Presidential General Election ";
const string CONST_politics049 = "The Elections are being held today!";
const string CONST_politics048 = "Press any key to continue the elections.    ";
const string CONST_politics047 = "        ";
const string CONST_politics046 = "+";
const string CONST_politics045 = "   C+: ";
const string CONST_politics043 = "   C: ";
const string CONST_politics041 = "   m: ";
const string CONST_politics039 = "   L: ";
const string CONST_politics037 = "   L+: ";
const string CONST_politics035 = "   S: ";
const string CONST_politics034 = "Net change:";
const string CONST_politics033 = "S ";
const string CONST_politics032 = "L+";
const string CONST_politics031 = "L ";
const string CONST_politics030 = "m ";
const string CONST_politics029 = "C ";
const string CONST_politics028 = "C+";
const string CONST_politics020 = "House Elections ";
const string CONST_politics004 = "                    ";
const string CONST_politics002 = "Senate Elections ";
const string CONST_politics001 = "corporateSuffix.txt";

//// #include "../monthly/EndGameStatus.h"
/* EndGameStatus - attempts to pass a constitutional amendment to help win the game */
void tossjustices(char canseethings);
/* EndGameStatus - attempts to pass a constitutional amendment to help win the game */
void amendment_termlimits(char canseethings);
map<short, string> conservatiseLaw;
map<short, string> liberalizeLaw;
string establishPrisonReform;
string improvePrisonConditions;
vector<string> corporateSuffix;
map<short, string> winnerOfElection;
vector<file_and_text_collection> politics_text_file_collection = {
	customText(&corporateSuffix, mostlyendings + CONST_politics001),
};

/* politics -- appoints a figure to an executive office, based on the President's alignment */
void fillCabinetPost(int position)
{
	extern char execname[EXECNUM][POLITICIAN_NAMELEN];
	extern short exec[EXECNUM];
	// Set alignment
	if (exec[EXEC_PRESIDENT] == ALIGN_ARCHCONSERVATIVE) exec[position] = ALIGN_ARCHCONSERVATIVE;
	else if (exec[EXEC_PRESIDENT] == ALIGN_ELITELIBERAL) exec[position] = ALIGN_ELITELIBERAL;
	else if (exec[EXEC_PRESIDENT] == ALIGN_STALINIST) exec[position] = ALIGN_STALINIST;
	else exec[position] = exec[EXEC_PRESIDENT] + LCSrandom(3) - 1;
	// Set name
	if (exec[position] == ALIGN_ARCHCONSERVATIVE) generate_name(execname[position], GENDER_WHITEMALEPATRIARCH);
	else if (exec[position] == ALIGN_CONSERVATIVE) generate_name(execname[position], GENDER_MALE);
	else generate_name(execname[position]);
}
/* politics -- promotes the Vice President to President, and replaces VP */
void promoteVP()
{
	extern short presparty;
	extern char execname[EXECNUM][POLITICIAN_NAMELEN];
	extern short exec[EXECNUM];
	exec[EXEC_PRESIDENT] = exec[EXEC_VP]; // VP takes over as President
	strcpy(execname[EXEC_PRESIDENT], execname[EXEC_VP]);
	switch (exec[EXEC_PRESIDENT])
	{ // make sure presparty is set correctly (if old President was moderate they could've been in Liberal OR Conservative Party,
	case ALIGN_ARCHCONSERVATIVE: // and new President might have a political alignment incompatible with that party)
	case ALIGN_CONSERVATIVE:
		presparty = CONSERVATIVE_PARTY; break; // Conservatives and Arch-Conservatives align with the Conservative Party
	case ALIGN_MODERATE:
		break; // same party as previous President (either Liberal Party or Conservative Party)
	case ALIGN_LIBERAL:
	case ALIGN_ELITELIBERAL:
		presparty = LIBERAL_PARTY; break; // Liberals and Elite Liberals align with the Liberal Party
	case ALIGN_STALINIST:
		presparty = STALINIST_PARTY; break; // Stalinists align with the Stalinist Party
	}
	fillCabinetPost(EXEC_VP); // the vacant VP slot needs to be filled
	if (abs(exec[EXEC_PRESIDENT]) > 1)
	{  // new President has extreme views... make sure all cabinet members agree with new President
		if (exec[EXEC_PRESIDENT] != exec[EXEC_STATE]) fillCabinetPost(EXEC_STATE);
		if (exec[EXEC_PRESIDENT] != exec[EXEC_ATTORNEY]) fillCabinetPost(EXEC_ATTORNEY);
	}
	else
	{  // new President has fairly moderate views, but anyone who differs too much from them must be replaced
		if (abs(exec[EXEC_PRESIDENT] - exec[EXEC_STATE]) > 1) fillCabinetPost(EXEC_STATE);
		if (abs(exec[EXEC_PRESIDENT] - exec[EXEC_ATTORNEY]) > 1) fillCabinetPost(EXEC_ATTORNEY);
	}
}
void elections_senate(int senmod, char canseethings)
{
	extern MusicClass music;
	extern int year;
	extern bool termlimits;
	extern bool stalinmode;
	extern char disbanding;
	extern short lawList[LAWNUM];
	extern short senate[SENATENUM];
	int mood = publicmood(LAW_MOOD);
	int stalinmood = publicmood(LAW_STALIN);
	if (canseethings)
	{
		music.play(MUSIC_ELECTIONS);
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, CONST_politics002);
		addstrAlt(year);
	}
	int x = 0, y = 2;
	for (int s = 0; s < SENATENUM; s++)
	{
		if (senmod != -1 && s % 3 != senmod)continue;
		if (canseethings)
		{
			set_alignment_color(senate[s], true);
			mvaddstrAlt(y, x, getalign(senate[s], false));
		}
		x += 20;
		if (x > 70) x = 0, y++;
	}
	if (canseethings)
	{
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(23, 0, CONST_politics069);
		pressAnyKey();
	}
	int vote, change[6] = { 0,0,0,0,0,0 };
	x = 0, y = 2;
	for (int s = 0; s < SENATENUM; s++)
	{
		if (senmod != -1 && s % 3 != senmod) continue;
		vote = -2;
		for (int i = 0; i < 4; i++) if (mood > LCSrandom(100)) vote++;
		if (stalinmode&&stalinmood < LCSrandom(100) && stalinmood < LCSrandom(100) && stalinmood < LCSrandom(100) && stalinmood < LCSrandom(100)) vote = 3;
		change[senate[s] + 2]--;
		if (termlimits) senate[s] = vote;
		else
		{
			int vote2;
			bool first = true;
			do {
				vote2 = -2;
				for (int i = 0; i < 4; i++) if (mood > LCSrandom(100)) vote2++;
				if (stalinmode&&stalinmood < LCSrandom(100) && stalinmood < LCSrandom(100) && stalinmood < LCSrandom(100) && stalinmood < LCSrandom(100)) vote2 = 3;
				if (first) switch (lawList[LAW_ELECTIONS])
				{
				case -2: if (LCSrandom(3)) vote2 = senate[s]; break; // 2/3 chance of incumbent winning no matter what (huge   advantage)
				case -1: if (LCSrandom(2)) vote2 = senate[s]; break; // 1/2 chance of incumbent winning no matter what (big    advantage)
				case  0: if (!LCSrandom(3)) vote2 = senate[s]; break; // 1/3 chance of incumbent winning no matter what (medium advantage)
				case  1: if (!LCSrandom(5)) vote2 = senate[s]; break; // 1/5 chance of incumbent winning no matter what (small  advantage)
				case  2: if (!LCSrandom(8)) vote2 = senate[s]; break; // 1/8 chance of incumbent winning no matter what (tiny   advantage)
				}
				first = false;
			} while (vote2 != senate[s] && vote2 != vote);
			senate[s] = vote2;
		}
		change[senate[s] + 2]++;
		if (canseethings)
		{
			set_alignment_color(senate[s], true);
			mvaddstrAlt(y, x, CONST_politics004);
			mvaddstrAlt(y, x, getalign(senate[s], false));
		}
		x += 20;
		if (x > 70) x = 0, y++;
		if (canseethings)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(20, 0, CONST_politics034);
			if (stalinmode)
			{
				addstrAlt(CONST_politics035);
				if (change[5] > 0) addstrAlt(CONST_politics046);
				addstrAlt(change[5]);
			}
			addstrAlt(CONST_politics037);
			if (change[4] > 0) addstrAlt(CONST_politics046);
			addstrAlt(change[4]);
			addstrAlt(CONST_politics039);
			if (change[3] > 0) addstrAlt(CONST_politics046);
			addstrAlt(change[3]);
			addstrAlt(CONST_politics041);
			if (change[2] > 0) addstrAlt(CONST_politics046);
			addstrAlt(change[2]);
			addstrAlt(CONST_politics043);
			if (change[1] > 0) addstrAlt(CONST_politics046);
			addstrAlt(change[1]);
			addstrAlt(CONST_politics045);
			if (change[0] > 0) addstrAlt(CONST_politics046);
			addstrAlt(change[0]);
			addstrAlt(CONST_politics047);
			if (!disbanding) pause_ms(30);
		}
	}
	if (canseethings)
	{
		moveAlt(21, 0);
		signed char winner;
		if (change[5] > 0 && change[5] > change[0] + change[1] && change[5] > change[3] + change[4]) // Stalinist increased and Stalinist gain is more than C or L side gain/loss
			winner = ALIGN_STALINIST;
		else if (change[0] + change[1] > change[3] + change[4]) // C side gain/loss is more than L side gain/loss
		{
			if (change[1] < 0 && mood < 25) winner = ALIGN_ARCHCONSERVATIVE;
			else winner = ALIGN_CONSERVATIVE;
		}
		else if (change[3] + change[4] > change[0] + change[1]) // L side gain/loss is more than C side gain/loss
		{
			if (change[3] < 0 && mood>75) winner = ALIGN_ELITELIBERAL;
			else winner = ALIGN_LIBERAL;
		}
		else if (change[0] > 0 && change[4] <= 0 && change[5] <= 0) // C+ increased and L+ and Stalinist both same or decreased
		{
			if (mood < 25) winner = ALIGN_ARCHCONSERVATIVE;
			else winner = ALIGN_CONSERVATIVE;
		}
		else if (change[4] > 0 && change[0] <= 0 && change[5] <= 0) // L+ increased and C+ and Stalinist both same or decreased
		{
			if (mood > 75) winner = ALIGN_ELITELIBERAL;
			else winner = ALIGN_LIBERAL;
		}
		else if (change[5] > 0 && change[0] <= 0 && change[4] <= 0) // Stalinist increased and C+ and L+ both same or decreased
			winner = ALIGN_STALINIST;
		else winner = ALIGN_MODERATE; // nobody won
		addstrAlt(winnerOfElection[winner]);
		mvaddstrAlt(22, 0, CONST_politics048);
		pressAnyKey();
	}
}
void elections_house(char canseethings)
{
	extern MusicClass music;
	extern int year;
	extern bool termlimits;
	extern bool stalinmode;
	extern char disbanding;
	extern short lawList[LAWNUM];
	extern short house[HOUSENUM];
	int mood = publicmood(LAW_MOOD);
	int stalinmood = publicmood(LAW_STALIN);
	if (canseethings)
	{
		music.play(MUSIC_ELECTIONS);
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, CONST_politics020);
		addstrAlt(year);
	}
	int x = 0, y = 2;
	for (int h = 0; h < HOUSENUM; h++)
	{
		if (canseethings)
		{
			moveAlt(y, x);
			if (house[h] == -2)
			{
				set_color_easy(RED_ON_BLACK_BRIGHT);
				addstrAlt(CONST_politics028);
			}
			else if (house[h] == -1)
			{
				set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
				addstrAlt(CONST_politics029);
			}
			else if (house[h] == 0)
			{
				set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				addstrAlt(CONST_politics030);
			}
			else if (house[h] == 1)
			{
				set_color_easy(CYAN_ON_BLACK_BRIGHT);
				addstrAlt(CONST_politics031);
			}
			else if (house[h] == 2)
			{
				set_color_easy(GREEN_ON_BLACK_BRIGHT);
				addstrAlt(CONST_politics032);
			}
			else
			{
				set_color_easy(RED_ON_BLACK_BRIGHT);
				addstrAlt(CONST_politics033);
			}
		}
		x += 3;
		if (x > 78) x = 0, y++;
	}
	if (canseethings)
	{
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(23, 0, CONST_politics069);
		pressAnyKey();
	}
	int change[6] = { 0,0,0,0,0,0 };
	x = 0, y = 2;
	for (int h = 0; h < HOUSENUM; h++)
	{
		int vote = -2;
		for (int i = 0; i < 4; i++) if (mood > LCSrandom(100)) vote++;
		if (stalinmode&&stalinmood < LCSrandom(100) && stalinmood < LCSrandom(100) && stalinmood < LCSrandom(100) && stalinmood < LCSrandom(100)) vote = 3;
		change[house[h] + 2]--;
		if (termlimits) house[h] = vote;
		else
		{
			int vote2;
			bool first = true;
			do {
				vote2 = -2;
				for (int i = 0; i < 4; i++) if (mood > LCSrandom(100)) vote2++;
				if (stalinmode&&stalinmood < LCSrandom(100) && stalinmood < LCSrandom(100) && stalinmood < LCSrandom(100) && stalinmood < LCSrandom(100)) vote2 = 3;
				if (first) switch (lawList[LAW_ELECTIONS])
				{
				case -2: if (LCSrandom(3)) vote2 = house[h]; break; // 2/3 chance of incumbent winning no matter what (huge   advantage)
				case -1: if (LCSrandom(2)) vote2 = house[h]; break; // 1/2 chance of incumbent winning no matter what (big    advantage)
				case  0: if (!LCSrandom(3)) vote2 = house[h]; break; // 1/3 chance of incumbent winning no matter what (medium advantage)
				case  1: if (!LCSrandom(5)) vote2 = house[h]; break; // 1/5 chance of incumbent winning no matter what (small  advantage)
				case  2: if (!LCSrandom(8)) vote2 = house[h]; break; // 1/8 chance of incumbent winning no matter what (tiny   advantage)
				}
				first = false;
			} while (vote2 != house[h] && vote2 != vote);
			house[h] = vote2;
		}
		change[house[h] + 2]++;
		if (canseethings)
		{
			moveAlt(y, x);
			if (house[h] == -2)
			{
				set_color_easy(RED_ON_BLACK_BRIGHT);
				addstrAlt(CONST_politics028);
			}
			else if (house[h] == -1)
			{
				set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
				addstrAlt(CONST_politics029);
			}
			else if (house[h] == 0)
			{
				set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				addstrAlt(CONST_politics030);
			}
			else if (house[h] == 1)
			{
				set_color_easy(CYAN_ON_BLACK_BRIGHT);
				addstrAlt(CONST_politics031);
			}
			else if (house[h] == 2)
			{
				set_color_easy(GREEN_ON_BLACK_BRIGHT);
				addstrAlt(CONST_politics032);
			}
			else
			{
				set_color_easy(RED_ON_BLACK_BRIGHT);
				addstrAlt(CONST_politics033);
			}
		}
		x += 3;
		if (x > 78) x = 0, y++;
		if (canseethings)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(20, 0, CONST_politics034);
			if (stalinmode)
			{
				addstrAlt(CONST_politics035);
				if (change[5] > 0) addstrAlt(CONST_politics046);
				addstrAlt(change[5]);
			}
			addstrAlt(CONST_politics037);
			if (change[4] > 0) addstrAlt(CONST_politics046);
			addstrAlt(change[4]);
			addstrAlt(CONST_politics039);
			if (change[3] > 0) addstrAlt(CONST_politics046);
			addstrAlt(change[3]);
			addstrAlt(CONST_politics041);
			if (change[2] > 0) addstrAlt(CONST_politics046);
			addstrAlt(change[2]);
			addstrAlt(CONST_politics043);
			if (change[1] > 0) addstrAlt(CONST_politics046);
			addstrAlt(change[1]);
			addstrAlt(CONST_politics045);
			if (change[0] > 0) addstrAlt(CONST_politics046);
			addstrAlt(change[0]);
			addstrAlt(CONST_politics047);
			if (!disbanding) pause_ms(5);
		}
	}
	if (canseethings)
	{
		moveAlt(21, 0);
		signed char winner;
		if (change[5] > 0 && change[5] > change[0] + change[1] && change[5] > change[3] + change[4]) // Stalinist increased and Stalinist gain is more than C or L side gain/loss
			winner = ALIGN_STALINIST;
		else if (change[0] + change[1] > change[3] + change[4]) // C side gain/loss is more than L side gain/loss
		{
			if (change[1] < 0 && mood < 25) winner = ALIGN_ARCHCONSERVATIVE;
			else winner = ALIGN_CONSERVATIVE;
		}
		else if (change[3] + change[4] > change[0] + change[1]) // L side gain/loss is more than C side gain/loss
		{
			if (change[3] < 0 && mood>75) winner = ALIGN_ELITELIBERAL;
			else winner = ALIGN_LIBERAL;
		}
		else if (change[0] > 0 && change[4] <= 0 && change[5] <= 0) // C+ increased and L+ and Stalinist both same or decreased
		{
			if (mood < 25) winner = ALIGN_ARCHCONSERVATIVE;
			else winner = ALIGN_CONSERVATIVE;
		}
		else if (change[4] > 0 && change[0] <= 0 && change[5] <= 0) // L+ increased and C+ and Stalinist both same or decreased
		{
			if (mood > 75) winner = ALIGN_ELITELIBERAL;
			else winner = ALIGN_LIBERAL;
		}
		else if (change[5] > 0 && change[0] <= 0 && change[4] <= 0) // Stalinist increased and C+ and L+ both same or decreased
			winner = ALIGN_STALINIST;
		else winner = ALIGN_MODERATE; // nobody won
		addstrAlt(winnerOfElection[winner]);
		if (!disbanding)
		{
			mvaddstrAlt(22, 0, CONST_politics048);
			pressAnyKey();
		}
		else pause_ms(800);
	}
}
bool voteOnBill(const char canseethings, const int mood, const int propdir, const int p) {
	bool yeswin = false;
	bool recount = false;
	for (int l = 0, yesvotes = 0; l < 1000; l++)
	{
		if (LCSrandom(100) < mood ? propdir == 1 : propdir == -1) yesvotes++;
		if (l == 999)
		{
			if (yesvotes > 500) yeswin = true;
			else if (yesvotes == 500) yeswin = (LCSrandom(100) < mood ? propdir == 1 : propdir == -1), recount = true;
		}
		if (canseethings && (l % 10 == 9))
		{
			if ((l != 999 && yesvotes > l / 2) || (l == 999 && yeswin)) set_color_easy(WHITE_ON_BLACK_BRIGHT);
			else if (yesvotes < l / 2 || l == 999) set_color_easy(BLACK_ON_BLACK_BRIGHT);
			else set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(p * 3 + 2, 70, yesvotes / 10);
			addcharAlt('.');
			addstrAlt(yesvotes % 10);
			addstrAlt(CONST_politics070);
			if ((l != 999 && yesvotes < l / 2) || (l == 999 && !yeswin)) set_color_easy(WHITE_ON_BLACK_BRIGHT);
			else if (yesvotes > l / 2 || l == 999) set_color_easy(BLACK_ON_BLACK_BRIGHT);
			else set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(p * 3 + 3, 70, (l + 1 - yesvotes) / 10);
			addcharAlt('.');
			addstrAlt((l + 1 - yesvotes) % 10);
			addstrAlt(CONST_politics071);
			pause_ms(10);
		}
	}
	if (canseethings&&recount)
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(p * 3 + 3, 0, CONST_politics072);
	}
	return yeswin;
}
/* politics - causes the people to vote (presidential, congressional, propositions) */
void elections(char clearformess, char canseethings)
{
	extern MusicClass music;
	extern int year;
	extern short presparty;
	extern bool stalinmode;
	extern char disbanding;
	extern short execterm;
	extern char execname[EXECNUM][POLITICIAN_NAMELEN];
	extern short exec[EXECNUM];
	extern short lawList[LAWNUM];
	extern short public_interest[VIEWNUM];
	if (canseethings)
	{
		music.play(MUSIC_ELECTIONS);
		if (clearformess) eraseAlt();
		else makedelimiter();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, CONST_politics049);
		pressAnyKey();
	}
	//PRESIDENTIAL
	if (year % 4 == 0)
	{
		if (canseethings)
		{
			eraseAlt();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(0, 0, CONST_politics050);
			addstrAlt(year);
			set_color_easy(WHITE_ON_BLACK);
			moveAlt(2, 0);
			if (stalinmode) addstrAlt(CONST_politics051);
			else addstrAlt(CONST_politics052);
		}
		char candidate[3][POLITICIAN_NAMELEN + 1];
		int votes[3] = { 0,0,0 };
		//Primaries
		int approvepres = 0, approveveep = 0;              // presidential & vice-presidential approval within own party
		int libvotes[3] = { 0,0,0 }, consvotes[3] = { 0,0,0 }; // liberal & conservative parties' candidates votes received
															   // run primaries for 100 voters
		for (int i = 0; i < 100; i++)
		{
			int voters[2] = { getsimplevoter(1),getsimplevoter(1) }; // liberal & conservative party voter both decide
			if (presparty != STALINIST_PARTY) // Stalinist Party doesn't do primaries
			{
				// Incumbent can win primary automatically if their approval in their party is over 50%,
				// so we need to know what their inter-party approval rating is.
				// check if this voter supports the president (1/2 chance if closely aligned)
				if (voters[presparty] == exec[EXEC_PRESIDENT] + presparty * 2 || (abs(exec[EXEC_PRESIDENT] + presparty * 2 - voters[presparty]) == 1 && !LCSrandom(2))) approvepres++;
				// check if this voter supports the vice-president (1/3 chance if closely aligned)
				if (voters[presparty] == exec[EXEC_VP] + presparty * 2 || (abs(exec[EXEC_VP] + presparty * 2 - voters[presparty]) == 1 && !LCSrandom(3))) approveveep++;
			}
			consvotes[voters[CONSERVATIVE_PARTY]]++, libvotes[voters[LIBERAL_PARTY]]++; // count ballots
		}
		// determine conservative winner
		if (consvotes[0] > consvotes[1] && consvotes[0] > consvotes[2]) candidate[CONSERVATIVE_PARTY][0] = ALIGN_ARCHCONSERVATIVE;
		else if (consvotes[1] > consvotes[2]) candidate[CONSERVATIVE_PARTY][0] = ALIGN_CONSERVATIVE;
		else candidate[CONSERVATIVE_PARTY][0] = ALIGN_MODERATE;
		// determine liberal winner
		if (libvotes[0] > libvotes[1] && libvotes[0] > libvotes[2]) candidate[LIBERAL_PARTY][0] = ALIGN_MODERATE;
		else if (libvotes[1] > libvotes[2]) candidate[LIBERAL_PARTY][0] = ALIGN_LIBERAL;
		else candidate[LIBERAL_PARTY][0] = ALIGN_ELITELIBERAL;
		// Stalinist winner is always Stalinist
		candidate[STALINIST_PARTY][0] = ALIGN_STALINIST;
		// approval within own party of Stalinist pres and VP is 100%, since all Stalinist party members have the same political views
		if (presparty == STALINIST_PARTY) approvepres = 100, approveveep = 100;
		// name the candidates
		if (candidate[CONSERVATIVE_PARTY][0] == -2) generate_name(candidate[CONSERVATIVE_PARTY] + 1, GENDER_WHITEMALEPATRIARCH);
		else if (candidate[CONSERVATIVE_PARTY][0] == -1) generate_name(candidate[CONSERVATIVE_PARTY] + 1, GENDER_MALE);
		else generate_name(candidate[CONSERVATIVE_PARTY] + 1);
		generate_name(candidate[LIBERAL_PARTY] + 1);
		generate_name(candidate[STALINIST_PARTY] + 1);
		// Special Incumbency Rules: If the incumbent president or vice president
		// has approval of over 50% in their party, they win their primary
		// automatically. Even if they don't have over 50%, if their alignment wins
		// using the normal primary process, they are the chosen candidate for
		// that alignment (this last bit only applies to President; unpopular VP
		// candidates just don't run, and if their alignment wins it will be
		// someone else).
		if (execterm == 1) // President running for re-election
		{
			if (approvepres >= 50) candidate[presparty][0] = exec[EXEC_PRESIDENT];
			if (candidate[presparty][0] == exec[EXEC_PRESIDENT]) strcpy(candidate[presparty] + 1, execname[EXEC_PRESIDENT]);
			else execterm = 2; // Boom! Incumbent president was defeated in their
		}                   // own party. New candidate works with a clean slate.
		else if (approveveep >= 50 &&                                              // Vice-President running for President
			(presparty != LIBERAL_PARTY || exec[EXEC_VP] != ALIGN_CONSERVATIVE) && // We don't want conservative liberals
			(presparty != CONSERVATIVE_PARTY || exec[EXEC_VP] != ALIGN_LIBERAL))   // or liberal conservatives.
		{
			if (approvepres >= 50)
			{
				candidate[presparty][0] = exec[EXEC_VP];
				strcpy(candidate[presparty] + 1, execname[EXEC_VP]);
			}
		}
		//Print candidates
		if (canseethings)
		{
			for (int c = 0; c < 2 + stalinmode; c++)
			{
				// Pick color by political orientation
				set_alignment_color(candidate[c][0], true);
				moveAlt(8 - ((c + 1) % 3) * 2, 0);
				// Choose title -- president or vice president special titles, otherwise
				// pick based on historically likely titles (eg, governor most likely...)
				if (c == presparty && execterm == 1) addstrAlt(CONST_politics053);
				else if (c == presparty && !strcmp(candidate[c] + 1, execname[EXEC_VP])) addstrAlt(CONST_politics054);
				else if (LCSrandom(2)) addstrAlt(CONST_politics055);
				else if (LCSrandom(2)) addstrAlt(CONST_politics056);
				else if (LCSrandom(2)) addstrAlt(CONST_politics057);
				else if (LCSrandom(2)) addstrAlt(CONST_politics058);
				else if (LCSrandom(2)) addstrAlt(CONST_politics059);
				else addstrAlt(CONST_politics060);
				addstrAlt(candidate[c] + 1);
				addstrAlt(commaSpace + getalign(candidate[c][0], false));
			}
			if (!disbanding)
			{
				set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(8 + stalinmode * 2, 0, CONST_politics061);
				pressAnyKey();
			}
			else pause_ms(200);
		}
		int winner = -1;
		bool recount = false;
		for (int l = 0; l < 1000; l++) // 1000 Voters!
		{
			if (l % 2 == 0 && LCSrandom(5))
			{  // Partyline Liberals (~40%) - except when stalin mode is enabled they can go Stalinist sometimes
				if (!stalinmode || getswingvoter(true) != -2 || getswingvoter(false) == 2) // if we aren't in stalin mode or they don't agree with Stalinism or they are an Elite Liberal
					votes[LIBERAL_PARTY]++;                                        // go with Liberal Party affiliation (Good Loyal Liberal!)
				else votes[STALINIST_PARTY]++;                                    // otherwise, this Liberal's gone Stalinist and betrayed Liberalism (TRAITOR!)
			}
			else if (l % 2 == 1 && LCSrandom(5))
			{  // Partyline Conservatives (~40%) - except when stalin mode is enabled they can go Stalinist sometimes
				if (!stalinmode || getswingvoter(true) != -2 || getswingvoter(false) == -2) // if we aren't in stalin mode or they don't agree with Stalinism or they are an Arch-Conservative
					votes[CONSERVATIVE_PARTY]++;                                    // go with Conservative Party affiliation (Good Loyal Conservative!)
				else votes[STALINIST_PARTY]++;                                     // otherwise, this Conservative's gone Stalinist and betrayed Conservatism (TRAITOR!)
			}
			else // Swing Issue Voters (~20%)
			{
				// Get the leanings of an issue voter
				int vote = getswingvoter(false);
				// If they agree with the Stalinist candidate and Stalinist mode is enabled,
				// cast a vote for the Stalinist candidate
				if (stalinmode&&getswingvoter(true) == -2)
					votes[STALINIST_PARTY]++;
				// If they are to the left or equal to the liberal candidate,
				// and they disagree with the other candidate(s), cast a
				// vote for the liberal candidate.
				else if (vote >= candidate[LIBERAL_PARTY][0] && vote != candidate[CONSERVATIVE_PARTY][0])
					votes[LIBERAL_PARTY]++;
				// If they are to the right or equal to the conservative candidate,
				// and they disagree with the other candidate(s), cast a vote
				// for the conservative candidate.
				else if (vote <= candidate[CONSERVATIVE_PARTY][0] && vote != candidate[LIBERAL_PARTY][0])
					votes[CONSERVATIVE_PARTY]++;
				// If they disagree with all the candidates, vote randomly.
				else votes[LCSrandom(2 + stalinmode)]++;
			}
			if (l % 5 == 4)
			{
				int maxvote = 0;
				for (int c = 0; c < 2 + stalinmode; c++) if (votes[c] > maxvote) maxvote = votes[c];
				vector<int> eligible;
				for (int c = 0; c < 2 + stalinmode; c++) if (votes[c] == maxvote) eligible.push_back(c);
				recount = len(eligible) > 1;
				winner = pickrandom(eligible);
				if (canseethings)
				{
					for (int c = 0; c < 2 + stalinmode; c++)
					{
						if (c == winner) set_color_easy(WHITE_ON_BLACK_BRIGHT);
						else set_color_easy(BLACK_ON_BLACK_BRIGHT);
						moveAlt(8 - ((c + 1) % 3) * 2, 45);
						addstrAlt(votes[c] / 10);
						addcharAlt('.');
						addstrAlt(votes[c] % 10);
						addcharAlt('%');
						if (c == winner && recount&&l == 999) addstrAlt(CONST_politics062);
					}
					if (!disbanding) pause_ms(40);
					else pause_ms(20);
				}
			}
		}
		if (canseethings)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(8 + stalinmode * 2, 0, CONST_politics063);
			pressAnyKey();
		}
		//else if(disbanding) pause_ms(800);
		//CONSTRUCT EXECUTIVE BRANCH
		if (winner == presparty && execterm == 1) execterm = 2;
		else
		{
			presparty = winner, execterm = 1, exec[EXEC_PRESIDENT] = candidate[winner][0];
			strcpy(execname[EXEC_PRESIDENT], candidate[winner] + 1);
			for (int e = EXEC_PRESIDENT + 1; e < EXECNUM; e++) fillCabinetPost(e);
		}
	}
	if (year % 2 == 0)
	{
		elections_senate((year % 6) / 2, canseethings); //SENATE
		elections_house(canseethings); //HOUSE
	}
	//PROPOSITIONS
	if (canseethings)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, CONST_politics064);
		addstrAlt(year);
	}
	vector<int> prop, propdir, canlaw;
	int pnum = LCSrandom(4) + 4; // this expression for pnum has a maximum value of 7, important later on
	char lawtaken[LAWNUM];
	memset(lawtaken, 0, LAWNUM * sizeof(char));
	int lawpriority[LAWNUM];
	memset(lawpriority, 0, LAWNUM * sizeof(int));
	char lawdir[LAWNUM];
	memset(lawdir, 0, LAWNUM * sizeof(char));
	//DETERMINE PROPS
	for (int l = 0; l < LAWNUM; l++)
	{
		int pmood = publicmood(l);
		int pvote = -2;
		for (int i = 0; i < 4; i++) if (LCSrandom(100) < pmood) pvote++;
		if (lawList[l] < pvote) lawdir[l] = 1;
		if (lawList[l] >= pvote) lawdir[l] = -1;
		if (lawList[l] == -2) lawdir[l] = 1;
		if (lawList[l] == 2) lawdir[l] = -1;
		pvote = (lawList[l] + 2) * 25; //CALC PRIORITY
		lawpriority[l] = abs(pvote - pmood) + LCSrandom(10) + public_interest[l];
	}
	prop.resize(pnum);
	propdir.resize(pnum);
	int propnums[7] = { 0,0,0,0,0,0,0 }; // 7 is maximum value for pnum
	if (canseethings)
	{
		for (int p = 0; p < pnum; p++)
		{
			int propnum = 0;
			do
			{  // this loop prevents duplicate proposition numbers from occurring
				switch (p)
				{ // 7 entries, as 7 is maximum value for pnum
				case 0: propnum = 2 * (17 - LCSrandom(2) * 6)*(19 - LCSrandom(2) * 6); break;
				case 1: propnum = 7 * (17 - LCSrandom(2) * 6)*(19 - LCSrandom(2) * 6); break;
				case 2: propnum = 3 * (17 - LCSrandom(2) * 6)*(19 - LCSrandom(2) * 6); break;
				case 3: propnum = 5 * (17 - LCSrandom(2) * 6)*(2 - LCSrandom(2) * 1); break;
				case 4: propnum = 11 * (17 - LCSrandom(2) * 6)*(2 - LCSrandom(2) * 1); break;
				case 5: propnum = 13 * (17 - LCSrandom(2) * 6)*(2 - LCSrandom(2) * 1); break;
				case 6: propnum = 17 * (17 - LCSrandom(2) * 6)*(2 - LCSrandom(2) * 1); break;
				}
			} while (find(propnums, propnums + p, propnum) != propnums + p); // redo loop if we already used this proposition number, end loop if it's unused
			propnums[p] = propnum; // put the proposition number we chose into the array, so we don't choose it again for a later proposition
		}
		sort(propnums, propnums + pnum);
	}
	for (int p = 0; p < pnum; p++)
	{
		int maxprior = 0;
		for (int l = 0; l < LAWNUM; l++) if (lawpriority[l] > maxprior && !lawtaken[l]) maxprior = lawpriority[l];
		canlaw.clear();
		for (int l = 0; l < LAWNUM; l++) if (lawpriority[l] == maxprior && !lawtaken[l]) canlaw.push_back(l);
		prop[p] = pickrandom(canlaw);
		lawtaken[prop[p]] = 1;
		propdir[p] = lawdir[prop[p]];
		if (canseethings)
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(p * 3 + 2, 0, CONST_politics065 + tostring(propnums[p]) + ':');
			mvaddstrAlt(p * 3 + 2, 18, CONST_politics095);
			set_alignment_color(propdir[p]);
			if (propdir[p] == 1) {
				if (prop[p] == LAW_PRISONS) {
					if (lawList[LAW_PRISONS] == 1) addstrAlt(establishPrisonReform);
					else addstrAlt(improvePrisonConditions);
				}
				else {
					addstrAlt(liberalizeLaw[prop[p]]);
				}
			}
			else {
				addstrAlt(conservatiseLaw[prop[p]]);
			}
			set_color_easy(WHITE_ON_BLACK);
		}
	}
	if (canseethings)
	{
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(23, 0, CONST_politics069);
		pressAnyKey();
	}
	for (int p = 0; p < pnum; p++)
	{
		bool yeswin = voteOnBill(canseethings, publicmood(prop[p]),   propdir[p],   p);
		if (yeswin) lawList[prop[p]] += propdir[p];
	}
	if (canseethings)
	{
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(23, 0, pressKeyToReflect);
		pressAnyKey();
	}
}
/* politics - causes the supreme court to hand down decisions */
void supremecourt(char clearformess, char canseethings)
{
	extern MusicClass music;
	extern int year;
	extern short exec[EXECNUM];
	extern short lawList[LAWNUM];
	extern short senate[SENATENUM];
	extern short court[COURTNUM];
	extern char courtname[COURTNUM][POLITICIAN_NAMELEN];
	if (canseethings)
	{
		music.play(MUSIC_ELECTIONS);
		if (clearformess) eraseAlt();
		else makedelimiter();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, CONST_politics073);
		pressAnyKey();
	}
	//CHANGE THINGS AND REPORT
	if (canseethings)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, CONST_politics074);
		addstrAlt(year);
		set_color_easy(WHITE_ON_BLACK);
	}
	vector<int> scase, scasedir;
	int cnum = LCSrandom(5) + 2, bias = 0;
	char lawtaken[LAWNUM];
	memset(lawtaken, 0, LAWNUM * sizeof(char));
	scase.resize(cnum);
	scasedir.resize(cnum);
	for (int c = 0; c < cnum; c++)
	{
		do
		{
			scase[c] = LCSrandom(LAWNUM);
		} while (lawtaken[scase[c]]);
		lawtaken[scase[c]] = 1;
		//Constitutional bias -- free speech, flag burning issues, supreme court
		//is extra liberal, gun control, supreme court is extra conservative
		if (scase[c] == LAW_FREESPEECH || scase[c] == LAW_FLAGBURNING)bias = 1;
		else if (scase[c] == LAW_GUNCONTROL)bias = -1;
		else bias = 0;
		if (lawList[scase[c]] == 2)scasedir[c] = -1;
		else if (lawList[scase[c]] == -2)scasedir[c] = 1;
		else
		{
			if (bias)scasedir[c] = bias;
			else if (!LCSrandom(2))scasedir[c] = 1;
			else scasedir[c] = -1;
		}
		if (canseethings)
		{

			string name1, name2;
			if (!LCSrandom(5)) (name1 = CONST_politics075);
			else name1 = lastname();
			if ((scase[c] == LAW_LABOR || scase[c] == LAW_CORPORATE ||
				scase[c] == LAW_ANIMALRESEARCH || scase[c] == LAW_POLLUTION) &&
				!LCSrandom(5))
			{
				name2 = lastname(true) + pickrandom(corporateSuffix);
			}
			else {
				name2 = lastname();
			}
			mvaddstrAlt(c * 3 + 2, 0, name1 + CONST_politics076 + name2);
			mvaddstrAlt(c * 3 + 3, 0, CONST_politics077);
			set_alignment_color(scasedir[c]);
			if (scasedir[c] == 1) {
				if (scase[c] == LAW_PRISONS) {
					if (lawList[LAW_PRISONS] == 1) addstrAlt(establishPrisonReform);
					else addstrAlt(improvePrisonConditions);
				}
				else {
					addstrAlt(liberalizeLaw[scase[c]]);
				}
			}
			else {
				addstrAlt(conservatiseLaw[scase[c]]);
			}
			set_color_easy(WHITE_ON_BLACK);
			refreshAlt();
		}
	}
	if (canseethings)
	{
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(23, 0, CONST_politics080);
		pressAnyKey();
	}
	for (int c = 0; c < cnum; c++)
	{
		char yeswin = 0;
		int yesvotes = 0;
		//Constitutional bias -- free speech, flag burning issues, supreme court
		//is extra liberal, gun control, supreme court is extra conservative
		//"All court justices will vote according to alignment and bias and do not consult
		//popular opinion...---Servant Corps"
		if (scase[c] == LAW_FREESPEECH || scase[c] == LAW_FLAGBURNING) bias = 1;
		else if (scase[c] == LAW_GUNCONTROL) bias = -1;
		else bias = 0;
		for (int l = 0; l < COURTNUM; l++)
		{
			int vote = court[l];
			if (vote == ALIGN_STALINIST)
			{
				if (stalinview(scase[c], true)) vote = ALIGN_ELITELIBERAL;
				else vote = ALIGN_ARCHCONSERVATIVE;
			}
			if (vote >= -1 && vote <= 1) vote += bias;
			if (lawList[scase[c]] > vote && scasedir[c] == -1) yesvotes++;
			if (lawList[scase[c]] < vote && scasedir[c] == 1) yesvotes++;
			if (l == COURTNUM - 1 && yesvotes >= COURTMAJORITY) yeswin = 1;
			if (canseethings)
			{
				if (l == COURTNUM - 1 && yeswin)set_color_easy(WHITE_ON_BLACK_BRIGHT);
				else if (l == COURTNUM - 1)set_color_easy(BLACK_ON_BLACK_BRIGHT);
				else set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(c * 3 + 2, 63, yesvotes);
				addstrAlt(CONST_politics082);
				if (l == COURTNUM - 1 && !yeswin)set_color_easy(WHITE_ON_BLACK_BRIGHT);
				else if (l == COURTNUM - 1)set_color_easy(BLACK_ON_BLACK_BRIGHT);
				else set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(c * 3 + 3, 63, l + 1 - yesvotes);
				addstrAlt(CONST_politics083);
				pause_ms(60);
			}
		}
		if (yeswin) lawList[scase[c]] += scasedir[c];
	}
	if (canseethings)
	{
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(23, 0, pressKeyToReflect);
		pressAnyKey();
	}
	//CHANGE A JUSTICE 40% OF THE TIME
	if (LCSrandom(10) >= 6)
	{
		if (canseethings)
		{
			eraseAlt();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(0, 0, CONST_politics084);
		}
		int j = LCSrandom(COURTNUM);
		if (canseethings)
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(2, 0, CONST_politics085);
			addstrAlt(courtname[j]);
			addstrAlt(commaSpace);
			addstrAlt(getalign(court[j], false));
			addstrAlt(CONST_politics086);
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(7, 0, CONST_politics087);
			pressAnyKey();
		}
		float president = (exec[EXEC_PRESIDENT] == ALIGN_STALINIST ? (float)-3 : (float)exec[EXEC_PRESIDENT]);
		float sen = 0;
		for (int s = 0; s < 100; s++) sen += (senate[s] == ALIGN_STALINIST ? (float)-3 : (float)senate[s]);
		sen /= 100.0f;
		float consensus = (president + sen)*.5f;
		if (consensus < -2.1f) court[j] = ALIGN_STALINIST;
		else if (consensus < -1.5f) court[j] = ALIGN_ARCHCONSERVATIVE;
		else if (consensus < -.5f) court[j] = ALIGN_CONSERVATIVE;
		else if (consensus < .5f) court[j] = ALIGN_MODERATE;
		else if (consensus < 1.5f) court[j] = ALIGN_LIBERAL;
		else court[j] = ALIGN_ELITELIBERAL;
		do
		{
			if (court[j] == ALIGN_ARCHCONSERVATIVE)
				generate_name(courtname[j], GENDER_WHITEMALEPATRIARCH);
			else generate_name(courtname[j]);
		} while (len(courtname[j]) > 20);
		if (canseethings)
		{
			mvaddstrAlt(4, 0, CONST_politics088);
			moveAlt(5, 0);
			if (court[j] == ALIGN_STALINIST) addstrAlt(CONST_politics089);
			else addstrAlt(CONST_politics090);
			addstrAlt(courtname[j]);
			addstrAlt(commaSpace);
			addstrAlt(getalign(court[j], false));
			addstrAlt(CONST_politics091);
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(7, 0, pressKeyToReflect);
			pressAnyKey();
		}
	}
}
enum BillStatus
{
	BILL_SIGNED = -2,
	BILL_OVERRIDE_VETO = -1,
	BILL_PASSED_CONGRESS = 0,
	BILL_FAILED = 1
};
//Some politicians listen to public opinion, but no politician will radically deviate from their alignment.
//More extreme politicians are less likely to deviate from their views. Moderates always consult public opinion.
char determine_politician_vote(char alignment, int law)
{
	char vote = alignment;
	int mood = publicmood(law);
	if (vote == ALIGN_STALINIST)
	{
		// Stalinist -- Will not accept public opinion
		if (stalinview(law, true)) vote = ALIGN_ELITELIBERAL;
		else vote = ALIGN_ARCHCONSERVATIVE;
	}
	else if (vote == -2 || vote == 2)
	{
		// Extremist -- Damn public opinion, I'm doing what I think is right
	}
	else if (vote == -1 || vote == 1)
	{
		// Partisan -- Listens to public opinion, but won't accept opposing views
		vote = -2;
		for (int i = 0; i < 4; i++)if (LCSrandom(100) < mood)vote++;
		if (abs(vote - alignment) > 1)vote = 0;
	}
	else if (vote == 0)
	{
		// Moderate -- Listens to public opinion, but won't accept either extreme
		vote = -2;
		for (int i = 0; i < 4; i++)if (LCSrandom(100) < mood)vote++;
		if (abs(vote) > 1)vote = vote / 2;
	}
	return vote;
}
void determineBills(const char canseethings, vector<int> &bill, vector<int> &billdir) {
	extern int year;
	extern short lawList[LAWNUM];
	extern short house[HOUSENUM];
	extern short senate[SENATENUM];

	char lawtaken[LAWNUM];
	memset(lawtaken, 0, LAWNUM * sizeof(char));
	int lawpriority[LAWNUM];
	memset(lawpriority, 0, LAWNUM * sizeof(int));
	char lawdir[LAWNUM];
	memset(lawdir, 0, LAWNUM * sizeof(char));

	for (int l = 0; l < LAWNUM; l++)
	{
		int pup = 0;
		int pdown = 0;
		int pprior = 0;
		// Consult House
		for (int cl = 0; cl < HOUSENUM; cl++)
		{
			short housealign = house[cl];
			if (housealign == ALIGN_STALINIST)
			{
				if (stalinview(l, true)) housealign = ALIGN_ELITELIBERAL;
				else housealign = ALIGN_ARCHCONSERVATIVE;
			}
			if (lawList[l] < housealign)pup++;
			else if (lawList[l] > housealign)pdown++;
			pprior += abs(housealign - lawList[l]);
		}
		// Consult Senate
		for (int sl = 0; sl < SENATENUM; sl++)
		{
			short senatealign = senate[sl];
			if (senatealign == ALIGN_STALINIST)
			{
				if (stalinview(l, true)) senatealign = ALIGN_ELITELIBERAL;
				else senatealign = ALIGN_ARCHCONSERVATIVE;
			}
			if (lawList[l] < senatealign)pup += 4;
			else if (lawList[l] > senatealign)pdown += 4;
			pprior += abs(senatealign - lawList[l]) * 4;
		}
		// Consult Public Opinion
		int mood = publicmood(l);
		int public_position = -2;
		for (int i = 0; i < 4; i++)if (10 + 20 * i < mood)public_position++;
		if (lawList[l] < public_position)pup += 600;
		if (lawList[l] > public_position)pdown += 600;
		pprior += abs(public_position - lawList[l]) * 600;
		if (pup > pdown) lawdir[l] = 1;
		else if (pup == pdown) lawdir[l] = LCSrandom(2) * 2 - 1;
		else lawdir[l] = -1;
		if (lawList[l] == -2) lawdir[l] = 1;
		if (lawList[l] == 2) lawdir[l] = -1;
		//CALC PRIORITY
		lawpriority[l] = pprior;
	}
	vector<int> canlaw;
	for (int c = 0; c < bill.size(); c++)
	{
		int maxprior = 0;
		for (int l = 0; l < LAWNUM; l++)
			if (lawpriority[l] > maxprior && !lawtaken[l])maxprior = lawpriority[l];
		canlaw.clear();
		for (int l = 0; l < LAWNUM; l++)
			if (lawpriority[l] == maxprior && !lawtaken[l])
				canlaw.push_back(l);
		bill[c] = pickrandom(canlaw);
		lawtaken[bill[c]] = 1;
		billdir[c] = lawdir[bill[c]];
		if (canseethings)
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(c * 3 + 2, 0, CONST_politics094);
			addstrAlt(year);
			addcharAlt('-');
			addstrAlt(c + 1);
			mvaddstrAlt(c * 3 + 3, 0, CONST_politics095);
			if (billdir[c] == 1)set_color_easy(GREEN_ON_BLACK_BRIGHT);
			else set_color_easy(RED_ON_BLACK_BRIGHT);
			set_alignment_color(billdir[c]);
			if (billdir[c] == 1) {
				if (bill[c] == LAW_PRISONS) {
					if (lawList[LAW_PRISONS] == 1) addstrAlt(establishPrisonReform);
					else addstrAlt(improvePrisonConditions);
				}
				else {
					addstrAlt(liberalizeLaw[bill[c]]);
				}
			}
			else {
				addstrAlt(conservatiseLaw[bill[c]]);
			}
			set_color_easy(WHITE_ON_BLACK);
			refreshAlt();
		}
	}
}
void attemptAmendmentEnding(char canseethings, Alignment enforcedAlignment);
/* politics - causes congress to act on legislation */
void congress(char clearformess, char canseethings)
{
	extern MusicClass music;
	extern int year;
	extern bool notermlimit;           //These determine if ELAs can take place --kviiri
	extern bool nocourtpurge;
	extern char execname[EXECNUM][POLITICIAN_NAMELEN];
	extern short exec[EXECNUM];
	extern short lawList[LAWNUM];
	extern short house[HOUSENUM];
	extern short senate[SENATENUM];
	extern short court[COURTNUM];
	if (canseethings)
	{
		music.play(MUSIC_ELECTIONS);
		if (clearformess) eraseAlt();
		else makedelimiter();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, CONST_politics092);
		pressAnyKey();
	}
	//CHANGE THINGS AND REPORT
	if (canseethings)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, CONST_politics093);
		addstrAlt(year);
	}
	vector<int> bill, billdir, killbill;
	int cnum = LCSrandom(3) + 1;
	bill.resize(cnum);
	billdir.resize(cnum);
	killbill.resize(cnum);
	for (int c = 0; c < killbill.size(); c++)
	{
		killbill[c] = BILL_PASSED_CONGRESS;
	}
	//DETERMINE BILLS
	determineBills(canseethings, bill, billdir);
	
	if (canseethings)
	{
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(23, 0, CONST_politics098);
		pressAnyKey();
		mvaddstrAlt(0, 62, CONST_politics099);
		mvaddstrAlt(0, 70, CONST_politics100);
	}
	for (int c = 0; c < cnum; c++)
	{
		char yeswin_h = 0, yeswin_s = 0;
		int yesvotes_h = 0, yesvotes_s = 0;
		int s = 0;
		for (int l = 0; l < HOUSENUM; l++)
		{
			int vote = determine_politician_vote(house[l], bill[c]);
			if (lawList[bill[c]] > vote&&billdir[c] == -1) yesvotes_h++;
			if (lawList[bill[c]] < vote&&billdir[c] == 1) yesvotes_h++;
			if (l == HOUSENUM - 1)
			{
				if (yesvotes_h >= HOUSEMAJORITY) yeswin_h = 1;
				if (yesvotes_h >= HOUSESUPERMAJORITY) killbill[c] = BILL_OVERRIDE_VETO;
			}
			if (canseethings)
			{
				if (l == HOUSENUM - 1 && yeswin_h) set_color_easy(WHITE_ON_BLACK_BRIGHT);
				else if (l == HOUSENUM - 1) set_color_easy(BLACK_ON_BLACK_BRIGHT);
				else set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(c * 3 + 2, 62, yesvotes_h);
				addstrAlt(YEA);
				if (l == HOUSENUM - 1 && !yeswin_h) set_color_easy(WHITE_ON_BLACK_BRIGHT);
				else if (l == HOUSENUM - 1) set_color_easy(BLACK_ON_BLACK_BRIGHT);
				else set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(c * 3 + 3, 62, l + 1 - yesvotes_h);
				addstrAlt(NAY);
			}
			if (l % 4 == 0 && s < SENATENUM)
			{
				vote = determine_politician_vote(senate[s++], bill[c]);
				if (lawList[bill[c]] > vote&&billdir[c] == -1) yesvotes_s++;
				if (lawList[bill[c]] < vote&&billdir[c] == 1) yesvotes_s++;
			}
			if (l == HOUSENUM - 1)
			{
				if (yesvotes_s >= SENATEMAJORITY) yeswin_s = 1;
				if (yesvotes_s < SENATESUPERMAJORITY&&killbill[c] == BILL_OVERRIDE_VETO) killbill[c] = BILL_PASSED_CONGRESS;
				if (yesvotes_s == SENATEMAJORITY - 1)
				{  //TIE BREAKER
					int vote;
					if ((exec[EXEC_VP] >= -1 && exec[EXEC_VP] <= 1) ||
						(exec[EXEC_PRESIDENT] >= -1 && exec[EXEC_PRESIDENT] <= 1))
						vote = (exec[EXEC_PRESIDENT] + // only consult Cabinet and random number generator if alignment between -1 and 1
							exec[EXEC_VP] +        // for President and/or Vice President
							exec[EXEC_STATE] +
							exec[EXEC_ATTORNEY] + LCSrandom(9) - 4) / 4;
					else
					{
						vote = exec[EXEC_VP];
						if (vote == ALIGN_STALINIST)
						{
							if (stalinview(bill[c], true)) vote = ALIGN_ELITELIBERAL;
							else vote = ALIGN_ARCHCONSERVATIVE;
						}
					}
					if (lawList[bill[c]] > vote&&billdir[c] == -1) yeswin_s = 1;
					if (lawList[bill[c]] < vote&&billdir[c] == 1) yeswin_s = 1;
					//ASSURED SIGNING BY PRESIDENT IF VP VOTED YES
					if (yeswin_s) killbill[c] = BILL_SIGNED;
				}
			}
			if (canseethings)
			{
				if (l == HOUSENUM - 1 && yeswin_s) set_color_easy(WHITE_ON_BLACK_BRIGHT);
				else if (l == HOUSENUM - 1) set_color_easy(BLACK_ON_BLACK_BRIGHT);
				else set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(c * 3 + 2, 70, yesvotes_s);
				addstrAlt(YEA);
				if (l == HOUSENUM - 1 && yesvotes_s == SENATEMAJORITY - 1 && yeswin_s)
				{
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(c * 3 + 2, 78, CONST_politics102);
				}
				if (l == HOUSENUM - 1 && !yeswin_s) set_color_easy(WHITE_ON_BLACK_BRIGHT);
				else if (l == HOUSENUM - 1) set_color_easy(BLACK_ON_BLACK_BRIGHT);
				else set_color_easy(WHITE_ON_BLACK);
				mvaddstrAlt(c * 3 + 3, 70, (s - yesvotes_s));
				addstrAlt(NAY);
				if (l == HOUSENUM - 1 && yesvotes_s == SENATEMAJORITY - 1 && !yeswin_s)
				{
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(c * 3 + 3, 78, CONST_politics102);
				}
				if (l % 5 == 0) pause_ms(5);
			}
		}
		if (!yeswin_h || !yeswin_s) killbill[c] = BILL_FAILED;
	}
	int havebill = 0;
	for (int c = 0; c < cnum; c++) if (killbill[c] != BILL_FAILED) havebill++;
	if (havebill)
	{
		if (canseethings)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(23, 0, CONST_politics103);
			pressAnyKey();
			mvaddstrAlt(0, 35, CONST_politics104);
			pause_ms(500);
		}
		for (int c = 0; c < len(bill); c++)
		{
			if (killbill[c] != BILL_FAILED)
			{
				int vote;
				if (exec[EXEC_PRESIDENT] >= -1 && exec[EXEC_PRESIDENT] <= 1)
					vote = (exec[EXEC_PRESIDENT] + // only consult Cabinet and random number generator if alignment between -1 and 1
						exec[EXEC_VP] +        // for President
						exec[EXEC_STATE] +
						exec[EXEC_ATTORNEY] + LCSrandom(9) - 4) / 4;
				else
				{
					vote = exec[EXEC_PRESIDENT];
					if (vote == ALIGN_STALINIST)
					{
						if (stalinview(bill[c], true)) vote = ALIGN_ELITELIBERAL;
						else vote = ALIGN_ARCHCONSERVATIVE;
					}
				}
				if ((lawList[bill[c]] > vote&&billdir[c] == -1) || (lawList[bill[c]] < vote&&billdir[c] == 1)) killbill[c] = BILL_SIGNED;
			}
			if (canseethings)
			{
				moveAlt(c * 3 + 2, 35);
				if (killbill[c] == BILL_SIGNED)
				{
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					addstrAlt(execname[EXEC_PRESIDENT]);
				}
				else if (killbill[c] == BILL_FAILED)
				{
					set_color_easy(BLACK_ON_BLACK_BRIGHT);
					addstrAlt(CONST_politics105);
				}
				else if (killbill[c] == BILL_OVERRIDE_VETO)
				{
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					addstrAlt(CONST_politics106);
				}
				else
				{
					set_color_easy(RED_ON_BLACK_BRIGHT);
					addstrAlt(CONST_politics107);
				}
				pause_ms(500);
			}
			if (killbill[c] == BILL_SIGNED || killbill[c] == BILL_OVERRIDE_VETO) lawList[bill[c]] += billdir[c];
		}
		if (canseethings)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(23, 0, pressKeyToReflect + CONST_politics110);
			pressAnyKey();
		}
	}
	else if (canseethings)
	{
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(23, 0, CONST_politics109);
		mvaddstrAlt(24, 0, pressKeyToReflect + CONST_politics110);
		pressAnyKey();
	}
	//CONGRESS CONSTITUTION CHANGES
	int housemake[6] = { 0,0,0,0,0,0 };
	for (int h = 0; h < HOUSENUM; h++) housemake[house[h] + 2]++;
	int senatemake[6] = { 0,0,0,0,0,0 };
	for (int s = 0; s < SENATENUM; s++) senatemake[senate[s] + 2]++;
	// Throw out non-L+ Justices?
	bool tossj = false;
	for (int j = 0; j < COURTNUM; j++) if (court[j] != ALIGN_ELITELIBERAL) tossj = true;
	if (housemake[4] + housemake[3] / 2 >= HOUSESUPERMAJORITY && senatemake[4] + senatemake[3] / 2 >= SENATESUPERMAJORITY && tossj && !nocourtpurge)
		tossjustices(canseethings);
	// Purge Congress, implement term limits, and hold new elections?
	if ((housemake[4] + housemake[3] / 2 < HOUSESUPERMAJORITY || senatemake[4] + senatemake[3] / 2 < SENATESUPERMAJORITY) && publicmood(-1) > 80 && !notermlimit)
		amendment_termlimits(canseethings);
	// LET ARCH-CONSERVATIVES REPEAL THE CONSTITUTION AND LOSE THE GAME?
	if (housemake[0] >= HOUSESUPERMAJORITY && senatemake[0] >= SENATESUPERMAJORITY)
		attemptAmendmentEnding(canseethings, ALIGN_ARCHCONSERVATIVE);
	// LET STALINISTS REPEAL THE CONSTITUTION AND LOSE THE GAME?
	if (housemake[5] >= HOUSESUPERMAJORITY && senatemake[5] >= SENATESUPERMAJORITY)
		attemptAmendmentEnding(canseethings, ALIGN_STALINIST);
}
/* politics - checks if the game is won */
char wincheck()
{
	extern short wincondition;
	extern short exec[EXECNUM];
	extern short lawList[LAWNUM];
	extern short house[HOUSENUM];
	extern short senate[SENATENUM];
	extern short court[COURTNUM];
	for (int e = 0; e < EXECNUM; e++) if (exec[e] < ALIGN_ELITELIBERAL) return 0;
	if (wincondition == WINCONDITION_ELITE) for (int l = 0; l < LAWNUM; l++) if (lawList[l] < ALIGN_ELITELIBERAL) return 0;
	else
	{
		int liberalLaws = 0, eliteLaws = 0;
		for (int l = 0; l < LAWNUM; l++)
		{
			if (lawList[l] < ALIGN_LIBERAL) return 0;
			if (lawList[l] == ALIGN_LIBERAL) liberalLaws++;
			else eliteLaws++;
		}
		if (eliteLaws < liberalLaws) return 0;
	}
	int housemake[6] = { 0,0,0,0,0,0 };
	for (int h = 0; h < HOUSENUM; h++) housemake[house[h] + 2]++;
	if (housemake[4] + housemake[3] / 2 < ((wincondition == WINCONDITION_ELITE) ? HOUSESUPERMAJORITY : HOUSECOMFYMAJORITY)) return 0; // Elite Libs plus half of Libs >= 3/5 for easy, 2/3 for elite
	if (housemake[4] < ((wincondition == WINCONDITION_ELITE) ? HOUSECOMFYMAJORITY : HOUSEMAJORITY)) return 0; // Elite Libs themselves >= 1/2 for easy, 3/5 for elite
	int senatemake[6] = { 0,0,0,0,0,0 };
	for (int s = 0; s < SENATENUM; s++) senatemake[senate[s] + 2]++;
	if (senatemake[4] + senatemake[3] / 2 < ((wincondition == WINCONDITION_ELITE) ? SENATESUPERMAJORITY : SENATECOMFYMAJORITY)) return 0; // Elite Libs plus half of Libs >= 3/5 for easy, 2/3 for elite
	if (wincondition != WINCONDITION_ELITE) senatemake[exec[EXEC_VP] + 2]++; // VP counts as Senator only for breaking ties (so counts for 1/2 fraction but not higher fractions)
	if (senatemake[4] < ((wincondition == WINCONDITION_ELITE) ? SENATECOMFYMAJORITY : SENATEMAJORITY)) return 0; // Elite Libs themselves >= 1/2 for easy, 3/5 for elite
	int elibjudge = 0, libjudge = 0;
	for (int c = 0; c < COURTNUM; c++)
	{
		if (court[c] == ALIGN_ELITELIBERAL) elibjudge++;
		if (court[c] == ALIGN_LIBERAL) libjudge++;
	}
	if (elibjudge < COURTMAJORITY && (wincondition == WINCONDITION_ELITE || elibjudge + libjudge / 2 < COURTSUPERMAJORITY)) return 0;
	return 1;
}


// #include "../includes.h"
const string CONST_reviewmode134 = "Press Z to Assemble a New Squad.  Press T to Assign New Bases to the Squadless.";
const string CONST_reviewmode133 = "  Press U to Promote Liberals.";
const string CONST_reviewmode132 = "Press a Letter to select a squad.  1-7 to view Liberal groups.";
const string CONST_reviewmode131 = "Press Y to turn on some Music.";
const string CONST_reviewmode130 = "Press Y to turn off the Music.";
const string CONST_reviewmode129 = "Press V to Inspect Liberal finances.";
const string CONST_reviewmode128 = "8 - Review and Move Equipment (";
const string CONST_reviewmode127 = "7 - Away (";
const string CONST_reviewmode126 = "6 - The Dead (";
const string CONST_reviewmode125 = "5 - Sleepers (";
const string CONST_reviewmode124 = "4 - Justice System (";
const string CONST_reviewmode123 = "3 - Hospital (";
const string CONST_reviewmode122 = "2 - Hostages (";
const string CONST_reviewmode121 = "1 - Active Liberals (";
const string CONST_reviewmode120 = "Acting Individually";
const string CONST_reviewmode119 = "ÄÄÄÄSQUAD NAMEÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄLOCATIONÄÄÄÄÄÄÄÄÄÄÄÄACTIVITYÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ";
const string CONST_reviewmode118 = "Review your Liberals and Assemble Squads";
const string CONST_reviewmode117 = "Enlightened Liberals follow anyone. Seduced Liberals follow only their lover.";
const string CONST_reviewmode116 = "Press a letter to promote a Liberal. You cannot promote Liberals in hiding.";
const string CONST_reviewmode115 = "<LCS Leader>";
const string CONST_reviewmode114 = "<Can't Lead More>";
const string CONST_reviewmode113 = "<Refuses Promotion>";
const string CONST_reviewmode112 = "CONTACT AFTER PROMOTION";
const string CONST_reviewmode111 = "ÄÄÄÄCODE NAMEÄÄÄÄÄÄÄÄÄÄÄÄÄÄCURRENT CONTACTÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ";
const string CONST_reviewmode110 = "Promote the Elite Liberals";
const string CONST_reviewmode109 = "T to sort people.";
const string CONST_reviewmode108 = ",. to view other Base pages.";
const string CONST_reviewmode107 = "Liberals must be moved in squads to transfer between cities.";
const string CONST_reviewmode106 = "Press a Letter to assign a Base.  Press a Number to select a Base.";
const string CONST_reviewmode105 = " <Under Siege>";
const string CONST_reviewmode104 = "NEW BASE";
const string CONST_reviewmode103 = "ÄÄÄÄCODE NAMEÄÄÄÄÄÄÄÄÄÄÄÄCURRENT BASEÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ";
const string CONST_reviewmode102 = "New Bases for Squadless Liberals";
const string CONST_reviewmode101 = " with";
const string CONST_reviewmode100 = "Choose squad member to replace ";
const string eightyBlankSpaces = "                                                                                ";
const string CONST_reviewmode097 = " has gained wisdom.                                                             ";
const string CONST_reviewmode096 = " grows colder.                                                                  ";
const string CONST_reviewmode095 = " has lost heart.                                                                ";
const string CONST_reviewmode094 = " feels sick to the stomach afterward and                                        ";
const string CONST_reviewmode091 = " by ";
const string CONST_reviewmode090 = " executes ";
const string CONST_reviewmode089 = "  C - Confirm       Any other key to continue                                   ";
const string CONST_reviewmode088 = "Killing your squad members is Not a Liberal Act.                                ";
const string CONST_reviewmode087 = " kill this squad member?                               ";
const string CONST_reviewmode086 = "Confirm you want to have ";
const string CONST_reviewmode085 = " in court.";
const string CONST_reviewmode084 = "to testify against ";
const string CONST_reviewmode083 = "The Conservative traitor has ratted you out to the police, and sworn";
const string CONST_reviewmode082 = "'s whereabouts.";
const string CONST_reviewmode081 = "A Liberal friend tips you off on ";
const string CONST_reviewmode078 = " has been released.                                                             ";
const string CONST_reviewmode076 = "If the member has low heart they may go to the police.                          ";
const string CONST_reviewmode075 = "Do you want to permanently release this squad member from the LCS?              ";
const string CONST_reviewmode073 = "What is the new code name?                                                      ";
const string CONST_reviewmode072 = "    UP/DOWN  - More Info";
const string CONST_reviewmode071 = "Press any other key to continue the Struggle";
const string CONST_reviewmode070 = "    LEFT/RIGHT - View Others";
const string CONST_reviewmode069 = "N - Change Code Name      G - Fix Gender Label";
const string CONST_reviewmode068 = "Press N to change this Automaton's Code Name";
const string CONST_reviewmode067 = "         K - Kill member";
const string CONST_reviewmode066 = "R - Remove member";
const string CONST_reviewmode065 = "Profile of a Liberal";
const string CONST_reviewmode064 = "Profile of an Automaton";
const string CONST_reviewmode063 = " T to sort people.";
const string CONST_reviewmode062 = "Reorder Liberals";
const string CONST_reviewmode061 = "Place ";
const string CONST_reviewmode060 = "Press a Letter to View Status.        Z - ";
const string CONST_reviewmode059 = "<No Contact>";
const string CONST_reviewmode058 = "Day";
const string CONST_reviewmode057 = "Days";
const string CONST_reviewmode054 = "Month";
const string CONST_reviewmode053 = "Months";
const string CONST_reviewmode052 = "Out in ";
const string CONST_reviewmode051 = "ÄÄÄÄÄÄÄ";
const string CONST_reviewmode048 = "Life Sentence";
const string CONST_reviewmode047 = " Life Sentences";
const string CONST_reviewmode044 = "DEATH ROW: ";
const string CONST_reviewmode041 = "SQUAD";
const string CONST_reviewmode040 = "Away";
const string CONST_reviewmode039 = "ÄÄÄÄCODE NAMEÄÄÄÄÄÄÄÄÄÄÄÄSKILLÄÄÄHEALTHÄÄÄLOCATIONÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ";
const string CONST_reviewmode038 = "The Liberal Crime Squad";
const string CONST_reviewmode036 = "What shall we designate this Liberal squad?                                     ";
const string CONST_reviewmode033 = "You cannot form a Squad with only Conservatives!                                ";
const string CONST_reviewmode031 = "Temporary Squad";
const string CONST_reviewmode028 = "Press a Letter to view Liberal details.                                         ";
const string CONST_reviewmode026 = "                Squad Liberals must be able to move around.                     ";
const string CONST_reviewmode023 = "           Liberals must be in the same location to form a Squad.               ";
const string CONST_reviewmode021 = "9 - Dissolve the squad.";
const string CONST_reviewmode020 = "Enter - I need no squad!";
const string CONST_reviewmode019 = "Enter - The squad is ready.";
const string CONST_reviewmode018 = "V - View a Liberal";
const string CONST_reviewmode016 = "Press a Letter to add or remove a Liberal from the squad.";
const string CONST_reviewmode015 = "AWAY";
const string CONST_reviewmode012 = "ÄÄÄÄCODE NAMEÄÄÄÄÄÄÄÄÄÄÄÄSKILLÄÄÄHEALTHÄÄÄÄÄÄÄÄÄÄÄPROFESSIONÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ";
const string CONST_reviewmode011 = "Squad: ";
const string CONST_reviewmode010 = "New Squad";
const string CONST_reviewmode009 = "The squad is full.";
const string CONST_reviewmode008 = "Assemble the squad!";
const string CONST_reviewmode007 = "getsSick.txt";
const string CONST_reviewmode006 = "methodOfExecution.txt";

//// #include "../common/equipment.h"
void consolidateloot(vector<Item *>&);
void equipmentbaseassign();

int getsquad(int);
int getpoolcreature(int);
//// #include "../monthly/lcsmonthly.h"
void fundreport(char &clearformess);
void printname(Creature &cr);

const int PAGELENGTH = 19;

vector<string> methodOfExecution;
vector<string> getsSick;
vector<file_and_text_collection> reviewmode_text_file_collection = {
	/*transferred via algorithm*/
	customText(&methodOfExecution, mostlyendings + CONST_reviewmode006),
	customText(&getsSick, mostlyendings + CONST_reviewmode007),
};
struct stringAndColor
{
	string str;
	ColorSetup type;
	stringAndColor(const string& str_, const ColorSetup type_) : str(str_), type(type_) { }
	stringAndColor(const ColorSetup type_, const string& str_) : str(str_), type(type_) { }
};
map<short, string> reviewStrings;
map<short, string> reviewStringsSecondLine;
vector<stringAndColor> liberalListAndColor;
void nukeAllEmptySquads(const vector<int> squadloc, const int mode);
/* base - review - assemble a squad */
void assemblesquad(squadst *cursquad)
{
	extern short mode;
	extern squadst *activesquad;
	extern long cursquadid;
	extern short interface_pgup;
	extern short interface_pgdn;
	extern short activesortingchoice[SORTINGCHOICENUM];
	extern vector<Creature *> pool;
	extern vector<squadst *> squad;
	int culloc = -1;
	if (cursquad != NULL) culloc = cursquad->squad[0]->location;
	char newsquad = 0;
	if (cursquad == NULL)
	{
		cursquad = new squadst;
		cursquad->id = cursquadid;
		cursquadid++;
		newsquad = 1;
	}
	vector<Creature *> temppool;
	for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
		if (pool[p]->is_active_liberal() &&
			(pool[p]->location == culloc || culloc == -1))
		{
			temppool.push_back(pool[p]);
		}
	sortliberals(temppool, activesortingchoice[SORTINGCHOICE_ASSEMBLESQUAD]);
	//BUILD LIST OF BASES FOR EACH SQUAD IN CASE IT ENDS UP EMPTY
	//THEN WILL DROP ITS LOOT THERE
	// Must be declared before new squads are formed
	// In order to assure squadloc contains the locations of all current squads
	vector<int> squadloc;
	squadloc.resize(len(squad));
	for (int sl = 0; sl < len(squad); sl++)
	{
		squadloc[sl] = squad[sl]->squad[0]->location;
		if (squadloc[sl] != -1) if (LocationsPool::getInstance().getRentingType(squadloc[sl]) == RENTING_NOCONTROL)
			squadloc[sl] = -1;
	}
	int page = 0;
	while (true)
	{
		int partysize = squadsize(cursquad);
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		moveAlt(0, 0);
		if (partysize < 6)addstrAlt(CONST_reviewmode008);
		else addstrAlt(CONST_reviewmode009);
		if (newsquad)
		{
			mvaddstrAlt(0, 71, CONST_reviewmode010);
		}
		else
		{
			mvaddstrAlt(0, 73 - len(cursquad->name), CONST_reviewmode011);
			addstrAlt(cursquad->name);
		}
		mvaddstrAlt(1, 0, CONST_reviewmode012); // 80 characters
		int y = 2;
		for (int p = page * 19; p < len(temppool) && p < page * 19 + 19; p++)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddcharAlt(y, 0, y + 'A' - 2); addstrAlt(spaceDashSpace);
			addstrAlt(temppool[p]->name);
			char bright = 0;
			int skill = 0;
			for (int sk = 0; sk < SKILLNUM; sk++)
			{
				skill += (int)temppool[p]->get_skill(sk);
				if (temppool[p]->get_skill_ip(sk) >= 100 + (10 * temppool[p]->get_skill(sk)) &&
					temppool[p]->get_skill(sk) < temppool[p]->skill_cap(sk, true)) bright = 1;
			}
			set_color_easy(bright ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
			mvaddstrAlt(y, 25, skill);
			printhealthstat(*temppool[p], y, 33, FALSE);
			if (temppool[p]->squadid == cursquad->id)
			{
				set_color_easy(GREEN_ON_BLACK_BRIGHT);
				mvaddstrAlt(y, 75, CONST_reviewmode041);
			}
			else if (temppool[p]->squadid != -1)
			{
				set_color_easy(YELLOW_ON_BLACK);
				mvaddstrAlt(y, 75, CONST_reviewmode041);
			}
			else if (cursquad->squad[0] != NULL)
			{
				if (cursquad->squad[0]->location != temppool[p]->location)
				{
					set_color_easy(BLACK_ON_BLACK_BRIGHT);
					mvaddstrAlt(y, 75, CONST_reviewmode015);
				}
			}
			if (temppool[p]->align == -1) set_color_easy(RED_ON_BLACK_BRIGHT);
			else if (temppool[p]->align == 0) set_color_easy(WHITE_ON_BLACK_BRIGHT);
			else set_color_easy(GREEN_ON_BLACK_BRIGHT);
			mvaddstrAlt(y, 50, temppool[p]->get_type_name());
			y++;
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(22, 0, CONST_reviewmode016);
		mvaddstrAlt(23, 0, addpagestr() + CONST_reviewmode063);
		mvaddstrAlt(23, 50, CONST_reviewmode018);
		moveAlt(24, 0);
		if (partysize > 0) addstrAlt(CONST_reviewmode019);
		else addstrAlt(CONST_reviewmode020);
		if (partysize > 0) set_color_easy(WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(24, 40, CONST_reviewmode021);
		int c = getkeyAlt();
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0) page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 19 < len(temppool)) page++;
		if (c >= 'a'&&c <= 's')
		{
			int p = page * 19 + c - 'a';
			if (p < len(temppool))
			{
				char conf = 1;
				if (cursquad->squad[0] != NULL)
				{
					if (cursquad->squad[0]->location != temppool[p]->location)
					{
						set_color_easy(RED_ON_BLACK_BRIGHT);
						mvaddstrAlt(22, 0, eightyBlankSpaces); // 80 spaces
						mvaddstrAlt(23, 0, CONST_reviewmode023); // 80 characters
						mvaddstrAlt(24, 0, eightyBlankSpaces); // 80 spaces
						pressAnyKey();
						conf = 0;
					}
				}
				if (!temppool[p]->canwalk() &&
					!(temppool[p]->flag & CREATUREFLAG_WHEELCHAIR))
				{
					set_color_easy(RED_ON_BLACK_BRIGHT);
					mvaddstrAlt(22, 0, eightyBlankSpaces); // 80 spaces
					mvaddstrAlt(23, 0, CONST_reviewmode026); // 80 characters
					mvaddstrAlt(24, 0, eightyBlankSpaces); // 80 spaces
					pressAnyKey();
					conf = 0;
				}
				if (conf)
				{
					if (temppool[p]->squadid == cursquad->id)
					{
						bool flipstart = 0;
						for (int pt = 0; pt < 6; pt++)
						{
							if (cursquad->squad[pt] == temppool[p])
							{
								flipstart = 1;
								cursquad->squad[pt]->squadid = -1;
							}
							if (flipstart&&pt < 5)cursquad->squad[pt] = cursquad->squad[pt + 1];
						}
						if (flipstart)cursquad->squad[5] = NULL;
					}
					else if (partysize < 6)
					{
						for (int pt = 0; pt < 6; pt++)
						{
							if (cursquad->squad[pt] == NULL)
							{
								removesquadinfo(*temppool[p]);
								cursquad->squad[pt] = temppool[p];
								temppool[p]->squadid = cursquad->id;
								break;
							}
						}
					}
				}
			}
		}
		if (c == 't')
		{
			sorting_prompt(SORTINGCHOICE_ASSEMBLESQUAD);
			sortliberals(temppool, activesortingchoice[SORTINGCHOICE_ASSEMBLESQUAD], true);
		}
		if (c == 'v')
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(22, 0, CONST_reviewmode028); // 80 characters
			mvaddstrAlt(23, 0, eightyBlankSpaces); // 80 spaces
			mvaddstrAlt(24, 0, eightyBlankSpaces); // 80 spaces
			int c2 = getkeyAlt();
			if (c2 >= 'a'&&c2 <= 's')
			{
				int p = page * 19 + c2 - 'a';
				if (p < len(temppool))
				{
					//Create a temporary squad from which to view this character - even if they already have a squad.
					squadst *oldactivesquad = activesquad;
					int oldSquadID = temppool[p]->squadid;
					//create a temp squad containing just this liberal
					activesquad = new squadst;
					strcpy(activesquad->name, CONST_reviewmode031.c_str());
					activesquad->id = cursquadid;
					activesquad->squad[0] = temppool[p];
					temppool[p]->squadid = activesquad->id;
					fullstatus(0);
					delete_and_nullify(activesquad);
					temppool[p]->squadid = oldSquadID;
					activesquad = oldactivesquad;
				}
			}
		}
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR)
		{
			//CHECK IF GOOD (either has at least one Liberal or is empty)
			bool good = true; // Start off at true for empty squads
			for (int p = 0; p < 6; p++)
				if (cursquad->squad[p])
				{  // It is good if either there is at least one Liberal, or if the squad is completely empty
					if (cursquad->squad[p]->align == 1)
					{
						good = true; break;
					} // We found a Liberal, it's good
					else good = false; // We found a non-Liberal, this is bad unless we can find a Liberal too
				}
			if (good) break;
			else
			{  // At this point we have a non-empty squad, none of whose members are Liberal
				set_color_easy(RED_ON_BLACK_BRIGHT);
				mvaddstrAlt(22, 0, eightyBlankSpaces); // 80 spaces
				mvaddstrAlt(23, 0, CONST_reviewmode033); // 80 characters
				mvaddstrAlt(24, 0, eightyBlankSpaces); // 80 spaces
				pressAnyKey();
			}
		}
		if (c == '9')
		{
			for (int p = 0; p < 6; p++)
			{
				if (cursquad->squad[p] != NULL)
				{
					cursquad->squad[p]->squadid = -1;
					cursquad->squad[p] = NULL;
				}
			}
		}
	}
	//FINALIZE NEW SQUADS
	if (newsquad)
	{
		bool hasmembers = squadsize(cursquad) > 0;
		if (hasmembers)
		{
			mvaddstrAlt(22, 0, eightyBlankSpaces); // 80 spaces
			mvaddstrAlt(23, 0, CONST_reviewmode036); // 80 characters
			mvaddstrAlt(24, 0, eightyBlankSpaces); // 80 spaces
			enter_name(24, 0, cursquad->name, SQUAD_NAMELEN, CONST_reviewmode038.c_str());
			squad.push_back(cursquad);
		}
		else delete cursquad;
	}

	nukeAllEmptySquads(squadloc, mode);
}
vector<Creature *> countLiberals(const short mode) {
	extern vector<Creature *> pool;
	vector<Creature *> temppool;
	switch (mode) {
	case REVIEWMODE_LIBERALS:
		for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
		{
			if (pool[p]->is_active_liberal())
				temppool.push_back(pool[p]);
		}
		break;
	case REVIEWMODE_HOSTAGES:
		for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
		{
			if (pool[p]->align != ALIGN_LIBERAL && pool[p]->alive)
				temppool.push_back(pool[p]);
		}
		break;
	case REVIEWMODE_CLINIC:
		for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
		{
			if (pool[p]->clinic && pool[p]->alive)
				temppool.push_back(pool[p]);
		}
		break;
	case REVIEWMODE_JUSTICE:
		for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
		{
			if (pool[p]->is_imprisoned())
				temppool.push_back(pool[p]);
		}
		break;
	case REVIEWMODE_SLEEPERS:
		for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
		{
			if (pool[p]->is_lcs_sleeper())
				temppool.push_back(pool[p]);
		}
		break;
	case REVIEWMODE_DEAD:
		for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
		{
			if (!pool[p]->alive)
				temppool.push_back(pool[p]);
		}
		break;
	case REVIEWMODE_AWAY:
		for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
		{
			if ((pool[p]->dating || pool[p]->hiding) && pool[p]->alive)
				temppool.push_back(pool[p]);
		}
		break;
	}
	return temppool;
}
void evaluateLiberals(vector<Creature *> temppool, const int page, const short mode) {
	int y = 2;
	extern vector<squadst *> squad;
	for (int p = page * 19; p < len(temppool) && p < page * 19 + 19; p++)
	{
		set_color_easy(WHITE_ON_BLACK);
		mvaddcharAlt(y, 0, y + 'A' - 2); addstrAlt(spaceDashSpace);
		addstrAlt(temppool[p]->name);
		char bright = 0;
		int skill = 0;
		for (int sk = 0; sk < SKILLNUM; sk++)
		{
			skill += (int)temppool[p]->get_skill(sk);
			if (temppool[p]->get_skill_ip(sk) >= 100 + (10 * temppool[p]->get_skill(sk)) &&
				temppool[p]->get_skill(sk) < temppool[p]->skill_cap(sk, true))bright = 1;
		}
		set_color_easy(bright ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
		mvaddstrAlt(y, 25, skill);
		printhealthstat(*temppool[p], y, 33, TRUE);
		if (mode == REVIEWMODE_JUSTICE)set_color_easy(YELLOW_ON_BLACK_BRIGHT);
		else set_color_easy(WHITE_ON_BLACK);
		moveAlt(y, 42);
		if (temppool[p]->location == -1) addstrAlt(CONST_reviewmode040);
		else addstrAlt(LocationsPool::getInstance().getLocationNameWithGetnameMethod(temppool[p]->location, true, true));
		moveAlt(y, 57);
		switch (mode)
		{
		case REVIEWMODE_LIBERALS:
		{
			char usepers = 1;
			if (temppool[p]->squadid != -1)
			{
				int sq = getsquad(temppool[p]->squadid);
				if (sq != -1)
				{
					if (squad[sq]->activity.type != ACTIVITY_NONE)
					{
						set_color_easy(GREEN_ON_BLACK_BRIGHT);
						addstrAlt(CONST_reviewmode041);
						usepers = 0;
					}
				}
			}
			if (usepers)
			{  // Let's add some color here...
				set_activity_color(temppool[p]->activity.type);
				addstrAlt(getactivity(temppool[p]->activity));
			}
			break;
		}
		case REVIEWMODE_HOSTAGES:
		{
			set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
			addstrAlt(temppool[p]->joindays);
			addstrAlt(singleSpace);
			if (temppool[p]->joindays > 1)addstrAlt(CONST_reviewmode057);
			else addstrAlt(CONST_reviewmode058);
			break;
		}
		case REVIEWMODE_JUSTICE:
		{
			if (temppool[p]->deathpenalty&&temppool[p]->sentence != 0 &&
				LocationsPool::getInstance().getLocationType(temppool[p]->location) == SITE_GOVERNMENT_PRISON)
			{
				set_color_easy(RED_ON_BLACK_BRIGHT);
				addstrAlt(CONST_reviewmode044);
				addstrAlt(temppool[p]->sentence);
				addstrAlt(singleSpace);
				if (temppool[p]->sentence > 1)addstrAlt(CONST_reviewmode053);
				else addstrAlt(CONST_reviewmode054);
			}
			else if (temppool[p]->sentence <= -1 &&
				LocationsPool::getInstance().getLocationType(temppool[p]->location) == SITE_GOVERNMENT_PRISON)
			{
				set_color_easy(WHITE_ON_BLACK);
				if (temppool[p]->sentence < -1)
				{
					addstrAlt(-(temppool[p]->sentence));
					addstrAlt(CONST_reviewmode047);
				}
				else
					addstrAlt(CONST_reviewmode048);
			}
			else if (temppool[p]->sentence != 0 &&
				LocationsPool::getInstance().getLocationType(temppool[p]->location) == SITE_GOVERNMENT_PRISON)
			{
				set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				addstrAlt(temppool[p]->sentence);
				addstrAlt(singleSpace);
				if (temppool[p]->sentence > 1)addstrAlt(CONST_reviewmode053);
				else addstrAlt(CONST_reviewmode054);
			}
			else
			{
				set_color_easy(BLACK_ON_BLACK_BRIGHT);
				addstrAlt(CONST_reviewmode051); // 7 characters
			}
			break;
		}
		case REVIEWMODE_CLINIC:
		{
			set_color_easy(CYAN_ON_BLACK_BRIGHT);
			addstrAlt(CONST_reviewmode052);
			addstrAlt(temppool[p]->clinic);
			addstrAlt(singleSpace);
			if (temppool[p]->clinic > 1)addstrAlt(CONST_reviewmode053);
			else addstrAlt(CONST_reviewmode054);
			break;
		}
		case REVIEWMODE_SLEEPERS:
		{
			if (temppool[p]->align == -1)set_color_easy(RED_ON_BLACK_BRIGHT);
			else if (temppool[p]->align == 0)set_color_easy(WHITE_ON_BLACK_BRIGHT);
			else set_color_easy(GREEN_ON_BLACK_BRIGHT);
			addstrAlt(temppool[p]->get_type_name());
			break;
		}
		case REVIEWMODE_DEAD:
		{
			set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
			addstrAlt(temppool[p]->deathdays);
			addstrAlt(singleSpace);
			if (temppool[p]->deathdays > 1)addstrAlt(CONST_reviewmode057);
			else addstrAlt(CONST_reviewmode058);
			break;
		}
		case REVIEWMODE_AWAY:
		{
			set_color_easy(CYAN_ON_BLACK_BRIGHT);
			if (temppool[p]->hiding != -1)
			{
				addstrAlt(temppool[p]->dating + temppool[p]->hiding);
				addstrAlt(singleSpace);
				if (temppool[p]->dating + temppool[p]->hiding > 1)
					addstrAlt(CONST_reviewmode057);
				else addstrAlt(CONST_reviewmode058);
			}
			else addstrAlt(CONST_reviewmode059);
			break;
		}
		}
		y++;
	}
}
void review_mode(const short mode)
{
	extern Log gamelog;
	extern int stat_kills;
	extern short interface_pgup;
	extern short interface_pgdn;
	extern short activesortingchoice[SORTINGCHOICENUM];
	extern vector<Creature *> pool;
	extern vector<squadst *> squad;
	Creature *swap = NULL;
	int swapPos = 0;
	vector<Creature *> temppool = countLiberals(mode);
	

	if (!len(temppool)) return;
	sortliberals(temppool, activesortingchoice[reviewmodeenum_to_sortingchoiceenum(mode)]);
	int page = 0;
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(0, 0, reviewStrings[mode]);
		mvaddstrAlt(1, 0, CONST_reviewmode039); // 80 characters
		mvaddstrAlt(1, 57, reviewStringsSecondLine[mode]);
		evaluateLiberals(temppool, page, mode);

		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(22, 0, CONST_reviewmode060);
		if (swap) { addstrAlt(CONST_reviewmode061); addstrAlt(swap->name); }
		else addstrAlt(CONST_reviewmode062);
		mvaddstrAlt(23, 0, addpagestr() + CONST_reviewmode063);
		int c = getkeyAlt();
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0) page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 19 < len(temppool)) page++;
		if (c >= 'a'&&c <= 's')
		{
			int p = page * 19 + (int)(c - 'a');
			if (p < len(temppool))
			{
				int page = 0;
				//const int pagenum=2;
				while (true)
				{
					eraseAlt();
					moveAlt(0, 0);
					if (temppool[p]->align != 1)
					{
						set_color_easy(RED_ON_BLACK_BRIGHT);
						addstrAlt(CONST_reviewmode064);
					}
					else
					{
						set_color_easy(GREEN_ON_BLACK_BRIGHT);
						addstrAlt(CONST_reviewmode065);
					}
					if (page == 0) printliberalstats(*temppool[p]);
					else if (page == 1) printliberalskills(*temppool[p]);
					else if (page == 2) printliberalcrimes(*temppool[p]);
					// Add removal of squad members member
					moveAlt(22, 0);
					if (temppool[p]->is_active_liberal() &&
						temppool[p]->hireid != -1)  // If alive and not own boss? (suicide?)
					{
						addstrAlt(CONST_reviewmode066);
						int boss = getpoolcreature(temppool[p]->hireid);
						if (pool[boss]->location == temppool[p]->location)
							addstrAlt(CONST_reviewmode067);
					}
					moveAlt(23, 0);
					if (temppool[p]->align != 1) addstrAlt(CONST_reviewmode068);
					else addstrAlt(CONST_reviewmode069);
					if (len(temppool) > 1) addstrAlt(CONST_reviewmode070);
					mvaddstrAlt(24, 0, CONST_reviewmode071);
					addstrAlt(CONST_reviewmode072);
					int c = getkeyAlt();
					if (len(temppool) > 1 && ((c == KEY_LEFT) || (c == KEY_RIGHT)))
					{
						int sx = 1;
						if (c == KEY_LEFT) sx = -1;
						p = (p + len(temppool) + sx) % len(temppool);
						continue;
					}
					if (c == KEY_DOWN)
					{
						page++;
						if (page > 2) page = 0;
						continue;
					}
					if (c == KEY_UP)
					{
						page--;
						if (page < 0) page = 2;
						continue;
					}
					if (c == 'n')
					{
						set_color_easy(WHITE_ON_BLACK);
						mvaddstrAlt(23, 0, CONST_reviewmode073); // 80 characters
						mvaddstrAlt(24, 0, eightyBlankSpaces); // 80 spaces
						enter_name(24, 0, temppool[p]->name, CREATURE_NAMELEN, temppool[p]->propername);
					}
					else if (c == 'g' && temppool[p]->align == 1)
					{
						temppool[p]->gender_liberal++;
						if (temppool[p]->gender_liberal > 2)
							temppool[p]->gender_liberal = 0;
					}
					else if (c == 'r' && temppool[p]->is_active_liberal() &&
						temppool[p]->hireid != -1)  // If alive and not own boss? (suicide?)
					{
						int boss = getpoolcreature(temppool[p]->hireid);
						set_color_easy(WHITE_ON_BLACK);
						mvaddstrAlt(22, 0, CONST_reviewmode075); // 80 characters
						mvaddstrAlt(23, 0, CONST_reviewmode076); // 80 characters
						mvaddstrAlt(24, 0, CONST_reviewmode089); // 80 characters
						int c = getkeyAlt();
						if (c == 'c')
						{
							// Release squad member
							mvaddstrAlt(22, 0, temppool[p]->name, gamelog);
							addstrAlt(CONST_reviewmode078, gamelog); // 80 characters
							gamelog.newline(); //New line.
							mvaddstrAlt(23, 0, eightyBlankSpaces); // 80 spaces
							mvaddstrAlt(24, 0, eightyBlankSpaces); // 80 spaces
							pressAnyKey();
							// Chance of member going to police if boss has criminal record and
							// if they have low heart
							// TODO: Do law check against other members?
							if (temppool[p]->get_attribute(ATTRIBUTE_HEART, true) < temppool[p]->get_attribute(ATTRIBUTE_WISDOM, true) + LCSrandom(5)
								&& iscriminal(*pool[boss]))
							{
								set_color_easy(CYAN_ON_BLACK_BRIGHT);
								mvaddstrAlt(22, 0, CONST_reviewmode081, gamelog);
								addstrAlt(temppool[p]->name, gamelog);
								addstrAlt(CONST_reviewmode082, gamelog);
								gamelog.newline(); //New line.
								mvaddstrAlt(24, 0, CONST_reviewmode083, gamelog);
								gamelog.newline(); //New line.
								mvaddstrAlt(25, 0, CONST_reviewmode084, gamelog);
								addstrAlt(pool[boss]->name, gamelog);
								addstrAlt(CONST_reviewmode085, gamelog);
								criminalize(*pool[boss], LAWFLAG_RACKETEERING);
								pool[boss]->confessions++;
								// TODO: Depending on the crime increase heat or make seige
								if (LocationsPool::getInstance().getHeat(pool[boss]->base) > 20)
									LocationsPool::getInstance().setSiegetimeuntillocated(pool[boss]->base, 3);
								else
									LocationsPool::getInstance().addHeat(pool[boss]->base, 20);
							}
							gamelog.nextMessage(); //Write out buffer to prepare for next message.
												   // Remove squad member
							removesquadinfo(*temppool[p]);
							cleangonesquads();
							delete_and_remove(temppool, p, pool, getpoolcreature(temppool[p]->id));
							break;
						}
					}
					else if (c == 'k' && temppool[p]->is_active_liberal() &&
						temppool[p]->hireid != -1)  // If alive and not own boss? (suicide?)
					{
						// Kill squad member
						int boss = getpoolcreature(temppool[p]->hireid);
						if (pool[boss]->location != temppool[p]->location) break;
						set_color_easy(WHITE_ON_BLACK);
						mvaddstrAlt(22, 0, CONST_reviewmode086); // 25 characters (25+55=80)
						addstrAlt(pool[boss]->name);
						addstrAlt(CONST_reviewmode087); // 55 characters (25+55=80)
						mvaddstrAlt(23, 0, CONST_reviewmode088); // 80 characters
						mvaddstrAlt(24, 0, CONST_reviewmode089); // 80 characters
						int c = getkeyAlt();
						if (c == 'c')
						{
							temppool[p]->die();
							cleangonesquads();
							stat_kills++;
							mvaddstrAlt(22, 0, pool[boss]->name, gamelog);
							addstrAlt(CONST_reviewmode090, gamelog); // 10 characters (10+4+66=80)
							addstrAlt(temppool[p]->name, gamelog);
							addstrAlt(CONST_reviewmode091, gamelog); // 4 characters (10+4+66=80)
							addstrAlt(pickrandom(methodOfExecution), gamelog);
							mvaddstrAlt(23, 0, eightyBlankSpaces); // 80 spaces
							mvaddstrAlt(24, 0, eightyBlankSpaces); // 80 spaces
							pressAnyKey();
							if (boss != -1)
							{
								if (LCSrandom(pool[boss]->get_attribute(ATTRIBUTE_HEART, false)) > LCSrandom(3))
								{
									set_color_easy(GREEN_ON_BLACK_BRIGHT);
									gamelog.newline(); //New line.
									mvaddstrAlt(22, 0, pool[boss]->name, gamelog);
									addstrAlt(CONST_reviewmode094, gamelog); // 80 characters
									pool[boss]->adjust_attribute(ATTRIBUTE_HEART, -1);
									// this sentence probably takes more than 80 characters so use 2 lines and break it here
									gamelog.newline(); //New line.
									mvaddstrAlt(23, 0, pickrandom(getsSick), gamelog);
									gamelog.newline(); //New line.
									mvaddstrAlt(24, 0, pool[boss]->name, gamelog);
									addstrAlt(CONST_reviewmode095, gamelog); // 80 characters
									pressAnyKey();
								}
								else if (!LCSrandom(3))
								{
									gamelog.newline(); //New line here too.
									set_color_easy(CYAN_ON_BLACK_BRIGHT);
									mvaddstrAlt(22, 0, pool[boss]->name, gamelog);
									addstrAlt(CONST_reviewmode096, gamelog); // 80 characters
									pool[boss]->adjust_attribute(ATTRIBUTE_WISDOM, +1);
									gamelog.newline(); //New line.
									mvaddstrAlt(24, 0, pool[boss]->name, gamelog);
									addstrAlt(CONST_reviewmode097, gamelog); // 80 characters
									pressAnyKey();
								}
							}
							gamelog.nextMessage(); //Write buffer out to prepare for next message.
							break;
						}
					}
					else break;
				}
			}
		}
		if (c == 't')
		{
			sorting_prompt(reviewmodeenum_to_sortingchoiceenum(mode));
			sortliberals(temppool, activesortingchoice[reviewmodeenum_to_sortingchoiceenum(mode)], true);
		}
		// Reorder squad
		if (c == 'z')
		{
			if (len(temppool) <= 1) continue;
			mvaddstrAlt(22, 0, eightyBlankSpaces); // 80 spaces
			mvaddstrAlt(23, 0, eightyBlankSpaces); // 80 spaces
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(22, 8, CONST_reviewmode100);
			if (!swap) {
				int c = getkeyAlt();
				if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
				if (c<'a' || c>'s') continue; // Not within correct range
											  // Get first member to swap
				int p = page * 19 + c - 'a';
				if (p < len(temppool)) swap = temppool[swapPos = p];
			}
			else { // non-null swap
				addstrAlt(swap->name);
				addstrAlt(CONST_reviewmode101);
				int c = getkeyAlt();
				if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
				if (c<'a' || c>'s') continue; // Not within correct range
				int p = page * 19 + c - 'a';
				if (p < len(temppool) && temppool[p] != swap)
				{
					Creature* swap2 = temppool[p];
					for (int i = 0; i < CreaturePool::getInstance().lenpool(); i++)
						if (pool[i]->id == swap->id)
						{
							pool.erase(pool.begin() + i);
							break;
						}
					for (int i = 0; i < CreaturePool::getInstance().lenpool(); i++)
						if (pool[i]->id == swap2->id)
						{
							pool.insert(pool.begin() + i + (swapPos < p), swap);
							break;
						}
					temppool.erase(temppool.begin() + swapPos);
					temppool.insert(temppool.begin() + p, swap);
					swap = NULL;
				}
			}
		}
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
	}
}
/* base - review - assign new bases to the squadless */
void squadlessbaseassign()
{
	extern bool multipleCityMode;
	extern short interface_pgup;
	extern short interface_pgdn;
	extern short activesortingchoice[SORTINGCHOICENUM];
	extern vector<Creature *> pool;
	int page_lib = 0, page_loc = 0, selectedbase = 0;
	vector<Creature *> temppool;
	for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++) if (pool[p]->is_active_liberal() && pool[p]->squadid == -1) temppool.push_back(pool[p]);
	if (!len(temppool)) return;
	sortliberals(temppool, activesortingchoice[SORTINGCHOICE_BASEASSIGN]);
	vector<int> temploc;
	for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++) if (LocationsPool::getInstance().getRentingType(l) >= 0 && !LocationsPool::getInstance().isThereASiegeHere(l)) temploc.push_back(l);
	if (!len(temploc)) return;
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		printfunds();
		mvaddstrAlt(0, 0, CONST_reviewmode102);
		mvaddstrAlt(1, 0, CONST_reviewmode103); // 80 characters
		mvaddstrAlt(1, 51, CONST_reviewmode104);
		for (int p = page_lib * 19, y = 2; p < len(temppool) && p < page_lib * 19 + 19; p++, y++)
		{
			// Red name if location under siege
			if (temppool[p]->base == temppool[p]->location &&
				LocationsPool::getInstance().isThereASiegeHere(temppool[p]->base))
				set_color_easy(RED_ON_BLACK_BRIGHT);
			else if (multipleCityMode && LocationsPool::getInstance().getLocationCity(temppool[p]->base) != LocationsPool::getInstance().getLocationCity(temploc[selectedbase]))
				set_color_easy(BLACK_ON_BLACK_BRIGHT);
			else set_color_easy(WHITE_ON_BLACK);
			mvaddcharAlt(y, 0, y + 'A' - 2); addstrAlt(spaceDashSpace);
			addstrAlt(temppool[p]->name);
			mvaddstrAlt(y, 25, LocationsPool::getInstance().getLocationNameWithGetnameMethod(temppool[p]->base, true, true));
			if (LocationsPool::getInstance().isThereASiegeHere(temppool[p]->base))
				addstrAlt(CONST_reviewmode105);
		}
		for (int p = page_loc * 9, y = 2; p < len(temploc) && p < page_loc * 9 + 9; p++, y++)
		{
			if (p == selectedbase)set_color_easy(WHITE_ON_BLACK_BRIGHT);
			else set_color_easy(WHITE_ON_BLACK);
			mvaddcharAlt(y, 51, y + '1' - 2); addstrAlt(spaceDashSpace);
			addstrAlt(LocationsPool::getInstance().getLocationNameWithGetnameMethod(temploc[p], true, true));
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(21, 0, CONST_reviewmode106);
		mvaddstrAlt(22, 0, CONST_reviewmode107);
		if (len(temppool) > 19)
		{
			mvaddstrAlt(23, 0, addpagestr());
		}
		if (len(temploc) > 9)
		{
			mvaddstrAlt(24, 0, CONST_reviewmode108);
		}
		mvaddstrAlt(23, 35, CONST_reviewmode109);
		int c = getkeyAlt();
		//PAGE UP (people)
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page_lib > 0) page_lib--;
		//PAGE DOWN (people)
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page_lib + 1) * 19 < len(temppool)) page_lib++;
		//PAGE UP (locations)
		if (c == ','&&page_loc > 0) page_loc--;
		//PAGE DOWN (locations)
		if (c == '.' && (page_loc + 1) * 9 < len(temploc)) page_loc++;
		if (c >= 'a'&&c <= 's')
		{
			int p = page_lib * 19 + c - 'a';
			// Assign new base, IF the selected letter is a liberal, AND the Liberal is not under siege or in a different city
			if (p < len(temppool)
				&& !(temppool[p]->base == temppool[p]->location && LocationsPool::getInstance().isThereASiegeHere(temppool[p]->base))
				&& !(multipleCityMode && LocationsPool::getInstance().getLocationCity(temppool[p]->base) != LocationsPool::getInstance().getLocationCity(temploc[selectedbase])))
			{
				temppool[p]->base = temploc[selectedbase];
			}
		}
		if (c >= '1'&&c <= '9')
		{
			int p = page_loc * 9 + c - '1';
			if (p < len(temploc)) selectedbase = p;
		}
		if (c == 't')
		{
			sorting_prompt(SORTINGCHOICE_BASEASSIGN);
			sortliberals(temppool, activesortingchoice[SORTINGCHOICE_BASEASSIGN], true);
		}
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
	}
}
void sortbyhire(vector<Creature *> &temppool, vector<int> &level)
{
	vector<Creature *> newpool;
	level.clear();
	for (int i = len(temppool) - 1; i >= 0; i--)
		if (temppool[i]->hireid == -1)
		{
			newpool.insert(newpool.begin(), temppool[i]);
			level.insert(level.begin(), 0);
			temppool.erase(temppool.begin() + i);
		}
	bool changed;
	do
	{
		changed = false;
		for (int i = 0; i < len(newpool); i++)
			for (int j = len(temppool) - 1; j >= 0; j--)
				if (temppool[j]->hireid == newpool[i]->id)
				{
					newpool.insert(newpool.begin() + i + 1, temppool[j]);
					level.insert(level.begin() + i + 1, level[i] + 1);
					temppool.erase(temppool.begin() + j);
					changed = true;
				}
	} while (changed);
	temppool.clear();
	for (int p = 0; p < len(newpool); p++)
		temppool.push_back(newpool[p]);
}
/* base - review - promote liberals */
void promoteliberals()
{
	extern short interface_pgup;
	extern short interface_pgdn;
	extern vector<Creature *> pool;
	vector<Creature *> temppool;
	vector<int> level;
	for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
		if (pool[p]->alive&&pool[p]->align == 1)
			temppool.push_back(pool[p]);
	if (!len(temppool)) return;
	//SORT
	sortbyhire(temppool, level);
	//PROMOTE
	int page = 0;
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		printfunds();
		mvaddstrAlt(0, 0, CONST_reviewmode110);
		mvaddstrAlt(1, 0, CONST_reviewmode111); // 80 characters
		mvaddstrAlt(1, 54, CONST_reviewmode112);
		int y = 2;
		for (int p = page * PAGELENGTH; p < len(temppool) && p < page*PAGELENGTH + PAGELENGTH; p++)
		{
			set_color_easy(WHITE_ON_BLACK);
			mvaddcharAlt(y, 0, y + 'A' - 2); addstrAlt(spaceDashSpace);
			moveAlt(y, 27);
			bool iAmTheLeader = true;
			for (int p2 = 0; p2 < CreaturePool::getInstance().lenpool() && iAmTheLeader; p2++)
			{
				if (pool[p2]->alive == 1 && pool[p2]->id == temppool[p]->hireid)
				{
					printname(*pool[p2]);
					moveAlt(y, 54);
					for (int p3 = 0; p3 < CreaturePool::getInstance().lenpool(); p3++)
					{
						if (pool[p3]->alive == 1 && pool[p3]->id == pool[p2]->hireid)
						{
							if (temppool[p]->flag&CREATUREFLAG_LOVESLAVE)
								addstrAlt(CONST_reviewmode113);
							else if (!subordinatesleft(*pool[p3]) && !(temppool[p]->flag&CREATUREFLAG_BRAINWASHED))
								addstrAlt(CONST_reviewmode114);
							else
								printname(*pool[p3]);
							break;
						}
					}
					iAmTheLeader = false;
				}
			}
			if (iAmTheLeader) addstrAlt(CONST_reviewmode115);
			moveAlt(y++, 4 + level[p]);
			printname(*temppool[p]);
		}
		moveAlt(21, 0);
		for (stringAndColor s : liberalListAndColor) {
			set_color_easy(s.type);
			addstrAlt(s.str);
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(22, 0, CONST_reviewmode116);
		mvaddstrAlt(23, 0, CONST_reviewmode117);
		if (len(temppool) > PAGELENGTH)
		{
			mvaddstrAlt(24, 0, addpagestr());
		}
		int c = getkeyAlt();
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0) page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1)*PAGELENGTH < len(temppool)) page++;
		if (c >= 'a'&&c <= 'a' + PAGELENGTH)
		{
			int p = page * PAGELENGTH + (int)(c - 'a');
			// *JDS* can't promote liberals in hiding OR loveslaves
			if (p < len(temppool) && !temppool[p]->hiding && !(temppool[p]->flag&CREATUREFLAG_LOVESLAVE))
			{
				for (int p2 = 0; p2 < CreaturePool::getInstance().lenpool(); p2++)
				{
					if (pool[p2]->alive == 1 && pool[p2]->id == temppool[p]->hireid)
					{
						addstrAlt(pool[p2]->name);
						for (int p3 = 0; p3 < CreaturePool::getInstance().lenpool(); p3++)
						{
							// Can't promote if new boss can't accept more subordinates
							if (pool[p3]->alive == 1 && pool[p3]->id == pool[p2]->hireid &&
								(temppool[p]->flag&CREATUREFLAG_BRAINWASHED || subordinatesleft(*pool[p3])))
							{
								temppool[p]->hireid = pool[p2]->hireid;
								sortbyhire(temppool, level);
								break;
							}
						}
						break;
					}
				}
			}
		}
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
	}
}
void setColorBasedOnSiege(const int cursite, const int y, const bool p);
int consolidateSiegeLoot();
/* base - review and reorganize liberals */
void review()
{
	extern MusicClass music;
	extern squadst *activesquad;
	extern short interface_pgup;
	extern short interface_pgdn;
	extern vector<Creature *> pool;
	extern vector<squadst *> squad;
	int page = 0;
	while (true)
	{
		music.play(MUSIC_REVIEWMODE);
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(0, 0, CONST_reviewmode118);
		mvaddstrAlt(1, 0, CONST_reviewmode119); // 80 characters
		int n[8] = { 0,0,0,0,0,0,0,0 }, y = 2;
		for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
		{
			if (pool[p]->is_active_liberal()) n[0]++; // Active Liberals
			if (pool[p]->align != ALIGN_LIBERAL && pool[p]->alive) n[1]++; // Hostages
			if (pool[p]->clinic && pool[p]->alive) n[2]++; // Hospital
			if (pool[p]->is_imprisoned()) n[3]++; // Justice System
			if (pool[p]->is_lcs_sleeper()) n[4]++; // Sleepers
			if (!pool[p]->alive) n[5]++; // The Dead
			if ((pool[p]->dating || pool[p]->hiding) && pool[p]->alive) n[6]++; // Away
		}
		n[7] += consolidateSiegeLoot();

		for (int p = page * 19; p < len(squad) + REVIEWMODENUM + 1 && p < page * 19 + 19; p++, y++)
		{
			if (p < len(squad))
			{
				set_color_easy(activesquad == squad[p] ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
				mvaddcharAlt(y, 0, y + 'A' - 2); addstrAlt(spaceDashSpace);
				addstrAlt(squad[p]->name);
				if (squad[p]->squad[0] != NULL && squad[p]->squad[0]->location != -1)
				{
					setColorBasedOnSiege(squad[p]->squad[0]->location, y, activesquad == squad[p]);
					set_color_easy(activesquad == squad[p] ? WHITE_ON_BLACK_BRIGHT : WHITE_ON_BLACK);
				}
				if (squad[p]->squad[0] != NULL)
				{
					std::string str = getactivity(squad[p]->activity);
					set_activity_color(squad[p]->activity.type);
					if (squad[p]->activity.type == ACTIVITY_NONE)
					{
						bool haveact = false, multipleact = false;
						for (int p2 = 0; p2 < 6; p2++)
						{
							if (squad[p]->squad[p2] == NULL) continue;
							const std::string str2 = getactivity(squad[p]->squad[p2]->activity);
							set_activity_color(squad[p]->squad[p2]->activity.type);
							if (haveact&&str != str2) multipleact = true;
							str = str2, haveact = true;
						}
						if (multipleact)
						{
							str = CONST_reviewmode120;
							set_color_easy(WHITE_ON_BLACK_BRIGHT);
						}
					}
					mvaddstrAlt(y, 51, str);
				}
			}
			else if (p == len(squad))
			{
				set_color_easy(GREEN_ON_BLACK_BRIGHT);
				mvaddstrAlt(y, 0, CONST_reviewmode121 + tostring(n[0]) + ')');
			}
			else if (p == len(squad) + 1)
			{
				set_color_easy(RED_ON_BLACK_BRIGHT);
				mvaddstrAlt(y, 0, CONST_reviewmode122 + tostring(n[1]) + ')');
			}
			else if (p == len(squad) + 2)
			{
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(y, 0, CONST_reviewmode123 + tostring(n[2]) + ')');
			}
			else if (p == len(squad) + 3)
			{
				set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				mvaddstrAlt(y, 0, CONST_reviewmode124 + tostring(n[3]) + ')');
			}
			else if (p == len(squad) + 4)
			{
				set_color_easy(MAGENTA_ON_BLACK_BRIGHT);
				mvaddstrAlt(y, 0, CONST_reviewmode125 + tostring(n[4]) + ')');
			}
			else if (p == len(squad) + 5)
			{
				set_color_easy(BLACK_ON_BLACK_BRIGHT);
				mvaddstrAlt(y, 0, CONST_reviewmode126 + tostring(n[5]) + ')');
			}
			else if (p == len(squad) + 6)
			{
				set_color_easy(BLUE_ON_BLACK_BRIGHT);
				mvaddstrAlt(y, 0, CONST_reviewmode127 + tostring(n[6]) + ')');
			}
			else if (p == len(squad) + 7)
			{
				set_color_easy(CYAN_ON_BLACK_BRIGHT);
				mvaddstrAlt(y, 0, CONST_reviewmode128 + tostring(n[7]) + ')');
			}
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(21, 0, CONST_reviewmode129);
		if (music.isEnabled())
			mvaddstrAlt(21, 38, CONST_reviewmode130);
		else mvaddstrAlt(21, 38, CONST_reviewmode131);
		mvaddstrAlt(22, 0, CONST_reviewmode132);
		mvaddstrAlt(23, 0, addpagestr() + CONST_reviewmode133);
		mvaddstrAlt(24, 0, CONST_reviewmode134);
		int c = getkeyAlt();
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0) page--;
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 19 < len(squad) + REVIEWMODENUM) page++;
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) return;
		if (c >= 'a'&&c <= 's')
		{
			int sq = page * 19 + c - 'a';
			if (sq < len(squad) && sq >= 0)
			{
				if (squad[sq] == activesquad)assemblesquad(squad[sq]);
				else activesquad = squad[sq];
			}
		}
		if (c >= '1'&&c <= '7') review_mode(c - '1');
		if (c == '8') equipmentbaseassign();
		if (c == 'z')
		{
			assemblesquad(NULL);
			if (!activesquad&&len(squad))
				activesquad = squad[len(squad) - 1];
		}
		if (c == 't') squadlessbaseassign();
		if (c == 'u') promoteliberals();
		if (c == 'v')
		{
			char clearformess = false;
			fundreport(clearformess);
			if (clearformess) eraseAlt();
		}
		if (c == 'y') music.enableIf(!music.isEnabled());
	}
}


// #include "../includes.h"
const string CONST_shop062 = "$";
const string CONST_shop061 = "Enter - ";
const string CONST_shop060 = "B - Choose a buyer";
const string CONST_shop059 = "S - Sell something";
const string CONST_shop058 = "E - Look over Equipment";
const string CONST_shop057 = "M - Buy a Mask                ($15)";
const string CONST_shop056 = "Buyer: ";
const string CONST_shop055 = " With a Random Mask";
const string CONST_shop054 = "Z - Surprise ";
const string CONST_shop053 = "Press a Letter to select a Mask";
const string CONST_shop052 = "ÄÄÄÄPRODUCT NAMEÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?ESCRIPTIONÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ";
const string CONST_shop051 = " buy?";
const string CONST_shop050 = "Which mask will ";
const string CONST_shop049 = "SPEND.";
const string CONST_shop048 = " to Liberal Funds.";
const string CONST_shop047 = "You add $";
const string CONST_shop046 = "Really sell all clothes? (Y)es to confirm.           ";
const string CONST_shop045 = "Really sell all ammo? (Y)es to confirm.              ";
const string CONST_shop044 = "Really sell all weapons? (Y)es to confirm.           ";
const string CONST_shop043 = "Enter - Done pawning";
const string CONST_shop042 = "L - Pawn all Loot";
const string CONST_shop041 = "C - Pawn all Clothes";
const string CONST_shop040 = "A - Pawn all Ammunition";
const string CONST_shop039 = "W - Pawn all Weapons";
const string CONST_shop038 = "F - Pawn Selectively";
const string CONST_shop036 = " You can't sell damaged goods.";
const string CONST_shop035 = "Press a letter to select an item to sell.";
const string CONST_shop034 = " x";
const string CONST_shop033 = "/";
const string CONST_shop032 = "Estimated Liberal Amount: $";
const string CONST_shop031 = "What will you sell?";
const string CONST_shop029 = "Press a Letter to select an option";
const string CONST_shop028 = "ÄÄÄÄPRODUCT NAMEÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?RICEÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ";
const string CONST_shop026 = "What will ";

const string tag_letter = "letter";
const string tag_sleeperprice = "sleeperprice";
const string tag_price = "price";

const string tag_class = "class";
const string tag_item = "item";
const string tag_sell_masks = "sell_masks";
const string tag_exit = "exit";
const string tag_entry = "entry";
const string tag_department = "department";
const string tag_increase_prices_with_illegality = "increase_prices_with_illegality";
const string tag_allow_selling = "allow_selling";
const string tag_fullscreen = "fullscreen";
const string tag_on = "on";
const string tag_only_sell_legal_items = "only_sell_legal_items";

int squadsize(const squadst *st);

#include <functional>

string paranthesisDollar;
ShopOption::ShopOption() : description_(undefined), letter_(0), letter_defined_(false)
{ }
Shop::Shop(MCD_STR xmlstring)
	: allow_selling_(false), only_sell_legal_(true), increase_prices_with_illegality_(false),
	fullscreen_(false), sell_masks_(false)
{
	init(xmlstring);
}
Shop::Shop(MCD_STR xmlstring, bool fullscreen, bool only_sell_legal,
	bool increase_prices_with_illegality)
	: allow_selling_(false), only_sell_legal_(only_sell_legal),
	increase_prices_with_illegality_(increase_prices_with_illegality),
	fullscreen_(fullscreen), sell_masks_(false)
{
	init(xmlstring);
}
void Shop::init(const MCD_STR &xmlstring)
{
	CMarkup xml;
	xml.SetDoc(xmlstring);
	xml.FindElem();
	xml.IntoElem();
	while (xml.FindElem())
	{
		std::string tag = xml.GetTagName();
		if (tag == tag_only_sell_legal_items)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1 || b == 0) only_sell_legal_ = b;
		}
		else if (tag == tag_fullscreen)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1 || b == 0) fullscreen_ = b;
		}
		else if (tag == tag_allow_selling)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1 || b == 0) allow_selling_ = b;
		}
		else if (tag == tag_increase_prices_with_illegality)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1 || b == 0) increase_prices_with_illegality_ = b;
		}
		else if (tag == tag_department)
			options_.push_back(new Shop(xml.GetSubDoc(), fullscreen_, only_sell_legal_,
				increase_prices_with_illegality_));
		else if (tag == tag_entry) description_ = xml.GetData();
		else if (tag == tag_exit) exit_ = xml.GetData();
		else if (tag == tag_sell_masks)
		{
			int b = stringtobool(xml.GetData());
			if (b == 1 || b == 0) sell_masks_ = b;
		}
		else if (tag == tag_letter)
		{
			letter_ = xml.GetData()[0];
			if (97 <= letter_ && letter_ <= 122) //Check it is a letter.
				letter_defined_ = true;
			else if (65 <= letter_ && letter_ <= 90)
			{
				letter_ += 32;
				letter_defined_ = true;
			}
			else if (letter_ == '!') //Allow special character.
				letter_defined_ = true;
		}
		else if (tag == tag_item)
			options_.push_back(new ShopItem(xml.GetSubDoc(), only_sell_legal_,
				increase_prices_with_illegality_));
	}
}
Shop::~Shop()
{
	delete_and_clear(options_);
}
void Shop::enter(squadst& customers) const
{
	extern MusicClass music;
	music.play(MUSIC_SHOPPING);
	int buyer = 0;
	choose(customers, buyer);
}
void Shop::choose(squadst& customers, int& buyer) const
{
	if (fullscreen_) browse_fullscreen(customers, buyer);
	else browse_halfscreen(customers, buyer);
}
void Shop::browse_fullscreen(squadst& customers, int& buyer) const
{
	extern short interface_pgup;
	extern short interface_pgdn;
	int page = 0;
	std::vector<ShopOption*> available_options = options_;
	available_options.erase(remove_if(available_options.begin(),
		available_options.end(),
		not1(mem_fun(&ShopOption::display))),
		available_options.end());
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(0, 0, CONST_shop026);
		addstrAlt(customers.squad[buyer]->name);
		addstrAlt(CONST_shop051);
		mvaddstrAlt(1, 0, CONST_shop028);
		//Write wares and prices
		for (int p = page * 19, y = 2; p < len(available_options) && p < page * 19 + 19; p++, y++)
		{
			if (available_options[p]->is_available())
				set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);

			mvaddcharAlt(y, 0, 'A' + y - 2);
			addstrAlt(spaceDashSpace);
			addstrAlt(available_options[p]->get_description_fullscreen());
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(22, 0, CONST_shop029); //allow customize CONST_shopB061? -XML
		mvaddstrAlt(23, 0, addpagestr());
		mvaddstrAlt(24, 0, CONST_shop061 + std::string(customers.squad[buyer]->name) + singleSpace + exit_);
		int c = getkeyAlt();
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0) page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 19 < len(available_options)) page++;
		if (c >= 'a'&&c <= 's')
		{
			int p = page * 19 + c - 'a';
			if (p < len(available_options) && available_options[p]->is_available())
				available_options[p]->choose(customers, buyer);
			break;
		}
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
	}
}
void consolidateLoot(const int l);
int lenloot(const int l);
string getLootTitle(const int base, const int l);
int getFenceValueLocation(int l, int slot);
int getLootNumber(const int base, const int l);
int getLocationLootNumber(int l, int slot);
bool getCanBeSoldLocation(int l, int slot);
void decreateLocationLoot(int loc, int loot, int num);
int fenceselect(squadst& customers)
{
	extern short interface_pgup;
	extern short interface_pgdn;
	int ret = 0, page = 0;
	consolidateLoot(customers.squad[0]->base);

	vector<int> selected(lenloot(customers.squad[0]->base), 0);
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(0, 0, CONST_shop031);
		if (ret)
		{
			mvaddstrAlt(0, 30, CONST_shop032);
			addstrAlt(ret);
		}
		printparty();
		int x = 1, y = 10;
		for (int l = page * 18; l < lenloot(customers.squad[0]->base) && l < page * 18 + 18; l++)
		{
			if (selected[l])
				set_color_easy(GREEN_ON_BLACK_BRIGHT);
			else set_color_easy(WHITE_ON_BLACK);
			string itemstr = getLootTitle(customers.squad[0]->base, l);
			if (getLootNumber(customers.squad[0]->base, l) > 1)
			{
				if (selected[l])
					itemstr += singleSpace + tostring(selected[l]) + CONST_shop033;
				else itemstr += CONST_shop034;
				itemstr += tostring(getLootNumber(customers.squad[0]->base, l));
			}
			string outstr;
			outstr = static_cast<char>(l - page * 18 + 'A');
			outstr += spaceDashSpace + itemstr;
			mvaddstrAlt(y, x, outstr);
			x += 26;
			if (x > 53) x = 1, y++;
		}
		//PAGE UP
		set_color_easy(WHITE_ON_BLACK);
		if (page > 0)
		{
			mvaddstrAlt(17, 1, addprevpagestr());
		}
		//PAGE DOWN
		if ((page + 1) * 18 < lenloot(customers.squad[0]->base))
		{
			mvaddstrAlt(17, 53, addnextpagestr());
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(23, 1, CONST_shop035);
		mvaddstrAlt(24, 1, enter_done);
		int c = getkeyAlt();
		if (c >= 'a' && c <= 'r')
		{
			int slot = c - 'a' + page * 18;
			if (slot >= 0 && slot < lenloot(customers.squad[0]->base))
			{
				if (selected[slot])
				{
					ret -= getFenceValueLocation(customers.squad[0]->base, slot) * selected[slot];
					selected[slot] = 0;
				}
				else
				{
					if (!getCanBeSoldLocation(customers.squad[0]->base, slot))
					{
						printparty();
						set_color_easy(WHITE_ON_BLACK_BRIGHT);
						mvaddstrAlt(8, 15, CONST_shop036);
						pressAnyKey();
					}
					else
					{
						if (getLocationLootNumber(customers.squad[0]->base, slot) > 1)
							selected[slot] = prompt_amount(0, getLocationLootNumber(customers.squad[0]->base, slot));
						else selected[slot] = 1;
						ret += getFenceValueLocation(customers.squad[0]->base, slot) * selected[slot];
					}
				}
			}
		}
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0)
			page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) &&
			(page + 1) * 18 < lenloot(customers.squad[0]->base))
			page++;
	}
	for (int l = lenloot(customers.squad[0]->base) - 1; l >= 0; l--)
	{
		if (selected[l])
		{
			decreateLocationLoot(customers.squad[0]->base, l, selected[l]);

		}
	}
	return ret;
}
void equipLoot(int l, int loc);
void deleteLocationLoot(int loc, int loot);
int whatIsThisItemInLocation(int loc, int l);
bool noQuickFenceLocation(int loc, int l);
void sell_loot(squadst& customers)
{
	extern short party_status;
	extern class Ledger ledger;
	int partysize = squadsize(&customers);
	while (true)
	{
		eraseAlt();
		locheader();
		printparty();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(10, 1, CONST_shop058);
		if (lenloot(customers.squad[0]->base))
			set_color_easy(WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(10, 40, CONST_shop038);
		mvaddstrAlt(11, 1, CONST_shop039);
		mvaddstrAlt(11, 40, CONST_shop040);
		mvaddstrAlt(12, 1, CONST_shop041);
		mvaddstrAlt(12, 40, CONST_shop042);
		if (party_status != -1)
			set_color_easy(WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(15, 1, show_squad_liberal_status);
		if (partysize && (party_status == -1 || partysize > 1))
			set_color_easy(WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(15, 40, check_status_of_squad_liberal);
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(16, 40, CONST_shop043);
		int c = getkeyAlt();
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
		if (c == 'e'&&customers.squad[0]->base != -1)
			equipLoot(customers.squad[0]->base, -1);
		if (c == 'w' || c == 'a' || c == 'c')
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			switch (c)
			{
			case 'w': mvaddstrAlt(18, 1, CONST_shop044); break;
			case 'a': mvaddstrAlt(18, 1, CONST_shop045); break;
			case 'c': mvaddstrAlt(18, 1, CONST_shop046); break;
			}
			if (getkeyAlt() != 'y') c = 0; //no sale
		}
		if ((c == 'w' || c == 'c' || c == 'l' || c == 'a' || c == 'f') &&
			lenloot(customers.squad[0]->base))
		{
			int fenceamount = 0;
			if (c == 'f') fenceamount = fenceselect(customers);
			else
			{
				for (int l = lenloot(customers.squad[0]->base) - 1; l >= 0; l--)
				{
					if (c == 'w' && whatIsThisItemInLocation(customers.squad[0]->base, l) == THIS_IS_WEAPON
						&& getCanBeSoldLocation(customers.squad[0]->base, l))
					{
						fenceamount += getFenceValueLocation(customers.squad[0]->base, l)
							* getLocationLootNumber(customers.squad[0]->base, l);
						deleteLocationLoot(customers.squad[0]->base, l);
					}
					else if (c == 'c' && whatIsThisItemInLocation(customers.squad[0]->base, l) == THIS_IS_ARMOR
						&& getCanBeSoldLocation(customers.squad[0]->base, l))
					{
						fenceamount += getFenceValueLocation(customers.squad[0]->base, l)
							* getLocationLootNumber(customers.squad[0]->base, l);
						deleteLocationLoot(customers.squad[0]->base, l);
					}
					else if (c == 'a' && whatIsThisItemInLocation(customers.squad[0]->base, l) == THIS_IS_CLIP
						&& getCanBeSoldLocation(customers.squad[0]->base, l))
					{
						fenceamount += getFenceValueLocation(customers.squad[0]->base, l)
							* getLocationLootNumber(customers.squad[0]->base, l);
						deleteLocationLoot(customers.squad[0]->base, l);
					}
					else if (c == 'l' && whatIsThisItemInLocation(customers.squad[0]->base, l) == THIS_IS_LOOT
						&& getCanBeSoldLocation(customers.squad[0]->base, l))
					{
						if (!noQuickFenceLocation(customers.squad[0]->base, l))
						{
							fenceamount += getFenceValueLocation(customers.squad[0]->base, l)
								* getLocationLootNumber(customers.squad[0]->base, l);
							deleteLocationLoot(customers.squad[0]->base, l);
						}
					}
				}
			}
			if (fenceamount)
			{
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(8, 1, CONST_shop047);
				addstrAlt(fenceamount);
				addstrAlt(CONST_shop048);
				pressAnyKey();
				ledger.add_funds(fenceamount, INCOME_PAWN);
			}
		}
	}
}
void choose_buyer(squadst& customers, int& buyer)
{
	extern short party_status;
	party_status = -1;
	int partysize = squadsize(&customers);
	if (partysize <= 1) return;
	while (true)
	{
		printparty();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 20, chooseALiberalTo + CONST_shop049);
		int c = getkeyAlt();
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) return;
		if (c >= '1'&&c <= partysize + '1' - 1)
		{
			buyer = c - '1';
			return;
		}
	}
}
void maskselect(Creature &buyer);
void Shop::browse_halfscreen(squadst& customers, int& buyer) const
{
	extern short party_status;
	extern class Ledger ledger;
	int page = 0, partysize = squadsize(&customers);
	std::vector<ShopOption*> available_options = options_;
	available_options.erase(remove_if(available_options.begin(),
		available_options.end(),
		not1(mem_fun(&ShopOption::display))),
		available_options.end());
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		locheader();
		printparty();
		mvaddstrAlt(8, 45, CONST_shop056);
		addstrAlt(customers.squad[buyer]->name);
		//Write wares and prices
		int y = 10, x = 1, taken_letters = 0;
		for (int p = page * 19; p < len(available_options) && p < page * 19 + 20; p++)
		{
			if (available_options[p]->is_available())
				set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			int xNew;
			if (x == 1)xNew = 1;
			else xNew = 40;
			if (available_options[p]->letter_defined_)
				mvaddcharAlt(y, xNew, available_options[p]->showletter());
			else
			{
				// Find an available letter to use for this ware.
				bool done = false;
				while (taken_letters < 27 && !done)
				{
					done = true;
					if ('a' + taken_letters == 'b' || // Letters used by the shop UI are disallowed.
						'a' + taken_letters == 'e' ||
						('a' + taken_letters == 's'&&allow_selling_) ||
						('a' + taken_letters == 'm'&&sell_masks_))
					{
						taken_letters++;
						done = false;
						continue;
					}
					for (int i = 0; i < len(available_options); i++)
					{
						if (available_options[i]->letter_defined_&&
							'a' + taken_letters == available_options[i]->letter_)
						{
							taken_letters++;
							done = false;
							break;
						}
					}
				}
				available_options[p]->letter_ = 'a' + taken_letters;
				mvaddcharAlt(y, xNew, 'A' + taken_letters++);
			}
			addstrAlt(spaceDashSpace);
			addstrAlt(available_options[p]->get_description_halfscreen());
			if (x == 1) x = 2;
			else y++, x = 1;
		}
		if (sell_masks_)
		{
			if (ledger.get_funds() >= 15) set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(y, 1 + (x - 1) * 39, CONST_shop057);
		}
		if (x == 2) y++;
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(y++, 1, CONST_shop058);
		if (allow_selling_)
		{
			if (lenloot(customers.squad[0]->base))
				set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(y++, 1, CONST_shop059);
		}
		if (party_status != -1) set_color_easy(WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(++y, 1, show_squad_liberal_status);
		if (partysize > 0 && (party_status == -1 || partysize > 1))
			set_color_easy(WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(y++, 40, check_status_of_squad_liberal);
		if (partysize >= 2) set_color_easy(WHITE_ON_BLACK);
		else set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(y, 1, CONST_shop060);
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(y, 40, CONST_shop061);
		addstrAlt(exit_);
		int c = getkeyAlt();
		for (int i = 0; i < len(available_options); i++)
			if (c == available_options[i]->letter_)
			{
				available_options[i]->choose(customers, buyer); break;
			}
		if (c == 'e' && customers.squad[0]->base != -1)
			equipLoot(customers.squad[0]->base, -1);
		else if (c == 's'&&allow_selling_&&lenloot(customers.squad[0]->base))
			sell_loot(customers);
		else if (c == 'm'&&sell_masks_&&ledger.get_funds() >= 15)
			maskselect(*customers.squad[buyer]);
		else if (c == 'b') choose_buyer(customers, buyer);
		else if (c == '0') party_status = -1;
		else if (c >= '1'&&c <= '6')
		{
			if (customers.squad[c - '1'] != NULL)
			{
				if (party_status == c - '1')
					fullstatus(party_status);
				else party_status = c - '1';
			}
		}
		else if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
	}
}
bool Shop::is_available() const
{  //Disable shop (department) if it has nothing to sell.
	bool r = false;
	for (int i = 0; i < len(options_) && !(r = options_[i]->display()); i++);
	return r;
}
Shop::ShopItem::ShopItem(MCD_STR xmlstring, bool only_sell_legal,
	bool increase_price_with_illegality)
	: price_(0), only_sell_legal_(only_sell_legal),
	increase_price_with_illegality_(increase_price_with_illegality),
	description_defined_(false)
{
	CMarkup xml;
	xml.SetDoc(xmlstring);
	xml.FindElem();
	xml.IntoElem();
	while (xml.FindElem())
	{
		std::string tag = xml.GetTagName();
		if (tag == tag_class)
		{
			if (xml.GetData() == tag_WEAPON)
				itemclass_ = WEAPON;
			else if (xml.GetData() == tag_CLIP)
				itemclass_ = CLIP;
			else if (xml.GetData() == tag_ARMOR)
				itemclass_ = ARMOR;
			else if (xml.GetData() == tag_LOOT)
				itemclass_ = LOOT;
		}
		else if (tag == tag_type)
			itemtypename_ = xml.GetData();
		else if (tag == tag_description)
		{
			description_ = xml.GetData();
			description_defined_ = true;
		}
		else if (tag == tag_price)
			price_ = atoi(xml.GetData());
		else if (tag == tag_sleeperprice)
			sleeperprice_ = atoi(xml.GetData());
		else if (tag == tag_letter)
		{
			letter_ = xml.GetData()[0];
			if (97 <= letter_ && letter_ <= 122) //Check it is a letter.
				letter_defined_ = true;
			else if (65 <= letter_ && letter_ <= 90)
			{
				letter_ += 32;
				letter_defined_ = true;
			}
			else if (letter_ == '!') //Allow special character.
				letter_defined_ = true;
		}
	}
}

bool Shop::ShopItem::is_available() const
{
	return valid_item() && (!only_sell_legal_ || legal()) && can_afford();
}
const std::string Shop::ShopItem::get_description_halfscreen() const
{
	std::string r = get_description();
	r.resize(26, ' ');
	r += paranthesisDollar + tostring(adjusted_price()) + closeParenthesis;
	return r;
}
const std::string Shop::ShopItem::get_description_fullscreen() const
{
	std::string r = get_description();
	r.resize(35, ' ');
	r += CONST_shop062 + tostring(adjusted_price());
	return r;
}
bool Shop::ShopItem::display() const
{
	return(valid_item() && (!only_sell_legal_ || legal()));
}
bool Shop::ShopItem::can_afford() const
{
	extern class Ledger ledger;
	return(adjusted_price() <= ledger.get_funds());
}
bool Shop::ShopItem::legal() const
{
	extern vector<WeaponType *> weapontype;
	bool r = true;
	switch (itemclass_)
	{
	case WEAPON: r = weapontype[getweapontype(itemtypename_)]->is_legal(); break;
	case CLIP:
		// Decide if clip is legal by looping through all weapons and
		// testing if there exists a weapon such that it is legal and
		// it can take this clip. If no legal weapon can take this type
		// of clip, the clip is implicitly illegal as well.
		r = false;
		for (int i = 0; i < len(weapontype) && !r; i++)
			if (weapontype[i]->acceptable_ammo(itemtypename_) && weapontype[i]->is_legal())
				r = true;
		break;
	case ARMOR:       //Can't be illegal.
	case LOOT: break; //Can't be illegal.
	}
	return r;
}
bool Shop::ShopItem::valid_item() const
{
	int i = -1;
	switch (itemclass_)
	{
	case WEAPON: i = getweapontype(itemtypename_); break;
	case CLIP:   i = getcliptype(itemtypename_); break;
	case ARMOR:  i = getarmortype(itemtypename_); break;
	case LOOT:   i = getloottype(itemtypename_); break;
	}
	return(i != -1);
}
int Shop::ShopItem::adjusted_price() const
{
	extern short lawList[LAWNUM];
	extern vector<WeaponType *> weapontype;
	int p = price_;
	if (increase_price_with_illegality_&&itemclass_ == WEAPON && valid_item())
		for (int i = weapontype[getweapontype(itemtypename_)]->get_legality(); i < lawList[LAW_GUNCONTROL]; i++)
			p *= 2;
	return p;
}
const std::string Shop::ShopItem::get_description() const
{
	extern vector<ArmorType *> armortype;
	extern vector<ClipType *> cliptype;
	extern vector<WeaponType *> weapontype;
	if (description_defined_) return description_;
	else switch (itemclass_)
	{
	case WEAPON: return weapontype[getweapontype(itemtypename_)]->get_name();
	case CLIP:   return cliptype[getcliptype(itemtypename_)]->get_name();
	case ARMOR:  return armortype[getarmortype(itemtypename_)]->get_name();
	case LOOT:   return LootTypePool::getInstance().getName(itemtypename_); // loottype[getloottype(itemtypename_)]->get_name();
	default:     return description_; // Will be undefined
	}
}

// Removing the subsequent references to location will be difficult.
void maskselect(Creature &buyer)
{
	extern short interface_pgup;
	extern short interface_pgdn;
	extern class Ledger ledger;
	extern vector<ArmorType *> armortype;
	short maskindex = -1;
	std::vector<int> masktype;
	for (int a = 0; a < len(armortype); a++)
	{
		if (armortype[a]->is_mask() && !armortype[a]->is_surprise_mask())
			masktype.push_back(a);
	}
	int page = 0;
	while (true)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(0, 0, CONST_shop050);
		addstrAlt(buyer.name);
		addstrAlt(CONST_shop051);
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(1, 0, CONST_shop052);
		for (int p = page * 19, y = 2; p < len(masktype) && p < page * 19 + 19; p++, y++)
		{
			set_color_easy(WHITE_ON_BLACK);

			mvaddcharAlt(y, 0, y + 'A' - 2);
			addstrAlt(spaceDashSpace);
			addstrAlt(armortype[masktype[p]]->get_name());
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(y, 39, armortype[masktype[p]]->get_description());
		}
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(22, 0, CONST_shop053);
		mvaddstrAlt(23, 0, addpagestr());
		mvaddstrAlt(24, 0, CONST_shop054);
		addstrAlt(buyer.name);
		addstrAlt(CONST_shop055);
		int c = getkeyAlt();
		//PAGE UP
		if ((c == interface_pgup || c == KEY_UP || c == KEY_LEFT) && page > 0) page--;
		//PAGE DOWN
		if ((c == interface_pgdn || c == KEY_DOWN || c == KEY_RIGHT) && (page + 1) * 19 < len(masktype)) page++;
		if (c >= 'a'&&c <= 's')
		{
			int p = page * 19 + c - 'a';
			if (p < len(masktype))
			{
				maskindex = masktype[p];
				break;
			}
		}
		if (c == 'z')
		{
			for (int i = 0; i < len(armortype); i++)
				if (armortype[i]->is_mask() && armortype[i]->is_surprise_mask())
					masktype.push_back(i);
			maskindex = pickrandom(masktype);
			break;
		}
		if (c == 'x' || c == ENTER || c == ESC || c == SPACEBAR) break;
	}
	extern vector<Location *> location;
	if (maskindex != -1 && ledger.get_funds() >= 15)
	{
		Armor a = Armor(maskindex);
		buyer.give_armor(a, &location[buyer.base]->loot);
		ledger.subtract_funds(15, EXPENSE_SHOPPING);
	}
}
void Shop::ShopItem::choose(squadst& customers, int& buyer) const
{
	extern class Ledger ledger;
	extern vector<ClipType *> cliptype;
	extern vector<WeaponType *> weapontype;
	if (!is_available()) return;
	ledger.subtract_funds(adjusted_price(), EXPENSE_SHOPPING);
	extern vector<Location *> location;
	switch (itemclass_)
	{
	case WEAPON: {
		Weapon* i = new Weapon(*weapontype[getweapontype(itemtypename_)]);
		customers.squad[buyer]->give_weapon(*i, &location[customers.squad[0]->base]->loot);
		if (i->empty()) delete i;
		else location[customers.squad[0]->base]->loot.push_back(i);
		break; }
	case CLIP: {
		Clip* i = new Clip(*cliptype[getcliptype(itemtypename_)]);
		customers.squad[buyer]->take_clips(*i, 1);
		if (i->empty()) delete i;
		else location[customers.squad[0]->base]->loot.push_back(i);
		break; }
	case ARMOR: {
		Armor* i = new Armor(getarmortype(itemtypename_));
		customers.squad[buyer]->give_armor(*i, &location[customers.squad[0]->base]->loot);
		if (i->empty()) delete i;
		else location[customers.squad[0]->base]->loot.push_back(i);
		break; }
	case LOOT: {
		location[customers.squad[0]->base]->loot.push_back(getNewLoot(itemtypename_));
		break; }
	}
}

//// #include "../sitemode/advance.h"
void creatureadvance();
//// #include "../sitemode/sitemode.h"
void mode_site(short loc);
vector<string> words_meaning_news;
vector<string> newspaper_first_name;
vector<string> newspaper_last_name;
vector<string> insult_for_liberal;
vector<string> word_replacing_liberal;
vector<string> engageConservativesEscape;
vector<string> engageConservatives;
vector<string> nextSiegeAgain;
vector<string> nextSiege;
const string siege = "siege\\";

const string CONST_siege014 = "engageConservativesEscape.txt";
const string CONST_siege013 = "engageConservatives.txt";
const string CONST_siege012 = "nextSiegeAgain.txt";
const string CONST_siege011 = "nextSiege.txt";
const string CONST_siege010 = "word_replacing_liberal.txt";
const string CONST_siege009 = "insult_for_liberal.txt";
const string CONST_siege008 = "newspaper_last_name.txt";
const string CONST_siege007 = "newspaper_first_name.txt";
const string CONST_siege006 = "words_meaning_news.txt";
vector<file_and_text_collection> siege_text_file_collection = {
	/*siege.cpp*/
	customText(&words_meaning_news, siege + CONST_siege006),
	customText(&newspaper_first_name, siege + CONST_siege007),
	customText(&newspaper_last_name, siege + CONST_siege008),
	customText(&insult_for_liberal, siege + CONST_siege009),
	customText(&word_replacing_liberal, siege + CONST_siege010),
	customText(&nextSiege, mostlyendings + CONST_siege011),
	customText(&nextSiegeAgain, mostlyendings + CONST_siege012),
	customText(&engageConservatives, mostlyendings + CONST_siege013),
	customText(&engageConservativesEscape, mostlyendings + CONST_siege014),
};

void createNewStoryMassacre(const int loc, const int killnumber) {
	extern vector<newsstoryst *> newsstory;

	newsstoryst *ns = new newsstoryst;
	ns->type = NEWSSTORY_MASSACRE;
	ns->loc = loc;
	ns->crime.push_back(LocationsPool::getInstance().getSiegeType(loc));
	ns->crime.push_back(killnumber);
	newsstory.push_back(ns);
}

void createNewStoryFieldAttack(const int loc) {
	extern vector<newsstoryst *> newsstory;
	newsstoryst *ns = new newsstoryst;
	if (LocationsPool::getInstance().isThisUnderAttack(loc)) ns->type = NEWSSTORY_SQUAD_FLEDATTACK;
	else ns->type = NEWSSTORY_SQUAD_ESCAPED;
	ns->positive = 1;
	ns->loc = loc;
	ns->siegetype = LocationsPool::getInstance().getSiegeType(loc);
	newsstory.push_back(ns);
}


void emptyEncounter();
void fillEncounter(CreatureTypes c, int numleft);
// #include "../common/creaturePool.h"
/* TODO
make it less likely to be raided based on:
- the number of sleepers.
- how effective said sleepers are.
- what action each sleeper is doing (promoting liberalism decreases chance while promoting conservatism increases chance)
- what the sleeper does for a living (police officers are more influential than janitors, for instance)
make it more likely to be raided:
- when a liberal hacks or steals credit cards.
- dead bodies in the base. [DONE]
*/
/* siege - gives up on sieges with empty locations */
/* Work in progress. It works, but needs to be called in more places. */
/* Currently, it only works when you confront a siege and then fail. */
/* siege - handles giving up */
bool hasPrintingPress(int l);
void deletePrintingPress(int loc);
void deleteCompoundWalls(int loc);
void deleteBusinessFront(int loc);
void CCSCapturesSite(int loc);
void endLocationSiege(int l);
void deleteLocationLoot(int l);
void deleteLocationVehicles(int loc);
const string CONST_siege174 = "The printing press is dismantled and burned.";
const string CONST_siege188 = "!";
const string CONST_siege177 = ", an unoccupied safehouse.";
const string CONST_siege179 = " has been rescued.";
const string CONST_siege178 = "'s corpse has been recovered.";
const string CONST_siege167 = "Surrender yourselves!";

void giveup()
{
	const string CONST_siege031 = " is slain.";
	const string CONST_siege030 = "Everyone in the ";
	const string CONST_siege029 = "Materials relating to the business front have been taken.";
	const string CONST_siege028 = "The compound is dismantled.";
	const string CONST_siege026 = "Law enforcement has confiscated $%d in LCS funds.";
	const string CONST_siege025 = "Fortunately, your funds remain intact.";
	const string CONST_siege024 = " Liberals are taken to the police station.";
	const string CONST_siege023 = "is taken to the police station.";
	const string CONST_siege022 = ",";
	const string CONST_siege021 = ", aka ";
	const string CONST_siege020 = "The kidnap victims are rehabilitated and freed.";
	const string CONST_siege019 = " is rehabilitated and freed.";
	const string CONST_siege018 = " confiscate everything, including Squad weapons.";
	const string CONST_siege017 = "The firemen";
	const string CONST_siege016 = "The soldiers";
	const string CONST_siege015 = "The police";
	extern Log gamelog;
	extern squadst *activesquad;
	extern int selectedsiege;
	extern int stat_dead;
	extern short cursite;
	extern short offended_firemen;
	extern short offended_amradio;
	extern short offended_cablenews;
	extern MusicClass music;
	extern vector<Creature *> pool;
	extern vector<squadst *> squad;
	extern class Ledger ledger;
	int loc = -1;
	if (selectedsiege != -1)loc = selectedsiege;
	if (activesquad != NULL)loc = activesquad->squad[0]->location;
	if (loc == -1)return;
	if (LocationsPool::getInstance().getRentingType(loc) > 1)LocationsPool::getInstance().setRenting(loc, RENTING_NOCONTROL);
	//IF POLICE, END SIEGE
	if (LocationsPool::getInstance().getSiegeType(loc) == SIEGE_POLICE ||
		LocationsPool::getInstance().getSiegeType(loc) == SIEGE_FIREMEN)
	{
		music.play(MUSIC_SIEGE);
		int polsta = find_site_index_in_same_city(SITE_GOVERNMENT_POLICESTATION, loc);
		//END SIEGE
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		if (LocationsPool::getInstance().getSiegeType(loc) == SIEGE_POLICE && LocationsPool::getInstance().getSiegeEscalationState(loc) == 0)
			mvaddstrAlt(1, 1, CONST_siege015, gamelog);
		else if (LocationsPool::getInstance().getSiegeType(loc) == SIEGE_POLICE && LocationsPool::getInstance().getSiegeEscalationState(loc) >= 1)
			mvaddstrAlt(1, 1, CONST_siege016, gamelog);
		else mvaddstrAlt(1, 1, CONST_siege017, gamelog);
		addstrAlt(CONST_siege018, gamelog);
		gamelog.newline();
		int kcount = 0, pcount = 0, icount = 0;
		string kname;
		string pname;
		string pcname;
		for (int p = CreaturePool::getInstance().lenpool() - 1; p >= 0; p--)
		{
			if (pool[p]->location != loc || !pool[p]->alive) continue;
			if (pool[p]->flag&CREATUREFLAG_ILLEGALALIEN) icount++;
			if (pool[p]->flag&CREATUREFLAG_MISSING&&pool[p]->align == -1)
			{
				kcount++;
				kname = pool[p]->propername;
				if (pool[p]->type == CREATURE_RADIOPERSONALITY) offended_amradio = 1;
				if (pool[p]->type == CREATURE_NEWSANCHOR) offended_cablenews = 1;
				//clear InterrogationST data if deleted
				delete pool[p]->activity.intr();
			}
		}
		//CRIMINALIZE POOL IF FOUND WITH KIDNAP VICTIM OR ALIEN
		if (kcount) criminalizepool(LAWFLAG_KIDNAPPING, -1, loc);
		if (icount) criminalizepool(LAWFLAG_HIREILLEGAL, -1, loc);
		if (LocationsPool::getInstance().getSiegeType(loc) == SIEGE_FIREMEN && hasPrintingPress(loc))
			criminalizepool(LAWFLAG_SPEECH, -1, loc); // Criminalize pool for unacceptable speech
													  //LOOK FOR PRISONERS (MUST BE AFTER CRIMINALIZATION ABOVE)
		for (int p = CreaturePool::getInstance().lenpool() - 1; p >= 0; p--)
		{
			if (pool[p]->location != loc || !pool[p]->alive) continue;
			if (iscriminal(*pool[p]) && !(pool[p]->flag&CREATUREFLAG_MISSING&&pool[p]->align == -1))
			{
				pcount++;
				pname = pool[p]->propername;
				pcname = pool[p]->name;
			}
		}
		if (kcount == 1)
		{
			mvaddstrAlt(3, 1, kname);
			addstrAlt(CONST_siege019, gamelog);
			gamelog.newline();
		}
		if (kcount > 1)
		{
			mvaddstrAlt(3, 1, CONST_siege020, gamelog);
			gamelog.newline();
		}
		if (pcount == 1)
		{
			mvaddstrAlt(5, 1, pname, gamelog);
			if (pname == pcname)
			{
				addstrAlt(CONST_siege021, gamelog);
				addstrAlt(pcname, gamelog);
				addstrAlt(CONST_siege022, gamelog);
			}
			mvaddstrAlt(6, 1, CONST_siege023, gamelog);
			gamelog.newline();
		}
		if (pcount > 1)
		{
			mvaddstrAlt(5, 1, pcount, gamelog);
			addstrAlt(CONST_siege024, gamelog);
			gamelog.newline();
		}
		if (ledger.get_funds() > 0)
		{
			if (ledger.get_funds() <= 2000 || LocationsPool::getInstance().getSiegeType(loc) == SIEGE_FIREMEN)
			{
				mvaddstrAlt(8, 1, CONST_siege025, gamelog);
				gamelog.newline();
			}
			else
			{
				int confiscated = LCSrandom(LCSrandom(ledger.get_funds() - 2000) + 1) + 1000;
				if (ledger.get_funds() - confiscated > 50000)
					confiscated += ledger.get_funds() - 30000 - LCSrandom(20000) - confiscated;
				mvaddstr_fl(8, 1, gamelog, CONST_siege026.c_str(), confiscated);
				gamelog.newline();
				ledger.subtract_funds(confiscated, EXPENSE_CONFISCATED);
			}
		}
		if (LocationsPool::getInstance().getSiegeType(loc) == SIEGE_FIREMEN)
		{
			if (hasPrintingPress(loc))
			{
				mvaddstrAlt(10, 1, CONST_siege174, gamelog);
				gamelog.newline();
				deletePrintingPress(loc);
			}
		}
		else
		{
			if (LocationsPool::getInstance().getCompoundWalls(loc))
			{
				mvaddstrAlt(10, 1, CONST_siege028, gamelog);
				gamelog.newline();
				deleteCompoundWalls(loc);
			}
		}
		if (LocationsPool::getInstance().isThisAFront(loc) != -1)
		{
			mvaddstrAlt(12, 1, CONST_siege029, gamelog);
			gamelog.newline();
			deleteBusinessFront(loc);
		}
		pressAnyKey();
		if (LocationsPool::getInstance().getSiegeType(loc) == SIEGE_FIREMEN)
			offended_firemen = 0; // Firemen do not hold grudges
		for (int p = CreaturePool::getInstance().lenpool() - 1; p >= 0; p--)
		{
			if (pool[p]->location != loc) continue;
			//ALL KIDNAP VICTIMS FREED REGARDLESS OF CRIMES
			if ((pool[p]->flag & CREATUREFLAG_MISSING) ||
				!pool[p]->alive)
			{
				// Clear actions for anybody who was tending to this person
				for (int i = 0; i < CreaturePool::getInstance().lenpool(); i++)
					if (pool[i]->alive&&pool[i]->activity.type == ACTIVITY_HOSTAGETENDING && pool[i]->activity.arg == pool[p]->id)
						pool[i]->activity.type = ACTIVITY_NONE;
				removesquadinfo(*pool[p]);
				delete_and_remove(pool, p);
				continue;
			}
			//TAKE SQUAD EQUIPMENT
			if (pool[p]->squadid != -1)
			{
				int sq = getsquad(pool[p]->squadid);
				if (sq != -1)delete_and_clear(squad[sq]->loot);
			}
			pool[p]->drop_weapons_and_clips(NULL);
			if (iscriminal(*pool[p]))
			{
				removesquadinfo(*pool[p]);
				pool[p]->location = polsta;
				pool[p]->activity.type = ACTIVITY_NONE;
			}
		}
		endLocationSiege(loc);
	}
	else
	{
		//OTHERWISE IT IS SUICIDE
		int killnumber = 0;
		for (int p = CreaturePool::getInstance().lenpool() - 1; p >= 0; p--)
		{
			if (pool[p]->location != loc) continue;
			if (pool[p]->alive&&pool[p]->align == 1) stat_dead++;
			killnumber++;
			removesquadinfo(*pool[p]);
			pool[p]->die();
			pool[p]->location = -1;
		}
		if (LocationsPool::getInstance().getSiegeType(loc) == SIEGE_CCS && LocationsPool::getInstance().getLocationType(loc) == SITE_INDUSTRY_WAREHOUSE)
			CCSCapturesSite(loc);
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(1, 1, CONST_siege030, gamelog);
		addstrAlt(LocationsPool::getInstance().getLocationName(loc), gamelog);
		addstrAlt(CONST_siege031, gamelog);
		gamelog.newline();
		if (!endcheck(-2)) music.play(MUSIC_SIEGE); // play correct music for if we lost the game or didn't lose it
		pressAnyKey();
		createNewStoryMassacre(loc, killnumber);
		//MUST SET cursite TO SATISFY endcheck() CODE
		int tmp = cursite;
		cursite = loc;
		endcheck();
		cursite = tmp;
		endLocationSiege(loc);
	}
	//CONFISCATE MATERIAL
	deleteLocationLoot(loc);
	deleteLocationVehicles(loc);
	gamelog.newline();
}
void resolvesafehouses()
{
	extern int selectedsiege;
	for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++)
	{
		if (LocationsPool::getInstance().getRentingType(l) >= 0 && LocationsPool::getInstance().isThereASiegeHere(l))
		{
			cleangonesquads();
			selectedsiege = l; // hack for calling giveup()
			giveup();
		}
	}
}


/* siege - CONST_siege032 */
void statebrokenlaws(int loc)
{
	const string CONST_siege075 = " and other crimes";
	const string CONST_siege074 = "You are wanted for harboring a fugitive from justice";
	const string CONST_siege073 = "You are wanted for loitering";
	const string CONST_siege072 = "You are wanted for indecent exposure";
	const string CONST_siege071 = "You are wanted for disturbing the peace";
	const string CONST_siege070 = "You are wanted for resisting arrest";
	const string CONST_siege069 = "You are wanted for vandalism";
	const string CONST_siege068 = "You are wanted for breaking and entering";
	const string CONST_siege067 = "You are wanted for unlawful burial";
	const string CONST_siege066 = "You are wanted for unlawful access of an information system";
	const string CONST_siege065 = "You are wanted for interference with interstate commerce";
	const string CONST_siege062 = "You are wanted for hiring an illegal alien";
	const string CONST_siege061 = "You are wanted for prostitution";
	const string CONST_siege060 = "You are wanted for petty larceny";
	const string CONST_siege059 = "You are wanted for credit card fraud";
	const string CONST_siege058 = "You are wanted for grand theft auto";
	const string CONST_siege057 = "You are wanted for misdemeanor assault";
	const string CONST_siege056 = "You are wanted for assault with a deadly weapon";
	const string CONST_siege055 = "You are wanted for extortion";
	const string CONST_siege054 = "You are wanted for racketeering";
	const string CONST_siege053 = "You are wanted for jury tampering";
	const string CONST_siege052 = "You are wanted for aiding a prison escape";
	const string CONST_siege051 = "You are wanted for escaping prison";
	const string CONST_siege050 = "You are wanted for sale and distribution of a controlled substance";
	const string CONST_siege049 = "You are wanted for sedition";
	const string CONST_siege048 = "You are wanted for flag burning";
	const string CONST_siege047 = "You are wanted for felony flag burning";
	const string CONST_siege046 = "You are wanted for Flag Murder";
	const string CONST_siege045 = "You are wanted for arson";
	const string CONST_siege044 = "You are wanted for bank robbery";
	const string CONST_siege043 = "You are wanted for kidnapping";
	const string CONST_siege042 = "You are wanted for first degree murder";
	const string CONST_siege041 = "You are wanted for terrorism";
	const string CONST_siege040 = "You are wanted for treason";
	const string CONST_siege039 = " unharmed!";
	const string CONST_siege038 = " and the others";
	const string CONST_siege037 = "Release ";
	const string CONST_siege035 = "In the name of God, your campaign of terror ends here!";
	const string CONST_siege034 = "You hear a blaring voice on a loudspeaker:";
	const string CONST_siege033 = "You hear shouts:";
	const string CONST_siegeB252 = "You are wanted for hiring an undocumented worker";
	extern Log gamelog;
	extern MusicClass music;
	extern short lawList[LAWNUM];
	extern vector<Creature *> pool;
	music.play(MUSIC_SIEGE);
	short breakercount[LAWFLAGNUM] = { 0 };
	int typenum = 0, criminalcount = 0, kidnapped = 0;
	string kname;
	for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
	{
		if (!pool[p]->alive || pool[p]->location != loc) continue;
		if (pool[p]->flag&CREATUREFLAG_KIDNAPPED)
		{
			kname = pool[p]->propername;
			kidnapped++;
		}
		if (iscriminal(*pool[p])) criminalcount++;
		for (int i = 0; i < LAWFLAGNUM; i++) if (pool[p]->crimes_suspected[i]) breakercount[i]++;
	}
	for (int i = 0; i < LAWFLAGNUM; i++) if (breakercount[i]) typenum++;
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	if (LocationsPool::getInstance().isThisUnderAttack(loc)) mvaddstrAlt(1, 1, CONST_siege033, gamelog);
	else mvaddstrAlt(1, 1, CONST_siege034, gamelog);
	gamelog.newline();
	if (LocationsPool::getInstance().getSiegeEscalationState(loc) >= 2 && publicmood(-1) < 20)
		mvaddstrAlt(3, 1, CONST_siege035, gamelog);
	else mvaddstrAlt(3, 1, CONST_siege167, gamelog);
	gamelog.newline();
	//KIDNAP VICTIM
	if (kidnapped)
	{
		mvaddstrAlt(4, 1, CONST_siege037, gamelog);
		addstrAlt(kname, gamelog);
		if (kidnapped > 1) addstrAlt(CONST_siege038, gamelog);
		addstrAlt(CONST_siege039, gamelog);
	}
	//TREASON
	else if (breakercount[LAWFLAG_TREASON])
		mvaddstrAlt(4, 1, CONST_siege040, gamelog);
	//TERRORISM
	else if (breakercount[LAWFLAG_TERRORISM])
		mvaddstrAlt(4, 1, CONST_siege041, gamelog);
	//MURDERER
	else if (breakercount[LAWFLAG_MURDER])
		mvaddstrAlt(4, 1, CONST_siege042, gamelog);
	//KIDNAPPER
	else if (breakercount[LAWFLAG_KIDNAPPING])
		mvaddstrAlt(4, 1, CONST_siege043, gamelog);
	//BANK ROBBER
	else if (breakercount[LAWFLAG_BANKROBBERY])
		mvaddstrAlt(4, 1, CONST_siege044, gamelog);
	//ARSONIST
	else if (breakercount[LAWFLAG_ARSON])
		mvaddstrAlt(4, 1, CONST_siege045, gamelog);
	//BURN FLAG
	else if (breakercount[LAWFLAG_BURNFLAG])
	{
		if (lawList[LAW_FLAGBURNING] == -2)mvaddstrAlt(4, 1, CONST_siege046, gamelog);
		else if (lawList[LAW_FLAGBURNING] == -1)mvaddstrAlt(4, 1, CONST_siege047, gamelog);
		else mvaddstrAlt(4, 1, CONST_siege048, gamelog);
	}
	//SPEECH
	else if (breakercount[LAWFLAG_SPEECH])
		mvaddstrAlt(4, 1, CONST_siege049, gamelog);
	//BROWNIES
	else if (breakercount[LAWFLAG_BROWNIES])
		mvaddstrAlt(4, 1, CONST_siege050, gamelog);
	//ESCAPED
	else if (breakercount[LAWFLAG_ESCAPED])
		mvaddstrAlt(4, 1, CONST_siege051, gamelog);
	//HELP ESCAPED
	else if (breakercount[LAWFLAG_HELPESCAPE])
		mvaddstrAlt(4, 1, CONST_siege052, gamelog);
	//JURY
	else if (breakercount[LAWFLAG_JURY])
		mvaddstrAlt(4, 1, CONST_siege053, gamelog);
	//RACKETEERING
	else if (breakercount[LAWFLAG_RACKETEERING])
		mvaddstrAlt(4, 1, CONST_siege054, gamelog);
	//EXTORTION
	else if (breakercount[LAWFLAG_EXTORTION])
		mvaddstrAlt(4, 1, CONST_siege055, gamelog);
	//ASSAULT
	else if (breakercount[LAWFLAG_ARMEDASSAULT])
		mvaddstrAlt(4, 1, CONST_siege056, gamelog);
	//ASSAULT
	else if (breakercount[LAWFLAG_ASSAULT])
		mvaddstrAlt(4, 1, CONST_siege057, gamelog);
	//CAR THEFT
	else if (breakercount[LAWFLAG_CARTHEFT])
		mvaddstrAlt(4, 1, CONST_siege058, gamelog);
	//CC FRAUD
	else if (breakercount[LAWFLAG_CCFRAUD])
		mvaddstrAlt(4, 1, CONST_siege059, gamelog);
	//THIEF
	else if (breakercount[LAWFLAG_THEFT])
		mvaddstrAlt(4, 1, CONST_siege060, gamelog);
	//PROSTITUTION
	else if (breakercount[LAWFLAG_PROSTITUTION])
		mvaddstrAlt(4, 1, CONST_siege061, gamelog);
	//HIRE ILLEGAL
	else if (breakercount[LAWFLAG_HIREILLEGAL])
		mvaddstrAlt(4, 1, (lawList[LAW_IMMIGRATION] < 1 ? CONST_siege062 : CONST_siegeB252), gamelog);
	//COMMERCE
	else if (breakercount[LAWFLAG_COMMERCE])
		mvaddstrAlt(4, 1, CONST_siege065, gamelog);
	//INFORMATION
	else if (breakercount[LAWFLAG_INFORMATION])
		mvaddstrAlt(4, 1, CONST_siege066, gamelog);
	//UNLAWFUL BURIAL
	else if (breakercount[LAWFLAG_BURIAL])
		mvaddstrAlt(4, 1, CONST_siege067, gamelog);
	//BREAKING
	else if (breakercount[LAWFLAG_BREAKING])
		mvaddstrAlt(4, 1, CONST_siege068, gamelog);
	//VANDALISM
	else if (breakercount[LAWFLAG_VANDALISM])
		mvaddstrAlt(4, 1, CONST_siege069, gamelog);
	//RESIST
	else if (breakercount[LAWFLAG_RESIST])
		mvaddstrAlt(4, 1, CONST_siege070, gamelog);
	//DISTURBANCE
	else if (breakercount[LAWFLAG_DISTURBANCE])
		mvaddstrAlt(4, 1, CONST_siege071, gamelog);
	//PUBLIC NUDITY
	else if (breakercount[LAWFLAG_PUBLICNUDITY])
		mvaddstrAlt(4, 1, CONST_siege072, gamelog);
	//LOITERING
	else if (breakercount[LAWFLAG_LOITERING])
		mvaddstrAlt(4, 1, CONST_siege073, gamelog);
	//THEY WERE LOOKING FOR SOMEONE ELSE
	else mvaddstrAlt(4, 1, CONST_siege074, gamelog);
	if (!kidnapped)
	{
		if (typenum > 1) addstrAlt(CONST_siege075, gamelog);
		addstrAlt(singleDot, gamelog);
	}
	gamelog.nextMessage();
	pressAnyKey();
}
void statebrokenlaws(Creature & cr)
{
	const string CONST_siegeB254 = "HIRING UNDOCUMENTED WORKERS";
	const string CONST_siegeB253 = "FLAG BURNING";
	const string CONST_siege109 = "LOITERING";
	const string CONST_siege108 = "PUBLIC NUDITY";
	const string CONST_siege107 = "DISTURBING THE PEACE";
	const string CONST_siege106 = "RESISTING ARREST";
	const string CONST_siege105 = "VANDALISM";
	const string CONST_siege104 = "BREAKING AND ENTERING";
	const string CONST_siege103 = "UNLAWFUL BURIAL";
	const string CONST_siege102 = "HACKING";
	const string CONST_siege101 = "ELECTRONIC SABOTAGE";
	const string CONST_siege098 = "HIRING ILLEGAL ALIENS";
	const string CONST_siege097 = "PROSTITUTION";
	const string CONST_siege096 = "THEFT";
	const string CONST_siege095 = "CREDIT CARD FRAUD";
	const string CONST_siege094 = "GRAND THEFT AUTO";
	const string CONST_siege093 = "ASSAULT";
	const string CONST_siege092 = "ARMED ASSAULT";
	const string CONST_siege091 = "EXTORTION";
	const string CONST_siege090 = "RACKETEERING";
	const string CONST_siege089 = "JURY TAMPERING";
	const string CONST_siege088 = "RELEASING PRISONERS";
	const string CONST_siege087 = "ESCAPING PRISON";
	const string CONST_siege086 = "DRUG DEALING";
	const string CONST_siege085 = "HARMFUL SPEECH";
	const string CONST_siege084 = "FLAG MURDER";
	const string CONST_siege083 = "ARSON";
	const string CONST_siege082 = "BANK ROBBERY";
	const string CONST_siege081 = "KIDNAPPING";
	const string CONST_siege080 = "MURDER";
	const string CONST_siege079 = "TERRORISM";
	const string CONST_siege078 = "TREASON";
	const string CONST_siege077 = "REHABILITATION";
	const string CONST_siege076 = "WANTED FOR ";
	extern short lawList[LAWNUM];
	bool kidnapped = (cr.flag&CREATUREFLAG_KIDNAPPED), criminal = false, breakercount[LAWFLAGNUM];
	for (int i = 0; i < LAWFLAGNUM; i++)
		if (cr.crimes_suspected[i]) breakercount[i] = true, criminal = true;
		else breakercount[i] = false;
		if (!criminal && !kidnapped) return;
		set_color_easy(YELLOW_ON_BLACK_BRIGHT);
		addstrAlt(CONST_siege076);
		//KIDNAP VICTIM
		if (kidnapped)
			addstrAlt(CONST_siege077);
		//TREASON
		else if (breakercount[LAWFLAG_TREASON])
			addstrAlt(CONST_siege078);
		//TERRORISM
		else if (breakercount[LAWFLAG_TERRORISM])
			addstrAlt(CONST_siege079);
		//MURDERER
		else if (breakercount[LAWFLAG_MURDER])
			addstrAlt(CONST_siege080);
		//KIDNAPPER
		else if (breakercount[LAWFLAG_KIDNAPPING])
			addstrAlt(CONST_siege081);
		//BANK ROBBER
		else if (breakercount[LAWFLAG_BANKROBBERY])
			addstrAlt(CONST_siege082);
		//ARSONIST
		else if (breakercount[LAWFLAG_BANKROBBERY])
			addstrAlt(CONST_siege083);
		//BURN FLAG
		else if (breakercount[LAWFLAG_BURNFLAG])
			addstrAlt(lawList[LAW_FLAGBURNING] == -2 ? CONST_siege084 : CONST_siegeB253);
		//SPEECH
		else if (breakercount[LAWFLAG_SPEECH])
			addstrAlt(CONST_siege085);
		//BROWNIES
		else if (breakercount[LAWFLAG_BROWNIES])
			addstrAlt(CONST_siege086);
		//ESCAPED
		else if (breakercount[LAWFLAG_ESCAPED])
			addstrAlt(CONST_siege087);
		//HELP ESCAPED
		else if (breakercount[LAWFLAG_HELPESCAPE])
			addstrAlt(CONST_siege088);
		//JURY
		else if (breakercount[LAWFLAG_JURY])
			addstrAlt(CONST_siege089);
		//RACKETEERING
		else if (breakercount[LAWFLAG_RACKETEERING])
			addstrAlt(CONST_siege090);
		//EXTORTION
		else if (breakercount[LAWFLAG_EXTORTION])
			addstrAlt(CONST_siege091);
		//ASSAULT
		else if (breakercount[LAWFLAG_ARMEDASSAULT])
			addstrAlt(CONST_siege092);
		//ASSAULT
		else if (breakercount[LAWFLAG_ASSAULT])
			addstrAlt(CONST_siege093);
		//CAR THEFT
		else if (breakercount[LAWFLAG_CARTHEFT])
			addstrAlt(CONST_siege094);
		//CC FRAUD
		else if (breakercount[LAWFLAG_CCFRAUD])
			addstrAlt(CONST_siege095);
		//THIEF
		else if (breakercount[LAWFLAG_THEFT])
			addstrAlt(CONST_siege096);
		//PROSTITUTION
		else if (breakercount[LAWFLAG_PROSTITUTION])
			addstrAlt(CONST_siege097);
		//HIRE ILLEGAL
		else if (breakercount[LAWFLAG_HIREILLEGAL])
			addstrAlt(lawList[LAW_IMMIGRATION] < 1 ? CONST_siege098 : CONST_siegeB254);
		//COMMERCE
		else if (breakercount[LAWFLAG_COMMERCE])
			addstrAlt(CONST_siege101);
		//INFORMATION
		else if (breakercount[LAWFLAG_INFORMATION])
			addstrAlt(CONST_siege102);
		//UNLAWFUL BURIAL
		else if (breakercount[LAWFLAG_BURIAL])
			addstrAlt(CONST_siege103);
		//BREAKING
		else if (breakercount[LAWFLAG_BREAKING])
			addstrAlt(CONST_siege104);
		//VANDALISM
		else if (breakercount[LAWFLAG_VANDALISM])
			addstrAlt(CONST_siege105);
		//RESIST
		else if (breakercount[LAWFLAG_RESIST])
			addstrAlt(CONST_siege106);
		//DISTURBANCE
		else if (breakercount[LAWFLAG_DISTURBANCE])
			addstrAlt(CONST_siege107);
		//PUBLIC NUDITY
		else if (breakercount[LAWFLAG_PUBLICNUDITY])
			addstrAlt(CONST_siege108);
		//LOITERING
		else if (breakercount[LAWFLAG_LOITERING])
			addstrAlt(CONST_siege109);
}
/* siege - updates upcoming sieges */
void dropHeatByFivePercent(int l);
int getTimeUntilSiege(int l);
void huntFasterIfSiteIncrediblyHot(int l);
void updateLocationHeatProtection(int l);
void letPlaceCoolOffUnlessCrime(int crimes, int l);
void policeSiege(int l);
void corporateSiege(int l);
void CCSSiege(int l);
void CIASiege(int l);
void hicksSiege(int l);
void firemanSiege(int l);
bool hasCameras(int l);
bool hasAGenerator(int l);
bool hasBusinessFront(int l);
bool siteHasAAGun(int l);
void deleteAAGun(int l);

int allCreatureHeatGeneration(const int l, int& numpres) {
	extern Log gamelog;
	extern short offended_corps;
	int crimes = 0;
	extern vector<Creature *> pool;
	for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
	{
		// Sleepers and people not at this base don't count
		if (pool[p]->location != l || pool[p]->flag & CREATUREFLAG_SLEEPER)continue;
		if (!pool[p]->alive) // Corpses attract attention
		{
			crimes += 5;
			continue;
		}
		if (pool[p]->flag & CREATUREFLAG_KIDNAPPED && pool[p]->align != 1)
		{
			crimes += 5 * pool[p]->joindays; // Kidnapped persons increase heat
			continue;
		}
		if (pool[p]->align != 1)continue; // Non-liberals don't count other than that
		numpres++;
		// Accumulate heat from liberals who have it, but let them bleed it off in the process
		if (pool[p]->heat > 0)
		{
			crimes += pool[p]->heat / (pool[p]->activity.type == ACTIVITY_NONE ? 60 : 10) + 1;
			pool[p]->heat -= min(pool[p]->activity.type == ACTIVITY_NONE ? pool[p]->heat / 10 : 5, pool[p]->heat);
		}
	}
	return crimes;
}
void possibleWarningFromSleepers(const int l) {
	extern Log gamelog;

	const string CONST_siege116 = "Press Esc to ponder the situation...";
	const string CONST_siege115 = "attack will be carried out by SEAL Team 6.";
	const string CONST_siege114 = "Planes will bomb the compound during the siege, and the final ";
	const string CONST_siege113 = "A tank will cover the entrance to the compound.";
	const string CONST_siege112 = "The fighting force will be composed of national guard troops.";
	const string CONST_siege111 = "an imminent police raid on ";
	const string CONST_siege110 = "You have received advance warning from your sleepers regarding ";

	extern vector<Creature *> pool;
	int policesleeperwarning = 0;
	for (int pl = 0; pl < CreaturePool::getInstance().lenpool(); pl++)
	{
		if (pool[pl]->flag & CREATUREFLAG_SLEEPER &&
			pool[pl]->location != -1 &&
			LocationsPool::getInstance().getLocationType(pool[pl]->location) == SITE_GOVERNMENT_POLICESTATION &&
			LocationsPool::getInstance().getLocationCity(pool[pl]->location) == LocationsPool::getInstance().getLocationCity(l))
		{
			//if(pool[pl]->infiltration*100>LCSrandom(50))
			{
				policesleeperwarning = 1;
				break;
			}
		}
	}
	if (policesleeperwarning)
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, CONST_siege110, gamelog);
		mvaddstrAlt(9, 1, CONST_siege111, gamelog);
		addstrAlt(LocationsPool::getInstance().getLocationName(l));
		addstrAlt(singleDot, gamelog);
		gamelog.newline();
		if (LocationsPool::getInstance().getSiegeEscalationState(l) >= 1)
		{
			mvaddstrAlt(11, 1, CONST_siege112, gamelog);
		}
		if (LocationsPool::getInstance().getSiegeEscalationState(l) >= 2)
		{
			mvaddstrAlt(12, 1, CONST_siege113, gamelog);
		}
		if (LocationsPool::getInstance().getSiegeEscalationState(l) >= 3)
		{
			mvaddstrAlt(13, 1, CONST_siege114, gamelog);
			mvaddstrAlt(14, 1, CONST_siege115, gamelog);
		}
		gamelog.nextMessage(); //Write out buffer to prepare for next message.
		mvaddstrAlt(15, 1, CONST_siege116);
		pressSpecificKey('x', ESC);
	}
}
void policeSiegePrint(const int l, const int numpres) {
	extern Log gamelog;
	extern short offended_corps;

	extern MusicClass music;
	extern vector<Creature *> pool;

	const string CONST_siege124 = "The cops have raided the ";
	const string CONST_siege123 = "You are wanted for blahblah and other crimes.";
	const string CONST_siege122 = "You hear jet bombers streak overhead.";
	const string CONST_siege121 = "An M1 Abrams Tank takes up position outside the compound.";
	const string CONST_siege120 = "An M1 Abrams Tank is stopped by the tank traps.";
	const string CONST_siege119 = "National Guard troops are replacing normal SWAT units.";
	const string CONST_siege117 = "The police have surrounded the ";

	LocationsPool::getInstance().setSiegetimeuntillocated(l, -2);
	LocationsPool::getInstance().clearHeat(l);
	if (numpres > 0)
	{
		music.play(MUSIC_SIEGE);
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, CONST_siege117, gamelog);
		addstrAlt(LocationsPool::getInstance().getLocationName(l), gamelog);
		addstrAlt(CONST_siege188, gamelog);
		gamelog.newline();
		LocationsPool::getInstance().clearunderattack(l);
		pressAnyKey();
		//MENTION ESCALATION STATE
		if (LocationsPool::getInstance().getSiegeEscalationState(l) >= 1)
		{
			mvaddstrAlt(9, 1, CONST_siege119, gamelog);
			gamelog.nextMessage();
			pressAnyKey();
		}
		if (LocationsPool::getInstance().getSiegeEscalationState(l) >= 2)
		{
			if (LocationsPool::getInstance().doWeHaveTankTraps(l))
				mvaddstrAlt(10, 1, CONST_siege120, gamelog);
			else mvaddstrAlt(10, 1, CONST_siege121, gamelog);
			gamelog.nextMessage();
			pressAnyKey();
		}
		if (LocationsPool::getInstance().getSiegeEscalationState(l) >= 3)
		{
			mvaddstrAlt(11, 1, CONST_siege122, gamelog);
			gamelog.nextMessage();
			pressAnyKey();
		}
		// CONST_siege123
		statebrokenlaws(l);
		policeSiege(l);
	}
	else
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, CONST_siege124, gamelog);
		addstrAlt(LocationsPool::getInstance().getLocationName(l), gamelog);
		addstrAlt(CONST_siege177, gamelog);
		gamelog.newline();
		pressAnyKey();
		int y = 9;
		for (int p = CreaturePool::getInstance().lenpool() - 1; p >= 0; p--)
		{
			if (pool[p]->location != l) continue;
			if (!pool[p]->alive)
			{
				mvaddstrAlt(y, 1, pool[p]->name, gamelog);
				addstrAlt(CONST_siege178, gamelog);
				gamelog.newline();
				pressAnyKey();
				delete_and_remove(pool, p);
				y++;
				continue;
			}
			if (pool[p]->align != 1)
			{
				mvaddstrAlt(y, 1, pool[p]->name, gamelog);
				addstrAlt(CONST_siege179, gamelog);
				gamelog.newline();
				pressAnyKey();
				delete_and_remove(pool, p);
				y++;
				continue;
			}
		}
		gamelog.newline();
		deleteLocationLoot(l);
		deleteLocationVehicles(l);
	}
}

void possiblyWarnOfCorpSiege(const int l) {
	extern Log gamelog;

	extern vector<Creature *> pool;

	const string CONST_siege133 = "the LCS";
	const string CONST_siege132 = "are hiring mercenaries to attack ";
	const string CONST_siege131 = " that the Corporations ";
	const string CONST_siege130 = "an anonymous tip";
	const string CONST_siege129 = "your sleeper CEO's warning";
	const string CONST_siege128 = "You have received ";

	LocationsPool::getInstance().setTimeUntilSiege(l, SIEGE_CORPORATE, LCSrandom(3) + 1);
	// *JDS* CEO sleepers may give a warning before corp raids
	int ceosleepercount = 0;
	for (int pl = 0; pl < CreaturePool::getInstance().lenpool(); pl++)
	{
		if (pool[pl]->flag & CREATUREFLAG_SLEEPER&&
			pool[pl]->type == CREATURE_CORPORATE_CEO)
		{
			ceosleepercount = 1;
		}
	}
	if (ceosleepercount || !LCSrandom(5))
	{
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, CONST_siege128, gamelog);
		if (ceosleepercount)addstrAlt(CONST_siege129, gamelog);
		else addstrAlt(CONST_siege130, gamelog);
		addstrAlt(CONST_siege131, gamelog);
		mvaddstrAlt(9, 1, CONST_siege132, gamelog);
		if (ceosleepercount)addstrAlt(LocationsPool::getInstance().getLocationName(l), gamelog);
		else addstrAlt(CONST_siege133, gamelog);
		addstrAlt(singleDot, gamelog);
		gamelog.nextMessage();
		pressAnyKey();
	}
}

void corporateSiegePrint(const int l) {
	extern Log gamelog;
	extern short offended_corps;
	const string CONST_siege134 = "Corporate mercenaries are raiding the ";

	extern MusicClass music;

	music.play(MUSIC_SIEGE);
	LocationsPool::getInstance().setTimeUntilSiege(l, SIEGE_CORPORATE, -1);
	// Corps raid!
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(8, 1, CONST_siege134, gamelog);
	addstrAlt(LocationsPool::getInstance().getLocationName(l), gamelog);
	addstrAlt(CONST_siege188, gamelog);
	gamelog.nextMessage();
	pressAnyKey();
	corporateSiege(l);
	offended_corps = 0;
}

void CCSSiegePrint(const int l, const int numpres) {
	extern Log gamelog;
	extern vector<Creature *> pool;
	extern MusicClass music;

	const string CONST_siege144 = "CCS members pour out of the truck and shoot in the front doors!";
	const string CONST_siege143 = "INJURED: ";
	const string CONST_siege142 = "KILLED: ";
	const string CONST_siege141 = "CCS CAR BOMBING CASUALTY REPORT";
	const string CONST_siege140 = "The truck plows into the building and explodes!";
	const string CONST_siege138 = "A screeching truck pulls up to ";
	const string CONST_siege137 = " is gearing up to attack ";
	const string CONST_siege136 = "You have received a sleeper warning that the CCS ";

	if (LocationsPool::getInstance().getHeat(l) && LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_CCS) == -1 && !LocationsPool::getInstance().isThereASiegeHere(l) && !LCSrandom(60) && numpres > 0)
	{
		LocationsPool::getInstance().setTimeUntilSiege(l, SIEGE_CCS, LCSrandom(3) + 1);
		// CCS sleepers may give a warning before raids
		int ccssleepercount = 0;
		for (int pl = 0; pl < CreaturePool::getInstance().lenpool(); pl++)
		{
			if (pool[pl]->flag & CREATUREFLAG_SLEEPER &&
				(pool[pl]->type == CREATURE_CCS_VIGILANTE || pool[pl]->type == CREATURE_CCS_ARCHCONSERVATIVE ||
					pool[pl]->type == CREATURE_CCS_MOLOTOV || pool[pl]->type == CREATURE_CCS_SNIPER))
			{
				ccssleepercount = 1;
				break;
			}
		}
		if (ccssleepercount > 0)
		{
			eraseAlt();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(8, 1, CONST_siege136, gamelog);
			mvaddstrAlt(9, 1, CONST_siege137, gamelog);
			addstrAlt(LocationsPool::getInstance().getLocationName(l), gamelog);
			addstrAlt(singleDot, gamelog);
			gamelog.nextMessage();
			pressAnyKey();
		}
	}
	else if (LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_CCS) > 0)LocationsPool::getInstance().setTimeUntilSiege(l, SIEGE_CCS, LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_CCS) - 1); // CCS raid countdown!
	else if (LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_CCS) == 0 && !LocationsPool::getInstance().isThereASiegeHere(l) && numpres > 0)
	{
		music.play(MUSIC_SIEGE);
		LocationsPool::getInstance().setTimeUntilSiege(l, SIEGE_CCS, -1);
		// CCS raid!
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, CONST_siege138, gamelog);
		addstrAlt(LocationsPool::getInstance().getLocationName(l), gamelog);
		addstrAlt(CONST_siege188, gamelog);
		gamelog.newline();
		pressAnyKey();
		if (!(LocationsPool::getInstance().doWeHaveTankTraps(l)) &&
			!LCSrandom(5))
		{
			// CCS Carbombs safehouse!!
			eraseAlt();
			set_color_easy(RED_ON_BLACK_BRIGHT);
			mvaddstrAlt(8, 1, CONST_siege140, gamelog);
			gamelog.nextMessage();
			pressAnyKey();
			eraseAlt();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(0, 1, CONST_siege141);
			mvaddstrAlt(2, 1, CONST_siege142);
			int killed_y = 2;
			int killed_x = 9;
			mvaddstrAlt(6, 1, CONST_siege143);
			int injured_y = 6;
			int injured_x = 10;
			for (int i = 0; i < CreaturePool::getInstance().lenpool(); i++)
			{
				if (pool[i]->location == l)
				{
					if (LCSrandom(2))
					{
						int namelength = len(pool[i]->name);
						pool[i]->blood -= LCSrandom(101 - pool[i]->juice / 10) + 10;
						if (pool[i]->blood < 0)
						{
							if (killed_x + namelength > 78)
							{
								killed_y++;
								killed_x = 1;
								//Add limit for killed_y.
							}
							pool[i]->die();
							set_alignment_color(pool[i]->align, false);
							mvaddstrAlt(injured_y, injured_x, pool[i]->name);
							addstrAlt(commaSpace);
							killed_x += namelength + 2;
						}
						else
						{
							if (injured_x + namelength > 78)
							{
								injured_y++;
								injured_x = 1;
								//Add limit for injured_y.
							}
							set_alignment_color(pool[i]->align, false);
							mvaddstrAlt(injured_y, injured_x, pool[i]->name);
							addstrAlt(commaSpace);
							injured_x += namelength + 2;
						}
						//set_alignment_color(pool[i]->align,false);
						//addstrAlt(pool[i]->name);
					}
				}
			}
			pressAnyKey();
		}
		else
		{
			// CCS Raids safehouse
			eraseAlt();
			set_color_easy(RED_ON_BLACK_BRIGHT);
			mvaddstrAlt(8, 1, CONST_siege144, gamelog);
			gamelog.nextMessage();
			pressAnyKey();
			CCSSiege(l);
		}
	}
	else if (LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_CCS) == 0)LocationsPool::getInstance().setTimeUntilSiege(l, SIEGE_CCS, -1); // Silently call off foiled ccs raids
}

void huntingSiegePrint(const int l, int& numpres) {

	extern Log gamelog;
	extern char disbanding;
	extern short offended_corps;
	extern short offended_cia;
	extern char endgamestate;
	extern short offended_amradio;
	extern short offended_cablenews;
	extern short offended_firemen;
	extern MusicClass music;
	extern short lawList[LAWNUM];
	extern short attitude[VIEWNUM];
	extern vector<Creature *> pool;

	const string CONST_siege175 = "Materials relating to the business front have been destroyed.";
	const string CONST_siege170 = "The Firemen have raided the ";
	const string CONST_siege169 = "Come quietly and you will not be harmed.";
	const string CONST_siege168 = "Unacceptable Speech has occurred at this location.";
	const string CONST_siege166 = "You hear a screeching voice over the sound of fire engine sirens:";
	const string CONST_siege165 = "Armored firemen swarm out, pilot lights burning.";
	const string CONST_siege163 = "Screaming fire engines pull up to the ";
	const string CONST_siege162 = "the Firemen are planning to burn ";
	const string CONST_siege161 = "Word in the underground is that ";
	const string CONST_siege160 = "A sleeper Fireman has informed you that ";
	const string CONST_siege158 = "are storming the ";
	const string CONST_siege157 = "Masses dissatisfied with your lack of respect for Cable News ";
	const string CONST_siege154 = "Masses dissatisfied with your lack of respect for AM Radio ";
	const string CONST_siege153 = "They've shut off the lights!";
	const string CONST_siege152 = "to shut off the lights!";
	const string CONST_siege151 = "Through some form of high technology, they've managed ";
	const string CONST_siege150 = "to shut off the lights and the cameras!";
	const string CONST_siege147 = "Unmarked black vans are surrounding the ";
	const string CONST_siege146 = "to launch an attack on ";
	const string CONST_siege145 = "A sleeper agent has reported that the CIA is planning ";

	//HUNTING
	if (getTimeUntilSiege(l) > 0)
	{
		if (LocationsPool::getInstance().isThisAFront(l) == -1 || LCSrandom(2))
		{
			LocationsPool::getInstance().setTimeUntilSiege(l, getTimeUntilSiege(l) - 1);
			// Hunt faster if location is extremely hot
			huntFasterIfSiteIncrediblyHot(l);
		}
	}
	//CHECK FOR CRIMINALS AT THIS BASE
	//int heatprotection=0;
	int crimes = allCreatureHeatGeneration(l, numpres);
	// Determine how effective your current safehouse
	// is at keeping the police confused
	updateLocationHeatProtection(l);
	// Let the place cool off if not accumulating heat
	letPlaceCoolOffUnlessCrime(crimes, l);
	// Sleepers at the police department may give a warning just before police raids
	if (getTimeUntilSiege(l) == 1)
	{
		possibleWarningFromSleepers(l);
	}
	//COPS RAID THIS LOCATION
	if (!getTimeUntilSiege(l))
	{
		policeSiegePrint(l, numpres);
	}
	//OTHER OFFENDABLE ENTITIES
	//CORPS
	if (LocationsPool::getInstance().getHeat(l) && LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_CORPORATE) == -1 && !LocationsPool::getInstance().isThereASiegeHere(l) && offended_corps && !LCSrandom(600) && numpres > 0)
	{
		possiblyWarnOfCorpSiege(l);
	}
	else if (LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_CORPORATE) > 0) {
		LocationsPool::getInstance().setTimeUntilSiege(l, SIEGE_CORPORATE, LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_CORPORATE) - 1); // Corp raid countdown!
	}
	else if (LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_CORPORATE) == 0 && !LocationsPool::getInstance().isThereASiegeHere(l) && offended_corps&&numpres > 0)
	{
		corporateSiegePrint(l);
	}
	else if (LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_CORPORATE) == 0)LocationsPool::getInstance().setTimeUntilSiege(l, SIEGE_CORPORATE, -1); // Silently call off foiled corp raids
																																							 //CONSERVATIVE CRIME SQUAD
	bool ccs_active = endgamestate >= ENDGAME_CCS_APPEARANCE && endgamestate < ENDGAME_CCS_DEFEATED;
	bool target_interesting = endgamestate >= ENDGAME_CCS_SIEGES || hasPrintingPress(l);
	if (ccs_active && target_interesting)
	{
		CCSSiegePrint(l, numpres);
	}
	//CIA
	if (LocationsPool::getInstance().getHeat(l) && LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_CIA) == -1 && !LocationsPool::getInstance().isThereASiegeHere(l) && offended_cia && !LCSrandom(300) && numpres > 0)
	{
		LocationsPool::getInstance().setTimeUntilSiege(l, SIEGE_CIA, LCSrandom(3) + 1);
		// *JDS* agent sleepers may give a warning before cia raids
		int agentsleepercount = 0;
		for (int pl = 0; pl < CreaturePool::getInstance().lenpool(); pl++)
		{
			if (pool[pl]->flag & CREATUREFLAG_SLEEPER&&
				pool[pl]->type == CREATURE_AGENT)
			{
				//if(pool[pl]->infiltration*100>LCSrandom(100))
				{
					agentsleepercount = 1;
					break;
				}
			}
		}
		if (agentsleepercount)
		{
			eraseAlt();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(8, 1, CONST_siege145, gamelog);
			mvaddstrAlt(9, 1, CONST_siege146, gamelog);
			addstrAlt(LocationsPool::getInstance().getLocationName(l), gamelog);
			addstrAlt(singleDot, gamelog);
			gamelog.nextMessage();
			pressAnyKey();
		}
	}
	else if (LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_CIA) > 0)LocationsPool::getInstance().setTimeUntilSiege(l, SIEGE_CIA, LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_CIA) - 1); // CIA raid countdown!
	else if (LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_CIA) == 0 && !LocationsPool::getInstance().isThereASiegeHere(l) && offended_cia&&numpres > 0)
	{
		music.play(MUSIC_SIEGE);
		LocationsPool::getInstance().setTimeUntilSiege(l, SIEGE_CIA, -1);
		// CIA raids!
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, CONST_siege147, gamelog);
		addstrAlt(LocationsPool::getInstance().getLocationName(l), gamelog);
		addstrAlt(CONST_siege188, gamelog);
		gamelog.newline();
		if (hasCameras(l))
		{
			mvaddstrAlt(9, 1, CONST_siege151, gamelog);
			mvaddstrAlt(10, 1, CONST_siege150, gamelog);
			gamelog.nextMessage();
		}
		else if (hasAGenerator(l))
		{
			mvaddstrAlt(9, 1, CONST_siege151, gamelog);
			mvaddstrAlt(10, 1, CONST_siege152, gamelog);
			gamelog.nextMessage();
		}
		else
		{
			mvaddstrAlt(9, 1, CONST_siege153, gamelog);
			gamelog.nextMessage();
		}
		pressAnyKey();
		CIASiege(l);
	}
	else if (LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_CIA) == 0)LocationsPool::getInstance().setTimeUntilSiege(l, SIEGE_CIA, -1); // Silently call off foiled cia raids
																																				 //HICKS
	if (!LocationsPool::getInstance().isThereASiegeHere(l) && offended_amradio&&attitude[VIEW_AMRADIO] <= 35 && !LCSrandom(600) && numpres > 0)
	{
		music.play(MUSIC_SIEGE);
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, CONST_siege154, gamelog);
		mvaddstrAlt(9, 1, CONST_siege158, gamelog);
		addstrAlt(LocationsPool::getInstance().getLocationName(l), gamelog);
		addstrAlt(CONST_siege188, gamelog);
		gamelog.nextMessage();
		pressAnyKey();
		hicksSiege(l);
		offended_amradio = 0;
	}
	if (!LocationsPool::getInstance().isThereASiegeHere(l) && offended_cablenews&&attitude[VIEW_CABLENEWS] <= 35 && !LCSrandom(600) && numpres > 0)
	{
		music.play(MUSIC_SIEGE);
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, CONST_siege157, gamelog);
		mvaddstrAlt(9, 1, CONST_siege158, gamelog);
		addstrAlt(LocationsPool::getInstance().getLocationName(l), gamelog);
		addstrAlt(CONST_siege188, gamelog);
		gamelog.nextMessage();
		pressAnyKey();
		hicksSiege(l);
		offended_cablenews = 0;
	}
	//Firemen
	if (lawList[LAW_FREESPEECH] == -2 && LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_FIREMEN) == -1 && !LocationsPool::getInstance().isThereASiegeHere(l) &&
		offended_firemen && numpres > 0 && hasPrintingPress(l) && !LCSrandom(90))
	{
		LocationsPool::getInstance().setTimeUntilSiege(l, SIEGE_FIREMEN, LCSrandom(3) + 1);
		// Sleeper Firemen can warn you of an impending raid
		int firemensleepercount = 0;
		for (int pl = 0; pl < CreaturePool::getInstance().lenpool(); pl++)
			if (pool[pl]->flag & CREATUREFLAG_SLEEPER &&
				pool[pl]->type == CREATURE_FIREFIGHTER &&
				LocationsPool::getInstance().getLocationCity(pool[pl]->location) == LocationsPool::getInstance().getLocationCity(l))
				firemensleepercount++;
		if (LCSrandom(firemensleepercount + 1) > 0 || !LCSrandom(10))
		{
			eraseAlt();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			if (firemensleepercount) mvaddstrAlt(8, 1, CONST_siege160, gamelog);
			else mvaddstrAlt(8, 1, CONST_siege161, gamelog);
			mvaddstrAlt(9, 1, CONST_siege162, gamelog);
			addstrAlt(LocationsPool::getInstance().getLocationName(l), gamelog);
			addstrAlt(singleDot, gamelog);
			gamelog.nextMessage();
			pressAnyKey();
		}
	}
	else if (LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_FIREMEN) > 0) LocationsPool::getInstance().setTimeUntilSiege(l, SIEGE_FIREMEN, LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_FIREMEN) - 1);
	else if (lawList[LAW_FREESPEECH] == -2 && LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_FIREMEN) == 0 && !LocationsPool::getInstance().isThereASiegeHere(l) && numpres > 0)
	{
		music.play(MUSIC_SIEGE);
		LocationsPool::getInstance().setTimeUntilSiege(l, SIEGE_FIREMEN, -1);
		// Firemen raid!
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, CONST_siege163, gamelog);
		addstrAlt(LocationsPool::getInstance().getLocationName(l), gamelog);
		addstrAlt(CONST_siege188, gamelog);
		gamelog.newline();
		mvaddstrAlt(9, 1, CONST_siege165, gamelog);
		gamelog.newline();
		pressAnyKey();
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(1, 1, CONST_siege166, gamelog);
		gamelog.newline();
		mvaddstrAlt(3, 1, CONST_siege167, gamelog);
		gamelog.newline();
		mvaddstrAlt(4, 1, CONST_siege168, gamelog);
		gamelog.newline();
		mvaddstrAlt(6, 1, CONST_siege169, gamelog);
		gamelog.nextMessage();
		pressAnyKey();
		firemanSiege(l);
		offended_firemen = 0;
	}
	else if (lawList[LAW_FREESPEECH] == -2 && LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_FIREMEN) == 0)
	{
		LocationsPool::getInstance().setTimeUntilSiege(l, SIEGE_FIREMEN, -1);
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, CONST_siege170, gamelog);
		addstrAlt(LocationsPool::getInstance().getLocationName(l), gamelog);
		addstrAlt(CONST_siege177, gamelog);
		gamelog.newline();
		pressAnyKey();
		int y = 9;
		for (int p = CreaturePool::getInstance().lenpool() - 1; p >= 0; p--)
		{
			if (pool[p]->location != l)continue;
			if (!pool[p]->alive)
			{
				mvaddstrAlt(y++, 1, pool[p]->name, gamelog);
				addstrAlt(CONST_siege178, gamelog);
				gamelog.newline();
				pressAnyKey();
				delete_and_remove(pool, p);
				continue;
			}
			if (pool[p]->align != 1)
			{
				mvaddstrAlt(y++, 1, pool[p]->name, gamelog);
				addstrAlt(CONST_siege179, gamelog);
				gamelog.newline();
				pressAnyKey();
				delete_and_remove(pool, p);
				continue;
			}
		}
		deleteLocationLoot(l);
		if (hasPrintingPress(l))
		{
			mvaddstrAlt(10, 1, CONST_siege174, gamelog);
			gamelog.newline();
			deletePrintingPress(l);
			offended_firemen = 0;
		}
		if (hasBusinessFront(l))
		{
			mvaddstrAlt(12, 1, CONST_siege175, gamelog);
			gamelog.newline();
			deleteBusinessFront(l);
		}
		gamelog.newline();
	}
	else if (lawList[LAW_FREESPEECH] <= -1 && LocationsPool::getInstance().getTimeUntilSiege(l, SIEGE_FIREMEN) == 0)
		LocationsPool::getInstance().setTimeUntilSiege(l, SIEGE_FIREMEN, -1);
	offended_firemen = 0;

}

//TODO There is an absurd amount of duplicated code here
void siegecheck(char canseethings)
{
	extern Log gamelog;
	extern char disbanding;
	extern short offended_firemen;
	extern short lawList[LAWNUM];
	extern vector<Creature *> pool;

	if (disbanding)return;
	// Upkeep - even base-less should be considered.
	// XXX - candidate to create nice function?
	// Cleanse record on things that aren't illegal right now
	for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
	{
		if (lawList[LAW_FLAGBURNING] > 0)pool[p]->crimes_suspected[LAWFLAG_BURNFLAG] = 0;
		if (lawList[LAW_DRUGS] > 0)pool[p]->crimes_suspected[LAWFLAG_BROWNIES] = 0;
		if (lawList[LAW_IMMIGRATION] == 2)pool[p]->flag &= ~CREATUREFLAG_ILLEGALALIEN;
		if (lawList[LAW_FREESPEECH] > -2)pool[p]->crimes_suspected[LAWFLAG_SPEECH] = 0;
	}
	if (lawList[LAW_FREESPEECH] > -2)offended_firemen = 0;
	//FIRST, THE COPS
	int numpres;
	for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++)
	{
		if (LocationsPool::getInstance().isThisSiteClosed(find_site_index_in_same_city(SITE_GOVERNMENT_POLICESTATION, l)))
		{
			dropHeatByFivePercent(l);
		}
		if (LocationsPool::getInstance().isThereASiegeHere(l))continue;
		if (LocationsPool::getInstance().getRentingType(l) == RENTING_NOCONTROL)continue;
		numpres = 0;
		if (getTimeUntilSiege(l) == -2)
		{
			//IF JUST SIEGED, BUY SOME TIME
			LocationsPool::getInstance().setTimeUntilSiege(l, -1);
		}
		else
		{
			huntingSiegePrint(l, numpres);
		}
	}
}
/* siege - checks how many people are eating at the site */
int numbereating(int loc)
{
	extern vector<Creature *> pool;
	int eaters = 0;
	for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++) //Must be here, alive, Liberal, and not a sleeper, to count as an eater
		if (pool[p]->location == loc && pool[p]->alive&&pool[p]->align == 1 && !(pool[p]->flag&CREATUREFLAG_SLEEPER)) eaters++;
	return eaters;
}
void noOneIsThere(const int l) {
	extern Log gamelog;
	extern vector<Creature *> pool;
	const string CONST_siege176 = "Conservatives have raided the ";
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(8, 1, CONST_siege176, gamelog);
	addstrAlt(LocationsPool::getInstance().getLocationName(l), gamelog);
	addstrAlt(CONST_siege177, gamelog);
	gamelog.newline();
	if (LocationsPool::getInstance().getSiegeType(l) == SIEGE_CCS && LocationsPool::getInstance().getLocationType(l) == SITE_INDUSTRY_WAREHOUSE)
		CCSCapturesSite(l);
	pressAnyKey();
	int y = 9;
	for (int p = CreaturePool::getInstance().lenpool() - 1; p >= 0; p--)
	{
		if (pool[p]->location != l) continue;
		if (!pool[p]->alive)
		{
			mvaddstrAlt(y++, 1, pool[p]->name);
			addstrAlt(CONST_siege178, gamelog);
			gamelog.newline();
			pressAnyKey();
			delete_and_remove(pool, p);
			continue;
		}
		if (pool[p]->align != 1)
		{
			mvaddstrAlt(y++, 1, pool[p]->name);
			addstrAlt(CONST_siege179, gamelog);
			gamelog.newline();
			pressAnyKey();
			delete_and_remove(pool, p);
			continue;
		}
	}
	deleteLocationLoot(l);
	deleteLocationVehicles(l);
	gamelog.newline();
	endLocationSiege(l);
}
int siegeDontAttack(const int l, const bool clearformess, int num_liberals) {

	void deleteGeneratorLightsOff(int l);
	bool getLightsOff(int l);
	void setLightsOff(int l);
	bool hasBasicCompoundWalls(int l);

	const string CONST_siege224 = "'s words.";
	const string CONST_siege223 = "Virtually everyone in America was moved by ";
	const string CONST_siege222 = " later went on to win a Pulitzer for it.";
	const string CONST_siege221 = "Even the Cable News and AM Radio spend days talking about it.";
	const string CONST_siege220 = "The discussion was exciting and dynamic.";
	const string CONST_siege219 = " represents the LCS well.";
	const string CONST_siege218 = "'s verbal finesse leaves something to be desired.";
	const string CONST_siege217 = " stutters nervously the whole time.";
	const string CONST_siege216 = "But ";
	const string CONST_siege215 = " falls asleep.";
	const string CONST_siege214 = "But the interview is so boring that ";
	const string CONST_siege213 = "Retarded";
	const string CONST_siege212 = "Dumb";
	const string CONST_siege211 = "and later used the material for a Broadway play called";
	const string CONST_siege210 = " canceled the interview halfway through";
	const string CONST_siege209 = "The interview is wide-ranging, covering a variety of topics.";
	const string CONST_siege208 = " decides to give an interview.";
	const string CONST_siege207 = "got into the compound somehow!";
	const string CONST_siege206 = " from the ";
	const string CONST_siege205 = "Elitist ";
	const string CONST_siege204 = "The tank moves forward to your compound entrance.";
	const string CONST_siege203 = "Army engineers have removed your tank traps.";
	const string CONST_siege202 = "Fortunately, no one is hurt.";
	const string CONST_siege201 = " narrowly avoided death!";
	const string CONST_siege200 = " was killed in the bombing!";
	const string CONST_siege199 = "The lights fade and all is dark.";
	const string CONST_siege198 = "The generator has been destroyed!";
	const string CONST_siege197 = "There's nothing left but smoking wreckage...";
	const string CONST_siege196 = "The anti-aircraft gun takes a direct hit!";
	const string CONST_siege195 = "Explosions rock the compound!";
	const string CONST_siege194 = "A skilled pilot gets through!";
	const string CONST_siege193 = "It's all over the TV. Everyone in the Liberal Crime Squad gains 20 juice!";
	const string CONST_siege192 = "Hit! One of the bombers slams into to the ground.";
	const string CONST_siege191 = "You didn't shoot any down, but you've made them think twice!";
	const string CONST_siege190 = "The thunder of the anti-aircraft gun shakes the compound!";
	const string CONST_siege189 = "You hear planes streak overhead!";
	const string CONST_siege187 = "A sniper nearly hits ";
	const string CONST_siege185 = "A sniper takes out ";
	const string CONST_siege184 = "The police have cut the lights!";
	extern Log gamelog;
	extern int stat_dead;
	extern short lawList[LAWNUM];
	extern vector<Creature *> pool;

	char no_bad = 1;
	//CUT LIGHTS
	if (!getLightsOff(l) &&
		!(hasAGenerator(l)) && !LCSrandom(10))
	{
		no_bad = 0;
		if (clearformess) eraseAlt();
		else makedelimiter();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, CONST_siege184, gamelog);
		gamelog.newline();
		pressAnyKey();
		setLightsOff(l);
	}
	//SNIPER
	if (!(hasBasicCompoundWalls(l)) && !LCSrandom(5))
	{
		no_bad = 0;
		vector<int> pol;
		for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++) if (pool[p]->alive&&pool[p]->location == l) pol.push_back(p);
		if (len(pol))
		{
			if (clearformess) eraseAlt();
			else makedelimiter();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			int targ = pickrandom(pol);
			if ((int)LCSrandom(50) > pool[targ]->juice)
			{
				mvaddstrAlt(8, 1, CONST_siege185, gamelog);
				addstrAlt(pool[targ]->name, gamelog);
				addstrAlt(CONST_siege188, gamelog);
				gamelog.newline();
				if (pool[targ]->align == 1) stat_dead++, num_liberals--;
				removesquadinfo(*pool[targ]);
				pool[targ]->die();
			}
			else
			{
				mvaddstrAlt(8, 1, CONST_siege187, gamelog);
				addstrAlt(pool[targ]->name, gamelog);
				addstrAlt(CONST_siege188, gamelog);
				gamelog.newline();
			}
			pressAnyKey();
		}
	}
	if (LocationsPool::getInstance().getSiegeEscalationState(l) >= 3 && !LCSrandom(3))
	{
		no_bad = 0;
		//AIR STRIKE!
		bool hit = true;
		if (clearformess) eraseAlt();
		else makedelimiter();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, CONST_siege189, gamelog);
		gamelog.newline();
		pressAnyKey();
		bool hasAAGun = siteHasAAGun(l);
		bool hasGenerator = hasAGenerator(l);
		if (hasAAGun)
		{
			if (clearformess) eraseAlt();
			else makedelimiter();
			mvaddstrAlt(8, 1, CONST_siege190, gamelog);
			gamelog.newline();
			pressAnyKey();
			if (clearformess) eraseAlt();
			else makedelimiter();
			if (LCSrandom(5))
			{
				hit = false;
				if (LCSrandom(2)) mvaddstrAlt(8, 1, CONST_siege191, gamelog);
				else
				{
					mvaddstrAlt(8, 1, CONST_siege192, gamelog);
					gamelog.newline();
					pressAnyKey();
					if (clearformess) eraseAlt();
					else makedelimiter();
					mvaddstrAlt(8, 1, CONST_siege193, gamelog);
					for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++) addjuice(*pool[p], 20, 1000);
				}
				gamelog.newline();
				pressAnyKey();
			}
			else
			{
				mvaddstrAlt(8, 1, CONST_siege194, gamelog);
				gamelog.newline();
				pressAnyKey();
			}
		}
		if (hit)
		{
			if (clearformess) eraseAlt();
			else makedelimiter();
			mvaddstrAlt(8, 1, CONST_siege195, gamelog);
			gamelog.newline();
			pressAnyKey();
			if (hasAAGun && !LCSrandom(3))
			{
				if (clearformess) eraseAlt();
				else makedelimiter();
				mvaddstrAlt(8, 1, CONST_siege196, gamelog);
				gamelog.newline();
				pressAnyKey();
				if (clearformess) eraseAlt();
				else makedelimiter();
				mvaddstrAlt(8, 1, CONST_siege197, gamelog);
				gamelog.newline();
				pressAnyKey();
				deleteAAGun(l);
			}
			else if (hasGenerator && !LCSrandom(3))
			{
				if (clearformess) eraseAlt();
				else makedelimiter();
				mvaddstrAlt(8, 1, CONST_siege198, gamelog);
				gamelog.newline();
				pressAnyKey();
				if (clearformess) eraseAlt();
				else makedelimiter();
				mvaddstrAlt(8, 1, CONST_siege199, gamelog);
				gamelog.newline();
				pressAnyKey();
				deleteGeneratorLightsOff(l);
			}
			if (!LCSrandom(2))
			{
				vector<int> pol;
				for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++) if (pool[p]->alive&&pool[p]->location == l) pol.push_back(p);
				if (len(pol))
				{
					if (clearformess) eraseAlt();
					else makedelimiter();
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					int targ = pickrandom(pol);
					if ((int)LCSrandom(100) > pool[targ]->juice)
					{
						mvaddstrAlt(8, 1, pool[targ]->name, gamelog);
						addstrAlt(CONST_siege200, gamelog);
						gamelog.newline();
						if (pool[targ]->align == 1) stat_dead++, num_liberals--;
						removesquadinfo(*pool[targ]);
						pool[targ]->die();
					}
					else
					{
						mvaddstrAlt(8, 1, pool[targ]->name, gamelog);
						addstrAlt(CONST_siege201, gamelog);
						gamelog.newline();
					}
					pressAnyKey();
				}
			}
			else
			{
				if (clearformess) eraseAlt();
				else makedelimiter();
				mvaddstrAlt(8, 1, CONST_siege202, gamelog);
				gamelog.newline();
				pressAnyKey();
			}
		}
	}
	if ((LocationsPool::getInstance().doWeHaveTankTraps(l)) &&
		LocationsPool::getInstance().getSiegeEscalationState(l) >= 3 && !LCSrandom(15))
	{
		no_bad = 0;
		//ENGINEERS
		if (clearformess) eraseAlt();
		else makedelimiter();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(8, 1, CONST_siege203, gamelog);
		gamelog.newline();
		pressAnyKey();
		if (!clearformess)
		{
			makedelimiter();
		}
		mvaddstrAlt(clearformess ? 9 : 8, 1, CONST_siege204, gamelog);
		gamelog.newline();
		pressAnyKey();
		LocationsPool::getInstance().deleteTankTraps(l);
	}
	//NEED GOOD THINGS TO BALANCE THE BAD
	// ELITE REPORTER SNEAKS IN
	if (!LCSrandom(20) && no_bad&&num_liberals > 0)
	{
		string repname = generate_name();
		set_color_easy(WHITE_ON_BLACK);
		eraseAlt();
		mvaddstrAlt(1, 1, CONST_siege205, gamelog);
		addstrAlt(repname, gamelog);
		addstrAlt(CONST_siege206, gamelog);
		addstrAlt(pickrandom(words_meaning_news), gamelog);
		addstrAlt(singleSpace);
		addstrAlt(pickrandom(newspaper_first_name), gamelog);
		addstrAlt(singleSpace, gamelog);
		addstrAlt(pickrandom(newspaper_last_name), gamelog);
		mvaddstrAlt(2, 1, CONST_siege207, gamelog);
		gamelog.newline();
		pressAnyKey();
		int best = 0;
		for (int p = 0, bestvalue = -1000; p < CreaturePool::getInstance().lenpool(); p++)
		{
			if (!pool[p]->alive || pool[p]->align != 1 || pool[p]->location != l) continue;
			int sum = pool[p]->get_attribute(ATTRIBUTE_INTELLIGENCE, true)
				+ pool[p]->get_attribute(ATTRIBUTE_HEART, true)
				+ pool[p]->get_skill(SKILL_PERSUASION)
				+ pool[p]->juice;
			if (sum > bestvalue) best = p, bestvalue = sum;
		}
		mvaddstrAlt(4, 1, pool[best]->name, gamelog);
		addstrAlt(CONST_siege208, gamelog);
		gamelog.newline();
		pressAnyKey();
		mvaddstrAlt(6, 1, CONST_siege209, gamelog);
		gamelog.newline();
		pressAnyKey();
		int segmentpower = pool[best]->attribute_roll(ATTRIBUTE_INTELLIGENCE)
			+ pool[best]->attribute_roll(ATTRIBUTE_HEART)
			+ pool[best]->skill_roll(SKILL_PERSUASION)
			+ pool[best]->skill_roll(SKILL_PERSUASION)
			+ pool[best]->skill_roll(SKILL_PERSUASION);

		if (segmentpower < 15)
		{
			mvaddstrAlt(8, 1, repname, gamelog);
			addstrAlt(CONST_siege210, gamelog);
			mvaddstrAlt(9, 1, CONST_siege211, gamelog);
			if (LCSrandom(insult_for_liberal.size() + 1)) {
				mvaddstrAlt(10, 1, pickrandom(insult_for_liberal));
			}
			else {
				if (lawList[LAW_FREESPEECH] == -2) mvaddstrAlt(10, 1, CONST_siege212, gamelog);
				else mvaddstrAlt(10, 1, CONST_siege213, gamelog);
			}
			addstrAlt(singleSpace, gamelog);
			addstrAlt(pickrandom(word_replacing_liberal));
			addstrAlt(singleDot, gamelog);
			gamelog.newline();
		}
		else if (segmentpower < 20)
		{
			mvaddstrAlt(8, 1, CONST_siege214, gamelog);
			addstrAlt(repname, gamelog);
			addstrAlt(CONST_siege215, gamelog);
			gamelog.newline();
		}
		else if (segmentpower < 25)
		{
			mvaddstrAlt(8, 1, CONST_siege216, gamelog);
			addstrAlt(pool[best]->name, gamelog);
			addstrAlt(CONST_siege217, gamelog);
			gamelog.newline();
		}
		else if (segmentpower < 30)
		{
			mvaddstrAlt(8, 1, pool[best]->name, gamelog);
			addstrAlt(CONST_siege218, gamelog);
			gamelog.newline();
		}
		else if (segmentpower < 45)
		{
			mvaddstrAlt(8, 1, pool[best]->name, gamelog);
			addstrAlt(CONST_siege219, gamelog);
			gamelog.newline();
		}
		else if (segmentpower < 60)
		{
			mvaddstrAlt(8, 1, CONST_siege220, gamelog);
			mvaddstrAlt(9, 1, CONST_siege221, gamelog);
			gamelog.newline();
		}
		else
		{
			mvaddstrAlt(8, 1, repname);
			addstrAlt(CONST_siege222, gamelog);
			mvaddstrAlt(9, 1, CONST_siege223, gamelog);
			addstrAlt(pool[best]->name, gamelog);
			addstrAlt(CONST_siege224, gamelog);
			gamelog.newline();
		}
		pressAnyKey();
		//CHECK PUBLIC OPINION
		change_public_opinion(VIEW_LIBERALCRIMESQUAD, 20);
		change_public_opinion(VIEW_LIBERALCRIMESQUADPOS, (segmentpower - 25) / 2, segmentpower + 50);
		for (int v = 0; v < 5; v++) change_public_opinion(LCSrandom(VIEWNUM - 3), (segmentpower - 25) / 2);
	}
	return num_liberals;
}
/* siege - updates sieges in progress */
void reduceCompoundStores(int loc, int amount);
void emptyCompoundStores(int l);
void siegeturn(char clearformess)
{
	void setUnderAttack(int l);

	const string CONST_siege183 = "The cops are coming!";
	const string CONST_siege182 = " has starved to death.";
	const string CONST_siege181 = "Your Liberals are starving!";
	const string CONST_siege180 = "A day passes while under siege...";
	const string CONST_siege247 = "give up";
	extern Log gamelog;
	extern char disbanding;
	extern int stat_dead;
	extern short lawList[LAWNUM];
	extern vector<Creature *> pool;
	if (disbanding)return;
	// Count people at each location
	//int hs=-1;
	int* liberalcount = new int[LocationsPool::getInstance().lenpool()];
	char* food_prep = new char[LocationsPool::getInstance().lenpool()];
	// Clear food_prep and liberalcount lists
	std::memset(food_prep, 0, LocationsPool::getInstance().lenpool());
	std::memset(liberalcount, 0, sizeof(int)*LocationsPool::getInstance().lenpool());
	for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
	{
		if (!pool[p]->alive)continue; // Dead people don't count
		if (pool[p]->align != 1)continue; // Non-liberals don't count
		if (pool[p]->location == -1)continue; // Vacationers don't count
		liberalcount[pool[p]->location]++;
	}
	for (int l = 0; l < LocationsPool::getInstance().lenpool(); l++)
		if (LocationsPool::getInstance().isThereASiegeHere(l))
		{
			//resolve sieges with no people
			if (liberalcount[l] == 0)
			{
				noOneIsThere(l);
			}
			if (!LocationsPool::getInstance().isThisUnderAttack(l))
			{
				// Seperate logging message.
				gamelog.record(CONST_siege180);
				gamelog.newline();
				//EAT
				bool starving = false;
				int eaters = numbereating(l);
				if (LocationsPool::getInstance().getStoresAmount(l) == 0 && eaters > 0)
				{
					starving = true;
					if (clearformess) eraseAlt();
					else makedelimiter();
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(8, 1, CONST_siege181, gamelog);
					gamelog.newline();
					pressAnyKey();
				}
				if (LocationsPool::getInstance().getStoresAmount(l) >= eaters) reduceCompoundStores(l, eaters);
				else emptyCompoundStores(l);
				//ATTACK!
				char attack = 0;
				for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
				{
					if (!pool[p]->alive || pool[p]->location != l) continue;
					if (starving) pool[p]->blood -= LCSrandom(8) + 4;
					// Check if liberal starved to death.
					if (pool[p]->blood <= 0)
					{
						pool[p]->die();
						if (clearformess) eraseAlt();
						else makedelimiter();
						set_color_easy(WHITE_ON_BLACK_BRIGHT);
						mvaddstrAlt(8, 1, pool[p]->name, gamelog);
						addstrAlt(CONST_siege182, gamelog);
						gamelog.newline();
						pressAnyKey();
					}
				}
				if (!LCSrandom(12))attack = 1;
				if (attack)
				{
					if (clearformess) eraseAlt();
					else makedelimiter();
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(8, 1, CONST_siege183, gamelog);
					gamelog.newline();
					pressAnyKey();
					setUnderAttack(l);
				}
				else {
					liberalcount[l] = siegeDontAttack(l, clearformess, liberalcount[l]);
				}
				gamelog.newline(); // single blank line after every siege day
			}
		}
	delete[] liberalcount;
	delete[] food_prep;
}
/* siege - checks how many days of food left at the site */
int fooddaysleft(int loc)
{
	int eaters = numbereating(loc);
	if (eaters == 0) return -1;
	return LocationsPool::getInstance().getStoresAmount(loc) / eaters + ((LocationsPool::getInstance().getStoresAmount(loc) % eaters) > eaters / 2);
}
void escalateSite(int l);
void dumpLootAtLocation(int homes, vector<Item *>& loot);
/* siege - what happens when you escaped the siege */
void escapesiege(char won)
{
	const string CONST_siege227 = "Your Liberals split up and lay low for a few days.";
	const string CONST_siege226 = "Press any key to split up and lay low for a few days";
	const string CONST_siege225 = "You have escaped!";
	extern Log gamelog;
	extern squadst *activesquad;
	extern short cursite;
	extern MusicClass music;
	extern int police_heat;
	extern vector<Creature *> pool;
	//TEXT IF DIDN'T WIN
	if (!won)
	{
		music.play(MUSIC_CONQUER);
		//GIVE INFO SCREEN
		eraseAlt();
		set_color_easy(YELLOW_ON_BLACK_BRIGHT);
		mvaddstrAlt(1, 32, CONST_siege225, gamelog);
		gamelog.nextMessage();
		set_color_easy(WHITE_ON_BLACK);
		int yLevel = 3;
		for (int i = 0; i < len(engageConservativesEscape); i++) {
			mvaddstrAlt(yLevel + i, 11, engageConservativesEscape[i]);
		}
		yLevel += len(engageConservativesEscape);
		int homes = -1;
		if (activesquad)
			if (activesquad->squad[0] != NULL)
				homes = find_site_index_in_same_city(SITE_RESIDENTIAL_SHELTER, activesquad->squad[0]->location);
		set_color_easy(YELLOW_ON_BLACK_BRIGHT);
		mvaddstrAlt(yLevel + 1, 11, CONST_siege226);
		// Seperate logging text
		gamelog.log(CONST_siege227);
		pressAnyKey();
		//dump retrieved loot in homeless shelter - is there anywhere better to put it?
		if (activesquad&&homes != -1) dumpLootAtLocation(homes, activesquad->loot);
		activesquad = NULL; //active squad cannot be disbanded in removesquadinfo,
							//but we need to disband current squad as the people are going to be 'away'.
							//GET RID OF DEAD, etc.
		if (LocationsPool::getInstance().getRentingType(cursite) > 1)LocationsPool::getInstance().setRenting(cursite, RENTING_NOCONTROL);
		for (int p = CreaturePool::getInstance().lenpool() - 1; p >= 0; p--)
		{
			if (pool[p]->location != cursite) continue;
			if (!pool[p]->alive)
			{
				delete_and_remove(pool, p);
				continue;
			}
			//BASE EVERYONE LEFT AT HOMELESS SHELTER
			removesquadinfo(*pool[p]);
			pool[p]->hiding = LCSrandom(3) + 2;
			if (pool[p]->align == 1) // not a hostage
				pool[p]->location = -1;
			else // hostages don't go into hiding, just shove em into the homeless shelter
				pool[p]->location = homes;
			pool[p]->base = homes;
		}
		deleteLocationLoot(cursite);
		deleteLocationVehicles(cursite);
		deleteCompoundWalls(cursite);
		emptyCompoundStores(cursite);
		deleteBusinessFront(cursite);
		LocationsPool::getInstance().initLocation(cursite);
	}
	//SET UP NEW SIEGE CHARACTERISTICS, INCLUDING TIMING
	endLocationSiege(cursite);
	if (won&&LocationsPool::getInstance().getSiegeType(cursite) == SIEGE_POLICE)
	{
		escalateSite(cursite);
		if (police_heat < 4) police_heat++;
	}
}
const string CONST_siege255 = "* * * * *   VICTORY   * * * * *";
const string CONST_siege274 = "Press C to Continue Liberally.";
/* siege - flavor text when you fought off the raid */
void conquertext()
{
	const string CONST_siege234 = "this filth until the Liberal Agenda is realized.";
	const string CONST_siege233 = "Unfortunately, you will never truly be safe from ";
	const string CONST_siege232 = "The Conservative automatons have been driven back.  ";
	const string CONST_siege231 = "abandoning this safe house for a safer location.";
	const string CONST_siege230 = "the time being.  While they are regrouping, you might consider ";
	const string CONST_siege229 = "The Conservative automatons have been driven back ÄÄ for ";
	extern Log gamelog;
	extern short cursite;
	extern MusicClass music;
	//GIVE INFO SCREEN
	music.play(MUSIC_CONQUER);
	eraseAlt();
	set_color_easy(GREEN_ON_BLACK_BRIGHT);
	mvaddstrAlt(1, 26, CONST_siege255, gamelog);
	gamelog.newline();
	if (LocationsPool::getInstance().getSiegeType(cursite) == SIEGE_POLICE)
	{
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(3, 16, CONST_siege229, gamelog);
		mvaddstrAlt(4, 11, CONST_siege230, gamelog);
		mvaddstrAlt(5, 11, CONST_siege231, gamelog);
	}
	else
	{
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(3, 16, CONST_siege232, gamelog);
		mvaddstrAlt(4, 11, CONST_siege233, gamelog);
		mvaddstrAlt(5, 11, CONST_siege234, gamelog);
	}
	gamelog.nextMessage();
	mvaddstrAlt(7, 19, CONST_siege274);
	while (getkeyAlt() != 'c');
}
siegest getWholeSiege(int l);
// Siege -- Mass combat outside safehouse
char sally_forth_aux(int loc)
{
	const string CONST_siege242 = "The siege is broken!";
	const string CONST_siege241 = "You're free!";
	const string CONST_siege240 = "C - Reflect on your Conservative judgment.";
	const string CONST_siege239 = "G - Surrender";
	const string CONST_siege238 = "F - Fight!";
	const string CONST_siege237 = "E - Equip";
	const string CONST_siege236 = "D - Escape";
	extern Log gamelog;
	extern short mode;
	extern short cursite;
	extern char foughtthisround;
	extern squadst *activesquad;
	extern MusicClass music;
	extern short party_status;
	extern newsstoryst *sitestory;
	extern Creature encounter[ENCMAX];
	extern vector<Creature *> pool;
	reloadparty();
	siegest siege = getWholeSiege(loc);
	cursite = loc;
	emptyEncounter();
	switch (siege.siegetype)
	{
	case SIEGE_CIA:
	case SIEGE_HICKS:
	case SIEGE_CORPORATE:
	case SIEGE_CCS:
	case SIEGE_FIREMEN:
	default:
		// So yeah, WTF is the reason there isn't a break statement here???
		// If everything ends up in the SIEGE_POLICE case we shouldn't even have a switch statement here at all.
	case SIEGE_POLICE: // Currently only police sieges should allow this
					   // SWAT teams
		if (siege.escalationstate == 0)
			fillEncounter(CREATURE_SWAT, ENCMAX - 9);
		// Military
		else if (siege.escalationstate >= 1)
			fillEncounter(CREATURE_SOLDIER, ENCMAX - 9);
		// M1 Tank
		if (siege.escalationstate >= 2 && !(LocationsPool::getInstance().doWeHaveTankTraps(loc)))
			makecreature(encounter[ENCMAX - 9], CREATURE_TANK);
		break;
	}
	mode = GAMEMODE_CHASEFOOT;
	music.play(MUSIC_DEFENSE);
	bool ranaway = false;
	while (true)
	{
		// Count heroes
		int partysize = 0, partyalive = 0;
		for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++) if (pool[p]->align == 1 && pool[p]->location == cursite && !(pool[p]->flag&CREATUREFLAG_SLEEPER))
		{
			partysize++;
			if (pool[p]->alive) partyalive++;
		}
		// Count bad guys
		int encsize = 0;
		for (int e = 0; e < ENCMAX; e++) if (encounter[e].exists) encsize++;
		// Let's roll
		autopromote(loc);
		eraseAlt();
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(0, 0, LocationsPool::getInstance().getLocationName(loc));
		// Player's party
		if (partyalive == 0) party_status = -1;
		printparty();
		if (partyalive > 0)
		{
			// Options
			if (partysize > 1)set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(9, 40, change_squad_order);
			if (partysize > 0 && (party_status == -1 || partysize > 1))set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(10, 40, check_status_of_squad_liberal);
			if (party_status != -1)set_color_easy(WHITE_ON_BLACK);
			else set_color_easy(BLACK_ON_BLACK_BRIGHT);
			mvaddstrAlt(11, 40, show_squad_liberal_status);
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(9, 1, CONST_siege236);
			mvaddstrAlt(10, 1, CONST_siege237);
			mvaddstrAlt(11, 1, CONST_siege238);
			mvaddstrAlt(12, 1, CONST_siege239);
		}
		else
		{
			endcheck(END_BUT_NOT_END); // play the right music in case we're dead
			set_color_easy(WHITE_ON_BLACK);
			mvaddstrAlt(9, 1, CONST_siege240);
		}
		// Enemies
		printencounter();
		// check if we fought the previous loop; if so, add a blank gamelog line
		if (foughtthisround) gamelog.newline();
		foughtthisround = 0;
		int c = getkeyAlt();
		// Reflecting on your poor judgment
		if (partyalive == 0 && c == 'c' && !endcheck())
		{
			mode = GAMEMODE_BASE;
			return 0;
		}
		// Providing orders
		if (partyalive > 0)
		{
			// Reorder
			if (c == 'o'&&partysize > 1) orderparty();
			// View status
			if (c == '0') party_status = -1;
			// Character info
			if (c >= '1'&&c <= '6') if (activesquad->squad[c - '1'] != NULL)
			{
				if (party_status == c - '1')fullstatus(party_status);
				else party_status = c - '1';
			}
			// Surrender
			if (c == 'g') giveup();
			// Run away
			if (c == 'd')
			{
				if (encounter[0].exists&&encounter[0].type == CREATURE_COP)
				{
					sitestory->crime.push_back(CRIME_FOOTCHASE);
					criminalizeparty(LAWFLAG_RESIST);
				}
				evasiverun();
				enemyattack();
				creatureadvance();
				ranaway = true;
			}
			if (c == 'f')
			{
				youattack();
				enemyattack();
				creatureadvance();
			}
			if (c == 'e') LocationsPool::getInstance().equipLoc(loc, -1);
			// Check for victory
			partysize = 0, partyalive = 0;
			for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++) if (pool[p]->align == 1 && pool[p]->location == cursite && !(pool[p]->flag&CREATUREFLAG_SLEEPER))
			{
				partysize++;
				if (pool[p]->alive) partyalive++;
			}
			int baddiecount = 0;
			for (int e = 0; e < ENCMAX; e++) if (encounter[e].enemy() && encounter[e].alive&&encounter[e].exists) baddiecount++;
			if (partyalive && !baddiecount)
			{
				for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++) for (int w = 0; w < BODYPARTNUM; w++) pool[p]->wound[w] &= ~WOUND_BLEEDING;
				mode = GAMEMODE_BASE;
				if (ranaway)
				{
					music.play(MUSIC_CONQUER);
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					clearmessagearea();
					mvaddstrAlt(16, 1, CONST_siege241, gamelog);
					gamelog.nextMessage();
					pressAnyKey();
					escapesiege(false);
					return 1;
				}
				else
				{
					music.play(MUSIC_CONQUER);
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					clearmessagearea();
					mvaddstrAlt(16, 1, CONST_siege242, gamelog);
					gamelog.nextMessage();
					pressAnyKey();
					conquertext();
					escapesiege(true);
					return 2;
				}
			}
		}
	}
	mode = GAMEMODE_BASE;
	return 1;
}

void createNewStoryEscape(const int loc) {
	const string CONST_siege248 = "You have been defeated.";
	extern Log gamelog;
	extern newsstoryst *sitestory;
	extern vector<newsstoryst *> newsstory;
	newsstoryst *ns = new newsstoryst;
	ns->type = NEWSSTORY_SQUAD_ESCAPED;
	ns->positive = 1;
	ns->loc = loc;
	ns->siegetype = LocationsPool::getInstance().getSiegeType(loc);
	newsstory.push_back(ns);
	sitestory = ns;

	char result = sally_forth_aux(loc);

	if (result == 2) ns->type = NEWSSTORY_SQUAD_BROKESIEGE;


	// If you fail, make sure the safehouse isn't under siege anymore by
	// forcing you to CONST_siege247.
	if (result == 0)
	{
		gamelog.log(CONST_siege248);
		resolvesafehouses();
	}
}
const string CONST_siege252 = "Press any key to Confront the Conservative Aggressors";
const string CONST_siege254 = " Defense";
/* siege - prepares for exiting the siege to fight the attackers head on */
void sally_forth()
{
	const string CONST_siege245 = "Your Liberals sally forth to confront the siege.";
	const string CONST_siege243 = "UNDER SIEGE: ESCAPE OR ENGAGE";
	extern Log gamelog;
	extern int selectedsiege;
	extern squadst *activesquad;
	extern MusicClass music;
	extern long cursquadid;
	extern vector<Creature *> pool;
	extern vector<squadst *> squad;
	//GIVE INFO SCREEN
	music.play(MUSIC_DEFENSE);
	eraseAlt();
	set_color_easy(RED_ON_BLACK_BRIGHT);
	mvaddstrAlt(1, 26, CONST_siege243);
	set_color_easy(WHITE_ON_BLACK);
	int yLevel = 3;
	for (int i = 0; i < len(nextSiege); i++) {
		mvaddstrAlt(yLevel + i, 11, nextSiege[i]);
	}
	yLevel++;
	yLevel += len(nextSiege);
	for (int i = 0; i < len(nextSiegeAgain); i++) {
		mvaddstrAlt(yLevel + i, 11, nextSiegeAgain[i]);
	}
	int loc = -1;
	if (selectedsiege != -1)loc = selectedsiege;
	if (activesquad != NULL)loc = activesquad->squad[0]->location;
	if (loc == -1)return;
	set_color_easy(RED_ON_BLACK_BRIGHT);
	mvaddstrAlt(23, 11, CONST_siege252);
	// Seperate logging text
	gamelog.log(CONST_siege245);
	pressAnyKey();
	if (LocationsPool::getInstance().getSiegeType(loc) == SIEGE_CCS && LocationsPool::getInstance().getLocationType(loc) == SITE_INDUSTRY_WAREHOUSE)
		CCSCapturesSite(loc); // CCS Captures warehouse -- this will be reversed if you fight them off
							  //CRIMINALIZE
	if (LocationsPool::getInstance().getSiegeType(loc) == SIEGE_POLICE) criminalizepool(LAWFLAG_RESIST, -1, loc);
	//DELETE ALL SQUADS IN THIS AREA UNLESS THEY ARE THE activesquad
	for (int sq = len(squad) - 1; sq >= 0; sq--)
		if (squad[sq] != activesquad && squad[sq]->squad[0])
			if (squad[sq]->squad[0]->location == loc)
			{
				if (activesquad)
				{
					for (int p = 0; p < 6; p++)
					{
						if (!squad[sq]->squad[p]) continue;
						squad[sq]->squad[p]->squadid = -1;
					}
					delete_and_remove(squad, sq);
				}
				else activesquad = squad[sq];
			}
	// No squads at the location? Form a new one.
	if (!activesquad)
	{
		squad.push_back(new squadst);
		squad.back()->id = cursquadid++;
		strcpy(squad.back()->name, LocationsPool::getInstance().getLocationNameWithGetnameMethod(selectedsiege, true).c_str());
		strcat(squad.back()->name, CONST_siege254.c_str());
		int i = 0;
		for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
			if (pool[p]->location == selectedsiege && pool[p]->alive&&pool[p]->align == 1)
			{
				squad.back()->squad[i] = pool[p];
				pool[p]->squadid = squad.back()->id;
				if (++i >= 6) break;
			}
		activesquad = squad.back();
	}
	//MAKE SURE PARTY IS ORGANIZED
	autopromote(loc);
	//START FIGHTING
	createNewStoryEscape(loc);
}
/* siege - prepares for entering site mode to fight the siege */
void escape_engage()
{
	const string CONST_siege253 = "Your Liberals confront the Conservatives within the safehouse.";
	const string CONST_siege251 = "Your traps will harass the enemy, but not the Squad.";
	const string CONST_siege250 = "Your security cameras let you see units on the (M)ap.";
	const string CONST_siege249 = "UNDER ATTACK: ESCAPE OR ENGAGE";
	extern Log gamelog;
	extern int selectedsiege;
	extern squadst *activesquad;
	extern MusicClass music;
	extern long cursquadid;
	extern vector<Creature *> pool;
	extern vector<squadst *> squad;
	music.play(MUSIC_DEFENSE);
	//GIVE INFO SCREEN
	eraseAlt();
	set_color_easy(RED_ON_BLACK_BRIGHT);
	mvaddstrAlt(1, 26, CONST_siege249);
	set_color_easy(WHITE_ON_BLACK);
	int yLevel = 3;
	for (int i = 0; i < len(engageConservatives); i++) {
		mvaddstrAlt(yLevel + i, 11, engageConservatives[i]);
	}
	yLevel += len(engageConservatives);
	int loc = -1;
	if (selectedsiege != -1) loc = selectedsiege;
	if (activesquad != NULL) loc = activesquad->squad[0]->location;
	if (loc == -1) return;
	if (LocationsPool::getInstance().siteHasCameras(loc))
	{
		mvaddstrAlt(yLevel, 16, CONST_siege250);
	}
	if (LocationsPool::getInstance().hasTraps(loc))
	{
		mvaddstrAlt(yLevel + 1, 16, CONST_siege251);
	}
	set_color_easy(RED_ON_BLACK_BRIGHT);
	mvaddstrAlt(23, 11, CONST_siege252);
	// Seperate logging text
	gamelog.log(CONST_siege253);
	pressAnyKey();
	if (LocationsPool::getInstance().getSiegeType(loc) == SIEGE_CCS && LocationsPool::getInstance().getLocationType(loc) == SITE_INDUSTRY_WAREHOUSE)
		CCSCapturesSite(loc); // CCS Captures warehouse -- this will be reversed if you fight them off
							  //CRIMINALIZE
	if (LocationsPool::getInstance().getSiegeType(loc) == SIEGE_POLICE) criminalizepool(LAWFLAG_RESIST, -1, loc);
	//DELETE ALL SQUADS IN THIS AREA UNLESS THEY ARE THE activesquad
	for (int sq = len(squad) - 1; sq >= 0; sq--)
		if (squad[sq] != activesquad && squad[sq]->squad[0])
			if (squad[sq]->squad[0]->location == loc)
			{
				if (activesquad)
				{
					for (int p = 0; p < 6; p++)
					{
						if (!squad[sq]->squad[p]) continue;
						squad[sq]->squad[p]->squadid = -1;
					}
					delete_and_remove(squad, sq);
				}
				else activesquad = squad[sq];
			}
	// No squads at the location? Form a new one.
	if (!activesquad)
	{
		squad.push_back(new squadst);
		squad.back()->id = cursquadid++;
		strcpy(squad.back()->name, LocationsPool::getInstance().getLocationNameWithGetnameMethod(selectedsiege, true).c_str());
		strcat(squad.back()->name, CONST_siege254.c_str());
		int i = 0;
		for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++) if (pool[p]->location == selectedsiege && pool[p]->alive&&pool[p]->align == 1)
		{
			squad.back()->squad[i] = pool[p];
			pool[p]->squadid = squad.back()->id;
			if (++i >= 6) break;
		}
		activesquad = squad.back();
	}
	//MAKE SURE PARTY IS ORGANIZED
	autopromote(loc);
	//START FIGHTING
	createNewStoryFieldAttack(loc);
	mode_site(loc);
}
/* siege - flavor text when you crush a CCS safe house */
void conquertextccs()
{
	const string CONST_siege273 = "+200 JUICE TO EVERYONE FOR ERADICATING THE CONSERVATIVE CRIME SQUAD";
	const string CONST_siege272 = "revolution to attend to?";
	const string CONST_siege271 = "The CCS has been completely destroyed.  Now wasn't there a ";
	const string CONST_siege270 = "the last of the enemy's morale and confidence is shattered.";
	const string CONST_siege269 = "With its Founder killed in the heart of their own base, ";
	const string CONST_siege268 = "slips away.  ";
	const string CONST_siege267 = "The CCS Founder lying dead at their feet, the squad ";
	const string CONST_siege266 = "it is increasingly clear that this was the CCS's last safehouse.";
	const string CONST_siege265 = "As your Liberals pick through the remains of the safehouse, ";
	const string CONST_siege264 = "their final victory.  ";
	const string CONST_siege263 = "Gunfire still ringing in their ears, the squad revels in ";
	const string CONST_siege262 = "this will make a fine base for future Liberal operations.";
	const string CONST_siege261 = "power has been severely weakened.  Once the safehouse cools off, ";
	const string CONST_siege260 = "The CCS Founder wasn't here, but for now, their ";
	const string CONST_siege258 = "The CCS Lieutenant lying dead at their feet, the squad ";
	const string CONST_siege257 = "their victory.  ";
	extern Log gamelog;
	extern MusicClass music;
	extern int ccs_siege_kills;
	extern char ccs_kills;
	extern vector<Creature *> pool;
	music.play(MUSIC_CONQUER);
	//GIVE INFO SCREEN
	eraseAlt();
	set_color_easy(GREEN_ON_BLACK_BRIGHT);
	mvaddstrAlt(1, 26, CONST_siege255, gamelog);
	gamelog.newline();
	if (ccs_kills < 3)
	{
		set_color_easy(WHITE_ON_BLACK);
		if (ccs_siege_kills > 10)
		{
			mvaddstrAlt(3, 16, CONST_siege263, gamelog);
			mvaddstrAlt(4, 11, CONST_siege257, gamelog);
		}
		else
		{
			mvaddstrAlt(3, 16, CONST_siege258, gamelog);
			mvaddstrAlt(4, 11, CONST_siege268);
		}
		addstrAlt(CONST_siege260, gamelog);
		mvaddstrAlt(5, 11, CONST_siege261, gamelog);
		mvaddstrAlt(6, 11, CONST_siege262, gamelog);
	}
	else
	{
		if (ccs_siege_kills > 10)
		{
			mvaddstrAlt(3, 16, CONST_siege263, gamelog);
			mvaddstrAlt(4, 11, CONST_siege264, gamelog);
			mvaddstrAlt(6, 16, CONST_siege265, gamelog);
			mvaddstrAlt(7, 11, CONST_siege266, gamelog);
		}
		else
		{
			mvaddstrAlt(3, 16, CONST_siege267, gamelog);
			mvaddstrAlt(4, 11, CONST_siege268, gamelog);
			mvaddstrAlt(6, 16, CONST_siege269, gamelog);
			mvaddstrAlt(7, 11, CONST_siege270, gamelog);
		}
		gamelog.newline();
		mvaddstrAlt(9, 16, CONST_siege271, gamelog);
		mvaddstrAlt(10, 16, CONST_siege272, gamelog);
		gamelog.newline();
		mvaddstrAlt(12, 5, CONST_siege273, gamelog);
		for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++) addjuice(*pool[p], 200, 1000);
	}
	gamelog.nextMessage();
	mvaddstrAlt(15, 19, CONST_siege274);
	while (getkeyAlt() != 'c');
}

// #include "../includes.h"
const string CONST_sleeper_update046 = "canseethings";
const string CONST_sleeper_update045 = "abstracted debate";
const string CONST_sleeper_update044 = "liberal power";

void prepareencounter(short type, char sec);
Log gamelog; //The gamelog.
Log xmllog; // Log for xml errors or bad values.
string they_are_stashed;
string hasBeenCaughtSnooping;
string isNowHomeless;
string hasLeakedIntelligence;
string hasLeakedPolice;
string hasLeakedCorporate;
string hasLeakedPrison;
string hasLeakedCableNews;
string hasLeakedAMRadio;
string hasLeakedAnimalResearch;
string hasLeakedJudiciary;
string papersAreStashed;
string hasLeakedCCS;
string diskIsStashed;
string arrestedWhileEmbezzling;
string arrestedWhileStealing;
string droppedOffPackage;
string itemNotFound;
string lostStolenItem;
string contactModAuthor;
string hasRecruited;
string looksForwardToServing;
/*********************************
**
**   SLEEPERS INFLUENCING
**     PUBLIC OPINION
**
**********************************/
void sleeper_influence(Creature &cr, char &clearformess, char canseethings, int(&libpower)[VIEWNUM])
{
	extern short attitude[VIEWNUM];
	extern short lawList[LAWNUM];
	int power = (cr.get_attribute(ATTRIBUTE_CHARISMA, true) +
		cr.get_attribute(ATTRIBUTE_HEART, true) +
		cr.get_attribute(ATTRIBUTE_INTELLIGENCE, true) +
		cr.get_skill(SKILL_PERSUASION));
	// Profession specific skills
	switch (cr.type)
	{
	case CREATURE_CRITIC_ART:
		power += cr.get_skill(SKILL_WRITING);
	case CREATURE_PAINTER:
	case CREATURE_SCULPTOR:
		power += cr.get_skill(SKILL_ART);
		break;
	case CREATURE_CRITIC_MUSIC:
		power += cr.get_skill(SKILL_WRITING);
	case CREATURE_MUSICIAN:
		power += cr.get_skill(SKILL_MUSIC);
		break;
	case CREATURE_AUTHOR:
	case CREATURE_JOURNALIST:
		power += cr.get_skill(SKILL_WRITING);
		break;
	case CREATURE_JUDGE_CONSERVATIVE:
		power += cr.get_skill(SKILL_WRITING);
	case CREATURE_LAWYER:
		power += cr.get_skill(SKILL_LAW);
		break;
	case CREATURE_SCIENTIST_LABTECH:
	case CREATURE_SCIENTIST_EMINENT:
		power += cr.get_skill(SKILL_SCIENCE);
		break;
	case CREATURE_CORPORATE_CEO:
	case CREATURE_CORPORATE_MANAGER:
		power += cr.get_skill(SKILL_BUSINESS);
		break;
	case CREATURE_PRIEST:
	case CREATURE_NUN:
		power += cr.get_skill(SKILL_RELIGION);
		break;
	case CREATURE_EDUCATOR:
		power += cr.get_skill(SKILL_PSYCHOLOGY);
		break;
	}
	// Adjust power for super sleepers
	switch (cr.type)
	{
	case CREATURE_CORPORATE_CEO:
	case CREATURE_POLITICIAN:
	case CREATURE_SCIENTIST_EMINENT:
		power *= 20;
		break;
	case CREATURE_DEATHSQUAD:
	case CREATURE_EDUCATOR:
	case CREATURE_MILITARYOFFICER:
		power *= 6;
		break;
	case CREATURE_ACTOR:
	case CREATURE_GANGUNIT:
	case CREATURE_MILITARYPOLICE:
	case CREATURE_SEAL:
		power *= 4;
		break;
	default:
		power *= 2;
		break;
	}
	power = static_cast<int>(power*cr.infiltration);
	switch (cr.type)
	{
		/* Radio Personalities and News Anchors subvert Conservative news stations by
		reducing their audience and twisting views on the issues. As their respective
		media establishments become marginalized, so does their influence. */
	case CREATURE_RADIOPERSONALITY:
		change_public_opinion(VIEW_AMRADIO, 1);
		for (int i = 0; i < VIEWNUM - 3; i++)
		{
			libpower[i] += power * (100 - attitude[VIEW_AMRADIO]) / 100;
		}
		break;
	case CREATURE_NEWSANCHOR:
		change_public_opinion(VIEW_CABLENEWS, 1);
		for (int i = 0; i < VIEWNUM - 3; i++)
		{
			libpower[i] += power * (100 - attitude[VIEW_CABLENEWS]) / 100;
		}
		break;
		/* Cultural leaders block - influences cultural issues */
	case CREATURE_PRIEST:
	case CREATURE_PAINTER:
	case CREATURE_SCULPTOR:
	case CREATURE_AUTHOR:
	case CREATURE_JOURNALIST:
	case CREATURE_PSYCHOLOGIST:
	case CREATURE_MUSICIAN:
	case CREATURE_CRITIC_ART:
	case CREATURE_CRITIC_MUSIC:
	case CREATURE_ACTOR:
		libpower[VIEW_WOMEN] += power;
		libpower[VIEW_CIVILRIGHTS] += power;
		libpower[VIEW_GAY] += power;
		libpower[VIEW_FREESPEECH] += power;
		libpower[VIEW_DRUGS] += power;
		libpower[VIEW_IMMIGRATION] += power;
		break;
		/* Legal block - influences an array of social issues */
	case CREATURE_JUDGE_CONSERVATIVE:
		libpower[VIEW_JUSTICES] += power;
		libpower[VIEW_FREESPEECH] += power;
		libpower[VIEW_INTELLIGENCE] += power;
	case CREATURE_LAWYER:
		libpower[VIEW_POLICEBEHAVIOR] += power;
		libpower[VIEW_DEATHPENALTY] += power;
		libpower[VIEW_GUNCONTROL] += power;
		libpower[VIEW_DRUGS] += power;
		break;
		/* Scientists block */
	case CREATURE_SCIENTIST_EMINENT:
		libpower[VIEW_POLLUTION] += power;
	case CREATURE_SCIENTIST_LABTECH:
		libpower[VIEW_NUCLEARPOWER] += power;
		libpower[VIEW_ANIMALRESEARCH] += power;
		libpower[VIEW_GENETICS] += power;
		break;
		/* Corporate block */
	case CREATURE_CORPORATE_CEO:
		libpower[VIEW_CEOSALARY] += power;
	case CREATURE_CORPORATE_MANAGER:
		libpower[VIEW_WOMEN] += power;
		libpower[VIEW_TAXES] += power;
		libpower[VIEW_CORPORATECULTURE] += power;
		libpower[VIEW_SWEATSHOPS] += power;
		libpower[VIEW_POLLUTION] += power;
		libpower[VIEW_CIVILRIGHTS] += power;
		break;
		/* Law enforcement block */
	case CREATURE_DEATHSQUAD:
		libpower[VIEW_PRISONS] += power;
		libpower[VIEW_DEATHPENALTY] += power;
	case CREATURE_SWAT:
	case CREATURE_COP:
	case CREATURE_GANGUNIT:
		libpower[VIEW_POLICEBEHAVIOR] += power;
		libpower[VIEW_DRUGS] += power;
		libpower[VIEW_TORTURE] += power;
		libpower[VIEW_GUNCONTROL] += power;
		libpower[VIEW_PRISONS] += power;
		break;
		/* Prison block */
	case CREATURE_EDUCATOR:
	case CREATURE_PRISONGUARD:
	case CREATURE_PRISONER:
		libpower[VIEW_POLICEBEHAVIOR] += power;
		libpower[VIEW_DEATHPENALTY] += power;
		libpower[VIEW_DRUGS] += power;
		libpower[VIEW_TORTURE] += power;
		libpower[VIEW_PRISONS] += power;
		break;
		/* Intelligence block */
	case CREATURE_SECRET_SERVICE:
		libpower[VIEW_INTELLIGENCE] += power;
		break;
	case CREATURE_AGENT:
		libpower[VIEW_INTELLIGENCE] += power;
		libpower[VIEW_TORTURE] += power;
		libpower[VIEW_PRISONS] += power;
		libpower[VIEW_FREESPEECH] += power;
		break;
		/* Military block */
	case CREATURE_MERC:
		libpower[VIEW_GUNCONTROL] += power;
		break;
	case CREATURE_SOLDIER:
	case CREATURE_VETERAN:
	case CREATURE_MILITARYPOLICE:
	case CREATURE_MILITARYOFFICER:
	case CREATURE_SEAL:
		libpower[VIEW_MILITARY] += power;
		libpower[VIEW_TORTURE] += power;
		libpower[VIEW_GAY] += power;
		libpower[VIEW_WOMEN] += power;
		break;
		/* Sweatshop workers */
	case CREATURE_WORKER_SWEATSHOP:
		libpower[VIEW_IMMIGRATION] += power;
		libpower[VIEW_SWEATSHOPS] += power;
		break;
		/* No influence at all block - for people were liberal anyway, or have no way of doing any good */
	case CREATURE_WORKER_FACTORY_CHILD:
	case CREATURE_GENETIC:
	case CREATURE_GUARDDOG:
	case CREATURE_BUM:
	case CREATURE_CRACKHEAD:
	case CREATURE_TANK:
	case CREATURE_HIPPIE: // too liberal to be a proper sleeper
	case CREATURE_WORKER_FACTORY_UNION: // same
	case CREATURE_JUDGE_LIBERAL: // more again
	case CREATURE_MUTANT:
		return;
		/* Miscellaneous block -- includes everyone else */
	case CREATURE_POLITICIAN:
	{
		int a = LCSrandom(VIEWNUM - 5);
		int b = LCSrandom(VIEWNUM - 5);
		while (b == a)b = LCSrandom(VIEWNUM - 5);
		int c = LCSrandom(VIEWNUM - 5);
		while (c == a || c == b)c = LCSrandom(VIEWNUM - 5);
		libpower[a] += power;
		libpower[b] += power;
		libpower[c] += power;
	}
	break;
	case CREATURE_FIREFIGHTER:
		if (lawList[LAW_FREESPEECH] == -2)
		{
			libpower[VIEW_FREESPEECH] += power;
			break;
		}
	default: // Affect a random issue
		pickrandom(libpower) += power;
	}
}
/*********************************
**
**   SLEEPERS SNOOPING AROUND
**
**********************************/
void creatureLeaksIntel(Creature cr, const string& leak, const string& stashed) {
	eraseAlt();
	mvaddstrAlt(6, 1, string_sleeper, gamelog);
	addstrAlt(cr.name, gamelog);
	addstrAlt(leak, gamelog);
	gamelog.newline();
	mvaddstrAlt(7, 1, stashed, gamelog);
	gamelog.nextMessage();
}
void sleeper_spy(Creature &cr, char &clearformess, char canseethings, int(&libpower)[VIEWNUM])
{
	extern CCSexposure ccsexposure;
	extern short lawList[LAWNUM];
	int homes = find_site_index_in_same_city(SITE_RESIDENTIAL_SHELTER, cr.location);
	if (LCSrandom(100) > 100 * cr.infiltration)
	{
		cr.juice -= 1;
		if (cr.juice < -2)
		{
			eraseAlt();
			mvaddstrAlt(6, 1, string_sleeper, gamelog);
			addstrAlt(cr.name, gamelog);
			addstrAlt(hasBeenCaughtSnooping, gamelog);
			gamelog.newline();
			mvaddstrAlt(8, 1, isNowHomeless, gamelog);
			gamelog.nextMessage();
			pressAnyKey();
			removesquadinfo(cr);
			cr.location = homes;
			cr.base = homes;
			cr.drop_weapons_and_clips(NULL);
			cr.activity.type = ACTIVITY_NONE;
			cr.flag &= ~CREATUREFLAG_SLEEPER;
		}
		return;
	}
	// Improves juice, as confidence improves
	if (cr.juice < 100)
	{
		cr.juice += 10;
		if (cr.juice > 100) cr.juice = 100;
	}
	LocationsPool::getInstance().setLocationMappedAndUnhidden(cr.base);
	bool pause = false;
	switch (cr.type)
	{
	case CREATURE_SECRET_SERVICE:
	case CREATURE_AGENT:
	case CREATURE_POLITICIAN:
		// Agents can leak intelligence files to you
		if (!LocationsPool::getInstance().isThereASiegeHere(homes) && canseethings)
		{
			if (LCSrandom(lawList[LAW_PRIVACY] + 3)) break;
			LocationsPool::getInstance().stashThisLootHere(tag_LOOT_SECRETDOCUMENTS, homes);
			creatureLeaksIntel(cr, hasLeakedIntelligence, they_are_stashed);
			pause = true;
		}
		break;
	case CREATURE_DEATHSQUAD:
	case CREATURE_SWAT:
	case CREATURE_COP:
	case CREATURE_GANGUNIT:
		// Cops can leak police files to you
		if (!LocationsPool::getInstance().isThereASiegeHere(homes) && canseethings)
		{
			if (LCSrandom(lawList[LAW_POLICEBEHAVIOR] + 3)) break;
			LocationsPool::getInstance().stashThisLootHere(tag_LOOT_POLICERECORDS, homes);
			creatureLeaksIntel(cr, hasLeakedPolice, they_are_stashed);
			pause = true;
		}
		break;
	case CREATURE_CORPORATE_MANAGER:
	case CREATURE_CORPORATE_CEO:
		// Can leak corporate files to you
		if (!LocationsPool::getInstance().isThereASiegeHere(homes) && canseethings)
		{
			if (LCSrandom(lawList[LAW_CORPORATE] + 3) && cr.type != CREATURE_CORPORATE_CEO) break;
			LocationsPool::getInstance().stashThisLootHere(tag_LOOT_CORPFILES, homes);
			creatureLeaksIntel(cr, hasLeakedCorporate, they_are_stashed);
			pause = true;
		}
		break;
	case CREATURE_EDUCATOR:
	case CREATURE_PRISONGUARD:
		if (!LocationsPool::getInstance().isThereASiegeHere(homes) && canseethings)
		{
			if (LCSrandom(lawList[LAW_POLICEBEHAVIOR] + 3)) break;
			LocationsPool::getInstance().stashThisLootHere(tag_LOOT_PRISONFILES, homes);
			creatureLeaksIntel(cr, hasLeakedPrison, they_are_stashed);
			pause = true;
		}
		break;
	case CREATURE_NEWSANCHOR:
		if (!LocationsPool::getInstance().isThereASiegeHere(homes) && canseethings)
		{
			// More likely to leak these documents the more restrictive
			// free speech is -- because the more free the society, the
			// less any particular action the media takes seems scandalous
			if (LCSrandom(lawList[LAW_FREESPEECH] + 3)) break;
			LocationsPool::getInstance().stashThisLootHere(tag_LOOT_CABLENEWSFILES, homes);
			creatureLeaksIntel(cr, hasLeakedCableNews, papersAreStashed);
			pause = true;
		}
		break;
	case CREATURE_RADIOPERSONALITY:
		if (!LocationsPool::getInstance().isThereASiegeHere(homes) && canseethings)
		{
			// More likely to leak these documents the more restrictive
			// free speech is -- because the more free the society, the
			// less any particular action the media takes seems scandalous
			if (LCSrandom(lawList[LAW_FREESPEECH] + 3)) break;
			LocationsPool::getInstance().stashThisLootHere(tag_LOOT_AMRADIOFILES, homes);
			creatureLeaksIntel(cr, hasLeakedAMRadio, papersAreStashed);
			pause = true;
		}
		break;
	case CREATURE_SCIENTIST_LABTECH:
	case CREATURE_SCIENTIST_EMINENT:
		if (!LocationsPool::getInstance().isThereASiegeHere(homes) && canseethings)
		{
			if (LCSrandom(lawList[LAW_ANIMALRESEARCH] + 3)) break;
			LocationsPool::getInstance().stashThisLootHere(tag_LOOT_RESEARCHFILES, homes);
			creatureLeaksIntel(cr, hasLeakedAnimalResearch, they_are_stashed);
			pause = true;
		}
		break;
	case CREATURE_JUDGE_CONSERVATIVE:
		if (!LocationsPool::getInstance().isThereASiegeHere(homes) && canseethings)
		{
			if (LCSrandom(5)) break;
			LocationsPool::getInstance().stashThisLootHere(tag_LOOT_JUDGEFILES, homes);
			creatureLeaksIntel(cr, hasLeakedJudiciary, papersAreStashed);
			pause = true;
		}
		break;
	case CREATURE_CCS_ARCHCONSERVATIVE:
		if (!LocationsPool::getInstance().isThereASiegeHere(homes) && canseethings)
		{
			if (ccsexposure >= CCSEXPOSURE_LCSGOTDATA) break;
			LocationsPool::getInstance().stashThisLootHere(tag_LOOT_CCS_BACKERLIST, homes);
			creatureLeaksIntel(cr, hasLeakedCCS, diskIsStashed);
			pause = true;
			ccsexposure = CCSEXPOSURE_LCSGOTDATA;
		}
		break;
	}
	if (pause) getkeyAlt();
}
/*********************************
**
**   SLEEPERS EMBEZZLING FUNDS
**
**********************************/
void sleeper_embezzle(Creature &cr, char &clearformess, char canseethings, int(&libpower)[VIEWNUM])
{
	extern class Ledger ledger;
	if (LCSrandom(100) > 100 * cr.infiltration)
	{
		cr.juice -= 1;
		if (cr.juice < -2)
		{
			eraseAlt();
			mvaddstrAlt(6, 1, string_sleeper, gamelog);
			addstrAlt(cr.name, gamelog);
			addstrAlt(arrestedWhileEmbezzling, gamelog);
			gamelog.nextMessage();
			pressAnyKey();
			cr.crimes_suspected[LAWFLAG_COMMERCE]++;
			removesquadinfo(cr);
			cr.location = find_site_index_in_same_city(SITE_GOVERNMENT_POLICESTATION, cr.location);
			cr.drop_weapons_and_clips(NULL);
			cr.activity.type = ACTIVITY_NONE;
			cr.flag &= ~CREATUREFLAG_SLEEPER;
		}
		return;
	}
	// Improves juice, as confidence improves
	if (cr.juice < 100)
	{
		cr.juice += 10;
		if (cr.juice > 100) cr.juice = 100;
	}
	int income;
	switch (cr.type)
	{
	case CREATURE_CORPORATE_CEO:
		income = static_cast<int>(50000 * cr.infiltration);
		break;
	case CREATURE_SCIENTIST_EMINENT:
	case CREATURE_CORPORATE_MANAGER:
	case CREATURE_BANK_MANAGER:
	case CREATURE_POLITICIAN:
		income = static_cast<int>(5000 * cr.infiltration);
		break;
	default:
		income = static_cast<int>(500 * cr.infiltration);
		break;
	}
	ledger.add_funds(income, INCOME_EMBEZZLEMENT);
}
struct stringAndInt
{
	string str;
	int integer;
	stringAndInt(const string& str_, int integer_) : str(str_), integer(integer_) {}
	stringAndInt(int integer_, const string& str_) : str(str_), integer(integer_) {}
};
string randomString(vector<stringAndInt>);
string randomString(vector<stringAndInt> outputList) {
	for (stringAndInt s : outputList) {
		if (!LCSrandom(s.integer)) {
			return s.str;
		}
	}
	return outputList[len(outputList) - 1].str;
}
/*********************************
**
**   SLEEPERS STEALING THINGS
**
**********************************/
void sleeper_steal(Creature &cr, char &clearformess, char canseethings, int(&libpower)[VIEWNUM])
{
	extern short lawList[LAWNUM];
	if (LCSrandom(100) > 100 * cr.infiltration)
	{
		cr.juice -= 1;
		if (cr.juice < -2)
		{
			eraseAlt();
			mvaddstrAlt(6, 1, string_sleeper, gamelog);
			addstrAlt(cr.name, gamelog);
			addstrAlt(arrestedWhileStealing, gamelog);
			gamelog.nextMessage();
			pressAnyKey();
			cr.crimes_suspected[LAWFLAG_THEFT]++;
			removesquadinfo(cr);
			cr.location = find_site_index_in_same_city(SITE_GOVERNMENT_POLICESTATION, cr.location);
			cr.drop_weapons_and_clips(NULL);
			cr.activity.type = ACTIVITY_NONE;
			cr.flag &= ~CREATUREFLAG_SLEEPER;
		}
		return;
	}
	// Improves juice, as confidence improves
	if (cr.juice < 100)
	{
		cr.juice += 10;
		if (cr.juice > 100)cr.juice = 100;
	}
	cr.infiltration -= LCSrandom(10)*0.01f - 0.02f; //No effectiveness drop before? -Niel
													//Item *item;
	string item;
	int shelter = find_site_index_in_same_city(SITE_RESIDENTIAL_SHELTER, cr.location);
	int number_of_items = LCSrandom(10) + 1;
	int itemindex = -1; // have to check case item not found to avoid brave modders segfaults.
	int numberofxmlfails = 0; // Tell them how many fails
	while (number_of_items--)
	{
		bool loot = false;
		bool armor = false;
		bool weapon = false;
		switch (LocationsPool::getInstance().getLocationType(cr.location)) //Temporary (transitionally) solution until sites are done. -XML
		{
		case SITE_RESIDENTIAL_TENEMENT:
			item = randomString({ stringAndInt(3, tag_LOOT_KIDART),
				stringAndInt(2, tag_LOOT_DIRTYSOCK),
				stringAndInt(1, tag_LOOT_FAMILYPHOTO) });
			loot = true;
			break;
		case SITE_RESIDENTIAL_APARTMENT:
			item = randomString({ stringAndInt(5, tag_LOOT_CELLPHONE),
				stringAndInt(4, tag_LOOT_SILVERWARE),
				stringAndInt(3, tag_LOOT_TRINKET),
				stringAndInt(2, tag_LOOT_CHEAPJEWELERY),
				stringAndInt(1,  tag_LOOT_COMPUTER) });
			loot = true;
			break;
		case SITE_RESIDENTIAL_APARTMENT_UPSCALE:
			item = randomString({ stringAndInt(10, tag_LOOT_EXPENSIVEJEWELERY),
				stringAndInt(5, tag_LOOT_CELLPHONE),
				stringAndInt(4, tag_LOOT_SILVERWARE),
				stringAndInt(3, tag_LOOT_PDA),
				stringAndInt(2, tag_LOOT_CHEAPJEWELERY),
				stringAndInt(1,  tag_LOOT_COMPUTER) });
			loot = true;
			break;
		case SITE_LABORATORY_COSMETICS:
		case SITE_INDUSTRY_NUCLEAR:
		case SITE_LABORATORY_GENETIC:
			item = randomString({ stringAndInt(5, tag_LOOT_RESEARCHFILES),
				stringAndInt(2, tag_LOOT_LABEQUIPMENT),
				stringAndInt(2, tag_LOOT_COMPUTER),
				stringAndInt(5, tag_LOOT_PDA),
				stringAndInt(5, tag_LOOT_CHEMICAL),
				stringAndInt(1,  tag_LOOT_COMPUTER) });
			loot = true;
			break;
		case SITE_GOVERNMENT_COURTHOUSE:
			item = randomString({ stringAndInt(5, tag_LOOT_JUDGEFILES),
				stringAndInt(3, tag_LOOT_CELLPHONE),
				stringAndInt(2, tag_LOOT_PDA),
				stringAndInt(1,  tag_LOOT_COMPUTER) });
			loot = true;
			break;
		case SITE_GOVERNMENT_PRISON:
			item = randomString({ stringAndInt(1, tag_WEAPON_SHANK) });
			weapon = true;
			break;
		case SITE_BUSINESS_BANK:
		case SITE_GOVERNMENT_FIRESTATION:
			item = randomString({ stringAndInt(2, tag_LOOT_TRINKET),
				stringAndInt(1,  tag_LOOT_COMPUTER) });
			loot = true;
			break;
		case SITE_INDUSTRY_SWEATSHOP:
			item = randomString({ stringAndInt(1, tag_LOOT_FINECLOTH) });
			loot = true;
			break;
		case SITE_INDUSTRY_POLLUTER:
			item = randomString({ stringAndInt(1, tag_LOOT_CHEMICAL) });
			loot = true;
			break;
		case SITE_CORPORATE_HEADQUARTERS:
			item = randomString({ stringAndInt(5, tag_LOOT_CORPFILES),
				stringAndInt(3, tag_LOOT_CELLPHONE),
				stringAndInt(2, tag_LOOT_PDA),
				stringAndInt(1,  tag_LOOT_COMPUTER) });
			loot = true;
			break;
		case SITE_CORPORATE_HOUSE:
			item = randomString({ stringAndInt(8, tag_LOOT_TRINKET),
				stringAndInt(7, tag_LOOT_WATCH),
				stringAndInt(6, tag_LOOT_PDA),
				stringAndInt(5, tag_LOOT_CELLPHONE),
				stringAndInt(4, tag_LOOT_SILVERWARE),
				stringAndInt(3, tag_LOOT_CHEAPJEWELERY),
				stringAndInt(2, tag_LOOT_FAMILYPHOTO),
				stringAndInt(1,  tag_LOOT_COMPUTER) });
			loot = true;
			break;
		case SITE_MEDIA_AMRADIO:
			item = randomString({ stringAndInt(5, tag_LOOT_AMRADIOFILES),
				stringAndInt(4, tag_LOOT_MICROPHONE),
				stringAndInt(3, tag_LOOT_PDA),
				stringAndInt(2, tag_LOOT_CELLPHONE),
				stringAndInt(1,  tag_LOOT_COMPUTER) });
			loot = true;
			break;
		case SITE_MEDIA_CABLENEWS:
			item = randomString({ stringAndInt(5, tag_LOOT_CABLENEWSFILES),
				stringAndInt(4, tag_LOOT_MICROPHONE),
				stringAndInt(3, tag_LOOT_PDA),
				stringAndInt(2, tag_LOOT_CELLPHONE),
				stringAndInt(1,  tag_LOOT_COMPUTER) });
			loot = true;
			break;
		case SITE_GOVERNMENT_POLICESTATION:
			if (!LCSrandom(3))
			{
				item = randomString({ stringAndInt(4, tag_WEAPON_SMG_MP5),
					stringAndInt(3, tag_WEAPON_SEMIPISTOL_45),
					stringAndInt(2, tag_WEAPON_SHOTGUN_PUMP),
					stringAndInt(1,  tag_WEAPON_SEMIRIFLE_AR15) });
				weapon = true;
			}
			else if (!LCSrandom(2))
			{
				if (lawList[LAW_POLICEBEHAVIOR] == -2 && lawList[LAW_DEATHPENALTY] == -2 && !LCSrandom(4))item = tag_ARMOR_DEATHSQUADUNIFORM;
				else item = randomString({ stringAndInt(3, tag_ARMOR_POLICEUNIFORM),
					stringAndInt(2, tag_ARMOR_SWATARMOR),
					stringAndInt(1,  tag_ARMOR_POLICEARMOR) });
				armor = true;
			}
			else
			{
				item = randomString({ stringAndInt(5, tag_LOOT_POLICERECORDS),
					stringAndInt(3, tag_LOOT_CELLPHONE),
					stringAndInt(2, tag_LOOT_PDA),
					stringAndInt(1,  tag_LOOT_COMPUTER) });
				loot = true;
			}
			break;
		case SITE_GOVERNMENT_ARMYBASE:
			if (!LCSrandom(3))
			{
				item = randomString({
					stringAndInt(3,  tag_WEAPON_CARBINE_M4),
					stringAndInt(1, tag_WEAPON_AUTORIFLE_M16) });
				weapon = true;
			}
			else if (!LCSrandom(2))
			{
				item = randomString({ stringAndInt(1, tag_ARMOR_ARMYARMOR) });
				armor = true;
			}
			else
			{
				item = randomString({ stringAndInt(5, tag_LOOT_SECRETDOCUMENTS),
					stringAndInt(3, tag_LOOT_CELLPHONE),
					stringAndInt(2, tag_LOOT_CHEMICAL),
					stringAndInt(1,  tag_LOOT_SILVERWARE) });
				loot = true;
			}
			break;
		case SITE_GOVERNMENT_WHITE_HOUSE:
		case SITE_GOVERNMENT_INTELLIGENCEHQ:
			if (!LCSrandom(3))
			{
				item = randomString({ stringAndInt(4, tag_WEAPON_SMG_MP5),
					stringAndInt(3, tag_WEAPON_AUTORIFLE_M16),
					stringAndInt(2, tag_WEAPON_SHOTGUN_PUMP),
					stringAndInt(1,  tag_WEAPON_CARBINE_M4) });
				weapon = true;
			}
			else if (!LCSrandom(2))
			{
				item = randomString({ stringAndInt(1, tag_ARMOR_BLACKSUIT) });
				armor = true;
			}
			else
			{
				item = randomString({ stringAndInt(5, tag_LOOT_SECRETDOCUMENTS),
					stringAndInt(3, tag_LOOT_CELLPHONE),
					stringAndInt(2, tag_LOOT_PDA),
					stringAndInt(1,  tag_LOOT_COMPUTER) });
				loot = true;
			}
			break;
		}
		if (loot) {
			itemindex = getloottype(item);
			if (itemindex > -1) { LocationsPool::getInstance().stashThisLootHere(item, shelter); }
			else { numberofxmlfails++; }
		}
		else if (armor) {
			itemindex = getarmortype(item);
			if (itemindex > -1) {
				LocationsPool::getInstance().stashThisArmorHere(itemindex, shelter);
			}
			else { numberofxmlfails++; }
		}
		else if (weapon) {
			itemindex = getweapontype(item);
			if (itemindex > -1) { LocationsPool::getInstance().stashThisWeaponHere(itemindex, shelter); }
			else { numberofxmlfails++; }
		}
		else {
			numberofxmlfails++;
		}
	}
	eraseAlt();
	set_color_easy(WHITE_ON_BLACK);   mvaddstrAlt(6, 1, string_sleeper, gamelog);
	addstrAlt(cr.name, gamelog);
	addstrAlt(droppedOffPackage, gamelog);
	gamelog.nextMessage();
	if (numberofxmlfails > 0) {
		set_color_easy(RED_ON_BLUE_BRIGHT);
		mvaddstrAlt(8, 1, itemNotFound, xmllog);
		mvaddstrAlt(9, 1, numberofxmlfails, xmllog);
		addstrAlt(lostStolenItem, xmllog);
		set_color_easy(RED_ON_GREEN_BRIGHT);
		mvaddstrAlt(11, 1, contactModAuthor, xmllog);
		xmllog.nextMessage();
	}
	pressAnyKey();
}
/*********************************
**
**   SLEEPERS CREATING SCANDALS
**
**********************************/
void sleeper_scandal(Creature &cr, char &clearformess, char canseethings, int(&libpower)[VIEWNUM])
{
	// Add content here!
	return;
}
/*********************************
**
**   SLEEPERS RECRUITING
**
**********************************/
void sleeper_recruit(Creature &cr, char &clearformess, char canseethings, int(&libpower)[VIEWNUM])
{
	extern int stat_recruits;
	extern Creature encounter[ENCMAX];
	if (subordinatesleft(cr))
	{
		prepareencounter(LocationsPool::getInstance().getLocationType(cr.worklocation), 0);
		for (int e = 0; e < 18; e++)
		{
			if (encounter[e].exists == false)
				break;
			if (encounter[e].worklocation == cr.worklocation || !LCSrandom(5))
			{
				if (encounter[e].align != 1 && LCSrandom(5))continue;
				Creature* recruit = new Creature(encounter[e]);
				liberalize(*recruit, 0);
				recruit->namecreature();
				recruit->hireid = cr.id;
				if (recruit->infiltration > cr.infiltration)
				{
					recruit->infiltration = cr.infiltration;
				}
				recruit->flag |= CREATUREFLAG_SLEEPER;
				LocationsPool::getInstance().setLocationMappedAndUnhidden(recruit->worklocation);
				addCreature(recruit);
				eraseAlt();
				mvaddstrAlt(6, 1, string_sleeper, gamelog);
				addstrAlt(cr.name, gamelog);
				addstrAlt(hasRecruited, gamelog);
				addstrAlt(recruit->get_type_name(), gamelog);
				addstrAlt(singleDot, gamelog);
				gamelog.newline();
				mvaddstrAlt(8, 1, recruit->name, gamelog);
				addstrAlt(looksForwardToServing, gamelog);
				gamelog.nextMessage();
				pressAnyKey();
				if (!subordinatesleft(cr))cr.activity.type = ACTIVITY_NONE;
				stat_recruits++;
				break;
			}
		}
	}
	return;
}
/**********************************************************************
** *JDS*
** ----- The sleeper system has been completely reworked.
** - Sleepers no longer directly influence the issues. They now affect
** the broad CONST_sleeper_update044 stats across many issues, which are used
** as a kind of monthly liberal roll akin to AM Radio and Cable News.
** - Each sleeper can affect one or more issue, throwing their power
** into the CONST_sleeper_update045 on that issue.
** - After all of the sleepers have contributed to the liberal power
** stats, a roll is made on each issue to see whether the liberals
** make background progress on those issues.
** - Several sleepers have special abilities. Lawyers and Judges, as
** always, can aid your people in the legal system. Police officers,
** corporate managers, CEOs, and agents can all now leak secret
** documents of the appropriate types, and they will make a check
** each month. This will only happen if the homeless shelter is not
** under siege, and CONST_sleeper_update046 is enabled (eg, you're not in prison
** or disbanded or some other situation where your sleeper can't get
** in touch with anyone in your squad).
** - News Anchors and Radio Personalities remain the two most powerful
** sleepers.
**********************************************************************/
void sleepereffect(Creature &cr, char &clearformess, char canseethings, int(&libpower)[VIEWNUM])
{
	extern char disbanding;
	if (disbanding)cr.activity.type = ACTIVITY_SLEEPER_LIBERAL;
	int infiltrate = 1;
	switch (cr.activity.type)
	{
	case ACTIVITY_SLEEPER_LIBERAL:
		sleeper_influence(cr, clearformess, canseethings, libpower);
		cr.infiltration -= 0.02f;
		break;
	case ACTIVITY_SLEEPER_EMBEZZLE:
		sleeper_embezzle(cr, clearformess, canseethings, libpower);
		break;
	case ACTIVITY_SLEEPER_STEAL:
		sleeper_steal(cr, clearformess, canseethings, libpower);
		infiltrate = 0;
		break;
	case ACTIVITY_SLEEPER_RECRUIT:
		sleeper_recruit(cr, clearformess, canseethings, libpower);
		break;
	case ACTIVITY_SLEEPER_SPY:
		sleeper_spy(cr, clearformess, canseethings, libpower);
		break;
	case ACTIVITY_SLEEPER_SCANDAL:
		sleeper_scandal(cr, clearformess, canseethings, libpower);
		break;
	case ACTIVITY_NONE:
	case ACTIVITY_SLEEPER_JOINLCS:
	default:
		break;
	}
	if (infiltrate) cr.infiltration += LCSrandom(8)*0.01f - 0.02f;
	if (cr.infiltration >= 1)
		cr.infiltration = 1;
	if (cr.infiltration <= 0)
		cr.infiltration = 0;
}

// #include "../includes.h"
const string CONST_stealth075 = "and shouts for help!";
const string CONST_stealth074 = "and lets forth a piercing Conservative alarm cry!";
const string CONST_stealth073 = "and launches into angry Conservative barking!";
const string CONST_stealth072 = " looks at the Squad with Intolerance ";
const string CONST_stealth069 = " sees the Squad's Liberal Weapons ";
const string CONST_stealth068 = " looks at the Squad suspiciously.";
const string CONST_stealth067 = " shouts in alarm at the squad's Liberal Trespassing!";
const string CONST_stealth066 = " acts natural.";
const string CONST_stealth065 = "The squad";
const string CONST_stealth064 = " fades into the shadows.";
const string CONST_stealth061 = "                                                        ";
const string CONST_stealth060 = "We've alienated absolutely everyone here!               ";
const string CONST_stealth059 = "We've alienated the masses here!              ";
const string CONST_stealth058 = "Prisoner";
const string CONST_stealth055 = " observes your Liberal activity ";
const string CONST_stealth053 = "blew_stealth_check.txt";

const string tag_ARMOR_SEALSUIT = "ARMOR_SEALSUIT";
const string tag_ARMOR_MILITARY = "ARMOR_MILITARY";
const string tag_ARMOR_SERVANTUNIFORM = "ARMOR_SERVANTUNIFORM";
const string tag_ARMOR_HARDHAT = "ARMOR_HARDHAT";
const string tag_ARMOR_OVERALLS = "ARMOR_OVERALLS";
const string tag_ARMOR_PRISONGUARD = "ARMOR_PRISONGUARD";
const string tag_ARMOR_WIFEBEATER = "ARMOR_WIFEBEATER";
const string tag_WEAPON_DESERT_EAGLE = "WEAPON_DESERT_EAGLE";
const string tag_WEAPON_MP5_SMG = "WEAPON_MP5_SMG";
vector<string> blew_stealth_check;
// #include "../customMaps.h"
const string stealth = "stealth\\";
vector<file_and_text_collection> stealth_text_file_collection = {
	customText(&blew_stealth_check, stealth + CONST_stealth053),
};

//extern short fieldskillrate;
/* checks if your liberal activity is noticed */
void noticecheck(int exclude, int difficulty)
{
	extern Log gamelog;
	extern short sitealarm;
	extern Creature encounter[ENCMAX];
	extern squadst *activesquad;
	if (sitealarm) return;
	char sneak = 0;
	int topi = 0;
	for (int i = 0; i < 6; ++i) if (activesquad->squad[i] && activesquad->squad[i]->get_skill(SKILL_STEALTH) > sneak)
		sneak = activesquad->squad[i]->get_skill(SKILL_STEALTH), topi = i;
	for (int e = 0; e < ENCMAX; e++)
	{  //Prisoners shouldn't shout for help.
		if (!strcmp(encounter[e].name, CONST_stealth058.c_str()) || e == exclude || encounter[e].exists == false || activesquad->squad[topi]->skill_check(SKILL_STEALTH, difficulty)) continue;
		else
		{
			clearmessagearea();
			set_color_easy(RED_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, encounter[e].name, gamelog);
			addstrAlt(CONST_stealth055, gamelog);
			if (encounter[e].align == ALIGN_CONSERVATIVE)
				mvaddstrAlt(17, 1, CONST_stealth074, gamelog);
			else mvaddstrAlt(17, 1, CONST_stealth075, gamelog);
			gamelog.newline();
			sitealarm = 1;
			pressAnyKey();
			break;
		}
	}
}
/* checks if your liberal behavior/attack alienates anyone */
char alienationcheck(char mistake)
{
	extern short cursite;
	extern Log gamelog;
	extern short mode;
	extern short sitealarm;
	extern short sitealienate;
	extern Creature encounter[ENCMAX];
	if (LocationsPool::getInstance().isThereASiegeHere(cursite))return 0;
	char alienate = 0;

	int oldsitealienate = sitealienate;
	vector<int> noticer;
	for (int e = 0; e < ENCMAX; e++)
	{
		// Prisoners should never be alienated by your crimes, as
		// they're happy to have you attacking their place of holding
		//if(encounter[e].type==CREATURE_PRISONER)continue;
		// ...but Prisoners are now spawned with a variety of creature
		// types, so we'll go by name instead
		if (!strcmp(encounter[e].name, CONST_stealth058.c_str())) continue;
		if (encounter[e].exists&&encounter[e].alive && (encounter[e].align == 0 || (encounter[e].align == 1 && mistake)))
			noticer.push_back(e);
	}
	if (len(noticer))
	{
		char alienatebig = 0;
		do
		{
			int an = LCSrandom(len(noticer));
			int n = noticer[an];
			noticer.erase(noticer.begin() + an);
			if (encounter[n].align == 1) alienatebig = 1;
			else alienate = 1;
		} while (len(noticer));
		if (alienatebig) sitealienate = 2;
		if (alienate&&sitealienate != 2) sitealienate = 1;
		if (oldsitealienate < sitealienate)
		{
			set_color_easy(YELLOW_ON_BLACK_BRIGHT);
			if (sitealienate == 1)mvaddstrAlt(16, 1, CONST_stealth059, gamelog);
			else mvaddstrAlt(16, 1, CONST_stealth060, gamelog);
			gamelog.newline();
			mvaddstrAlt(17, 1, CONST_stealth061);
			sitealarm = 1;
			for (int i = 0; i < ENCMAX; i++)
				if (encounter[i].exists && encounter[i].align != ALIGN_CONSERVATIVE)
					if (encounter[i].align == ALIGN_MODERATE || alienatebig)
						conservatise(encounter[i]);
			if (mode == GAMEMODE_CHASECAR ||
				mode == GAMEMODE_CHASEFOOT) printchaseencounter();
			else printencounter();
			pressAnyKey();
		}
	}
	return alienate;
}
char weapon_in_character(const string& wtype, const string& atype)
{
	extern short lawList[LAWNUM];
	//// TODO Move to XML
	if (atype == tag_ARMOR_LABCOAT && wtype == tag_WEAPON_SYRINGE)
		return CREATURE_SCIENTIST_LABTECH;
	if (atype == tag_ARMOR_BLACKROBE && wtype == tag_WEAPON_GAVEL)
		return CREATURE_JUDGE_LIBERAL;
	if (atype == tag_ARMOR_SECURITYUNIFORM && (wtype == tag_WEAPON_REVOLVER_38 ||
		wtype == tag_WEAPON_REVOLVER_44 || wtype == tag_WEAPON_DESERT_EAGLE ||
		wtype == tag_WEAPON_SEMIPISTOL_9MM || wtype == tag_WEAPON_SEMIPISTOL_45 ||
		wtype == tag_WEAPON_NIGHTSTICK || wtype == tag_WEAPON_MP5_SMG))
		return CREATURE_SECURITYGUARD;
	if ((atype == tag_ARMOR_POLICEUNIFORM || atype == tag_ARMOR_POLICEARMOR) &&
		(wtype == tag_WEAPON_REVOLVER_38 || wtype == tag_WEAPON_REVOLVER_44 ||
			wtype == tag_WEAPON_DESERT_EAGLE || wtype == tag_WEAPON_SEMIPISTOL_9MM ||
			wtype == tag_WEAPON_SEMIPISTOL_45 || wtype == tag_WEAPON_NIGHTSTICK ||
			wtype == tag_WEAPON_SHOTGUN_PUMP))
		return CREATURE_COP;
	if (wtype == tag_WEAPON_SMG_MP5 || wtype == tag_WEAPON_CARBINE_M4)
	{
		if (atype == tag_ARMOR_SWATARMOR)
			return CREATURE_SWAT;
		else if (atype == tag_ARMOR_SECURITYUNIFORM && lawList[LAW_GUNCONTROL] == -2)
			return CREATURE_SECURITYGUARD;
		else if (atype == tag_ARMOR_MILITARY || atype == tag_ARMOR_ARMYARMOR)
			return CREATURE_SOLDIER;
	}
	if (wtype == tag_WEAPON_AUTORIFLE_M16 || wtype == tag_WEAPON_SEMIRIFLE_AR15)
	{
		// Military
		if (atype == tag_ARMOR_MILITARY || atype == tag_ARMOR_ARMYARMOR)
			return CREATURE_SOLDIER;
		if (atype == tag_ARMOR_DEATHSQUADUNIFORM)
			return CREATURE_DEATHSQUAD;
	}
	if (wtype == tag_WEAPON_AXE && atype == tag_ARMOR_BUNKERGEAR)
		return CREATURE_FIREFIGHTER;
	if (wtype == tag_WEAPON_FLAMETHROWER && atype == tag_ARMOR_BUNKERGEAR && lawList[LAW_FREESPEECH] == -2)
		return CREATURE_FIREFIGHTER;
	if (atype == tag_ARMOR_PRISONGUARD && (wtype == tag_WEAPON_SMG_MP5 ||
		wtype == tag_WEAPON_SHOTGUN_PUMP || wtype == tag_WEAPON_NIGHTSTICK))
		return CREATURE_PRISONGUARD;
	if ((atype == tag_ARMOR_OVERALLS || atype == tag_ARMOR_WIFEBEATER) &&
		(wtype == tag_WEAPON_TORCH || wtype == tag_WEAPON_PITCHFORK ||
		(lawList[LAW_GUNCONTROL] == -2 && wtype == tag_WEAPON_SHOTGUN_PUMP)))
		return CREATURE_HICK;
	if (wtype == tag_WEAPON_SHANK && atype == tag_ARMOR_PRISONER)
		return CREATURE_PRISONER;
	if (wtype == tag_WEAPON_CHAIN &&
		(atype == tag_ARMOR_WORKCLOTHES || atype == tag_ARMOR_HARDHAT))
		return CREATURE_WORKER_FACTORY_UNION;
	if (wtype == tag_WEAPON_CARBINE_M4 && atype == tag_ARMOR_SEALSUIT)
		return CREATURE_SEAL;
	return -1;
}
map<int, vector<string> > siegeDisguises = {
	map<int, vector<string> >::value_type(SIEGE_CIA,
		{
			tag_ARMOR_BLACKSUIT,
			tag_ARMOR_BLACKDRESS,

		}),
	map<int, vector<string> >::value_type(SIEGE_CORPORATE,
			{
				tag_ARMOR_MILITARY,
				tag_ARMOR_ARMYARMOR,
				tag_ARMOR_SEALSUIT,

			}),
	map<int, vector<string> >::value_type(SIEGE_HICKS,
				{
					tag_ARMOR_CLOTHES, // duplication means uniformed is incremented twice, makint its value 2 instead of 1 or 0
					tag_ARMOR_CLOTHES, // it was how it was coded, what uniformed > 1 means is not clear from context
					tag_ARMOR_OVERALLS,
					tag_ARMOR_WIFEBEATER,

				}),

	map<int, vector<string> >::value_type(SIEGE_FIREMEN,
					{
						tag_ARMOR_BUNKERGEAR,

					}),
};
map<int, vector<string> > locationDisguises = {
	map<int, vector<string> >::value_type(SITE_BUSINESS_CIGARBAR, {
	tag_ARMOR_EXPENSIVESUIT,
	tag_ARMOR_CHEAPSUIT,
	tag_ARMOR_EXPENSIVEDRESS,
	tag_ARMOR_CHEAPDRESS,
	tag_ARMOR_BLACKSUIT,
	tag_ARMOR_BLACKDRESS,
		}),
	map<int, vector<string> >::value_type(SITE_CORPORATE_HOUSE, {
tag_ARMOR_EXPENSIVESUIT,
tag_ARMOR_EXPENSIVEDRESS,
tag_ARMOR_SECURITYUNIFORM,
tag_ARMOR_SERVANTUNIFORM,
}),
	map<int, vector<string> >::value_type(SITE_INDUSTRY_POLLUTER, {
tag_ARMOR_WORKCLOTHES,
tag_ARMOR_HARDHAT,
	}),
	map<int, vector<string> >::value_type(SITE_CORPORATE_HEADQUARTERS, {
	tag_ARMOR_EXPENSIVESUIT,
	tag_ARMOR_CHEAPSUIT,
	tag_ARMOR_SECURITYUNIFORM,
	tag_ARMOR_EXPENSIVEDRESS,
	tag_ARMOR_CHEAPDRESS,
		}),

};
map<int, vector<string> > restrictedLocationDisguises = {
	map<int, vector<string> >::value_type(SITE_GOVERNMENT_COURTHOUSE, {
		tag_ARMOR_BLACKROBE,
			tag_ARMOR_BLACKSUIT,
			tag_ARMOR_BLACKDRESS,
			tag_ARMOR_CHEAPSUIT,
			tag_ARMOR_CHEAPDRESS,
			tag_ARMOR_EXPENSIVESUIT,
			tag_ARMOR_EXPENSIVEDRESS,
			tag_ARMOR_POLICEUNIFORM,
			tag_ARMOR_POLICEARMOR,
			}),
	map<int, vector<string> >::value_type(SITE_GOVERNMENT_WHITE_HOUSE,{
	tag_ARMOR_BLACKSUIT,
	tag_ARMOR_BLACKDRESS,
	tag_ARMOR_CHEAPSUIT,
	tag_ARMOR_CHEAPDRESS,
	tag_ARMOR_EXPENSIVESUIT,
	tag_ARMOR_EXPENSIVEDRESS,
	tag_ARMOR_MILITARY,
	tag_ARMOR_ARMYARMOR,
	tag_ARMOR_SEALSUIT,
		}),
	map<int, vector<string> >::value_type(SITE_GOVERNMENT_ARMYBASE, {
	tag_ARMOR_MILITARY,
	tag_ARMOR_ARMYARMOR,
	tag_ARMOR_SEALSUIT,
		}),
	map<int, vector<string> >::value_type(SITE_MEDIA_AMRADIO, {
		tag_ARMOR_SECURITYUNIFORM,
			tag_ARMOR_EXPENSIVESUIT,
			tag_ARMOR_CHEAPSUIT,
			tag_ARMOR_EXPENSIVEDRESS,
			tag_ARMOR_CHEAPDRESS,

		}),
	map<int, vector<string> >::value_type(SITE_MEDIA_CABLENEWS, {
				tag_ARMOR_SECURITYUNIFORM,
					tag_ARMOR_EXPENSIVESUIT,
					tag_ARMOR_EXPENSIVEDRESS,

		}),
	map<int, vector<string> >::value_type(SITE_INDUSTRY_NUCLEAR, {
				tag_ARMOR_LABCOAT,
					tag_ARMOR_SECURITYUNIFORM,
					tag_ARMOR_CIVILLIANARMOR,
					tag_ARMOR_HARDHAT,

				}),
	map<int, vector<string> >::value_type(SITE_BUSINESS_BANK, {
		tag_ARMOR_CHEAPSUIT,
			tag_ARMOR_EXPENSIVESUIT,
			tag_ARMOR_CHEAPDRESS,
			tag_ARMOR_EXPENSIVEDRESS,
			tag_ARMOR_SECURITYUNIFORM,
			tag_ARMOR_POLICEUNIFORM,
			tag_ARMOR_POLICEARMOR,
			}),
	map<int, vector<string> >::value_type(SITE_GOVERNMENT_FIRESTATION, {
		tag_ARMOR_BUNKERGEAR,
			tag_ARMOR_WORKCLOTHES,
			tag_ARMOR_OVERALLS,
			}),
	map<int, vector<string> >::value_type(SITE_GOVERNMENT_INTELLIGENCEHQ, {
		tag_ARMOR_BLACKSUIT,
		tag_ARMOR_BLACKDRESS,
				}),

};
map<int, vector<string> > highSecurityLocationDisguises = {
	map<int, vector<string> >::value_type(SITE_INDUSTRY_POLLUTER,{
	tag_ARMOR_SECURITYUNIFORM,
	}),

	map<int, vector<string> >::value_type(SITE_CORPORATE_HOUSE, {
	tag_ARMOR_MILITARY,
	tag_ARMOR_ARMYARMOR,
	tag_ARMOR_SEALSUIT,
		}),

};
/* checks if a creature's uniform is appropriate to the location */
char hasdisguise(const Creature &cr)
{
	extern short cursite;
	extern int locx;
	extern int locy;
	extern int locz;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	extern short lawList[LAWNUM];
	short type = -1;
	if (cursite >= 0)type = LocationsPool::getInstance().getLocationType(cursite);
	char uniformed = 0;
	// Never uniformed in battle colors
	//if(activesquad->stance==SQUADSTANCE_BATTLECOLORS)
	//   return 0;
	if (LocationsPool::getInstance().isThereASiegeHere(cursite))
	{
		for (string str : siegeDisguises[LocationsPool::getInstance().getSiegeType(cursite)]) {
			if (cr.get_armor().get_itemtypename() == str) {
				uniformed++;
			}
		}
		if (LocationsPool::getInstance().getSiegeType(cursite) == SIEGE_CCS) {

			// CCS has trained in anticipation of this tactic
			// There is no fooling them
			// (They pull this shit all the time in their own sieges)
			uniformed = 0;
		}
		if (LocationsPool::getInstance().getSiegeType(cursite) == SIEGE_POLICE)
		{
			if (cr.get_armor().get_itemtypename() == tag_ARMOR_SWATARMOR &&
				LocationsPool::getInstance().getSiegeEscalationState(cursite) == 0)uniformed = 1;
			if (cr.get_armor().get_itemtypename() == tag_ARMOR_MILITARY &&
				LocationsPool::getInstance().getSiegeEscalationState(cursite) > 0)uniformed = 1;
			if (cr.get_armor().get_itemtypename() == tag_ARMOR_ARMYARMOR &&
				LocationsPool::getInstance().getSiegeEscalationState(cursite) > 0)uniformed = 1;
			if (cr.get_armor().get_itemtypename() == tag_ARMOR_SEALSUIT &&
				LocationsPool::getInstance().getSiegeEscalationState(cursite) > 0)uniformed = 1;
		}

	}
	else
	{

		if ((!cr.is_naked() || cr.animalgloss == ANIMALGLOSS_ANIMAL)
			&& cr.get_armor().get_itemtypename() != tag_ARMOR_HEAVYARMOR)uniformed = 1;
		if (
			locationDisguises.count(LocationsPool::getInstance().getLocationType(cursite)) ||
			(highSecurityLocationDisguises.count(LocationsPool::getInstance().getLocationType(cursite)) && LocationsPool::getInstance().isThisPlaceHighSecurity(cursite)) ||
			(restrictedLocationDisguises.count(LocationsPool::getInstance().getLocationType(cursite)) && levelmap[locx][locy][locz].flag & SITEBLOCK_RESTRICTED)
			) {
			uniformed = 0;
		}
		if (levelmap[locx][locy][locz].flag & SITEBLOCK_RESTRICTED && LocationsPool::getInstance().isThisPlaceHighSecurity(cursite)) {

			for (string str : restrictedLocationDisguises[LocationsPool::getInstance().getLocationType(cursite)]) {
				if (cr.get_armor().get_itemtypename() == str) {
					uniformed++;
				}
			}
			for (string str : highSecurityLocationDisguises[LocationsPool::getInstance().getLocationType(cursite)]) {
				if (cr.get_armor().get_itemtypename() == str) {
					uniformed++;
				}
			}
		}
		else
			if (levelmap[locx][locy][locz].flag & SITEBLOCK_RESTRICTED) {
				if (restrictedLocationDisguises.count(LocationsPool::getInstance().getLocationType(cursite))) {
					uniformed = 0;
				}
				for (string str : restrictedLocationDisguises[LocationsPool::getInstance().getLocationType(cursite)]) {
					if (cr.get_armor().get_itemtypename() == str) {
						uniformed++;
					}
				}

			}
			else
				if (LocationsPool::getInstance().isThisPlaceHighSecurity(cursite)) {
					if (highSecurityLocationDisguises.count(LocationsPool::getInstance().getLocationType(cursite))) {
						uniformed = 0;
					}
					for (string str : highSecurityLocationDisguises[LocationsPool::getInstance().getLocationType(cursite)]) {
						if (cr.get_armor().get_itemtypename() == str) {
							uniformed++;
						}
					}

				}
		for (string str : locationDisguises[LocationsPool::getInstance().getLocationType(cursite)]) {
			if (cr.get_armor().get_itemtypename() == str) {
				uniformed++;
			}
		}






		//// TODO Move to XML

		switch (type)
		{

		case SITE_INDUSTRY_WAREHOUSE:
		case SITE_RESIDENTIAL_SHELTER:
			uniformed = 1;
			break;

		case SITE_INDUSTRY_SWEATSHOP:
			uniformed = 0;
			if (cr.is_naked()) uniformed = 1;
			if (cr.get_armor().get_itemtypename() == tag_ARMOR_SECURITYUNIFORM) uniformed = 1;
			break;

		case SITE_LABORATORY_COSMETICS:
		case SITE_LABORATORY_GENETIC:
			if (levelmap[locx][locy][locz].flag & SITEBLOCK_RESTRICTED)
			{
				uniformed = 0;
				if (cr.get_armor().get_itemtypename() == tag_ARMOR_LABCOAT)uniformed = 1;
				if (cr.get_armor().get_itemtypename() == tag_ARMOR_SECURITYUNIFORM)uniformed = (LocationsPool::getInstance().isThisPlaceHighSecurity(cursite) ? 1 : 2);
			}
			break;

		case SITE_GOVERNMENT_POLICESTATION:
			if (levelmap[locx][locy][locz].flag & SITEBLOCK_RESTRICTED)
			{
				uniformed = 0;
				if (cr.get_armor().get_itemtypename() == tag_ARMOR_POLICEUNIFORM)uniformed = 1;
				if (cr.get_armor().get_itemtypename() == tag_ARMOR_POLICEARMOR)uniformed = 1;
				if (lawList[LAW_POLICEBEHAVIOR] == -2 && lawList[LAW_DEATHPENALTY] == -2 &&
					cr.get_armor().get_itemtypename() == tag_ARMOR_DEATHSQUADUNIFORM)uniformed = 1;
				if (cr.get_armor().get_itemtypename() == tag_ARMOR_SWATARMOR)uniformed = (LocationsPool::getInstance().isThisPlaceHighSecurity(cursite) ? 1 : 2);
			}
			break;

		case SITE_GOVERNMENT_COURTHOUSE:
			if (levelmap[locx][locy][locz].flag & SITEBLOCK_RESTRICTED)
			{
				uniformed = 0;
				if (lawList[LAW_POLICEBEHAVIOR] == -2 && lawList[LAW_DEATHPENALTY] == -2 &&
					cr.get_armor().get_itemtypename() == tag_ARMOR_DEATHSQUADUNIFORM)uniformed = 1;
				if (cr.get_armor().get_itemtypename() == tag_ARMOR_SWATARMOR)uniformed = (LocationsPool::getInstance().isThisPlaceHighSecurity(cursite) ? 1 : 2);
			}
			break;
		case SITE_GOVERNMENT_PRISON:
			if (levelmap[locx][locy][locz].flag & SITEBLOCK_RESTRICTED)
			{
				uniformed = 0;
				if (lawList[LAW_POLICEBEHAVIOR] == -2 && lawList[LAW_DEATHPENALTY] == -2)
				{
					if (cr.get_armor().get_itemtypename() == tag_ARMOR_LABCOAT) uniformed = 1;
				}
				else if (cr.get_armor().get_itemtypename() == tag_ARMOR_PRISONGUARD) uniformed = 1;
				if (cr.get_armor().get_itemtypename() == tag_ARMOR_PRISONER) uniformed = 1;
			}
			break;











		case SITE_GOVERNMENT_FIRESTATION:
			if (levelmap[locx][locy][locz].flag & SITEBLOCK_RESTRICTED)
			{
				uniformed = 0;
				if (LocationsPool::getInstance().isThisPlaceHighSecurity(cursite))
				{
					if (cr.get_armor().get_itemtypename() == tag_ARMOR_POLICEUNIFORM) uniformed = 1;
					if (cr.get_armor().get_itemtypename() == tag_ARMOR_POLICEARMOR) uniformed = 1;
					if (lawList[LAW_POLICEBEHAVIOR] == -2 && lawList[LAW_DEATHPENALTY] == -2 &&
						cr.get_armor().get_itemtypename() == tag_ARMOR_DEATHSQUADUNIFORM) uniformed = 1;
					if (cr.get_armor().get_itemtypename() == tag_ARMOR_SWATARMOR) uniformed = 1;
				}

				break;



		case SITE_BUSINESS_BANK:
			if (levelmap[locx][locy][locz].flag & SITEBLOCK_RESTRICTED)
			{
				if (lawList[LAW_POLICEBEHAVIOR] == -2 && lawList[LAW_DEATHPENALTY] == -2 &&
					cr.get_armor().get_itemtypename() == tag_ARMOR_DEATHSQUADUNIFORM)uniformed = 1;
				if (cr.get_armor().get_itemtypename() == tag_ARMOR_SWATARMOR)uniformed = (LocationsPool::getInstance().isThisPlaceHighSecurity(cursite) ? 1 : 2);
				if (LocationsPool::getInstance().isThisPlaceHighSecurity(cursite))
				{
					if (cr.get_armor().get_itemtypename() == tag_ARMOR_CIVILLIANARMOR)uniformed = 1;
				}
			}
			break;
		case SITE_RESIDENTIAL_TENEMENT:
		case SITE_RESIDENTIAL_APARTMENT:
		case SITE_RESIDENTIAL_APARTMENT_UPSCALE:
			if (levelmap[locx][locy][locz].flag & SITEBLOCK_RESTRICTED)uniformed = 0;
			break;

		default:
			break;
			}
		}
	}
	if (!uniformed)
	{
		if (cr.get_armor().get_itemtypename() == tag_ARMOR_POLICEUNIFORM)uniformed = 2;
		if (cr.get_armor().get_itemtypename() == tag_ARMOR_POLICEARMOR)uniformed = 2;
		if (lawList[LAW_POLICEBEHAVIOR] == -2 && lawList[LAW_DEATHPENALTY] == -2 &&
			cr.get_armor().get_itemtypename() == tag_ARMOR_DEATHSQUADUNIFORM)uniformed = 2;
		if (LocationsPool::getInstance().isThisPlaceHighSecurity(cursite) &&
			cr.get_armor().get_itemtypename() == tag_ARMOR_SWATARMOR)uniformed = 2;
		// Loop over adjacent locations to check if fire is anywhere in sight?
		// Or perhaps have a site fire alarm? - Nick
		if ((levelmap[locx][locy][locz].flag & SITEBLOCK_FIRE_START ||
			levelmap[locx][locy][locz].flag & SITEBLOCK_FIRE_END ||
			levelmap[locx][locy][locz].flag & SITEBLOCK_FIRE_PEAK) &&
			cr.get_armor().get_itemtypename() == tag_ARMOR_BUNKERGEAR)uniformed = 1;
	}
	if (uniformed)
	{
		int qlmax = cr.get_armor().get_quality_levels();
		int ql = cr.get_armor().get_quality() + cr.get_armor().is_damaged();
		if (ql > qlmax)  // Shredded clothes are obvious
		{
			uniformed = 0;
		}
		else if ((ql - 1) * 2 > qlmax) // poor clothes make a poor disguise
		{
			uniformed++;
		}
		if (uniformed > 2)
			uniformed = 0;
	}
	return uniformed;
}
/* checks if a creature's weapon is suspicious */
char weaponcheck(const Creature &cr, bool metaldetect)
{
	bool suspicious = cr.get_weapon().is_suspicious();
	bool concealed = cr.weapon_is_concealed();
	char incharacter = weapon_in_character(cr.get_weapon().get_itemtypename(), cr.get_armor().get_itemtypename());
	// If your disguise is inappropriate to the current location,
	// then being in character isn't sufficient
	if (hasdisguise(cr) == false)
		incharacter = -1;
	if (suspicious)
	{
		if (concealed && !metaldetect)
			return 0; // Hidden weapon, nothing to see
		else if (incharacter >= 0)
			return 1; // You look like you're supposed to have that weapon
		else
			return 2; // Looks like trouble
	}
	return 0; // Nothing to see here
}
/* checks if conservatives see through your disguise */
void disguisecheck(int timer)
{
	extern short cursite;
	extern short fieldskillrate;
	extern Log gamelog;
	extern short sitetype;
	extern short sitealarm;
	extern int locx;
	extern int locy;
	extern int locz;
	extern short sitealarmtimer;
	extern squadst *activesquad;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	extern Creature encounter[ENCMAX];
	int weapon = 0, partysize = squadsize(activesquad);

	bool forcecheck = false;

	//int weaponar[6]={0};
	// Only start to penalize the player's disguise/stealth checks after the first turn.
	timer--;
	for (int i = 0; i < 6; i++)
	{
		if (activesquad->squad[i] == NULL)break;
		if (activesquad->squad[i]->is_naked() &&
			activesquad->squad[i]->animalgloss != ANIMALGLOSS_ANIMAL)forcecheck = true;
		int thisweapon = weaponcheck(*activesquad->squad[i], false);
		if (thisweapon > weapon)weapon = thisweapon;
		//if(thisweapon==2)weaponar[i]=1;
	}
	// TODO if a weapon is holstered
	// meaning if it is within the squad inventory but not equipped by a squad member
	// not even metal detectors can detect it
	// This line checks all such weapons
	// but does nothing with the information
	// pending an overhaul of weapon concealment
	for (Item *l : activesquad->loot) {
		if (l->whatIsThis() == THIS_IS_WEAPON) {
			int thisweapon = static_cast <Weapon*> (l)->is_suspicious();
			//if (thisweapon > weapon)weapon = thisweapon;
		}
	}
	// Nothing suspicious going on here
	if (sitealarmtimer == -1 && weapon < 1 && !forcecheck)
	{
		if (!disguisesite(LocationsPool::getInstance().getLocationType(cursite)) &&
			!(levelmap[locx][locy][locz].flag & SITEBLOCK_RESTRICTED))return;
	}
	vector<int> noticer;
	for (int e = 0; e < ENCMAX; e++)
	{
		if (encounter[e].type == CREATURE_PRISONER)continue;
		if (encounter[e].exists&&encounter[e].alive&&
			encounter[e].enemy())
		{
			noticer.push_back(e);
		}
	}
	if (len(noticer))
	{
		int n;
		int blew_it = -1;
		bool spotted = false;
		char noticed = 0;
		do
		{
			int an = LCSrandom(len(noticer));
			n = noticer[an];
			noticer.erase(noticer.begin() + an);
			int stealth_difficulty;
			int disguise_difficulty;
			//// TODO Move to XML
			// Determine difficulty based on enemy type
			stealth_difficulty = encounter[n].get_stealth_difficulty();
			disguise_difficulty = encounter[n].get_disguise_difficulty();
			// Increase difficulty if Conservatives suspicious...
			if (sitealarmtimer == 1)
			{
				stealth_difficulty += 6;
				disguise_difficulty += 6;
			}
			else if (sitealarmtimer > 1)
			{
				stealth_difficulty += 3;
				disguise_difficulty += 3;
			}
			// Sneaking with a party is hard
			stealth_difficulty += (partysize - 1) * 3;
			// Make the attempt!
			for (int i = 0; i < 6; i++)
			{
				if (activesquad->squad[i] == NULL)break;
				// Try to sneak.
				if (!spotted)
				{
					int result = activesquad->squad[i]->skill_roll(SKILL_STEALTH);
					result -= timer;
					if (fieldskillrate == FIELDSKILLRATE_HARD && result + 1 == stealth_difficulty)
					{// Hard more = You only learn if you just missed, and realize what you did wrong.
						activesquad->squad[i]->train(SKILL_STEALTH, 10);
					}
					if (result < stealth_difficulty)
						spotted = true;
				}
				// Spotted! Act casual.
				if (spotted)
				{
					// Scary weapons are not very casual.
					if (weaponcheck(*activesquad->squad[i], false) == 2)
					{
						noticed = true;
						break;
					}
					else
					{
						int result = activesquad->squad[i]->skill_roll(SKILL_DISGUISE);
						result -= timer;
						if (fieldskillrate == FIELDSKILLRATE_HARD && result + 1 == disguise_difficulty)
						{// Hard more = You only learn if you just missed, and realize what you did wrong.
							activesquad->squad[i]->train(SKILL_DISGUISE, 10);
						}
						if (result < disguise_difficulty)
						{
							// That was not very casual, dude.
							if (result < 0)blew_it = i;
							noticed = true;
							break;
						}
					}
				}
			}
			if (noticed) break;
		} while (len(noticer));
		// Give feedback on the Liberal Performance
		if (!spotted)
		{
			for (int i = 0; i < 6; i++)
			{
				if (activesquad->squad[i] == NULL) break;
				switch (fieldskillrate)
				{
				case FIELDSKILLRATE_FAST:
					activesquad->squad[i]->train(SKILL_STEALTH, 40); break;
				case FIELDSKILLRATE_CLASSIC:
					activesquad->squad[i]->train(SKILL_STEALTH, 10); break;
				case FIELDSKILLRATE_HARD:
					activesquad->squad[i]->train(SKILL_STEALTH, 0); break;
				}
			}
			if (timer == 0)
			{
				set_color_easy(CYAN_ON_BLACK_BRIGHT);
				if (partysize > 1)
					mvaddstrAlt(16, 1, CONST_stealth065, gamelog);
				else
					mvaddstrAlt(16, 1, activesquad->squad[0]->name, gamelog);
				addstrAlt(CONST_stealth064, gamelog);
				gamelog.newline();
				pressAnyKey();
			}
		}
		else
		{
			if (blew_it == -1)
			{
				for (int i = 0; i < 6; i++)
				{
					if (activesquad->squad[i] == NULL) break;
					if (hasdisguise(*(activesquad->squad[i])))
					{
						switch (fieldskillrate)
						{
							//// TODO Move to XML
						case FIELDSKILLRATE_FAST:
							activesquad->squad[i]->train(SKILL_DISGUISE, 50); break;
						case FIELDSKILLRATE_CLASSIC:
							activesquad->squad[i]->train(SKILL_DISGUISE, 10); break;
						case FIELDSKILLRATE_HARD:
							activesquad->squad[i]->train(SKILL_DISGUISE, 0); break;
						}
					}
				}
			}
			if (blew_it != -1 && LCSrandom(2))
			{
				set_color_easy(YELLOW_ON_BLACK_BRIGHT);
				mvaddstrAlt(16, 1, activesquad->squad[blew_it]->name, gamelog);
				addstrAlt(pickrandom(blew_stealth_check), gamelog);
				gamelog.newline();
				pressAnyKey();
			}
			else if (!noticed)
			{
				set_color_easy(CYAN_ON_BLACK_BRIGHT);
				if (partysize > 1)
					mvaddstrAlt(16, 1, CONST_stealth065, gamelog);
				else
					mvaddstrAlt(16, 1, activesquad->squad[0]->name, gamelog);
				addstrAlt(CONST_stealth066, gamelog);
				gamelog.newline();
				pressAnyKey();
			}
		}
		if (!noticed)return;
		clearmessagearea();
		set_color_easy(RED_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, encounter[n].name, gamelog);
		if (sitealarmtimer != 0 && weapon < 1 && encounter[n].type != CREATURE_GUARDDOG)
		{
			if ((sitetype == SITE_RESIDENTIAL_TENEMENT ||
				sitetype == SITE_RESIDENTIAL_APARTMENT ||
				sitetype == SITE_RESIDENTIAL_APARTMENT_UPSCALE) &&
				levelmap[locx][locy][locz].flag & SITEBLOCK_RESTRICTED)
			{
				sitealarm = 1;
				addstrAlt(CONST_stealth067, gamelog);
			}
			else
			{
				addstrAlt(CONST_stealth068, gamelog);
				int time;
				time = 20 + LCSrandom(10) - encounter[n].get_attribute(ATTRIBUTE_INTELLIGENCE, true)
					- encounter[n].get_attribute(ATTRIBUTE_WISDOM, true);
				if (time < 1)time = 1;
				if (sitealarmtimer > time || sitealarmtimer == -1)sitealarmtimer = time;
				else
				{
					if (sitealarmtimer > 5) sitealarmtimer -= 5;
					if (sitealarmtimer <= 5)sitealarmtimer = 0;
				}
			}
		}
		else
		{
			if (weapon&&encounter[n].type != CREATURE_GUARDDOG)
			{
				addstrAlt(CONST_stealth069, gamelog);
				if (encounter[n].align == ALIGN_CONSERVATIVE)
					mvaddstrAlt(17, 1, CONST_stealth074, gamelog);
				else
					mvaddstrAlt(17, 1, CONST_stealth075, gamelog);
				for (int i = 0; i < 6; i++)
				{
					if (activesquad->squad[i] == NULL)break;
				}
			}
			else
			{
				addstrAlt(CONST_stealth072, gamelog);
				if (encounter[n].align == ALIGN_CONSERVATIVE)
				{
					if (encounter[n].type == CREATURE_GUARDDOG)
						mvaddstrAlt(17, 1, CONST_stealth073, gamelog);
					else
						mvaddstrAlt(17, 1, CONST_stealth074, gamelog);
				}
				else
					mvaddstrAlt(17, 1, CONST_stealth075, gamelog);
			}
			gamelog.newline();
			sitealarm = 1;
		}
		pressAnyKey();
	}
}

// #include "../includes.h"
const string CONST_talk040 = "# ";
const string CONST_talk039 = "allText.txt";
const string CONST_talk034 = "agree_to_release_hostages.txt";
const string CONST_talk033 = "go_ahead_and_die.txt";
const string CONST_talk032 = "let_hostages_go.txt";
const string CONST_talk031 = "please_no_more.txt";
const string CONST_talk030 = "hostage_negotiation.txt";
const string CONST_talk029 = "who_cares_about_hostage.txt";
const string CONST_talk028 = "please_spare_hostage.txt";
const string CONST_talk027 = "threaten_hostage.txt";
const string CONST_talk026 = "backs_off.txt";
const string CONST_talk025 = "come_at_me_bro.txt";
const string CONST_talk024 = "teller_complies.txt";
const string CONST_talk023 = "teller_gestures.txt";
const string CONST_talk022 = "robbing_bank.txt";
const string CONST_talk021 = "that_is_not_disturbing.txt";
const string CONST_talk020 = "that_is_disturbing.txt";
const string CONST_talk019 = "mutant_rejection.txt";
const string CONST_talk018 = "dog_rejection.txt";
const string CONST_talk017 = "normal_talk_to_dog.txt";
const string CONST_talk016 = "lovingly_talk_to_dog.txt";
const string CONST_talk015 = "normal_talk_to_mutant.txt";
const string CONST_talk014 = "lovingly_talk_to_mutant.txt";
const string CONST_talk013 = "pickupLines.txt";
const string CONST_talk012 = "no_free_speech_flirt.txt";

const string tag_ARMOR_MITHRIL = "ARMOR_MITHRIL";
/*
daily.cpp
*/
/* active squad visits the arms dealer */
void armsdealer(int loc);

// #include "../combat/fight.h"
// for void delenc(short e,char loot);
void delenc(Creature &tk);
// #include "../locations/locationsPool.h"
void moveEverythingAwayFromSite(int cursite);
vector<vector<string> > no_free_speech_flirt;
vector<vector<string> > pickupLines;
vector<vector<string> > lovingly_talk_to_mutant;
vector<vector<string> > normal_talk_to_mutant;
vector<vector<string> > lovingly_talk_to_dog;
vector<vector<string> > normal_talk_to_dog;
vector<string> dog_rejection;
vector<string> mutant_rejection;
vector<string> that_is_disturbing;
vector<string> that_is_not_disturbing;
vector<string> robbing_bank;
vector<string> teller_gestures;
vector<string> teller_complies;
const string talky = "talk\\";
const int PICKUP_LINE_SIZE = 5;
//const int DOUBLE_LINE = 2;
vector<string> come_at_me_bro;
vector<string> backs_off;
vector<string> threaten_hostage;
vector<string> please_spare_hostage;
vector<string> who_cares_about_hostage;
vector<string> hostage_negotiation;
vector<string> please_no_more;
vector<string> let_hostages_go;
vector<string> go_ahead_and_die;
vector<string> agree_to_release_hostages;
const string talk_combat = "talk_combat\\";
vector<file_and_text_collection> talk_file_collection = {
	/*talk.cpp*/
	customText(&no_free_speech_flirt, talky + CONST_talk012, PICKUP_LINE_SIZE),
	customText(&pickupLines, talky + CONST_talk013, PICKUP_LINE_SIZE),
	customText(&lovingly_talk_to_mutant, talky + CONST_talk014, DOUBLE_LINE),
	customText(&normal_talk_to_mutant, talky + CONST_talk015, DOUBLE_LINE),
	customText(&lovingly_talk_to_dog, talky + CONST_talk016, DOUBLE_LINE),
	customText(&normal_talk_to_dog, talky + CONST_talk017, DOUBLE_LINE),
	customText(&dog_rejection, talky + CONST_talk018),
	customText(&mutant_rejection, talky + CONST_talk019),
	customText(&that_is_disturbing, talky + CONST_talk020),
	customText(&that_is_not_disturbing, talky + CONST_talk021),
	customText(&robbing_bank, talky + CONST_talk022),
	customText(&teller_gestures, talky + CONST_talk023),
	customText(&teller_complies, talky + CONST_talk024),
	//talk in combat
	customText(&come_at_me_bro, talk_combat + CONST_talk025),
	customText(&backs_off, talk_combat + CONST_talk026),
	customText(&threaten_hostage, talk_combat + CONST_talk027),
	customText(&please_spare_hostage, talk_combat + CONST_talk028),
	customText(&who_cares_about_hostage, talk_combat + CONST_talk029),
	customText(&hostage_negotiation, talk_combat + CONST_talk030),
	customText(&please_no_more, talk_combat + CONST_talk031),
	customText(&let_hostages_go, talk_combat + CONST_talk032),
	customText(&go_ahead_and_die, talk_combat + CONST_talk033),
	customText(&agree_to_release_hostages, talk_combat + CONST_talk034),
};
string while_naked;
char heyMisterDog(Creature &a, Creature &tk);
char heyMisterMonster(Creature &a, Creature &tk);
char talkInCombat(Creature &a, Creature &tk);
char talkToBankTeller(Creature &a, Creature &tk);
char talkToGeneric(Creature &a, Creature &tk);
char wannaHearSomethingDisturbing(Creature &a, Creature &tk);
char talkAboutIssues(Creature &a, Creature &tk);
char doYouComeHereOften(Creature &a, Creature &tk);
char heyINeedAGun(Creature &a, Creature &tk);
char heyIWantToRentARoom(Creature &a, Creature &tk);
char heyIWantToCancelMyRoom(Creature &a, Creature &tk);
map<short, string> conservativeLegalArgument;
map<short, vector<string> > talkAboutTheIssues;
map<short, string> youAreStupidTalkAboutIssues;
map<short, string> issueTooLiberal;
string saysComma;
string respondsComma;
string colonSpace;
string unnamed_String_Talk_cpp_001;
string unnamed_String_Talk_cpp_002;
string unnamed_String_Talk_cpp_003;
string unnamed_String_Talk_cpp_004;
string unnamed_String_Talk_cpp_005;
string unnamed_String_Talk_cpp_006;
string unnamed_String_Talk_cpp_007;
string unnamed_String_Talk_cpp_008;
string unnamed_String_Talk_cpp_009;
string unnamed_String_Talk_cpp_010;
string unnamed_String_Talk_cpp_011;
string unnamed_String_Talk_cpp_012;
string unnamed_String_Talk_cpp_013;
string unnamed_String_Talk_cpp_014;
string unnamed_String_Talk_cpp_015;
string unnamed_String_Talk_cpp_016;
string unnamed_String_Talk_cpp_017;
string unnamed_String_Talk_cpp_018;
string unnamed_String_Talk_cpp_019;
string unnamed_String_Talk_cpp_020;
string unnamed_String_Talk_cpp_021;
string unnamed_String_Talk_cpp_022;
string unnamed_String_Talk_cpp_023;
string unnamed_String_Talk_cpp_024;
string unnamed_String_Talk_cpp_025;
string unnamed_String_Talk_cpp_026;
string unnamed_String_Talk_cpp_027;
string unnamed_String_Talk_cpp_028;
string unnamed_String_Talk_cpp_029;
string unnamed_String_Talk_cpp_030;
string unnamed_String_Talk_cpp_031;
string unnamed_String_Talk_cpp_032;
string unnamed_String_Talk_cpp_033;
string unnamed_String_Talk_cpp_034;
string unnamed_String_Talk_cpp_035;
string unnamed_String_Talk_cpp_036;
string unnamed_String_Talk_cpp_037;
string unnamed_String_Talk_cpp_038;
string unnamed_String_Talk_cpp_039;
string unnamed_String_Talk_cpp_040;
string unnamed_String_Talk_cpp_041;
string unnamed_String_Talk_cpp_042;
string unnamed_String_Talk_cpp_043;
string unnamed_String_Talk_cpp_044;
string unnamed_String_Talk_cpp_045;
string unnamed_String_Talk_cpp_046;
string unnamed_String_Talk_cpp_047;
string unnamed_String_Talk_cpp_048;
string unnamed_String_Talk_cpp_049;
string unnamed_String_Talk_cpp_050;
string unnamed_String_Talk_cpp_051;
string unnamed_String_Talk_cpp_052;
string unnamed_String_Talk_cpp_053;
string unnamed_String_Talk_cpp_054;
string unnamed_String_Talk_cpp_055;
string unnamed_String_Talk_cpp_056;
string unnamed_String_Talk_cpp_057;
string unnamed_String_Talk_cpp_058;
string unnamed_String_Talk_cpp_059;
string unnamed_String_Talk_cpp_060;
string unnamed_String_Talk_cpp_061;
string unnamed_String_Talk_cpp_062;
string unnamed_String_Talk_cpp_063;
string unnamed_String_Talk_cpp_064;
string unnamed_String_Talk_cpp_065;
string unnamed_String_Talk_cpp_066;
string unnamed_String_Talk_cpp_067;
string unnamed_String_Talk_cpp_068;
string unnamed_String_Talk_cpp_069;
string unnamed_String_Talk_cpp_070;
string unnamed_String_Talk_cpp_071;
string unnamed_String_Talk_cpp_072;
string unnamed_String_Talk_cpp_073;
string unnamed_String_Talk_cpp_074;
string unnamed_String_Talk_cpp_075;
string unnamed_String_Talk_cpp_076;
string unnamed_String_Talk_cpp_077;
string unnamed_String_Talk_cpp_078;
string unnamed_String_Talk_cpp_079;
string unnamed_String_Talk_cpp_080;
string unnamed_String_Talk_cpp_081;
string unnamed_String_Talk_cpp_082;
string unnamed_String_Talk_cpp_083;
string unnamed_String_Talk_cpp_084;
string unnamed_String_Talk_cpp_085;
string unnamed_String_Talk_cpp_086;
string unnamed_String_Talk_cpp_087;
string unnamed_String_Talk_cpp_088;
string unnamed_String_Talk_cpp_089;
string unnamed_String_Talk_cpp_090;
string unnamed_String_Talk_cpp_091;
string unnamed_String_Talk_cpp_092;
string unnamed_String_Talk_cpp_093;
string unnamed_String_Talk_cpp_094;
string unnamed_String_Talk_cpp_095;
string unnamed_String_Talk_cpp_096;
string unnamed_String_Talk_cpp_097;
string unnamed_String_Talk_cpp_098;
string unnamed_String_Talk_cpp_099;
string unnamed_String_Talk_cpp_100;
string unnamed_String_Talk_cpp_101;
string unnamed_String_Talk_cpp_102;
string unnamed_String_Talk_cpp_103;
string unnamed_String_Talk_cpp_104;
string unnamed_String_Talk_cpp_105;
string unnamed_String_Talk_cpp_106;
string unnamed_String_Talk_cpp_107;
string unnamed_String_Talk_cpp_108;
string unnamed_String_Talk_cpp_109;
string unnamed_String_Talk_cpp_110;
string unnamed_String_Talk_cpp_111;
string unnamed_String_Talk_cpp_112;
string unnamed_String_Talk_cpp_113;
string unnamed_String_Talk_cpp_114;
string unnamed_String_Talk_cpp_115;
string unnamed_String_Talk_cpp_116;
string unnamed_String_Talk_cpp_117;
string unnamed_String_Talk_cpp_118;
string unnamed_String_Talk_cpp_119;
string unnamed_String_Talk_cpp_120;
string unnamed_String_Talk_cpp_121;
string unnamed_String_Talk_cpp_122;
string unnamed_String_Talk_cpp_123;
string unnamed_String_Talk_cpp_124;
string unnamed_String_Talk_cpp_125;
string unnamed_String_Talk_cpp_126;
string unnamed_String_Talk_cpp_127;
string unnamed_String_Talk_cpp_128;
string unnamed_String_Talk_cpp_129;
string unnamed_String_Talk_cpp_130;
string unnamed_String_Talk_cpp_131;
string unnamed_String_Talk_cpp_132;
string unnamed_String_Talk_cpp_133;
string unnamed_String_Talk_cpp_134;
string unnamed_String_Talk_cpp_135;
string unnamed_String_Talk_cpp_136;
string unnamed_String_Talk_cpp_137;
string unnamed_String_Talk_cpp_138;
string unnamed_String_Talk_cpp_139;
string unnamed_String_Talk_cpp_140;
string unnamed_String_Talk_cpp_141;
string unnamed_String_Talk_cpp_142;
string unnamed_String_Talk_cpp_143;
string unnamed_String_Talk_cpp_144;
string unnamed_String_Talk_cpp_145;
string unnamed_String_Talk_cpp_146;
string unnamed_String_Talk_cpp_147;
string unnamed_String_Talk_cpp_148;
string unnamed_String_Talk_cpp_149;
/* bluff, date, issues */
char talk(Creature &a, const int t)
{
	extern short cursite;
	extern short sitealarm;
	extern Creature encounter[ENCMAX];
	Creature &tk = encounter[t];
	// TALKING TO DOGS
	if (tk.type == CREATURE_GUARDDOG && tk.align != ALIGN_LIBERAL)
	{
		return heyMisterDog(a, tk);
	}
	// TALKING TO MONSTERS
	if (tk.type == CREATURE_GENETIC && tk.align != ALIGN_LIBERAL)
	{
		return heyMisterMonster(a, tk);
	}
	// BLUFFING
	if ((sitealarm || LocationsPool::getInstance().isThereASiegeHere(cursite)) && tk.enemy())
	{
		return talkInCombat(a, tk);
	}
	return talkToGeneric(a, tk);
}
char talkToBankTeller(Creature &a, Creature &tk)
{
	extern Log gamelog;
	extern short cursite;
	extern short sitealarm;
	extern newsstoryst *sitestory;
	extern int sitecrime;
	extern squadst *activesquad;
	extern short sitealienate;

	extern Creature encounter[ENCMAX];
	extern string slogan_str;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	extern short sitealarmtimer;
	clearcommandarea(); clearmessagearea(); clearmaparea();
	set_color_easy(WHITE_ON_BLACK);
	const bool is_naked = a.is_naked() && a.animalgloss != ANIMALGLOSS_ANIMAL;
	mvaddstrAlt(11, 1, unnamed_String_Talk_cpp_001);
	if (is_naked)addstrAlt(while_naked);
	addstrAlt(singleDot);
	mvaddstrAlt(12, 1, unnamed_String_Talk_cpp_002);
	if (is_naked)addstrAlt(while_naked);
	addstrAlt(singleDot);
	mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_003);
	if (is_naked)addstrAlt(while_naked);
	addstrAlt(singleDot);
	int c = pressSpecificKey('a', 'b', 'c');
	switch (c)
	{
	case 'a':
		clearcommandarea(); clearmessagearea(); clearmaparea();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(9, 1, a.name, gamelog);
		addstrAlt(unnamed_String_Talk_cpp_004, gamelog);
		set_color_easy(GREEN_ON_BLACK_BRIGHT);
		mvaddstrAlt(10, 1, pickrandom(robbing_bank), gamelog);
		gamelog.newline();
		pressAnyKey();
		if (LocationsPool::getInstance().isThisPlaceHighSecurity(cursite))
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(11, 1, unnamed_String_Talk_cpp_005, gamelog);
			addstrAlt(pickrandom(teller_gestures), gamelog);
			mvaddstrAlt(12, 1, unnamed_String_Talk_cpp_006, gamelog);
			gamelog.newline();
			pressAnyKey();
			sitealarm = 1;
			criminalize(a, LAWFLAG_BANKROBBERY);
			sitestory->crime.push_back(CRIME_BANKTELLERROBBERY);
			sitecrime += 30;
			makecreature(encounter[0], CREATURE_MERC);
			makecreature(encounter[1], CREATURE_MERC);
			makecreature(encounter[2], CREATURE_MERC);
			makecreature(encounter[3], CREATURE_MERC);
		}
		else
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(11, 1, unnamed_String_Talk_cpp_007, gamelog);
			addstrAlt(pickrandom(teller_complies), gamelog);
			mvaddstrAlt(12, 1, unnamed_String_Talk_cpp_008, gamelog);
			gamelog.newline();
			pressAnyKey();
			criminalize(a, LAWFLAG_BANKROBBERY);
			sitestory->crime.push_back(CRIME_BANKTELLERROBBERY);
			sitecrime += 30;
			sitealarmtimer = 0;
			activesquad->loot.push_back(new Money(5000));
		}
		tk.cantbluff = 1;
		return 1;
	case 'b':
	{
		clearcommandarea(); clearmessagearea(); clearmaparea();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		Creature *armed_liberal = NULL;
		for (int i = 0; i < 6; i++)
		{
			if (activesquad->squad[i] &&
				activesquad->squad[i]->get_weapon().is_threatening())
			{
				armed_liberal = activesquad->squad[i];
				break;
			}
		}
		if (armed_liberal)
		{
			mvaddstrAlt(9, 1, armed_liberal->name, gamelog);
			addstrAlt(unnamed_String_Talk_cpp_009, gamelog);
			addstrAlt(armed_liberal->get_weapon().get_shortname(0), gamelog);
			addstrAlt(singleDot, gamelog);
			gamelog.newline();
			pressAnyKey();
			clearmessagearea();
		}
		mvaddstrAlt(10, 1, a.name, gamelog);
		addstrAlt(saysComma, gamelog);
		set_color_easy(GREEN_ON_BLACK_BRIGHT);
		mvaddstrAlt(11, 1, unnamed_String_Talk_cpp_010, gamelog);
		addstrAlt(slogan_str, gamelog);
		gamelog.record(singleSpace);
		mvaddstrAlt(12, 1, unnamed_String_Talk_cpp_011, gamelog);
		gamelog.newline();
		pressAnyKey();
		const int roll = a.skill_roll(SKILL_PERSUASION);
		int difficulty = DIFFICULTY_VERYEASY;
		if (armed_liberal == NULL)
			difficulty += 12;
		if (LocationsPool::getInstance().isThisPlaceHighSecurity(cursite))
			difficulty += 12;
		clearcommandarea(); clearmessagearea(); clearmaparea();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		if (roll < difficulty)
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(9, 1, unnamed_String_Talk_cpp_012, gamelog);
			mvaddstrAlt(10, 1, unnamed_String_Talk_cpp_013, gamelog);
			gamelog.newline();
			pressAnyKey();
			sitealarm = 1;
			sitealienate = 2;
			criminalizeparty(LAWFLAG_BANKROBBERY);
			sitestory->crime.push_back(CRIME_BANKSTICKUP);
			sitecrime += 50;
			CreatureTypes guard = CREATURE_SECURITYGUARD;
			if (LocationsPool::getInstance().isThisPlaceHighSecurity(cursite)) guard = CREATURE_MERC;
			makecreature(encounter[0], guard);
			makecreature(encounter[1], guard);
			makecreature(encounter[2], guard);
			makecreature(encounter[3], guard);
			makecreature(encounter[4], guard);
			makecreature(encounter[5], guard);
		}
		else
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(9, 1, unnamed_String_Talk_cpp_014, gamelog);
			gamelog.newline();
			pressAnyKey();
			mvaddstrAlt(10, 1, unnamed_String_Talk_cpp_015, gamelog);
			gamelog.newline();
			pressAnyKey();
			criminalizeparty(LAWFLAG_BANKROBBERY);
			sitestory->crime.push_back(CRIME_BANKSTICKUP);
			sitecrime += 50;
			sitealarm = 1;
			sitealienate = 2;
			for (int x = 0; x < MAPX; x++)
				for (int y = 0; y < MAPY; y++)
					for (int z = 0; z < MAPZ; z++)
					{
						levelmap[x][y][z].flag &= ~SITEBLOCK_LOCKED;
						if (levelmap[x][y][z].flag & SITEBLOCK_METAL)
							levelmap[x][y][z].flag &= ~SITEBLOCK_DOOR;
						if (levelmap[x][y][z].special == SPECIAL_BANK_VAULT)
							levelmap[x][y][z].special = SPECIAL_NONE;
					}
			encounter[0].exists = false;
		}
	}
	default:
	case 'c':
		return 0;
	}
}
char talkToGeneric(Creature &a, Creature &tk)
{
	extern short cursite;
	clearcommandarea(); clearmessagearea(); clearmaparea();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(9, 1, a.name);
	addstrAlt(unnamed_String_Talk_cpp_016);
	switch (tk.align)
	{
	case ALIGN_CONSERVATIVE:
		set_color_easy(RED_ON_BLACK_BRIGHT);
		break;
	case ALIGN_LIBERAL:
		set_color_easy(GREEN_ON_BLACK_BRIGHT);
		break;
	case ALIGN_MODERATE:
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		break;
	}
	addstrAlt(tk.name);
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	add_age(tk);
	addstrAlt(unnamed_String_Talk_cpp_017);
	const bool is_naked = a.is_naked() && a.animalgloss != ANIMALGLOSS_ANIMAL;
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(11, 1, unnamed_String_Talk_cpp_018);
	if (is_naked)addstrAlt(while_naked);
	addstrAlt(singleDot);
	if (tk.can_date(a))set_color_easy(WHITE_ON_BLACK);
	else set_color_easy(BLACK_ON_BLACK_BRIGHT);
	mvaddstrAlt(12, 1, unnamed_String_Talk_cpp_019);
	if (is_naked)addstrAlt(while_naked);
	addstrAlt(singleDot);
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_020);
	if (is_naked)addstrAlt(while_naked);
	addstrAlt(singleDot);
	if (tk.type == CREATURE_LANDLORD && LocationsPool::getInstance().getRentingType(cursite) == -1)
	{
		mvaddstrAlt(14, 1, unnamed_String_Talk_cpp_021);
		if (is_naked)addstrAlt(while_naked);
		addstrAlt(singleDot);
	}
	else if (tk.type == CREATURE_LANDLORD && LocationsPool::getInstance().getRentingType(cursite) > 0)
	{
		mvaddstrAlt(14, 1, unnamed_String_Talk_cpp_022);
		if (is_naked)addstrAlt(while_naked);
		addstrAlt(singleDot);
	}
	else if (tk.type == CREATURE_GANGMEMBER || tk.type == CREATURE_MERC)
	{
		mvaddstrAlt(14, 1, unnamed_String_Talk_cpp_023);
		if (is_naked)addstrAlt(while_naked);
		addstrAlt(singleDot);
	}
	else if (tk.type == CREATURE_BANK_TELLER)
	{
		mvaddstrAlt(14, 1, unnamed_String_Talk_cpp_024);
		if (is_naked)addstrAlt(while_naked);
		addstrAlt(singleDot);
	}
	while (true)
	{
		const int c = getkeyAlt();
		switch (c)
		{
		case 'a':
			return wannaHearSomethingDisturbing(a, tk);
		case 'b':
			if (!tk.can_date(a)) break;
			return doYouComeHereOften(a, tk);
		case 'c':
			return 0;
		case 'd':
			if (tk.type == CREATURE_LANDLORD && LocationsPool::getInstance().getRentingType(cursite) == -1)
				return heyIWantToRentARoom(a, tk);
			else if (tk.type == CREATURE_LANDLORD && LocationsPool::getInstance().getRentingType(cursite) > 0)
				return heyIWantToCancelMyRoom(a, tk);
			else if (tk.type == CREATURE_GANGMEMBER || tk.type == CREATURE_MERC)
				return heyINeedAGun(a, tk);
			else if (tk.type == CREATURE_BANK_TELLER)
				return talkToBankTeller(a, tk);
			break;
		}
	}
}
// #include "../common/creaturePool.h"
void locationIsNowRented(int l, int rent);
char heyIWantToCancelMyRoom(Creature &a, Creature &tk)
{
	extern Log gamelog;
	extern short cursite;
	clearcommandarea();
	clearmessagearea();
	clearmaparea();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(9, 1, a.name, gamelog);
	addstrAlt(saysComma, gamelog);
	set_color_easy(GREEN_ON_BLACK_BRIGHT);
	mvaddstrAlt(10, 1, unnamed_String_Talk_cpp_025, gamelog);
	gamelog.newline();
	pressAnyKey();
	const bool is_naked = a.is_naked() && a.animalgloss != ANIMALGLOSS_ANIMAL;
	if (is_naked)
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(12, 1, tk.name, gamelog);
		addstrAlt(respondsComma, gamelog);
		set_color_easy(CYAN_ON_BLACK_BRIGHT);
		mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_026, gamelog);
		gamelog.newline();
		pressAnyKey();
		return 1;
	}
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(12, 1, tk.name, gamelog);
	addstrAlt(respondsComma, gamelog);
	set_color_easy(CYAN_ON_BLACK_BRIGHT);
	mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_027, gamelog);
	gamelog.newline();
	pressAnyKey();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(15, 1, unnamed_String_Talk_cpp_028, gamelog);
	gamelog.newline();
	pressAnyKey();

	moveEverythingAwayFromSite(cursite);

	return 1;
}
char heyIWantToRentARoom(Creature &a, Creature &tk)
{
	extern Log gamelog;
	extern char newscherrybusted;
	extern short cursite;
	extern squadst *activesquad;
	extern class Ledger ledger;
	clearcommandarea(); clearmessagearea(); clearmaparea();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(9, 1, a.name, gamelog); addstrAlt(saysComma, gamelog);
	set_color_easy(GREEN_ON_BLACK_BRIGHT);
	mvaddstrAlt(10, 1, unnamed_String_Talk_cpp_029, gamelog);
	gamelog.newline();
	pressAnyKey();
	const bool is_naked = a.is_naked() && a.animalgloss != ANIMALGLOSS_ANIMAL;
	if (is_naked)
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(12, 1, tk.name, gamelog); addstrAlt(respondsComma, gamelog);
		set_color_easy(CYAN_ON_BLACK_BRIGHT);
		mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_030, gamelog);
		gamelog.newline();
		pressAnyKey();
		return 1;
	}
	int rent;
	switch (LocationsPool::getInstance().getLocationType(cursite))
	{
	default:rent = 200; break;
	case SITE_RESIDENTIAL_APARTMENT:rent = 650; break;
	case SITE_RESIDENTIAL_APARTMENT_UPSCALE:rent = 1500; break;
	}
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(12, 1, tk.name, gamelog); addstrAlt(respondsComma, gamelog);
	set_color_easy(CYAN_ON_BLACK_BRIGHT);
	mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_031, gamelog);
	addstrAlt(rent, gamelog);
	addstrAlt(unnamed_String_Talk_cpp_032, gamelog);
	gamelog.newline();
	mvaddstrAlt(14, 1, unnamed_String_Talk_cpp_033, gamelog);
	addstrAlt(rent, gamelog);
	addstrAlt(unnamed_String_Talk_cpp_034, gamelog);
	gamelog.newline();
	pressAnyKey();
	clearcommandarea(); clearmessagearea(); clearmaparea();
	while (true)
	{
		int c = 'a';
		if (ledger.get_funds() < rent)set_color_easy(BLACK_ON_BLACK_BRIGHT);
		mvaddstrAlt(11, 1, unnamed_String_Talk_cpp_035);
		set_color_easy(WHITE_ON_BLACK);
		mvaddstrAlt(12, 1, unnamed_String_Talk_cpp_036);
		mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_037);
		c = getkeyAlt();
		switch (c)
		{
		case 'a': // Accept rent deal
			if (ledger.get_funds() < rent) break;
			clearcommandarea(); clearmessagearea(); clearmaparea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(9, 1, a.name, gamelog); addstrAlt(saysComma, gamelog);
			set_color_easy(GREEN_ON_BLACK_BRIGHT);
			mvaddstrAlt(10, 1, unnamed_String_Talk_cpp_038, gamelog);
			gamelog.newline();
			pressAnyKey();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(12, 1, tk.name, gamelog); addstrAlt(respondsComma, gamelog);
			set_color_easy(CYAN_ON_BLACK_BRIGHT);
			mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_039, gamelog);
			gamelog.newline();
			mvaddstrAlt(14, 1, unnamed_String_Talk_cpp_040, gamelog);
			gamelog.newline();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			addstrAlt(unnamed_String_Talk_cpp_041);
			pressAnyKey();
			ledger.subtract_funds(rent, EXPENSE_RENT);
			locationIsNowRented(cursite, rent);
			basesquad(activesquad, cursite);
			return 1;
		case 'b': // Refuse rent deal
			clearcommandarea(); clearmessagearea(); clearmaparea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(9, 1, a.name, gamelog); addstrAlt(saysComma, gamelog);
			set_color_easy(GREEN_ON_BLACK_BRIGHT);
			mvaddstrAlt(10, 1, unnamed_String_Talk_cpp_042, gamelog);
			gamelog.newline();
			pressAnyKey();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			mvaddstrAlt(12, 1, tk.name, gamelog); addstrAlt(respondsComma, gamelog);
			set_color_easy(CYAN_ON_BLACK_BRIGHT);
			mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_043, gamelog);
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			addstrAlt(unnamed_String_Talk_cpp_044, gamelog);
			gamelog.newline();
			pressAnyKey();
			return 1;
		case 'c': // Threaten landlord
			clearcommandarea(); clearmessagearea(); clearmaparea();
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			Creature *armed_liberal = NULL;
			for (int i = 0; i < 6; i++)
			{
				if (activesquad->squad[i] &&
					activesquad->squad[i]->get_weapon().is_threatening())
				{
					armed_liberal = activesquad->squad[i];
					break;
				}
			}
			if (armed_liberal)
			{
				mvaddstrAlt(9, 1, armed_liberal->name, gamelog);
				addstrAlt(unnamed_String_Talk_cpp_045, gamelog);
				addstrAlt(armed_liberal->get_weapon().get_shortname(0), gamelog);
				addstrAlt(singleDot, gamelog);
				gamelog.newline();
				pressAnyKey();
				clearmessagearea();
			}
			mvaddstrAlt(9, 1, a.name, gamelog);
			addstrAlt(saysComma, gamelog);
			set_color_easy(GREEN_ON_BLACK_BRIGHT);
			mvaddstrAlt(10, 1, unnamed_String_Talk_cpp_046, gamelog);
			gamelog.newline();
			pressAnyKey();
			const int roll = a.skill_roll(SKILL_PERSUASION);
			int difficulty = DIFFICULTY_FORMIDABLE;
			if (!newscherrybusted)
				difficulty += 6;
			if (armed_liberal == NULL)
				difficulty += 6;
			if (roll < difficulty - 1)
			{
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(12, 1, tk.name, gamelog); addstrAlt(respondsComma, gamelog);
				set_color_easy(CYAN_ON_BLACK_BRIGHT);
				mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_047, gamelog);
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				addstrAlt(unnamed_String_Talk_cpp_048, gamelog);
				gamelog.newline();
				pressAnyKey();
				tk.cantbluff = 1;
				return 1;
			}
			else
			{
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(12, 1, tk.name, gamelog); addstrAlt(respondsComma, gamelog);
				set_color_easy(CYAN_ON_BLACK_BRIGHT);
				mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_049, gamelog);
				gamelog.newline();
				pressAnyKey();
				int rent;
				// Either he calls the cops...
				if (roll < difficulty)
				{
					for (int i = 0; i < 6; i++)
						if (activesquad->squad[i])
							criminalize(*(activesquad->squad[i]), LAWFLAG_EXTORTION);
					LocationsPool::getInstance().setSiegetimeuntillocated(cursite, 2);
					rent = 10000000; // Yeah he's kicking you out next month
				}
				// ...or it's yours for free
				else rent = 0;
				locationIsNowRented(cursite, rent);
				basesquad(activesquad, cursite);
				return 1;
			}
		}
	}
}
char heyINeedAGun(Creature &a, Creature &tk)
{
	extern Log gamelog;
	extern short cursite;
	extern short sitealarm;
	extern short lawList[LAWNUM];
	clearcommandarea(); clearmessagearea(); clearmaparea();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(9, 1, a.name, gamelog); addstrAlt(saysComma, gamelog);
	set_color_easy(GREEN_ON_BLACK_BRIGHT);
	mvaddstrAlt(10, 1, unnamed_String_Talk_cpp_050, gamelog);
	gamelog.newline();
	pressAnyKey();
	const bool is_naked = a.is_naked() && a.animalgloss != ANIMALGLOSS_ANIMAL;
	if (is_naked)
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(12, 1, tk.name, gamelog); addstrAlt(respondsComma, gamelog);
		set_color_easy(CYAN_ON_BLACK_BRIGHT);
		mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_051, gamelog);
		gamelog.newline();
		pressAnyKey();
		return 1;
	}
	// IsaacG Migrate Strings
	if (a.get_armor().get_itemtypename() == tag_ARMOR_POLICEUNIFORM ||
		a.get_armor().get_itemtypename() == tag_ARMOR_POLICEARMOR ||
		a.get_armor().get_itemtypename() == tag_ARMOR_SWATARMOR ||
		(lawList[LAW_POLICEBEHAVIOR] == -2 && lawList[LAW_DEATHPENALTY] == -2 &&
			a.get_armor().get_itemtypename() == tag_ARMOR_DEATHSQUADUNIFORM))
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(12, 1, tk.name, gamelog); addstrAlt(respondsComma, gamelog);
		set_color_easy(CYAN_ON_BLACK_BRIGHT);
		mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_052, gamelog);
		gamelog.newline();
		pressAnyKey();
		return 1;
	}
	if (sitealarm != 0)
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(12, 1, tk.name, gamelog); addstrAlt(respondsComma, gamelog);
		set_color_easy(CYAN_ON_BLACK_BRIGHT);
		mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_053, gamelog);
		gamelog.newline();
		pressAnyKey();
		return 1;
	}
	switch (LocationsPool::getInstance().getLocationType(cursite))
	{
	case SITE_OUTDOOR_BUNKER:
	case SITE_BUSINESS_CRACKHOUSE:
	case SITE_BUSINESS_BARANDGRILL:
	case SITE_BUSINESS_ARMSDEALER:
	case SITE_RESIDENTIAL_TENEMENT:
	case SITE_RESIDENTIAL_BOMBSHELTER:
	case SITE_RESIDENTIAL_SHELTER:
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(12, 1, tk.name, gamelog); addstrAlt(respondsComma, gamelog);
		set_color_easy(CYAN_ON_BLACK_BRIGHT);
		mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_054, gamelog);
		gamelog.newline();
		pressAnyKey();
		armsdealer(cursite);
		return 1;
	default:
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(12, 1, tk.name, gamelog); addstrAlt(respondsComma, gamelog);
		set_color_easy(CYAN_ON_BLACK_BRIGHT);
		mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_055, gamelog);
		gamelog.newline();
		pressAnyKey();
		return 1;
	}
}
char wannaHearSomethingDisturbing(Creature &a, Creature &tk)
{
	extern Log gamelog;
	clearcommandarea(); clearmessagearea(); clearmaparea();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(9, 1, a.name, gamelog); addstrAlt(saysComma, gamelog);
	set_color_easy(GREEN_ON_BLACK_BRIGHT);
	mvaddstrAlt(10, 1, unnamed_String_Talk_cpp_056, gamelog);
	gamelog.newline();
	pressAnyKey();
	bool interested = tk.talkreceptive();
	if (!interested && a.skill_check(SKILL_PERSUASION, DIFFICULTY_AVERAGE))
		interested = true;
	if ((tk.animalgloss == ANIMALGLOSS_ANIMAL && tk.align != ALIGN_LIBERAL) ||
		tk.animalgloss == ANIMALGLOSS_TANK)
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(12, 1, tk.name, gamelog);
		switch (tk.type)
		{
		case CREATURE_TANK: addstrAlt(unnamed_String_Talk_cpp_057, gamelog); break;
		case CREATURE_GUARDDOG: addstrAlt(unnamed_String_Talk_cpp_058, gamelog); break;
		default: addstrAlt(unnamed_String_Talk_cpp_059, gamelog); break;
		}
		gamelog.newline();
		pressAnyKey();
		return 1;
	}
	else if (strcmp(tk.name, unnamed_String_Talk_cpp_060.data()) != 0 && interested)
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(12, 1, tk.name, gamelog); addstrAlt(respondsComma, gamelog);
		set_color_easy(CYAN_ON_BLACK_BRIGHT);
		mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_061, gamelog);
		gamelog.newline();
		pressAnyKey();
		return talkAboutIssues(a, tk);
	}
	else
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(12, 1, tk.name, gamelog); addstrAlt(respondsComma, gamelog);
		set_color_easy(CYAN_ON_BLACK_BRIGHT);
		if (strcmp(tk.name, unnamed_String_Talk_cpp_060.data()) == 0)
		{
			if (tk.align == ALIGN_LIBERAL)
				mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_062, gamelog);
			else mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_063, gamelog);
		}
		else mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_064, gamelog);
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		addstrAlt(unnamed_String_Talk_cpp_065, gamelog);
		gamelog.newline();
		pressAnyKey();
		return 1;
	}
}
int getCity(int l);
void newDate(Creature &a, Creature &tk);
char doYouComeHereOften(Creature &a, Creature &tk)
{
	extern Log gamelog;
	extern short lawList[LAWNUM];
	int y = 12;
	clearcommandarea(); clearmessagearea(); clearmaparea();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(9, 1, a.name, gamelog); addstrAlt(saysComma, gamelog);
	set_color_easy(GREEN_ON_BLACK_BRIGHT);
	vector<string> selected_flirt;
	int line;
	if (lawList[LAW_FREESPEECH] == -2)
	{
		selected_flirt = pickrandom(no_free_speech_flirt);
	}
	else
	{
		selected_flirt = pickrandom(pickupLines);
	}
	mvaddstrAlt(10, 1, selected_flirt[0], gamelog);
	if (selected_flirt[1] != blankString) {
		y++;
		mvaddstrAlt(11, 1, selected_flirt[1], gamelog);
	}
	gamelog.newline();
	pressAnyKey();
	bool succeeded = false;
	int difficulty = DIFFICULTY_HARD;
	if (tk.type == CREATURE_CORPORATE_CEO)
		difficulty = DIFFICULTY_HEROIC;
	const bool is_naked = a.is_naked() && a.animalgloss != ANIMALGLOSS_ANIMAL;
	if (is_naked) difficulty -= 4;
	if (a.skill_check(SKILL_SEDUCTION, difficulty))
		succeeded = true;
	if ((tk.animalgloss == ANIMALGLOSS_ANIMAL && lawList[LAW_ANIMALRESEARCH] != 2 && a.animalgloss != ANIMALGLOSS_ANIMAL) ||
		tk.animalgloss == ANIMALGLOSS_TANK)
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(y++, 1, tk.name, gamelog);
		switch (tk.type)
		{
		case CREATURE_TANK:
			addstrAlt(unnamed_String_Talk_cpp_066, gamelog);
			break;
		case CREATURE_GUARDDOG:
			addstrAlt(saysComma, gamelog);
			set_color_easy(RED_ON_BLACK_BRIGHT);
			mvaddstrAlt(y, 1, pickrandom(dog_rejection), gamelog);
			tk.align = ALIGN_CONSERVATIVE;
			tk.cantbluff = 1;
			break;
		case CREATURE_GENETIC:
			addstrAlt(saysComma, gamelog);
			set_color_easy(RED_ON_BLACK_BRIGHT);
			mvaddstrAlt(y, 1, pickrandom(mutant_rejection), gamelog);
			tk.align = ALIGN_CONSERVATIVE;
			tk.cantbluff = 1;
			break;
		default:
			addstrAlt(unnamed_String_Talk_cpp_067, gamelog);
		}
		gamelog.newline();
		pressAnyKey();
		return 1;
	}
	a.train(SKILL_SEDUCTION, LCSrandom(5) + 2);
	if ((a.get_armor().get_itemtypename() == tag_ARMOR_POLICEUNIFORM // Police property on armor? -XML
		|| a.get_armor().get_itemtypename() == tag_ARMOR_POLICEARMOR
		|| a.get_armor().get_itemtypename() == tag_ARMOR_SWATARMOR
		|| (lawList[LAW_POLICEBEHAVIOR] == ALIGN_ARCHCONSERVATIVE && lawList[LAW_DEATHPENALTY] == ALIGN_ARCHCONSERVATIVE
			&& a.get_armor().get_itemtypename() == tag_ARMOR_DEATHSQUADUNIFORM))
		&& tk.type == CREATURE_PROSTITUTE)
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(y++, 1, tk.name, gamelog); addstrAlt(respondsComma, gamelog);
		set_color_easy(RED_ON_BLACK_BRIGHT);
		mvaddstrAlt(y++, 1, unnamed_String_Talk_cpp_068, gamelog);
		gamelog.newline();
		pressAnyKey();
		tk.cantbluff = 1;
	}
	else if (succeeded)
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(y++, 1, tk.name, gamelog); addstrAlt(respondsComma, gamelog);
		set_color_easy(CYAN_ON_BLACK_BRIGHT);
		mvaddstrAlt(y++, 1, selected_flirt[2], gamelog);
		gamelog.newline();
		pressAnyKey();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		++y;
		mvaddstrAlt(y++, 1, a.name, gamelog);
		addstrAlt(unnamed_String_Talk_cpp_069, gamelog);
		addstrAlt(tk.name, gamelog);
		addstrAlt(unnamed_String_Talk_cpp_070, gamelog);
		if (strcmp(tk.name, unnamed_String_Talk_cpp_060.data()) == 0)
		{
			addstrAlt(unnamed_String_Talk_cpp_071, gamelog);
			mvaddstrAlt(y++, 1, tk.name, gamelog);
			addstrAlt(unnamed_String_Talk_cpp_072, gamelog);
			criminalize(tk, LAWFLAG_ESCAPED);
		}
		addstrAlt(unnamed_String_Talk_cpp_073, gamelog);
		gamelog.newline();
		pressAnyKey();
		newDate(a, tk);
	}
	else
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(y++, 1, tk.name, gamelog);
		addstrAlt(respondsComma, gamelog);
		set_color_easy(RED_ON_BLACK_BRIGHT);
		if (tk.type == CREATURE_CORPORATE_CEO)
		{
			if (a.gender_liberal != GENDER_MALE)
				mvaddstrAlt(y++, 1, unnamed_String_Talk_cpp_074, gamelog);
			else mvaddstrAlt(y++, 1, unnamed_String_Talk_cpp_075, gamelog);
		}
		else
		{
			mvaddstrAlt(y++, 1, selected_flirt[3], gamelog);
			if (selected_flirt[4] != blankString) {
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				mvaddstrAlt(y++, 1, selected_flirt[4], gamelog);
			}
		}
		gamelog.newline();
		pressAnyKey();
		tk.cantbluff = 1;
	}
	return 1;
}
void newRecruit(Creature *cr, int c);
char talkAboutIssues(Creature &a, Creature &tk)
{
	extern Log gamelog;
	extern char newscherrybusted;
	extern short lawList[LAWNUM];
	const int lw = LCSrandom(LAWNUM); // pick a random law to talk about
	bool succeeded = false;
	bool you_are_stupid = false;
	bool issue_too_liberal = false;
	if (!(a.attribute_check(ATTRIBUTE_INTELLIGENCE, DIFFICULTY_EASY)))
		you_are_stupid = true;
	else if (lawList[lw] == ALIGN_ELITELIBERAL && newscherrybusted)
		issue_too_liberal = true;
	clearcommandarea();
	clearmessagearea();
	clearmaparea();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(9, 1, a.name, gamelog);
	addstrAlt(saysComma, gamelog);
	set_color_easy(GREEN_ON_BLACK_BRIGHT);
	int y = 10;
	if (you_are_stupid)
	{
		if (lw == LAW_POLICEBEHAVIOR) {
			if (lawList[LAW_FREESPEECH] == ALIGN_ARCHCONSERVATIVE)
				mvaddstrAlt(y++, 1, unnamed_String_Talk_cpp_076, gamelog);
			else
				mvaddstrAlt(y++, 1, unnamed_String_Talk_cpp_077, gamelog);
		}
		else {
			mvaddstrAlt(y++, 1, youAreStupidTalkAboutIssues[lw]);
		}
	}
	else if (issue_too_liberal)
	{

		mvaddstrAlt(y++, 1, issueTooLiberal[lw]);
	}
	else
	{
		if (lw == LAW_POLLUTION) {
			mvaddstrAlt(y++, 1, unnamed_String_Talk_cpp_078, gamelog);
			if (tk.animalgloss == ANIMALGLOSS_ANIMAL) mvaddstrAlt(y++, 1, unnamed_String_Talk_cpp_079, gamelog);
			else mvaddstrAlt(y++, 1, unnamed_String_Talk_cpp_080, gamelog);
		}
		else {
			mvaddstrAlt(y++, 1, talkAboutTheIssues[lw][0], gamelog);
			mvaddstrAlt(y++, 1, talkAboutTheIssues[lw][1], gamelog);
		}
	}
	gamelog.newline();
	pressAnyKey();
	int difficulty = DIFFICULTY_VERYEASY;
	if (tk.align == ALIGN_CONSERVATIVE)
		difficulty += 7;
	if (!(tk.talkreceptive()))
		difficulty += 7;
	if (you_are_stupid)
		difficulty += 5;
	if (issue_too_liberal)
		difficulty += 5;
	const bool is_naked = a.is_naked() && a.animalgloss != ANIMALGLOSS_ANIMAL;
	if (is_naked)
		difficulty += 5;
	succeeded = a.skill_check(SKILL_PERSUASION, difficulty);
	// Prisoners never accept to join you, you must liberate them instead
	if (succeeded && strcmp(tk.name, unnamed_String_Talk_cpp_081.data()) != 0)
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt((++y)++, 1, tk.name, gamelog); addstrAlt(respondsComma, gamelog);
		set_color_easy(CYAN_ON_BLACK_BRIGHT);
		if (tk.type == CREATURE_MUTANT && tk.get_attribute(ATTRIBUTE_INTELLIGENCE, true) < 3)
			mvaddstrAlt(y++, 1, unnamed_String_Talk_cpp_082, gamelog);
		else
		{
			switch (LCSrandom(10))
			{
			case 0: mvaddstrAlt(y++, 1, unnamed_String_Talk_cpp_083, gamelog);
				pressAnyKey();
				set_color_easy(GREEN_ON_BLACK_BRIGHT);
				mvaddstrAlt(y++, 1, unnamed_String_Talk_cpp_084, gamelog);
				break;
			case 1: mvaddstrAlt(y++, 1, unnamed_String_Talk_cpp_085, gamelog);
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				addstrAlt(unnamed_String_Talk_cpp_086, gamelog);
				break;
			default:
				mvaddstrAlt(y++, 1, pickrandom(that_is_disturbing), gamelog);
				break;
			}
		}
		gamelog.newline();
		pressAnyKey();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(++y, 1, unnamed_String_Talk_cpp_087, gamelog);
		addstrAlt(tk.name, gamelog);
		addstrAlt(unnamed_String_Talk_cpp_088, gamelog);
		gamelog.newline();
		pressAnyKey();
		Creature *newcr = new Creature;
		*newcr = tk;
		newcr->namecreature();
		newRecruit(newcr, a.id);
		delenc(tk);
		return 1;
	}
	else
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt((++y)++, 1, tk.name, gamelog); addstrAlt(respondsComma, gamelog);
		set_color_easy(CYAN_ON_BLACK_BRIGHT);
		if (tk.type == CREATURE_MUTANT &&
			tk.get_attribute(ATTRIBUTE_INTELLIGENCE, true) < 3)
		{
			mvaddstrAlt(y++, 1, unnamed_String_Talk_cpp_089, gamelog);
		}
		else
		{
			if (tk.align == ALIGN_CONSERVATIVE && you_are_stupid)
			{
				if (tk.type == CREATURE_GANGUNIT)
					mvaddstrAlt(y++, 1, unnamed_String_Talk_cpp_090, gamelog);
				else if (tk.type == CREATURE_DEATHSQUAD)
					mvaddstrAlt(y++, 1, unnamed_String_Talk_cpp_091, gamelog);
				else
				{
					mvaddstrAlt(y++, 1, pickrandom(that_is_not_disturbing), gamelog);
				}
			}
			else if (tk.align != ALIGN_LIBERAL && tk.attribute_check(ATTRIBUTE_WISDOM, DIFFICULTY_AVERAGE))
			{
				mvaddstrAlt(y++, 1, conservativeLegalArgument[lw], gamelog);
			}
			else
			{
				mvaddstrAlt(y++, 1, unnamed_String_Talk_cpp_092, gamelog);
			}
		}
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		addstrAlt(unnamed_String_Talk_cpp_093, gamelog);
		gamelog.newline();
		pressAnyKey();
		tk.cantbluff = 1;
		return 1;
	}
}
char talkInCombat(Creature &a, Creature &tk)
{
	extern Log gamelog;
	extern short cursite;
	extern newsstoryst *sitestory;
	extern int sitecrime;
	extern squadst *activesquad;
	extern int locx;
	extern int locy;
	extern int locz;
	extern short siteonfire;
	extern short fieldskillrate;

	extern short exec[EXECNUM];
	extern Creature encounter[ENCMAX];
	extern string slogan_str;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	extern short lawList[LAWNUM];
	extern short attitude[VIEWNUM];
	clearcommandarea();
	clearmessagearea();
	clearmaparea();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(9, 1, a.name, gamelog);
	addstrAlt(unnamed_String_Talk_cpp_094, gamelog);
	switch (tk.align)
	{
	case ALIGN_CONSERVATIVE: set_color_easy(RED_ON_BLACK_BRIGHT); break;
	case ALIGN_LIBERAL: set_color_easy(GREEN_ON_BLACK_BRIGHT); break;
	case ALIGN_MODERATE: set_color_easy(WHITE_ON_BLACK_BRIGHT); break;
	}
	addstrAlt(tk.name, gamelog);
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	addstrAlt(unnamed_String_Talk_cpp_095, gamelog);
	gamelog.newline();
	int c = 0, hostages = 0, weaponhostage = 0;
	bool cop = 0;
	for (int i = 0; i < 6; i++)
	{
		if (activesquad->squad[i] &&
			activesquad->squad[i]->prisoner&&
			activesquad->squad[i]->prisoner->alive&&
			activesquad->squad[i]->prisoner->enemy())
		{
			hostages++;
			if (activesquad->squad[i]->get_weapon().can_threaten_hostages())
				weaponhostage++;
		}
	}
	if (tk.type == CREATURE_COP ||
		tk.type == CREATURE_GANGUNIT ||
		tk.type == CREATURE_DEATHSQUAD ||
		tk.type == CREATURE_SWAT ||
		tk.type == CREATURE_SECURITYGUARD ||
		tk.type == CREATURE_MERC ||
		tk.type == CREATURE_SOLDIER ||
		tk.type == CREATURE_MILITARYPOLICE ||
		tk.type == CREATURE_MILITARYOFFICER ||
		tk.type == CREATURE_SEAL)
	{
		cop = 1;
	}
	set_color_easy(WHITE_ON_BLACK);
	mvaddstrAlt(11, 1, unnamed_String_Talk_cpp_096);
	if (!hostages)set_color_easy(BLACK_ON_BLACK_BRIGHT);
	mvaddstrAlt(12, 1, unnamed_String_Talk_cpp_097);
	if (tk.cantbluff != 2)set_color_easy(WHITE_ON_BLACK);
	else set_color_easy(BLACK_ON_BLACK_BRIGHT);
	mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_098);
	if (cop)set_color_easy(WHITE_ON_BLACK);
	else set_color_easy(BLACK_ON_BLACK_BRIGHT);
	mvaddstrAlt(14, 1, unnamed_String_Talk_cpp_099);
	set_color_easy(WHITE_ON_BLACK);
	while (true)
	{
		c = getkeyAlt();
		if (c == 'a')break;
		if (c == 'b' && hostages)break;
		if (c == 'c' && tk.cantbluff != 2)break;
		if (c == 'd' && cop)break;
	}
	if (c == 'a')
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, a.name, gamelog);
		addstrAlt(colonSpace, gamelog);
		set_color_easy(GREEN_ON_BLACK_BRIGHT);
		switch (LCSrandom(4))
		{
		case 0:
		{   // Formatting the slogan so that it always has quotes around it and punctuation
			if (slogan_str[0] != '"') mvaddcharAlt(17, 1, '"');
			mvaddstrAlt(17, 1 + (slogan_str[0] != '"' ? 1 : 0), slogan_str, gamelog);
			const int last = len(slogan_str);
			if (last && slogan_str[last - 1] != '"' && slogan_str[last - 1] != '!' && slogan_str[last - 1] != '.' && slogan_str[last - 1] != '?')
				addcharAlt('!', gamelog);
			if (last && slogan_str[last - 1] != '"') addcharAlt('"', gamelog);
			if (!sitestory->claimed)
				sitestory->claimed = 1;
			break;
		}
		default:
			mvaddstrAlt(17, 1, pickrandom(come_at_me_bro), gamelog);
			break;
		}
		pressAnyKey();
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		for (int e = 0; e < ENCMAX; e++)
		{
			if (encounter[e].exists&&encounter[e].alive&&encounter[e].enemy())
			{
				const int attack = a.juice / 50 + attitude[VIEW_LIBERALCRIMESQUAD] / 10;
				const int defense = encounter[e].attribute_roll(ATTRIBUTE_WISDOM);
				if (attack > defense)
				{
					if (encounter[e].type == CREATURE_COP ||
						encounter[e].type == CREATURE_GANGUNIT ||
						encounter[e].type == CREATURE_SWAT ||
						encounter[e].type == CREATURE_DEATHSQUAD ||
						encounter[e].type == CREATURE_SOLDIER ||
						encounter[e].type == CREATURE_HARDENED_VETERAN ||
						encounter[e].type == CREATURE_CCS_ARCHCONSERVATIVE ||
						encounter[e].type == CREATURE_AGENT ||
						encounter[e].type == CREATURE_SECRET_SERVICE)
					{
						if (LCSrandom(3)) continue;
					}
					clearmessagearea();
					mvaddstrAlt(16, 1, encounter[e].name, gamelog);
					addstrAlt(singleSpace + pickrandom(backs_off), gamelog);
					delenc(e, 0);
					addjuice(a, 2, 200); // Instant juice!
					pressAnyKey();
				}
			}
		}
	}
	else if (c == 'b')
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(16, 1, a.name + colonSpace, gamelog);
		{
			string anotherHostageThing;
			switch (LCSrandom(6))
			{
			case 0:anotherHostageThing = (unnamed_String_Talk_cpp_100);
				if (!sitestory->claimed)sitestory->claimed = 1; break;
			case 1:
				if (lawList[LAW_FREESPEECH] == -2)anotherHostageThing = (unnamed_String_Talk_cpp_101);
				else anotherHostageThing = (unnamed_String_Talk_cpp_102);
				break;
			default:
				anotherHostageThing = (pickrandom(threaten_hostage));
				break;
			}
			set_color_easy(GREEN_ON_BLACK_BRIGHT);
			mvaddstrAlt(17, 1, anotherHostageThing, gamelog);
		}
		gamelog.newline();
		sitecrime += 5;
		criminalizeparty(LAWFLAG_KIDNAPPING);
		addjuice(a, -2, -10); // DE-juice for this shit
		pressAnyKey();
		if (weaponhostage)
		{
			bool noretreat = false;
			int e = 0;
			for (; e < ENCMAX; e++)
			{
				if (encounter[e].exists&&encounter[e].alive&&
					encounter[e].enemy() && encounter[e].blood > 70)
				{
					if ((encounter[e].type == CREATURE_DEATHSQUAD ||
						encounter[e].type == CREATURE_SOLDIER ||
						encounter[e].type == CREATURE_HARDENED_VETERAN ||
						encounter[e].type == CREATURE_CCS_ARCHCONSERVATIVE ||
						encounter[e].type == CREATURE_AGENT ||
						encounter[e].type == CREATURE_MERC ||
						encounter[e].type == CREATURE_COP ||
						encounter[e].type == CREATURE_GANGUNIT ||
						encounter[e].type == CREATURE_SWAT ||
						encounter[e].type == CREATURE_SECRET_SERVICE) &&
						LCSrandom(5))
					{
						set_color_easy(WHITE_ON_BLACK_BRIGHT);
						clearmessagearea();
						mvaddstrAlt(16, 1, encounter[e].name, gamelog);
						addstrAlt(colonSpace, gamelog);
						if (encounter[e].align != ALIGN_CONSERVATIVE ||
							(encounter[e].type == CREATURE_SECRET_SERVICE && exec[EXEC_PRESIDENT] > ALIGN_CONSERVATIVE))
						{
							set_color_easy(GREEN_ON_BLACK_BRIGHT);
							mvaddstrAlt(17, 1, pickrandom(please_spare_hostage), gamelog);
						}
						else
						{
							set_color_easy(RED_ON_BLACK_BRIGHT);
							if (((encounter[e].type == CREATURE_DEATHSQUAD ||
								encounter[e].type == CREATURE_AGENT ||
								encounter[e].type == CREATURE_MERC ||
								encounter[e].type == CREATURE_CCS_ARCHCONSERVATIVE ||
								encounter[e].type == CREATURE_GANGUNIT))
								&& encounter[e].align == ALIGN_CONSERVATIVE)
							{
								mvaddstrAlt(17, 1, pickrandom(who_cares_about_hostage), gamelog);
							}
							else
							{
								string moreHostageQuestions;
								if (LCSrandom(5)) {
									moreHostageQuestions = (pickrandom(hostage_negotiation));
								}
								else {
									if (hostages > 1)
										moreHostageQuestions = (unnamed_String_Talk_cpp_103);
									else moreHostageQuestions = (unnamed_String_Talk_cpp_104);
								}
								mvaddstrAlt(17, 1, moreHostageQuestions, gamelog);
							}
						}
						gamelog.newline();
						pressAnyKey();
						noretreat = true;
						break;
					}
				}
			}
			if (e == ENCMAX) { e--; }
			if (noretreat == false)
			{
				set_color_easy(WHITE_ON_BLACK_BRIGHT);
				clearmessagearea();
				mvaddstrAlt(16, 1, unnamed_String_Talk_cpp_105, gamelog);
				gamelog.newline();
				for (int i = ENCMAX - 1; i >= 0; i--)
				{
					if (encounter[i].exists&&
						encounter[i].alive&&
						encounter[i].align <= -1)
					{
						delenc(i, 0);
					}
				}
				pressAnyKey();
			}
			else
			{
				set_color_easy(WHITE_ON_BLACK);
				clearcommandarea();
				clearmessagearea();
				clearmaparea();
				mvaddstrAlt(9, 1, unnamed_String_Talk_cpp_106);
				addstrAlt(a.name);
				addstrAlt(unnamed_String_Talk_cpp_107);
				mvaddstrAlt(11, 1, hostages > 1 ? (unnamed_String_Talk_cpp_108) : (unnamed_String_Talk_cpp_109));
				mvaddstrAlt(12, 1, hostages > 1 ? (unnamed_String_Talk_cpp_110) : (unnamed_String_Talk_cpp_111));
				mvaddstrAlt(13, 1, unnamed_String_Talk_cpp_112);
				while (true)
				{
					c = getkeyAlt();
					if (c == 'a' || c == 'b')break; // TODO: something to happen if you press 'c'
				}
				if (c == 'a')
				{
					Creature* executer = 0;
					if (a.prisoner)
						executer = &a;
					else for (int i = 0; i < 6; i++)
					{
						if (activesquad->squad[i] &&
							activesquad->squad[i]->prisoner &&
							activesquad->squad[i]->prisoner->alive &&
							activesquad->squad[i]->prisoner->enemy())
						{
							executer = activesquad->squad[i];
							break;
						}
					}
					set_color_easy(RED_ON_BLACK_BRIGHT);
					{
						string executerGetAmmo;
						if (executer->get_weapon().is_ranged()
							&& executer->get_weapon().get_ammoamount() > 0)
						{
							executerGetAmmo = (unnamed_String_Talk_cpp_113);
							executer->get_weapon().decrease_ammo(1); //What if it doesn't use ammo? -XML
						}
						else
						{
							executerGetAmmo = (unnamed_String_Talk_cpp_114);
						}
						mvaddstrAlt(16, 1, executerGetAmmo, gamelog);
					}
					gamelog.newline();
					pressAnyKey();
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(17, 1, executer->name, gamelog);
					addstrAlt(unnamed_String_Talk_cpp_115, gamelog);
					addstrAlt(executer->prisoner->name, gamelog);
					addstrAlt(unnamed_String_Talk_cpp_116, gamelog);
					gamelog.newline();
					addjuice(*executer, -5, -50); // DE-juice for this shit
					sitecrime += 10;
					sitestory->crime.push_back(CRIME_KILLEDSOMEBODY);
					criminalize(*executer, LAWFLAG_MURDER);
					if (executer->prisoner->type == CREATURE_CORPORATE_CEO ||
						executer->prisoner->type == CREATURE_RADIOPERSONALITY ||
						executer->prisoner->type == CREATURE_NEWSANCHOR ||
						executer->prisoner->type == CREATURE_SCIENTIST_EMINENT ||
						executer->prisoner->type == CREATURE_JUDGE_CONSERVATIVE)sitecrime += 30;
					makeloot(*executer->prisoner);
					pressAnyKey();
					delete_and_nullify(executer->prisoner);
					if (hostages > 1 && LCSrandom(2))
					{
						clearmessagearea();
						set_color_easy(WHITE_ON_BLACK_BRIGHT);
						mvaddstrAlt(16, 1, encounter[e].name, gamelog);
						addstrAlt(colonSpace, gamelog);
						set_color_easy(RED_ON_BLACK_BRIGHT);
						mvaddstrAlt(17, 1, lawList[LAW_FREESPEECH] > ALIGN_ARCHCONSERVATIVE ? unnamed_String_Talk_cpp_117 : unnamed_String_Talk_cpp_118, gamelog);
						addstrAlt(pickrandom(please_no_more), gamelog);
						gamelog.newline();
						for (int i = ENCMAX - 1; i >= 0; i--)
							if (encounter[i].exists && encounter[i].enemy() && encounter[i].alive)
								delenc(i, 0);
						pressAnyKey();
					}
				}
				else if (c == 'b')
				{
					set_color_easy(WHITE_ON_BLACK_BRIGHT);
					mvaddstrAlt(16, 1, a.name, gamelog);
					addstrAlt(colonSpace, gamelog);
					set_color_easy(GREEN_ON_BLACK_BRIGHT);
					{
						string nameHostages;
						if (LCSrandom(5))
						{
							if (hostages > 1) nameHostages = (unnamed_String_Talk_cpp_119);
							else nameHostages = (unnamed_String_Talk_cpp_120);
						}
						else {
							nameHostages = (pickrandom(let_hostages_go));
						}
						mvaddstrAlt(17, 1, nameHostages, gamelog);
					}
					gamelog.newline();
					pressAnyKey();
					if (((encounter[e].type == CREATURE_DEATHSQUAD ||
						encounter[e].type == CREATURE_AGENT ||
						encounter[e].type == CREATURE_MERC ||
						encounter[e].type == CREATURE_CCS_ARCHCONSERVATIVE ||
						encounter[e].type == CREATURE_GANGUNIT) &&
						LCSrandom(2)) && encounter[e].align == ALIGN_CONSERVATIVE)
					{
						clearmessagearea();
						set_color_easy(WHITE_ON_BLACK_BRIGHT);
						mvaddstrAlt(16, 1, encounter[e].name, gamelog);
						addstrAlt(colonSpace, gamelog);
						set_color_easy(RED_ON_BLACK_BRIGHT);
						mvaddstrAlt(17, 1, pickrandom(go_ahead_and_die), gamelog);
						gamelog.newline();
						pressAnyKey();
					}
					else
					{
						clearmessagearea();
						set_color_easy(WHITE_ON_BLACK_BRIGHT);
						mvaddstrAlt(16, 1, encounter[e].name, gamelog);
						addstrAlt(colonSpace, gamelog);
						set_color_easy(RED_ON_BLACK_BRIGHT);
						mvaddstrAlt(17, 1, pickrandom(agree_to_release_hostages), gamelog);
						gamelog.newline();
						pressAnyKey();
						for (int i = ENCMAX - 1; i >= 0; i--)
							if (encounter[i].exists&&encounter[i].enemy() && encounter[i].alive)
								delenc(i, 0);
						clearmessagearea();
						set_color_easy(WHITE_ON_BLACK_BRIGHT);
						juiceparty(15, 200); // Instant juice for successful hostage negotiation
						mvaddstrAlt(16, 1, hostages > 1 ? unnamed_String_Talk_cpp_121 : unnamed_String_Talk_cpp_122, gamelog);
						gamelog.newline();
						for (int i = 0; i < 6; i++)
						{
							if (activesquad->squad[i] &&
								activesquad->squad[i]->prisoner &&
								activesquad->squad[i]->prisoner->enemy())
							{
								delete_and_nullify(activesquad->squad[i]->prisoner);
							}
						}
						pressAnyKey();
					}
				}
			}
		}
		else
		{
			set_color_easy(WHITE_ON_BLACK_BRIGHT);
			clearmessagearea();
			mvaddstrAlt(16, 1, tk.name, gamelog);
			addstrAlt(unnamed_String_Talk_cpp_123, gamelog);
			gamelog.newline();
			pressAnyKey();
		}
	}
	else if (c == 'c')
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		if (LocationsPool::getInstance().isThereASiegeHere(cursite))
		{
			mvaddstrAlt(16, 1, a.name, gamelog);
			addstrAlt(singleSpace, gamelog);
			switch (LocationsPool::getInstance().getSiegeType(cursite))
			{
			case SIEGE_POLICE:
				addstrAlt(unnamed_String_Talk_cpp_124, gamelog);
				break;
			case SIEGE_CIA:
				addstrAlt(unnamed_String_Talk_cpp_125, gamelog);
				break;
			case SIEGE_CCS:
			case SIEGE_HICKS:
				switch (LCSrandom(2))
				{
				case 0:
					addstrAlt(unnamed_String_Talk_cpp_126, gamelog);
					mvaddstrAlt(17, 1, unnamed_String_Talk_cpp_127, gamelog);
					break;
				case 1:
					addstrAlt(unnamed_String_Talk_cpp_128, gamelog);
					mvaddstrAlt(17, 1, unnamed_String_Talk_cpp_129, gamelog);
					break;
				}
				break;
			case SIEGE_CORPORATE:
				addstrAlt(unnamed_String_Talk_cpp_130, gamelog);
				break;
			case SIEGE_FIREMEN:
				addstrAlt(unnamed_String_Talk_cpp_131, gamelog);
				if ((!(levelmap[locx][locy][locz].flag & SITEBLOCK_FIRE_END) ||
					!(levelmap[locx][locy][locz].flag & SITEBLOCK_FIRE_PEAK) ||
					!(levelmap[locx][locy][locz].flag & SITEBLOCK_FIRE_START) ||
					!(levelmap[locx][locy][locz].flag & SITEBLOCK_DEBRIS)) && !LCSrandom(10))
				{
					levelmap[locx][locy][locz].flag |= SITEBLOCK_FIRE_START;
					mvaddstrAlt(17, 1, unnamed_String_Talk_cpp_132, gamelog);
					gamelog.newline();
					mvaddstrAlt(18, 1, unnamed_String_Talk_cpp_133, gamelog);
				}
				break;
			}
		}
		else        //Special bluff messages for various uniforms
		{
			set_color_easy(GREEN_ON_BLACK_BRIGHT);
			if (a.get_armor().get_itemtypename() == tag_ARMOR_POLICEUNIFORM ||
				a.get_armor().get_itemtypename() == tag_ARMOR_POLICEARMOR ||
				a.get_armor().get_itemtypename() == tag_ARMOR_SWATARMOR)
			{
				mvaddstrAlt(16, 1, unnamed_String_Talk_cpp_134, gamelog);
			}
			else if (a.get_armor().get_itemtypename() == tag_ARMOR_BUNKERGEAR)
			{
				if (siteonfire) mvaddstrAlt(16, 1, unnamed_String_Talk_cpp_135, gamelog);
				else mvaddstrAlt(16, 1, unnamed_String_Talk_cpp_136, gamelog);
			}
			else if (a.get_armor().get_itemtypename() == tag_ARMOR_LABCOAT)
				mvaddstrAlt(16, 1, unnamed_String_Talk_cpp_137, gamelog);
			else if (a.get_armor().get_itemtypename() == tag_ARMOR_DEATHSQUADUNIFORM)
				mvaddstrAlt(16, 1, unnamed_String_Talk_cpp_138, gamelog);
			else if (a.get_armor().get_itemtypename() == tag_ARMOR_MITHRIL)
			{
				mvaddstrAlt(16, 1, a.name, gamelog);
				addstrAlt(unnamed_String_Talk_cpp_139, gamelog);
				set_color_easy(CYAN_ON_BLACK_BRIGHT);
				addstrAlt(unnamed_String_Talk_cpp_140, gamelog);     //Fanciful multicolor message
				set_color_easy(GREEN_ON_BLACK_BRIGHT);
				addstrAlt(unnamed_String_Talk_cpp_141, gamelog);
			}
			else
			{
				mvaddstrAlt(16, 1, a.name, gamelog);
				addstrAlt(unnamed_String_Talk_cpp_142, gamelog);
				mvaddstrAlt(17, 1, unnamed_String_Talk_cpp_143, gamelog);
			}

		}
		gamelog.newline();
		pressAnyKey();
		bool fooled = true;
		int e = 0;
		for (; e < ENCMAX; e++)
		{
			if (encounter[e].exists&&encounter[e].alive&&
				encounter[e].enemy())
			{
				const int roll = a.skill_roll(SKILL_DISGUISE);
				const int diff = encounter[e].get_attribute(ATTRIBUTE_WISDOM, true) > 10 ? DIFFICULTY_CHALLENGING : DIFFICULTY_AVERAGE;
				fooled = roll >= diff;
				if (roll + 1 == diff && fieldskillrate == FIELDSKILLRATE_HARD)
					a.train(SKILL_DISGUISE, 20);
				if (!fooled) break;
			}
		}
		if (e == ENCMAX) { e--; }
		switch (fieldskillrate)
		{
		case FIELDSKILLRATE_FAST:
			a.train(SKILL_DISGUISE, 50); break;
		case FIELDSKILLRATE_CLASSIC:
			a.train(SKILL_DISGUISE, 20); break;
		case FIELDSKILLRATE_HARD:
			a.train(SKILL_DISGUISE, 0); break;
		}
		if (!fooled)
		{
			clearmessagearea();
			set_color_easy(RED_ON_BLACK_BRIGHT);
			if (encounter[e].type == CREATURE_HICK)
			{
				mvaddstrAlt(16, 1, unnamed_String_Talk_cpp_144, gamelog);
				addstrAlt(encounter[e].name, gamelog);
				addstrAlt(unnamed_String_Talk_cpp_145, gamelog);
			}
			else
			{
				mvaddstrAlt(16, 1, encounter[e].name, gamelog);
				if (lawList[LAW_FREESPEECH] == ALIGN_ARCHCONSERVATIVE)
					addstrAlt(unnamed_String_Talk_cpp_146, gamelog);
				else addstrAlt(unnamed_String_Talk_cpp_147, gamelog);
			}
			pressAnyKey();
		}
		else
		{
			clearmessagearea();
			set_color_easy(GREEN_ON_BLACK_BRIGHT);
			mvaddstrAlt(16, 1, unnamed_String_Talk_cpp_148, gamelog);
			pressAnyKey();
			for (int e = ENCMAX - 1; e >= 0; e--)
				if (encounter[e].exists&&encounter[e].alive&&encounter[e].enemy())
					delenc(e, 0);
		}
		gamelog.newline();
	}
	else
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		mvaddstrAlt(14, 1, unnamed_String_Talk_cpp_149, gamelog);
		gamelog.newline();
		pressAnyKey();
		int stolen = 0;
		// Police assess stolen goods in inventory
		for (int l = 0; l < len(activesquad->loot); l++)
			if (activesquad->loot[l]->whatIsThis() == THIS_IS_LOOT)
				stolen++;
		for (int i = 0; i < 6; i++)
		{
			if (activesquad->squad[i])
			{
				activesquad->squad[i]->crimes_suspected[LAWFLAG_THEFT] += stolen;
				capturecreature(*activesquad->squad[i]);
			}
			activesquad->squad[i] = NULL;
		}
		LocationsPool::getInstance().isThereASiegeHere(cursite, 0);
	}
	return 1;
}
char heyMisterDog(Creature &a, Creature &tk)
{
	extern Log gamelog;
	extern squadst *activesquad;
	extern Creature encounter[ENCMAX];
	bool success = false;
	string pitch;
	string response;
	// Find most Heartful Liberal
	int bestp = 0;
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] &&
			activesquad->squad[p]->get_attribute(ATTRIBUTE_HEART, true) >
			activesquad->squad[bestp]->get_attribute(ATTRIBUTE_HEART, true))
		{
			bestp = p;
		}
	}
	// Say something unbelievably hippie
	if (activesquad->squad[bestp]->get_attribute(ATTRIBUTE_HEART, true) >= 15)
	{
		success = true;
		vector<string> which_choice = pickrandom(lovingly_talk_to_dog);
		pitch = which_choice[0];
		response = which_choice[1];
	}
	else // or not
	{
		tk.cantbluff = 1;
		vector<string> which_choice = pickrandom(normal_talk_to_dog);
		pitch = which_choice[0];
		response = which_choice[1];
	}
	clearcommandarea();
	clearmessagearea();
	clearmaparea();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(10, 1, activesquad->squad[bestp]->name, gamelog);
	addstrAlt(saysComma, gamelog);
	set_color_easy(GREEN_ON_BLACK_BRIGHT);
	mvaddstrAlt(11, 1, pitch, gamelog);
	gamelog.newline();
	pressAnyKey();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(13, 1, tk.name, gamelog);
	addstrAlt(saysComma, gamelog);
	set_color_easy(YELLOW_ON_BLACK_BRIGHT);
	mvaddstrAlt(14, 1, response, gamelog);
	gamelog.newline();
	pressAnyKey();
	if (success)
		for (int i = 0; i < ENCMAX; i++)
			if (encounter[i].type == CREATURE_GUARDDOG)
				encounter[i].align = ALIGN_LIBERAL;
	return 1;
}
char heyMisterMonster(Creature &a, Creature &tk)
{
	extern Log gamelog;
	extern squadst *activesquad;
	extern Creature encounter[ENCMAX];
	bool success = false;
	string pitch;
	string response;
	// Find most Heartful Liberal
	int bestp = 0;
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] &&
			activesquad->squad[p]->get_attribute(ATTRIBUTE_HEART, true) >
			activesquad->squad[bestp]->get_attribute(ATTRIBUTE_HEART, true))
		{
			bestp = p;
		}
	}
	// Say something diplomatic
	if (activesquad->squad[bestp]->get_attribute(ATTRIBUTE_HEART, true) >= 15)
	{
		success = true;
		vector<string> which_choice = pickrandom(lovingly_talk_to_mutant);
		pitch = which_choice[0];
		response = which_choice[1];
	}
	else // or not
	{
		tk.cantbluff = 1;
		vector<string> which_choice = pickrandom(normal_talk_to_mutant);
		pitch = which_choice[0];
		response = which_choice[1];
	}
	clearcommandarea();
	clearmessagearea();
	clearmaparea();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(10, 1, activesquad->squad[bestp]->name, gamelog);
	addstrAlt(saysComma, gamelog);
	set_color_easy(GREEN_ON_BLACK_BRIGHT);
	mvaddstrAlt(11, 1, pitch, gamelog);
	gamelog.newline();
	pressAnyKey();
	set_color_easy(WHITE_ON_BLACK_BRIGHT);
	mvaddstrAlt(13, 1, tk.name, gamelog);
	addstrAlt(saysComma, gamelog);
	set_color_easy(YELLOW_ON_BLACK_BRIGHT);
	mvaddstrAlt(14, 1, response, gamelog);
	gamelog.newline();
	pressAnyKey();
	if (success)
		for (int i = 0; i < ENCMAX; i++)
			if (encounter[i].type == CREATURE_GENETIC)
				encounter[i].align = ALIGN_LIBERAL;
	return 1;
}


const string tag_myear = "myear";
const string tag_color = "color";
const string tag_vtypeid = "vtypeid";
const string tag_vtypeidname = "vtypeidname";
const string tag_vehicle = "vehicle";
vector<VehicleType *> vehicletype;
long Vehicle::curcarid = 0;
string Vehicle::showXml() const
{
	CMarkup xml;
	xml.AddElem(tag_vehicle);
	xml.IntoElem();
	xml.AddElem(tag_vtypeidname, vtypeidname_);
	xml.AddElem(tag_vtypeid, tostring(vtypeid_));
	xml.AddElem(tag_color, color_);
	xml.AddElem(tag_heat, tostring(heat_));
	xml.AddElem(tag_location, tostring(location_));
	xml.AddElem(tag_myear, tostring(myear_));
	xml.AddElem(tag_id, tostring(id_));
	return xml.GetDoc();
}
Vehicle::Vehicle(const std::string& inputXml)
{
	CMarkup xml;
	xml.SetDoc(inputXml);
	xml.FindElem();
	xml.IntoElem();
	while (xml.FindElem())
	{
		std::string tag = xml.GetTagName();
		if (tag == tag_vtypeidname) vtypeidname_ = xml.GetData();
		else if (tag == tag_vtypeid) vtypeid_ = atoi(xml.GetData().c_str());
		else if (tag == tag_color) color_ = xml.GetData();
		else if (tag == tag_heat) heat_ = atoi(xml.GetData().c_str());
		else if (tag == tag_location) location_ = atoi(xml.GetData().c_str());
		else if (tag == tag_myear) myear_ = atoi(xml.GetData().c_str());
		else if (tag == tag_id) id_ = atoi(xml.GetData().c_str());
	}
}
void Vehicle::init(const VehicleType& seed, const string& color, int myear)
{
	id_ = curcarid++;
	heat_ = 0;
	location_ = -1;
	vtypeidname_ = seed.idname();
	vtypeid_ = seed.id();
	color_ = color;
	myear_ = myear;
}
void Vehicle::stop_riding_me() const
{
	CreaturePool::getInstance().stop_riding_me(id_);
}
void Vehicle::stop_preferring_me() const
{
	CreaturePool::getInstance().stop_preferring_me(id_);
}
string Vehicle::fullname(bool halffull) const
{
	const string CONST_vehicle007 = "Stolen ";
	string s;
	int words = 0;
	if (heat_)
	{
		s = CONST_vehicle007;
		words++;
	}
	if (displayscolor())
	{
		s += color_ + singleSpace;
		words++;
	}
	if (myear_ != -1 && words < 2) //don't print year if that will make the name too long.
		s += tostring(myear_) + singleSpace;
	if (halffull) s += shortname();
	else s += longname();
	return s;
}
int Vehicle::modifieddriveskill(int skillLevel)
{
	return vehicletype[getvehicletype(vtypeidname_)]->modifieddriveskill(skillLevel); // Todo - add bonus if car is upgraded with nitro
}
int Vehicle::modifieddodgeskill(int skillLevel)
{
	return vehicletype[getvehicletype(vtypeidname_)]->modifieddodgeskill(skillLevel); // Todo - add bonus if car is upgraded
}
Vehicle::Vehicle(const VehicleType& seed) { init(seed, pickrandom(seed.color()), seed.makeyear()); }
Vehicle::Vehicle(const VehicleType& seed, const string& color, int myear) { init(seed, color, myear); }
Vehicle::~Vehicle() { stop_riding_me(); stop_preferring_me(); }
short Vehicle::get_heat() const { return heat_; }
void Vehicle::add_heat(short heat) { heat_ += heat; }
long Vehicle::get_location() const { return location_; }
void Vehicle::set_location(long new_location) { location_ = new_location; }
const string& Vehicle::vtypeidname() const { return vtypeidname_; }
long Vehicle::vtypeid() const { return vtypeid_; }
const string& Vehicle::color() const { return color_; }
bool Vehicle::displayscolor() const { return vehicletype[getvehicletype(vtypeidname_)]->displayscolor(); }
int Vehicle::myear() const { return myear_; }
long Vehicle::id() const { return id_; }
int Vehicle::attackbonus(bool isDriver) const { return vehicletype[getvehicletype(vtypeidname_)]->attackbonus(isDriver); }
int Vehicle::gethitlocation(int bodypart) { return vehicletype[getvehicletype(vtypeidname_)]->gethitlocation(bodypart); }
string Vehicle::getpartname(int hitlocation) { return vehicletype[getvehicletype(vtypeidname_)]->getpartname(hitlocation); }
int Vehicle::armorbonus(int hitlocation) const { return vehicletype[getvehicletype(vtypeidname_)]->armorbonus(hitlocation); }
const string& Vehicle::longname() const { return vehicletype[getvehicletype(vtypeidname_)]->longname(); }
const string& Vehicle::shortname() const { return vehicletype[getvehicletype(vtypeidname_)]->shortname(); }
int Vehicle::steal_difficultytofind() const { return vehicletype[getvehicletype(vtypeidname_)]->steal_difficultytofind(); }
int Vehicle::steal_juice() const { return vehicletype[getvehicletype(vtypeidname_)]->steal_juice(); }
int Vehicle::steal_extraheat() const { return vehicletype[getvehicletype(vtypeidname_)]->steal_extraheat(); }
int Vehicle::sensealarmchance() const { return vehicletype[getvehicletype(vtypeidname_)]->sensealarmchance(); }
int Vehicle::touchalarmchance() const { return vehicletype[getvehicletype(vtypeidname_)]->touchalarmchance(); }
bool Vehicle::availableatshop() const { return vehicletype[getvehicletype(vtypeidname_)]->availableatshop(); }
int Vehicle::price() const { return vehicletype[getvehicletype(vtypeidname_)]->price(); }
int Vehicle::sleeperprice() const { return vehicletype[getvehicletype(vtypeidname_)]->sleeperprice(); }

/* transforms a vehicle type id into the index of that vehicle type in the global vector */
int getvehicletype(const int id)
{
	for (int i = 0; i < len(vehicletype); i++) if (vehicletype[i]->id() == id) return i;
	return -1;
}
/* transforms a vehicle type idname into the index of that vehicle type in the global vector */
int getvehicletype(const string &idname)
{
	for (int i = 0; i < len(vehicletype); i++) if (vehicletype[i]->idname() == idname) return i;
	return -1;
}

int steal_difficultytofind(const int v) {
	return vehicletype[v]->steal_difficultytofind();
}
int lenVehicleType() {
	return len(vehicletype);
}

string vehicleTypelongname(const int p) {
	return vehicletype[p]->longname();
}

Vehicle* getVehicleOfThisType(const int cartype) {
	return new Vehicle(*vehicletype[cartype]);
}

Vehicle* getVehicleFromTypeYear(const int carchoice, const int colorchoice, const int year) {
	return new Vehicle(*vehicletype[carchoice],
		vehicletype[carchoice]->color()[colorchoice], year);
}

int getVehicleTypePrice(const int carchoice) {
	return vehicletype[carchoice]->price();

}

int getVehicleTypeSleeperPrice(const int carchoice) {
	return vehicletype[carchoice]->sleeperprice();
}

vector<string> getVehicleTypeColor(const int carchoice) {
	return vehicletype[carchoice]->color();
}

bool vehicletypeavailableatshop(const int i) {
	return vehicletype[i]->availableatshop();
}
string vehicleSportsCar;
Vehicle* newSportsCar() {
	return new Vehicle(*vehicletype[getvehicletype(vehicleSportsCar)]);
}

void delete_and_clear_vehicle_types() {
	delete_and_clear(vehicletype);
}

const string CONST_vehicletypeB055 = "::colors: ";
const string CONST_vehicletypeB054 = "::year: ";
const string CONST_vehicletypeB053 = "UNDEF";
const string CONST_vehicletype054 = "::colors::display_color: ";
const string CONST_vehicletype051 = "::year::add_random_up_to_current_year: ";
const string CONST_vehicletype049 = "::year::start_at_current_year: ";
const string CONST_vehicletype047 = "LACKS IDNAME ";
const string CONST_vehicletype046 = "UNDEFINED";

const string tag_window = "window";
const string tag_Translucent = "Translucent";
const string tag_available_at_dealership = "available_at_dealership";
const string tag_armor_midpoint = "armor_midpoint";
const string tag_high_armor_max = "high_armor_max";
const string tag_high_armor_min = "high_armor_min";
const string tag_low_armor_max = "low_armor_max";
const string tag_low_armor_min = "low_armor_min";
const string tag_touch_alarm_chance = "touch_alarm_chance";
const string tag_sense_alarm_chance = "sense_alarm_chance";
const string tag_extra_heat = "extra_heat";
const string tag_difficulty_to_find = "difficulty_to_find";
const string tag_stealing = "stealing";
const string tag_longname = "longname";
const string tag_passenger = "passenger";
const string tag_driver = "driver";
const string tag_attackbonus = "attackbonus";
const string tag_hardlimit = "hardlimit";
const string tag_softlimit = "softlimit";
const string tag_skillfactor = "skillfactor";
const string tag_dodgebonus = "dodgebonus";
const string tag_dodge = "dodge";
const string tag_drivebonus = "drivebonus";
const string tag_display_color = "display_color";
const string tag_colors = "colors";
const string tag_add = "add";
const string tag_add_random = "add_random";
const string tag_add_random_up_to_current_year = "add_random_up_to_current_year";
const string tag_start_at_year = "start_at_year";
const string tag_start_at_current_year = "start_at_current_year";
const string tag_year = "year";
int VehicleType::number_of_vehicletypes = 0;
VehicleType::VehicleType(MCD_STR xmlstring)
	: /*idname_(CONST_vehicletype046), id_(-1),*/ year_startcurrent_(true), year_start_(0), //Default values
	year_randomuptocurrent_(false), year_addrandom_(0), year_add_(0), displaycolor_(true),
	longname_(CONST_vehicletype046), shortname_(CONST_vehicletypeB053),
	drivebonus_(0), drivebonus_factor_(1), drivebonus_limit1_(8), drivebonus_limit2_(99),
	dodgebonus_(0), dodgebonus_factor_(1), dodgebonus_limit1_(8), dodgebonus_limit2_(99),
	attackbonus_driver_(-2), attackbonus_passenger_(0),
	armormidpoint_(50), lowarmormin_(4), lowarmormax_(6), higharmormin_(0), higharmormax_(2),
	steal_difficultytofind_(1), steal_juice_(0), steal_extraheat_(0),
	sensealarmchance_(0), touchalarmchance_(0), availableatshop_(true), price_(1234), sleeperprice_(1111)
{
	id_ = number_of_vehicletypes++;
	CMarkup xmlfile;
	xmlfile.SetDoc(xmlstring);
	xmlfile.FindElem();
	idname_ = xmlfile.GetAttrib(tag_idname);
	if (idname_ == blankString)
		idname_ = CONST_vehicletype047 + tostring(id_);
	xmlfile.IntoElem();
	while (xmlfile.FindElem()) //Loop over all the elements inside the vehicletype element.
	{
		std::string element = xmlfile.GetTagName();
		if (element == tag_year)
		{
			xmlfile.IntoElem();
			while (xmlfile.FindElem())
			{
				element = xmlfile.GetTagName();
				if (element == tag_start_at_current_year)
				{
					int b = stringtobool(xmlfile.GetData());
					if (b == 1)
						year_startcurrent_ = true;
					else if (b == 0)
						year_startcurrent_ = false;
				}
				else if (element == tag_start_at_year)
					year_start_ = atoi(xmlfile.GetData());
				else if (element == tag_add_random_up_to_current_year)
				{
					int b = stringtobool(xmlfile.GetData());
					if (b == 1)
						year_randomuptocurrent_ = true;
					else if (b == 0)
						year_randomuptocurrent_ = false;
				}
				else if (element == tag_add_random)
					year_addrandom_ = atoi(xmlfile.GetData());
				else if (element == tag_add)
					year_add_ = atoi(xmlfile.GetData());
			}
			xmlfile.OutOfElem();
		}
		else if (element == tag_colors)
		{
			xmlfile.IntoElem();
			//std::string color;
			while (xmlfile.FindElem())
			{
				element = xmlfile.GetTagName();
				if (element == tag_color)
				{
					color_.push_back(xmlfile.GetData());
				}
				else if (element == tag_display_color)
				{
					int b = stringtobool(xmlfile.GetData());
					if (b == 1)
						displaycolor_ = true;
					else if (b == 0)
						displaycolor_ = false;
				}
			}
			xmlfile.OutOfElem();
		}
		else if (element == tag_drivebonus)
		{
			xmlfile.IntoElem();
			while (xmlfile.FindElem())
			{
				element = xmlfile.GetTagName();
				if (element == tag_base)
					drivebonus_ = atoi(xmlfile.GetData());
				else if (element == tag_skillfactor)
					drivebonus_factor_ = atof(xmlfile.GetData());
				else if (element == tag_softlimit)
					drivebonus_limit1_ = atoi(xmlfile.GetData());
				else if (element == tag_hardlimit)
					drivebonus_limit2_ = atoi(xmlfile.GetData());
			}
			xmlfile.OutOfElem();
		}
		else if (element == tag_dodgebonus)
		{
			xmlfile.IntoElem();
			while (xmlfile.FindElem())
			{
				element = xmlfile.GetTagName();
				if (element == tag_base)
					dodgebonus_ = atoi(xmlfile.GetData());
				else if (element == tag_skillfactor)
					dodgebonus_factor_ = atof(xmlfile.GetData());
				else if (element == tag_softlimit)
					dodgebonus_limit1_ = atoi(xmlfile.GetData());
				else if (element == tag_hardlimit)
					dodgebonus_limit2_ = atoi(xmlfile.GetData());
			}
			xmlfile.OutOfElem();
		}
		else if (element == tag_attackbonus)
		{
			xmlfile.IntoElem();
			while (xmlfile.FindElem())
			{
				element = xmlfile.GetTagName();
				if (element == tag_driver)
					attackbonus_driver_ = atoi(xmlfile.GetData());
				else if (element == tag_passenger)
					attackbonus_passenger_ = atoi(xmlfile.GetData());
			}
			xmlfile.OutOfElem();
		}
		else if (element == tag_longname)
			longname_ = xmlfile.GetData();
		else if (element == tag_shortname)
		{
			shortname_ = xmlfile.GetData();
			if (len(shortname_) > 7)
				shortname_.resize(7); //Only seven characters allowed for shortname_.
		}
		else if (element == tag_stealing)
		{
			xmlfile.IntoElem();
			while (xmlfile.FindElem())
			{
				element = xmlfile.GetTagName();
				if (element == tag_difficulty_to_find)
					steal_difficultytofind_ = atoi(xmlfile.GetData());
				else if (element == tag_juice)
					steal_juice_ = atoi(xmlfile.GetData());
				else if (element == tag_extra_heat)
					steal_extraheat_ = atoi(xmlfile.GetData());
				else if (element == tag_sense_alarm_chance)
					sensealarmchance_ = atoi(xmlfile.GetData());
				else if (element == tag_touch_alarm_chance)
					touchalarmchance_ = atoi(xmlfile.GetData());
			}
			xmlfile.OutOfElem();
		}
		else if (element == tag_armor)
		{
			xmlfile.IntoElem();
			while (xmlfile.FindElem())
			{
				element = xmlfile.GetTagName();
				if (element == tag_low_armor_min)
					lowarmormin_ = atoi(xmlfile.GetData());
				else if (element == tag_low_armor_max)
					lowarmormax_ = atoi(xmlfile.GetData());
				else if (element == tag_high_armor_min)
					higharmormin_ = atoi(xmlfile.GetData());
				else if (element == tag_high_armor_max)
					higharmormax_ = atoi(xmlfile.GetData());
				else if (element == tag_armor_midpoint)
					armormidpoint_ = atoi(xmlfile.GetData());
			}
			xmlfile.OutOfElem();
		}
		else if (element == tag_available_at_dealership)
		{
			int b = stringtobool(xmlfile.GetData());
			if (b == 1)
				availableatshop_ = true;
			else if (b == 0)
				availableatshop_ = false;
		}
		else if (element == tag_price)
			price_ = atoi(xmlfile.GetData());
		else if (element == tag_sleeperprice)
			sleeperprice_ = atoi(xmlfile.GetData());
	}
	if (len(color_) == 0)
		color_.push_back(tag_Translucent); //Default.
										   //xmlfile.OutOfElem();
}
int VehicleType::makeyear() const
{
	extern int year;
	int myear = 0;
	if (year_startcurrent_)
		myear = year;
	else
		myear = year_start_;
	if (year_randomuptocurrent_)
		myear += LCSrandom(year - year_start_ + 1);
	if (year_addrandom_ > 0)
		myear += LCSrandom(year_addrandom_);
	else if (year_addrandom_ < 0)
		myear -= LCSrandom(-year_addrandom_);
	myear += year_add_;
	return myear;
}
int VehicleType::gethitlocation(int bodypart)
{
	switch (bodypart)
	{
	case BODYPART_HEAD:
		return CARPART_WINDOW;
	case BODYPART_BODY:
	case BODYPART_ARM_RIGHT:
	case BODYPART_ARM_LEFT:
		return (LCSrandom(100) < armormidpoint_) ? CARPART_BODY : CARPART_WINDOW;
	case BODYPART_LEG_RIGHT:
	case BODYPART_LEG_LEFT:
		return CARPART_BODY;
	default:
		return CARPART_WINDOW;
	}
}
string VehicleType::getpartname(int location)
{
	return location == CARPART_WINDOW ? tag_window : tag_body;
}
int VehicleType::armorbonus(int location)
{
	switch (location)
	{
	case CARPART_BODY:
		return LCSrandom(lowarmormax_ - lowarmormin_ + 1) + lowarmormin_;
	case CARPART_WINDOW:
		return LCSrandom(higharmormax_ - higharmormin_ + 1) + higharmormin_;
	default:
		return 0;
	}
}
int VehicleType::modifieddriveskill(int skillLevel)
{
	int score = (int)floor((skillLevel + drivebonus_)*drivebonus_factor_);
	if (score < drivebonus_limit1_)
		return score;
	if (score > drivebonus_limit1_)
		score = (score + drivebonus_limit1_) / 2; // half credit after limit1
	return (score > drivebonus_limit2_) ? drivebonus_limit2_ : score;
}
int VehicleType::modifieddodgeskill(int skillLevel)
{
	int score = (int)floor((skillLevel + dodgebonus_)*dodgebonus_factor_);
	if (score < dodgebonus_limit1_)
		return score;
	if (score > dodgebonus_limit1_)
		score = (score + dodgebonus_limit1_) / 2; // half credit after limit1
	return (score > dodgebonus_limit2_) ? dodgebonus_limit2_ : score;
}
const string& VehicleType::idname() const { return idname_; }
long VehicleType::id() const { return id_; }
const vector<string>& VehicleType::color() const { return color_; }
bool VehicleType::displayscolor() const { return displaycolor_; }
const string& VehicleType::longname() const { return longname_; }
const string& VehicleType::shortname() const { return shortname_; }
int VehicleType::attackbonus(bool isDriving) const { return isDriving ? attackbonus_driver_ : attackbonus_passenger_; }
int VehicleType::steal_difficultytofind() const { return steal_difficultytofind_; }
int VehicleType::steal_juice() const { return steal_juice_; }
int VehicleType::steal_extraheat() const { return steal_extraheat_; }
int VehicleType::sensealarmchance() const { return sensealarmchance_; }
int VehicleType::touchalarmchance() const { return touchalarmchance_; }
bool VehicleType::availableatshop() const { return availableatshop_; }
int VehicleType::price() const { return price_; }
int VehicleType::sleeperprice() const { return sleeperprice_; }



extern string findingBugs;
extern string undefined;
extern string NONE;
extern string YEA;
extern string NAY;
extern string AND;
extern string counts_of;
extern string feels_sick_and;
extern string check_status_of_squad_liberal;
extern string show_squad_liberal_status;
extern string change_squad_order;
extern string string_sleeper;
extern string execution_in_three_months;
extern string major_news_take_it_up;
extern string they_are_stashed;
extern string they_ll_round_you_up;
extern string conservativesRemakeWorld;
extern string bound_to_rile_up;
extern string establishPrisonReform;
extern string improvePrisonConditions;
extern string stalinistsRemakeWorld;
extern string chooseALiberalTo;
extern string youWentOnVacation;
extern string youWentIntoHiding;
extern string whileYouWereInPrison;
extern string youDisappearedSafely;
extern string proposeConservative;
extern string proposeStalinist;
extern string enter_done;
extern string beingFollowedBySwine;
extern string lostThem;
extern string hereTheyCome;
extern string spaceDashSpace;
extern string currentLocation;
extern string safeHouse;
extern string enemySafeHouse;
extern string closedDown;
extern string highSecurity;
extern string needCar;
extern string spaceParanthesisDollar;
extern string paranthesisDollar;
extern string closeParenthesis;
extern string underSiege;
extern string percentSign;
extern string secrecyLevel;
extern string heatLevel;
extern string travelDifCity;
extern string smellsPanic;
extern string moderateLC;
extern string buggyString;
extern string isSeized;
extern string selectA;
extern string selectAn;
extern string enterDash;
extern string accordingToSourcesAtScene;
extern string accordingToPoliceSources;
extern string ampersandR;
extern string singleDot;
extern string membersOfLCS;
extern string lcsSpokeseperson;
extern string policeSpokesperson;
extern string pressKeyToReflect;
extern string pressLToViewHighScores;
extern string ampersandC;
extern string saysComma;
extern string while_naked;
extern string respondsComma;
extern string colonSpace;
extern string theLCS;
extern string notASkill;
extern string notAnAttribute;
extern string vehicleSportsCar;
extern string aNewConEra;
extern string theYearIs;
extern string conservativePresident;
extern string endsSecondTerm;
extern string highSeventiesApprovePres;
extern string conMajorityHouse;
extern string senateConMajority;
extern string beginningOfNew;
extern string conEra;
extern string thePresident;
extern string hasAskedCongressBeQuick;
extern string rubberStampArchCon;
extern string theLeftSeems;
extern string powerlessToStop;
extern string inThisDarkTime;
extern string whatIsYourName;
extern string pressEnterToBeRealName;
extern string invalidTag;
extern string theDocSaid;
extern string aBoy;
extern string aGirl;
extern string intersex;
extern string myParents;
extern string insistedOtherwise;
extern string they;
extern string namedMe;
extern string error;
extern string theFounder;
extern string firstName;
extern string pressAtoReconsider;
extern string lastName;
extern string pressBtoBeReborn;
extern string sexIs;
extern string male;
extern string female;
extern string itsComplicated;
extern string pressCtoChangeSex;
extern string history;
extern string letMeChoose;
extern string letFateDecide;
extern string pressDtoToggle;
extern string city;
extern string pressEtoRelocate;
extern string pressAnyKeyString;
extern string allOptions;
extern string unSelected;
extern string isSelected;
extern string pressAnyOtherKey;
extern string notCreature;
extern string notValidMap;
extern string notSpecialWound;
extern string newGameAdvanced;
extern string a_classicMode;
extern string b_weDidntStartIt;
extern string c_nightmareMode;
extern string d_nationalLCS;
extern string e_marathonMode;
extern string f_stalinistMode;
extern string newGameYourAgenda;
extern string a_noComprimise;
extern string b_democrat;
extern string newGameFieldLearn;
extern string affectsTheseSkills;
extern string a_fastSkills;
extern string b_classic;
extern string c_hardMode;
extern string deleteSave;
extern string chooseSave;
extern string titleScreenLine;
extern string newGame;
extern string pressToSelectSave;
extern string pressToDeleteSave;
extern string vToSwitchXToQuit;
extern string areYouSureDelte;
extern string questionYSlashN;
extern string pressMtoTurnOffMusic;
extern string pressMtoTurnOnMusic;
extern string inWhatWorld;
extern string enterNameForSave;
extern string pleaseEnterName;
extern string prettyPlease;
extern string justEnterName;
extern string liberalCrimeSquad;
extern string inspiredByOubliette;
extern string copyrightTarn;
extern string bayTwelveProductions;
extern string lcsHyperlink;
extern string vChar;
extern string maintainedByOpenSource;
extern string kingDrakeHyperlink;
extern string lcsForumHyperlink;
extern string lcsWikiHyperlink;
extern string pressESCToQuit;
extern string pressAnyKeyToPursue;
extern string plusChar;
extern string dotDat;
extern string itemType;
extern string doesNotExistItem;
extern string vehicleType;
extern string doesNotExistVehicle;
extern string couldNotLoad;
extern string itemClassClip;
extern string itemClassWeapon;
extern string itemClassArmor;
extern string itemClassLoot;
extern string itemClassMoney;
extern string failedToLoadSitemaps;
extern string debugCode;
extern string activated;
extern string failedToLoad;
extern string exclamationPoint;
extern string defaultMissingForMask;
extern string defaultUnknownForMask;
extern string ableToStopBleed;
extern string sWounds;
extern string isBurned;
extern string drops;
extern string sBody;
extern string hasBeenCaughtSnooping;
extern string isNowHomeless;
extern string hasLeakedIntelligence;
extern string hasLeakedPolice;
extern string hasLeakedCorporate;
extern string hasLeakedPrison;
extern string hasLeakedCableNews;
extern string hasLeakedAMRadio;
extern string hasLeakedAnimalResearch;
extern string hasLeakedJudiciary;
extern string papersAreStashed;
extern string hasLeakedCCS;
extern string diskIsStashed;
extern string arrestedWhileEmbezzling;
extern string arrestedWhileStealing;
extern string droppedOffPackage;
extern string itemNotFound;
extern string lostStolenItem;
extern string contactModAuthor;
extern string hasRecruited;
extern string looksForwardToServing;
extern string toSpend;
extern string chooseAColor;
extern string theseColorsAreCon;
extern string thisColor;
extern string notEnoughMoney;
extern string chooseVehicle;
extern string thisVehicle;
extern string weDontNeedCar;
extern string enterLeave;
extern string b_chooseBuyer;
extern string s_sellCar;
extern string s_sellThe;
extern string g_getCar;
extern string f_fixWounds;
extern string univer;
extern string numRecruit;
extern string numMartyr;
extern string numKills;
extern string numKidnap;
extern string cashTaxed;
extern string cashSpent;
extern string flagsBought;
extern string flagsBurned;
extern string noValid;
extern string heLiElite;
extern string heLiLiber;
extern string heLiBrought;
extern string heLiBlot;
extern string heLiMob;
extern string heLiDownsized;
extern string heLiKIA;
extern string hecoReag;
extern string heLiDie;
extern string heLiExec;
extern string heLiVaca;
extern string heLiHide;
extern string heLiHunted;
extern string heLiScattered;
extern string heLiOutCrime;
extern string heLiBurned;
extern string hecoStalinized;
extern string dotSpace;
extern string liberalHelpOn;
extern string pressAnyKeyToReturn;
string study_string1;
string study_string2;
vector<string> allText;
vector<file_and_text_collection> text_file_collection = {
	customText(&allText, CONST_talk039),
};
vector<string*> allTextString = {
	&respondsComma,
	&saysComma,
	&while_naked,
	&colonSpace,
	&pressLToViewHighScores,
	&ampersandC,
	&commaSpace,
	&findingBugs,
	&undefined,
	&NONE,
	&YEA,
	&NAY,
	&AND,
	&counts_of,
	&feels_sick_and,
	&show_squad_liberal_status,
	&change_squad_order,
	&string_sleeper,
	&execution_in_three_months,
	&major_news_take_it_up,
	&they_are_stashed,
	&they_ll_round_you_up,
	&conservativesRemakeWorld,
	&bound_to_rile_up,
	&establishPrisonReform,
	&improvePrisonConditions,
	&stalinistsRemakeWorld,
	&chooseALiberalTo,
	&youWentOnVacation,
	&youWentIntoHiding,
	&whileYouWereInPrison,
	&youDisappearedSafely,
	&proposeConservative,
	&proposeStalinist,

	&enter_done,
	&beingFollowedBySwine,
	&lostThem,
	&hereTheyCome,
	&spaceDashSpace,
	&currentLocation,
	&safeHouse,
	&enemySafeHouse,
	&closedDown,
	&highSecurity,
	&needCar,
	&spaceParanthesisDollar,
	&paranthesisDollar,
	&closeParenthesis,
	&underSiege,
	&percentSign,
	&secrecyLevel,
	&heatLevel,
	&travelDifCity,
	&smellsPanic,
	&moderateLC,
	&buggyString,
	&isSeized,
	&selectA,
	&selectAn,
	&enterDash,
	&accordingToSourcesAtScene,
	&accordingToPoliceSources,
	&ampersandR,
	&singleDot,
	&membersOfLCS,
	&lcsSpokeseperson,
	&policeSpokesperson,
	&pressKeyToReflect,
	&theLCS,
	&notASkill,
	&notAnAttribute,
	&vehicleSportsCar,
	&aNewConEra,
	&theYearIs,
	&conservativePresident,
	&endsSecondTerm,
	&highSeventiesApprovePres,
	&conMajorityHouse,
	&senateConMajority,
	&beginningOfNew,
	&conEra,
	&thePresident,
	&hasAskedCongressBeQuick,
	&rubberStampArchCon,
	&theLeftSeems,
	&powerlessToStop,
	&inThisDarkTime,
	&whatIsYourName,
	&pressEnterToBeRealName,
	&invalidTag,
	&theDocSaid,
	&aBoy,
	&aGirl,
	&intersex,
	&myParents,
	&insistedOtherwise,
	&they,
	&namedMe,
	&error,
	&theFounder,
	&firstName,
	&pressAtoReconsider,
	&lastName,
	&pressBtoBeReborn,
	&sexIs,
	&male,
	&female,
	&itsComplicated,
	&pressCtoChangeSex,
	&history,
	&letMeChoose,
	&letFateDecide,
	&pressDtoToggle,
	&city,
	&pressEtoRelocate,
	&pressAnyKeyString,
	&allOptions,
	&unSelected,
	&isSelected,
	&pressAnyOtherKey,
	&notCreature,
	&notValidMap,
	&notSpecialWound,
	&newGameAdvanced,
	&a_classicMode,
	&b_weDidntStartIt,
	&c_nightmareMode,
	&d_nationalLCS,
	&e_marathonMode,
	&f_stalinistMode,
	&newGameYourAgenda,
	&a_noComprimise,
	&b_democrat,
	&newGameFieldLearn,
	&affectsTheseSkills,
	&a_fastSkills,
	&b_classic,
	&c_hardMode,
	&deleteSave,
	&chooseSave,
	&titleScreenLine,
	&newGame,
	&pressToSelectSave,
	&pressToDeleteSave,
	&vToSwitchXToQuit,
	&areYouSureDelte,
	&questionYSlashN,
	&pressMtoTurnOffMusic,
	&pressMtoTurnOnMusic,
	&inWhatWorld,
	&enterNameForSave,
	&pleaseEnterName,
	&prettyPlease,
	&justEnterName,
	&liberalCrimeSquad,
	&inspiredByOubliette,
	&copyrightTarn,
	&bayTwelveProductions,
	&lcsHyperlink,
	&vChar,
	&maintainedByOpenSource,
	&kingDrakeHyperlink,
	&lcsForumHyperlink,
	&lcsWikiHyperlink,
	&pressESCToQuit,
	&pressAnyKeyToPursue,
	&plusChar,
	&dotDat,
	&itemType,
	&doesNotExistItem,
	&vehicleType,
	&doesNotExistVehicle,
	&couldNotLoad,
	&itemClassClip,
	&itemClassWeapon,
	&itemClassArmor,
	&itemClassLoot,
	&itemClassMoney,
	&failedToLoadSitemaps,
	&debugCode,
	&activated,
	&failedToLoad,
	&exclamationPoint,
	&defaultMissingForMask,
	&defaultUnknownForMask,
	&ableToStopBleed,
	&sWounds,
	&isBurned,
	&drops,
	&sBody,
	&hasBeenCaughtSnooping,
	&isNowHomeless,
	&hasLeakedIntelligence,
	&hasLeakedPolice,
	&hasLeakedCorporate,
	&hasLeakedPrison,
	&hasLeakedCableNews,
	&hasLeakedAMRadio,
	&hasLeakedAnimalResearch,
	&hasLeakedJudiciary,
	&papersAreStashed,
	&hasLeakedCCS,
	&diskIsStashed,
	&arrestedWhileEmbezzling,
	&arrestedWhileStealing,
	&droppedOffPackage,
	&itemNotFound,
	&lostStolenItem,
	&contactModAuthor,
	&hasRecruited,
	&looksForwardToServing,
	&toSpend,
	&chooseAColor,
	&theseColorsAreCon,
	&thisColor,
	&notEnoughMoney,
	&chooseVehicle,
	&thisVehicle,
	&weDontNeedCar,
	&enterLeave,
	&b_chooseBuyer,
	&s_sellCar,
	&s_sellThe,
	&g_getCar,
	&f_fixWounds,
	&univer,
	&numRecruit,
	&numMartyr,
	&numKills,
	&numKidnap,
	&cashTaxed,
	&cashSpent,
	&flagsBought,
	&flagsBurned,
	&noValid,
	&heLiElite,
	&heLiLiber,
	&heLiBrought,
	&heLiBlot,
	&heLiMob,
	&heLiDownsized,
	&heLiKIA,
	&hecoReag,
	&heLiDie,
	&heLiExec,
	&heLiVaca,
	&heLiHide,
	&heLiHunted,
	&heLiScattered,
	&heLiOutCrime,
	&heLiBurned,
	&hecoStalinized,
	&dotSpace,
	&unnamed_String_Talk_cpp_001,
	&unnamed_String_Talk_cpp_002,
	&unnamed_String_Talk_cpp_003,
	&unnamed_String_Talk_cpp_004,
	&unnamed_String_Talk_cpp_005,
	&unnamed_String_Talk_cpp_006,
	&unnamed_String_Talk_cpp_007,
	&unnamed_String_Talk_cpp_008,
	&unnamed_String_Talk_cpp_009,
	&unnamed_String_Talk_cpp_010,
	&unnamed_String_Talk_cpp_011,
	&unnamed_String_Talk_cpp_012,
	&unnamed_String_Talk_cpp_013,
	&unnamed_String_Talk_cpp_014,
	&unnamed_String_Talk_cpp_015,
	&unnamed_String_Talk_cpp_016,
	&unnamed_String_Talk_cpp_017,
	&unnamed_String_Talk_cpp_018,
	&unnamed_String_Talk_cpp_019,
	&unnamed_String_Talk_cpp_020,
	&unnamed_String_Talk_cpp_021,
	&unnamed_String_Talk_cpp_022,
	&unnamed_String_Talk_cpp_023,
	&unnamed_String_Talk_cpp_024,
	&unnamed_String_Talk_cpp_025,
	&unnamed_String_Talk_cpp_026,
	&unnamed_String_Talk_cpp_027,
	&unnamed_String_Talk_cpp_028,
	&unnamed_String_Talk_cpp_029,
	&unnamed_String_Talk_cpp_030,
	&unnamed_String_Talk_cpp_031,
	&unnamed_String_Talk_cpp_032,
	&unnamed_String_Talk_cpp_033,
	&unnamed_String_Talk_cpp_034,
	&unnamed_String_Talk_cpp_035,
	&unnamed_String_Talk_cpp_036,
	&unnamed_String_Talk_cpp_037,
	&unnamed_String_Talk_cpp_038,
	&unnamed_String_Talk_cpp_039,
	&unnamed_String_Talk_cpp_040,
	&unnamed_String_Talk_cpp_041,
	&unnamed_String_Talk_cpp_042,
	&unnamed_String_Talk_cpp_043,
	&unnamed_String_Talk_cpp_044,
	&unnamed_String_Talk_cpp_045,
	&unnamed_String_Talk_cpp_046,
	&unnamed_String_Talk_cpp_047,
	&unnamed_String_Talk_cpp_048,
	&unnamed_String_Talk_cpp_049,
	&unnamed_String_Talk_cpp_050,
	&unnamed_String_Talk_cpp_051,
	&unnamed_String_Talk_cpp_052,
	&unnamed_String_Talk_cpp_053,
	&unnamed_String_Talk_cpp_054,
	&unnamed_String_Talk_cpp_055,
	&unnamed_String_Talk_cpp_056,
	&unnamed_String_Talk_cpp_057,
	&unnamed_String_Talk_cpp_058,
	&unnamed_String_Talk_cpp_059,
	&unnamed_String_Talk_cpp_060,
	&unnamed_String_Talk_cpp_061,
	&unnamed_String_Talk_cpp_062,
	&unnamed_String_Talk_cpp_063,
	&unnamed_String_Talk_cpp_064,
	&unnamed_String_Talk_cpp_065,
	&unnamed_String_Talk_cpp_066,
	&unnamed_String_Talk_cpp_067,
	&unnamed_String_Talk_cpp_068,
	&unnamed_String_Talk_cpp_069,
	&unnamed_String_Talk_cpp_070,
	&unnamed_String_Talk_cpp_071,
	&unnamed_String_Talk_cpp_072,
	&unnamed_String_Talk_cpp_073,
	&unnamed_String_Talk_cpp_074,
	&unnamed_String_Talk_cpp_075,
	&unnamed_String_Talk_cpp_076,
	&unnamed_String_Talk_cpp_077,
	&unnamed_String_Talk_cpp_078,
	&unnamed_String_Talk_cpp_079,
	&unnamed_String_Talk_cpp_080,
	&unnamed_String_Talk_cpp_081,
	&unnamed_String_Talk_cpp_082,
	&unnamed_String_Talk_cpp_083,
	&unnamed_String_Talk_cpp_084,
	&unnamed_String_Talk_cpp_085,
	&unnamed_String_Talk_cpp_086,
	&unnamed_String_Talk_cpp_087,
	&unnamed_String_Talk_cpp_088,
	&unnamed_String_Talk_cpp_089,
	&unnamed_String_Talk_cpp_090,
	&unnamed_String_Talk_cpp_091,
	&unnamed_String_Talk_cpp_092,
	&unnamed_String_Talk_cpp_093,
	&unnamed_String_Talk_cpp_094,
	&unnamed_String_Talk_cpp_095,
	&unnamed_String_Talk_cpp_096,
	&unnamed_String_Talk_cpp_097,
	&unnamed_String_Talk_cpp_098,
	&unnamed_String_Talk_cpp_099,
	&unnamed_String_Talk_cpp_100,
	&unnamed_String_Talk_cpp_101,
	&unnamed_String_Talk_cpp_102,
	&unnamed_String_Talk_cpp_103,
	&unnamed_String_Talk_cpp_104,
	&unnamed_String_Talk_cpp_105,
	&unnamed_String_Talk_cpp_106,
	&unnamed_String_Talk_cpp_107,
	&unnamed_String_Talk_cpp_108,
	&unnamed_String_Talk_cpp_109,
	&unnamed_String_Talk_cpp_110,
	&unnamed_String_Talk_cpp_111,
	&unnamed_String_Talk_cpp_112,
	&unnamed_String_Talk_cpp_113,
	&unnamed_String_Talk_cpp_114,
	&unnamed_String_Talk_cpp_115,
	&unnamed_String_Talk_cpp_116,
	&unnamed_String_Talk_cpp_117,
	&unnamed_String_Talk_cpp_118,
	&unnamed_String_Talk_cpp_119,
	&unnamed_String_Talk_cpp_120,
	&unnamed_String_Talk_cpp_121,
	&unnamed_String_Talk_cpp_122,
	&unnamed_String_Talk_cpp_123,
	&unnamed_String_Talk_cpp_124,
	&unnamed_String_Talk_cpp_125,
	&unnamed_String_Talk_cpp_126,
	&unnamed_String_Talk_cpp_127,
	&unnamed_String_Talk_cpp_128,
	&unnamed_String_Talk_cpp_129,
	&unnamed_String_Talk_cpp_130,
	&unnamed_String_Talk_cpp_131,
	&unnamed_String_Talk_cpp_132,
	&unnamed_String_Talk_cpp_133,
	&unnamed_String_Talk_cpp_134,
	&unnamed_String_Talk_cpp_135,
	&unnamed_String_Talk_cpp_136,
	&unnamed_String_Talk_cpp_137,
	&unnamed_String_Talk_cpp_138,
	&unnamed_String_Talk_cpp_139,
	&unnamed_String_Talk_cpp_140,
	&unnamed_String_Talk_cpp_141,
	&unnamed_String_Talk_cpp_142,
	&unnamed_String_Talk_cpp_143,
	&unnamed_String_Talk_cpp_144,
	&unnamed_String_Talk_cpp_145,
	&unnamed_String_Talk_cpp_146,
	&unnamed_String_Talk_cpp_147,
	&unnamed_String_Talk_cpp_148,
	&unnamed_String_Talk_cpp_149,
	&liberalHelpOn,
	&pressAnyKeyToReturn,
	&study_string1,
	&study_string2,
};
bool initialize_incomplete_txt() {
	int i = 0;
	check_status_of_squad_liberal.append(CONST_talk040);
	check_status_of_squad_liberal.append(allText[i++]);
	for (string* str : allTextString) {
		*str = allText[i++];
	}
	return i == len(allText);
}

extern int ustat_recruits;
extern int ustat_kidnappings;
extern int ustat_dead;
extern int ustat_kills;
extern int ustat_funds;
extern int ustat_spent;
extern int ustat_buys;
extern int ustat_burns;
vector<saveLoadChunk> highScoreSaveLoad = {
	saveLoadChunk(&ustat_recruits, sizeof(int), 1),
	saveLoadChunk(&ustat_dead, sizeof(int), 1),
	saveLoadChunk(&ustat_kills, sizeof(int), 1),
	saveLoadChunk(&ustat_kidnappings, sizeof(int), 1),
	saveLoadChunk(&ustat_funds, sizeof(int), 1),
	saveLoadChunk(&ustat_spent, sizeof(int), 1),
	saveLoadChunk(&ustat_buys, sizeof(int), 1),
	saveLoadChunk(&ustat_burns, sizeof(int), 1),
	saveLoadChunk(score, sizeof(highscorest), SCORENUM)
};
/* loads the high scores file */
void loadhighscores()
{
	extern int lowestloadscoreversion;
	for (int s = 0; s < SCORENUM; s++)score[s].valid = 0;
	//LOAD FILE
	int loadversion;
	FILE *h = LCSOpenFile(CONST_highscore002.c_str(), CONST_highscoreB002.c_str(), LCSIO_PRE_HOME);
	if (h != NULL)
	{
		fread(&loadversion, sizeof(int), 1, h);
		if (loadversion < lowestloadscoreversion)
		{
			LCSCloseFile(h);
			return;
		}
		for (saveLoadChunk s : highScoreSaveLoad) {
			fread(s.Buffer, s.ElementSize, s.ElementCount, h);
		}
		LCSCloseFile(h);
	}
}

/* saves a new high score */
void savehighscore(char endtype)
{
	extern int ustat_recruits;
	extern int ustat_kidnappings;
	extern int ustat_dead;
	extern int ustat_kills;
	extern int ustat_funds;
	extern int ustat_spent;
	extern int ustat_buys;
	extern int ustat_burns;
	extern int stat_buys;
	extern int stat_burns;
	extern int stat_kidnappings;
	extern int year;
	extern int stat_dead;
	extern int stat_kills;
	extern int stat_recruits;
	extern int yourscore;
	extern int month;
	extern class Ledger ledger;
	extern int version;
	//	extern char slogan[SLOGAN_LEN];
	extern string slogan_str;
	loadhighscores();
	//MERGE THE STATS
	ustat_recruits += stat_recruits;
	ustat_dead += stat_dead;
	ustat_kills += stat_kills;
	ustat_kidnappings += stat_kidnappings;
	ustat_funds += ledger.total_income;
	ustat_spent += ledger.total_expense;
	ustat_buys += stat_buys;
	ustat_burns += stat_burns;
	//PLACE THIS HIGH SCORE BY DATE IF NECESSARY
	yourscore = -1;
	for (int s = 0; s < SCORENUM; s++)
	{
		if ((endtype == END_WON && score[s].endtype == END_WON &&
			year == score[s].year&&month == score[s].month&&
			ledger.total_expense + ledger.total_expense > score[s].stat_spent + score[s].stat_funds) ||
			(endtype == END_WON && score[s].endtype == END_WON
				&& (year < score[s].year ||
				(year == score[s].year && month < score[s].month))) ||
					(endtype == END_WON && score[s].endtype != END_WON) ||
			(endtype != END_WON && score[s].endtype != END_WON &&
				ledger.total_expense + ledger.total_income > score[s].stat_spent + score[s].stat_funds) ||
			score[s].valid == 0)
		{
			for (int s2 = SCORENUM - 1; s2 >= s + 1; s2--)
			{
				score[s2] = score[s2 - 1];
			}
			strcpy(score[s].slogan, slogan_str.c_str());
			score[s].month = month;
			score[s].year = year;
			score[s].stat_recruits = stat_recruits;
			score[s].stat_dead = stat_dead;
			score[s].stat_kills = stat_kills;
			score[s].stat_kidnappings = stat_kidnappings;
			score[s].stat_funds = ledger.total_income;
			score[s].stat_spent = ledger.total_expense;
			score[s].stat_buys = stat_buys;
			score[s].stat_burns = stat_burns;
			score[s].valid = 1;
			score[s].endtype = endtype;
			yourscore = s;
			break;
		}
	}
	FILE *h = LCSOpenFile(CONST_highscore002.c_str(), CONST_highscoreB003.c_str(), LCSIO_PRE_HOME);
	if (h != NULL)
	{
		int lversion = version;
		fwrite(&lversion, sizeof(int), 1, h);
		for (saveLoadChunk s : highScoreSaveLoad) {
			fwrite(s.Buffer, s.ElementSize, s.ElementCount, h);
		}
		LCSCloseFile(h);
	}
	title_screen::getInstance().reset();
}

extern vector<ArmorType *> armortype;
Armor::Armor(const int seed, int quality, int number)
	: Item(*armortype[seed], number), bloody_(false), damaged_(false), quality_(quality)
{ }




vector<string> prays;
vector<string> prays_on_drugs;
vector<vector<string> > fall_in_love;
vector<vector<string> > bad_trip;
vector<string> smarter_than_you_one_line;
vector<vector<string> > smarter_than_you;
vector<string> develops_hatred_one_line;
vector<vector<string> > develops_hatred;
vector<string> interrogater_shows_compassion_one_line;
vector<vector<string> > interrogater_shows_compassion;
vector<vector<string> > cling_to_interrogater;
vector<string> clinging_one_line;
vector<vector<string> > cling_to_religion;
vector<string> cling_to_religion_one_line;
vector<vector<string> > cling_to_business;
vector<vector<string> > cling_to_science;
vector<string> cling_to_business_one_line;
vector<string> cling_to_science_one_line;

const string interrogate = "interrogation\\";
//const int DOUBLE_LINE = 2;
vector<file_and_text_collection> interrogate_text_file_collection = {
	/*InterrogationST.cpp*/
	customText(&execution, interrogate + CONST_interrogation004),
	customText(&feels_sick, interrogate + CONST_interrogation005),
	customText(&low_heart_torture_props, interrogate + CONST_interrogation006),
	customText(&screaming, interrogate + CONST_interrogation007),
	customText(&beat_with_props, interrogate + CONST_interrogation008),
	customText(&words_meaning_screaming, interrogate + CONST_interrogation009),
	customText(&words_to_scream, interrogate + CONST_interrogation010),
	customText(&prays, interrogate + CONST_interrogation011),
	customText(&prays_on_drugs, interrogate + CONST_interrogation012),
	customText(&use_props, interrogate + CONST_interrogation013),
	customText(&resist_drugs, interrogate + CONST_interrogation014),
	customText(&partial_conversion, interrogate + CONST_interrogation015),
	customText(&broods_over_death, interrogate + CONST_interrogation016),
	customText(&self_wounding, interrogate + CONST_interrogation017),
	customText(&good_trip, interrogate + CONST_interrogation018),
	customText(&fall_in_love, interrogate + CONST_interrogation019, DOUBLE_LINE),
	customText(&bad_trip, interrogate + CONST_interrogation020, DOUBLE_LINE),
	customText(&good_trip_companion, interrogate + CONST_interrogation021, DOUBLE_LINE),
	customText(&smarter_than_you_one_line, interrogate + CONST_interrogation022),
	customText(&smarter_than_you, interrogate + CONST_interrogation023, DOUBLE_LINE),
	customText(&develops_hatred_one_line, interrogate + CONST_interrogation024),
	customText(&develops_hatred, interrogate + CONST_interrogation025, DOUBLE_LINE),
	customText(&interrogater_shows_compassion_one_line, interrogate + CONST_interrogation026),
	customText(&interrogater_shows_compassion, interrogate + CONST_interrogation027, DOUBLE_LINE),
	customText(&cling_to_interrogater, interrogate + CONST_interrogation028, DOUBLE_LINE),
	customText(&clinging_one_line, interrogate + CONST_interrogation029),
	customText(&cling_to_religion, interrogate + CONST_interrogation030, DOUBLE_LINE),
	customText(&cling_to_religion_one_line, interrogate + CONST_interrogation031),
	customText(&discuss, interrogate + CONST_interrogation032, DOUBLE_LINE),
	customText(&vanilla_recruit, interrogate + CONST_interrogation033),
	customText(&cling_to_business_one_line, interrogate + CONST_interrogation034),
	customText(&cling_to_science_one_line, interrogate + CONST_interrogation035),
	customText(&cling_to_business, interrogate + CONST_interrogation036, DOUBLE_LINE),
	customText(&cling_to_science, interrogate + CONST_interrogation037, DOUBLE_LINE),
};